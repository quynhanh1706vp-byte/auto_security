import importlib

m = importlib.import_module("vsp_demo_app")

if hasattr(m, "app"):
    application = m.app
elif hasattr(m, "create_app"):
    application = m.create_app()
else:
    raise RuntimeError("vsp_demo_app has no 'app' or 'create_app'")



# === VSP_GATEWAY_EXPORT_V3_IN_WSGI_V1 ===
def _vsp_install_export_v3_on_app(_app):
    # Install export route on the REAL gateway Flask app (application/app)
    try:
        from flask import request, jsonify, send_file, Response
    except Exception:
        return
    from pathlib import Path
    import glob, mimetypes

    if _app is None or not hasattr(_app, "route"):
        return
    if getattr(_app, "_vsp_export_v3_installed", False):
        return
    setattr(_app, "_vsp_export_v3_installed", True)

    def _vsp_norm_rid_to_ci_key(rid: str) -> str:
        s = (rid or "").strip()
        if s.startswith("RUN_"):
            s = s[len("RUN_"):]
        return s

    def _vsp_resolve_ci_run_dir(rid: str):
        key = _vsp_norm_rid_to_ci_key(rid)
        bases = [
            "/home/test/Data/SECURITY-10-10-v4/out_ci",
            "/home/test/Data/SECURITY_BUNDLE/out",
            "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        ]
        for b in bases:
            d = Path(b) / key
            if d.is_dir():
                return d
        # glob fallback
        pats = [f"**/{key}", f"**/RUN_{key}", f"**/{key}*"]
        for b in bases:
            bp = Path(b)
            if not bp.exists():
                continue
            for pat in pats:
                for m in bp.glob(pat):
                    if m.is_dir():
                        return m
        return None

    def _vsp_export_candidates(ci_run_dir, fmt: str):
        d = Path(ci_run_dir)
        html = [
            d / "reports" / "vsp_run_report_cio_v3.html",
            d / "reports" / "report.html",
            d / "reports" / "index.html",
            d / "vsp_run_report_cio_v3.html",
            d / "report.html",
        ]
        pdf = [
            d / "reports" / "report.pdf",
            d / "reports" / "vsp_run_report_cio_v3.pdf",
            d / "report.pdf",
        ]
        zips = [
            d / "reports" / "report.zip",
            d / "reports.zip",
            d / "report.zip",
        ]
        if fmt == "html":
            cands = html + [Path(x) for x in glob.glob(str(d / "reports" / "*.html"))]
        elif fmt == "pdf":
            cands = pdf + [Path(x) for x in glob.glob(str(d / "reports" / "*.pdf"))]
        else:
            cands = zips + [Path(x) for x in glob.glob(str(d / "reports" / "*.zip"))]

        out = []
        for f in cands:
            try:
                if f.is_file() and f.stat().st_size > 0:
                    out.append(f)
            except Exception:
                pass
        # de-dupe
        seen = set(); uniq = []
        for f in out:
            k = str(f)
            if k not in seen:
                uniq.append(f); seen.add(k)
        return uniq

    @_app.route("/api/vsp/run_export_v3/<rid>", methods=["GET","HEAD"])
    def api_vsp_run_export_v3(rid):
        fmt = (request.args.get("fmt", "html") or "html").lower().strip()
        if fmt not in ("html","pdf","zip"):
            return jsonify(ok=False, error="bad_fmt", fmt=fmt), 400

        ci_dir = _vsp_resolve_ci_run_dir(rid)
        if not ci_dir:
            return jsonify(ok=False, error="run_not_found", rid=rid), 404

        cands = _vsp_export_candidates(ci_dir, fmt)
        if not cands:
            # IMPORTANT: differentiate from missing-route
            return jsonify(ok=False, error="export_file_not_found", rid=rid, fmt=fmt, ci_run_dir=str(ci_dir)), 404

        f = cands[0]
        
        ctype = mimetypes.guess_type(str(f))[0] or "application/octet-stream"

        # meta mode for quick debugging
        if request.args.get("meta","0") == "1":
            return jsonify(ok=True, rid=rid, rel=rel, abs=str(f), ctype=ctype, size=int(f.stat().st_size)), 200

        if request.method == "HEAD":
            resp = Response(status=200)
            resp.headers["Content-Type"] = ctype
            resp.headers["X-VSP-ARTOPEN"] = "ok"
            try:
                resp.headers["Content-Length"] = str(f.stat().st_size)
            except Exception:
                pass
            return resp

        # Read file and respond with explicit mimetype (resists gateway header overrides better than send_file)
        data = f.read_bytes()
        resp = Response(data, status=200, mimetype=ctype)
        resp.headers["X-VSP-ARTOPEN"] = "ok"
        resp.headers["X-Content-Type-Options"] = "nosniff"
        return resp

# Install onto the live app
try:
    _APP = globals().get("application") or globals().get("app")
    _vsp_install_export_v3_on_app(_APP)
except Exception:
    pass
# === /VSP_GATEWAY_EXPORT_V3_IN_WSGI_V1 ===




# === VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_FILL8_BYTOOL_V1 ===
def _vsp_statusv2_fill8_bytool(obj: dict) -> dict:
    """
    Ensure run_gate_summary.by_tool includes 8 commercial tools keys.
    If missing, set verdict=NOT_RUN and total=0 (do NOT override existing).
    """
    want = ["SEMGREP","TRIVY","KICS","GITLEAKS","CODEQL","BANDIT","SYFT","GRYPE"]
    try:
        rgs = obj.get("run_gate_summary") or {}
        by_tool = rgs.get("by_tool") or {}
        if not isinstance(by_tool, dict):
            by_tool = {}
        changed = False
        for k in want:
            if k not in by_tool:
                by_tool[k] = {"tool": k, "verdict": "NOT_RUN", "total": 0}
                changed = True
            else:
                # normalize shape a bit (keep existing verdict/total)
                v = by_tool.get(k) or {}
                if isinstance(v, dict):
                    if "tool" not in v:
                        v["tool"] = k
                        changed = True
                    by_tool[k] = v
        if changed:
            rgs["by_tool"] = by_tool
            obj["run_gate_summary"] = rgs
    except Exception:
        pass
    return obj

def _vsp_try_fill8_on_json_bytes(b: bytes) -> bytes:
    import json
    try:
        obj = json.loads(b.decode("utf-8", errors="ignore"))
        if isinstance(obj, dict) and obj.get("ok") is True:
            obj2 = _vsp_statusv2_fill8_bytool(obj)
            return json.dumps(obj2, ensure_ascii=False).encode("utf-8")
    except Exception:
        return b
    return b

# Hook into existing bytes postprocess chain if present; otherwise wrap WSGI app at the end.
try:
    # If there is a global postprocess dispatcher, extend it
    if "_VSP_STATUSV2_BYTES_POSTPROCESSORS" in globals() and isinstance(globals().get("_VSP_STATUSV2_BYTES_POSTPROCESSORS"), list):
        globals()["_VSP_STATUSV2_BYTES_POSTPROCESSORS"].append(_vsp_try_fill8_on_json_bytes)
    else:
        globals()["_VSP_STATUSV2_BYTES_POSTPROCESSORS"] = [_vsp_try_fill8_on_json_bytes]
except Exception:
    pass
# === /VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_FILL8_BYTOOL_V1 ===




# === VSP_WSGI_STATUSV2_FILL8_MW_V1 ===
def _vsp_statusv2_fill8_obj(obj: dict) -> dict:
    want = ["SEMGREP","TRIVY","KICS","GITLEAKS","CODEQL","BANDIT","SYFT","GRYPE"]
    try:
        rgs = obj.get("run_gate_summary") or {}
        by_tool = rgs.get("by_tool") or {}
        if not isinstance(by_tool, dict):
            by_tool = {}
        for k in want:
            if k not in by_tool:
                by_tool[k] = {"tool": k, "verdict": "NOT_RUN", "total": 0}
            else:
                v = by_tool.get(k)
                if isinstance(v, dict) and "tool" not in v:
                    v["tool"] = k
                    by_tool[k] = v
        rgs["by_tool"] = by_tool
        obj["run_gate_summary"] = rgs
    except Exception:
        pass
    return obj

def _vsp_statusv2_fill8_bytes(body_bytes: bytes) -> bytes:
    import json
    try:
        obj = json.loads(body_bytes.decode("utf-8", errors="ignore"))
        if isinstance(obj, dict) and obj.get("ok") is True and isinstance(obj.get("run_gate_summary"), dict):
            obj = _vsp_statusv2_fill8_obj(obj)
            return json.dumps(obj, ensure_ascii=False).encode("utf-8")
    except Exception:
        return body_bytes
    return body_bytes

def _vsp_wsgi_wrap_statusv2_fill8(app):
    if getattr(app, "_vsp_wrapped_statusv2_fill8", False):
        return app
    setattr(app, "_vsp_wrapped_statusv2_fill8", True)

    def _wrapped(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_status_v2/"):
            return app(environ, start_response)

        # capture status/headers
        captured = {"status": None, "headers": None, "exc": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            # delay calling real start_response until we potentially rewrite body
            return None

        iterable = app(environ, _sr)

        # buffer body (status_v2 JSON is small)
        chunks = []
        try:
            for c in iterable:
                if c:
                    chunks.append(c)
        finally:
            try:
                close = getattr(iterable, "close", None)
                if close:
                    close()
            except Exception:
                pass

        body = b"".join(chunks)
        # Only rewrite when JSON-ish
        hdrs = captured["headers"] or []
        ct = ""
        for k, v in hdrs:
            if str(k).lower() == "content-type":
                ct = str(v).lower()
                break

        if ("application/json" in ct) or (body.lstrip().startswith(b"{")):
            body2 = _vsp_statusv2_fill8_bytes(body)
        else:
            body2 = body

        # fix Content-Length
        new_hdrs = []
        for k, v in hdrs:
            if str(k).lower() == "content-length":
                continue
            new_hdrs.append((k, v))
        new_hdrs.append(("Content-Length", str(len(body2))))

        start_response(captured["status"] or "200 OK", new_hdrs, captured["exc"])
        return [body2]

    return _wrapped

try:
    _APP = globals().get("application") or globals().get("app")
    if _APP is not None:
        globals()["application"] = _vsp_wsgi_wrap_statusv2_fill8(_APP)
except Exception:
    pass
# === /VSP_WSGI_STATUSV2_FILL8_MW_V1 ===




# === VSP_GATEWAY_ARTIFACT_OPEN_V1 ===
def _vsp_install_artifact_open_v1(_app):
    try:
        from flask import request, jsonify, send_file
    except Exception:
        return
    from pathlib import Path
    import mimetypes

    if _app is None or not hasattr(_app, "route"):
        return
    if getattr(_app, "_vsp_artifact_open_v1_installed", False):
        return
    setattr(_app, "_vsp_artifact_open_v1_installed", True)

    # reuse resolver from export_v3 if present
    _resolve = globals().get("_vsp_resolve_ci_run_dir", None)
    if _resolve is None:
        def _resolve(rid: str):
            key = (rid or "").strip()
            if key.startswith("RUN_"):
                key = key[len("RUN_"):]
            bases = [
                "/home/test/Data/SECURITY-10-10-v4/out_ci",
                "/home/test/Data/SECURITY_BUNDLE/out",
                "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
            ]
            for b in bases:
                d = Path(b) / key
                if d.is_dir():
                    return d
            return None

    # simple whitelist for rel paths (only allow inside run dir, deny parent traversal)
    def _safe_join(run_dir: Path, rel: str):
        rel = (rel or "").lstrip("/").strip()
        if not rel:
            return None
        if ".." in rel.split("/"):
            return None
        # allow only certain top-level folders/files
        allow_prefixes = ("reports/", "findings_", "summary_", "gitleaks/", "semgrep/", "trivy/", "kics/", "codeql/", "bandit/", "syft/", "grype/", "artifacts/")
        if not (rel.startswith(allow_prefixes) or rel in ("runner.log","SUMMARY.txt")):
            return None
        f = (run_dir / rel).resolve()
        if run_dir.resolve() not in f.parents and f != run_dir.resolve():
            return None
        return f

    @_app.route("/api/vsp/run_artifact_open_v1/<rid>", methods=["GET","HEAD"])
    def api_vsp_run_artifact_open_v1(rid):
        from flask import Response
        rel = request.args.get("rel","")
        run_dir = _resolve(rid)
        if not run_dir:
            return jsonify(ok=False, error="run_not_found", rid=rid), 404

        f = _safe_join(Path(run_dir), rel)
        if not f:
            return jsonify(ok=False, error="bad_rel", rel=rel), 400
        if not f.is_file():
            return jsonify(ok=False, error="file_not_found", rel=rel), 404

        ctype = mimetypes.guess_type(str(f))[0] or "application/octet-stream"
        if request.method == "HEAD":
            resp = Response(status=200)
            resp.headers["Content-Type"] = ctype
            try:
                resp.headers["Content-Length"] = str(f.stat().st_size)
            except Exception:
                pass
            return resp

        # inline for html/json/txt; attachment for others
        as_attach = not (ctype.startswith("text/") or ctype.endswith("json") or "html" in ctype)
        return send_file(str(f), mimetype=ctype, as_attachment=as_attach, download_name=f.name)
# === /VSP_GATEWAY_ARTIFACT_OPEN_V1 ===

try:
    _APP = globals().get("application") or globals().get("app")
    _vsp_install_artifact_open_v1(_APP)
except Exception:
    pass


# === VSP_GATEWAY_ARTIFACT_OPEN_V2_FIXCT ===



# === VSP_GATEWAY_FINDINGS_PREVIEW_V1 ===
def _vsp_install_findings_preview_v1(_app):
    try:
        from flask import request, jsonify
    except Exception:
        return
    import json, csv
    from pathlib import Path

    if _app is None or not hasattr(_app, "route"):
        return
    if getattr(_app, "_vsp_findings_preview_v1_installed", False):
        return
    setattr(_app, "_vsp_findings_preview_v1_installed", True)

    _resolve = globals().get("_vsp_resolve_ci_run_dir", None)
    if _resolve is None:
        def _resolve(rid: str):
            key = (rid or "").strip()
            if key.startswith("RUN_"):
                key = key[len("RUN_"):]
            bases = [
                "/home/test/Data/SECURITY-10-10-v4/out_ci",
                "/home/test/Data/SECURITY_BUNDLE/out",
                "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
            ]
            for b in bases:
                d = Path(b) / key
                if d.is_dir():
                    return d
            return None

    def _norm(x):
        return (x or "").strip()

    def _pick_fields(rec: dict):
        # normalize common fields across tools
        return {
            "severity": rec.get("severity") or rec.get("sev") or rec.get("level") or "",
            "tool": rec.get("tool") or rec.get("source") or "",
            "rule_id": rec.get("rule_id") or rec.get("check_id") or rec.get("id") or "",
            "title": rec.get("title") or rec.get("message") or rec.get("name") or "",
            "file": rec.get("file") or rec.get("path") or rec.get("filename") or "",
            "line": rec.get("line") or rec.get("start_line") or rec.get("startLine") or "",
            "cwe": rec.get("cwe") or rec.get("cwe_id") or "",
        }

    def _load_json_findings(fp: Path):
        obj = json.loads(fp.read_text(encoding="utf-8", errors="ignore"))
        if isinstance(obj, dict):
            # common: {"findings":[...]} or {"items":[...]}
            for k in ("findings","items","results","data"):
                if k in obj and isinstance(obj[k], list):
                    return obj[k]
            # or already normalized dict -> wrap
            return [obj]
        if isinstance(obj, list):
            return obj
        return []

    def _load_csv_findings(fp: Path):
        rows = []
        with fp.open("r", encoding="utf-8", errors="ignore", newline="") as f:
            r = csv.DictReader(f)
            for row in r:
                rows.append(row)
        return rows

    def _match(rec: dict, sevs:set, tools:set, search:str):
        s = search.lower().strip() if search else ""
        if sevs:
            sev = str(rec.get("severity","")).upper()
            if sev not in sevs:
                return False
        if tools:
            tool = str(rec.get("tool","")).upper()
            if tool not in tools:
                return False
        if s:
            hay = " ".join([
                str(rec.get("title","")),
                str(rec.get("rule_id","")),
                str(rec.get("file","")),
                str(rec.get("cwe","")),
                str(rec.get("tool","")),
                str(rec.get("severity","")),
            ]).lower()
            if s not in hay:
                return False
        return True

    @_app.route("/api/vsp/run_findings_preview_v1/<rid>", methods=["GET"])
    def api_vsp_run_findings_preview_v1(rid):
        limit = int(request.args.get("limit","200") or "200")
        limit = max(1, min(limit, 2000))
        page = int(request.args.get("page","1") or "1")
        page = max(1, page)

        sevs_q = _norm(request.args.get("sev",""))
        tools_q = _norm(request.args.get("tool",""))
        search = _norm(request.args.get("search",""))

        sevs = set([x.strip().upper() for x in sevs_q.split(",") if x.strip()]) if sevs_q else set()
        tools = set([x.strip().upper() for x in tools_q.split(",") if x.strip()]) if tools_q else set()

        run_dir = _resolve(rid)
        if not run_dir:
            return jsonify(ok=False, error="run_not_found", rid=rid), 404

        run_dir = Path(run_dir)
        cand = [
            run_dir / "findings_unified.json",
            run_dir / "reports" / "findings_unified.json",
            run_dir / "findings_unified.csv",
            run_dir / "reports" / "findings_unified.csv",
        ]
        fp = next((x for x in cand if x.is_file() and x.stat().st_size>0), None)
        if not fp:
            return jsonify(ok=False, error="findings_file_not_found", rid=rid, run_dir=str(run_dir)), 404

        try:
            if fp.suffix.lower() == ".json":
                raw = _load_json_findings(fp)
            else:
                raw = _load_csv_findings(fp)
        except Exception as e:
            return jsonify(ok=False, error="findings_parse_error", detail=str(e), file=str(fp)), 500

        # normalize + filter
        normed = []
        for r in raw:
            if not isinstance(r, dict):
                continue
            rec = _pick_fields(r)
            if _match(rec, sevs, tools, search):
                normed.append(rec)

        total = len(normed)
        start = (page-1)*limit
        end = start + limit
        items = normed[start:end]

        # helpful facets
        sev_counts = {}
        tool_counts = {}
        for rec in normed[:5000]:
            sv = str(rec.get("severity","")).upper() or "UNKNOWN"
            tl = str(rec.get("tool","")).upper() or "UNKNOWN"
            sev_counts[sv] = sev_counts.get(sv, 0) + 1
            tool_counts[tl] = tool_counts.get(tl, 0) + 1

        return jsonify(
            ok=True,
            rid=rid,
            run_dir=str(run_dir),
            file=str(fp),
            page=page,
            limit=limit,
            total=total,
            items=items,
            facets={"severity": sev_counts, "tool": tool_counts},
        )
# === /VSP_GATEWAY_FINDINGS_PREVIEW_V1 ===

try:
    _APP = globals().get("application") or globals().get("app")
    _vsp_install_findings_preview_v1(_APP)
except Exception:
    pass




# === VSP_WSGI_FINDINGS_PREVIEW_SCHEMA_GUARD_V1 ===
def _vsp_findings_preview_guard_bytes(body_bytes: bytes) -> bytes:
    import json
    try:
        obj = json.loads(body_bytes.decode("utf-8", errors="ignore"))
        if not isinstance(obj, dict):
            return body_bytes

        # If endpoint returns missing-file -> degrade gracefully (commercial)
        if obj.get("ok") is False and obj.get("error") in ("findings_file_not_found",):
            rid = obj.get("rid")
            run_dir = obj.get("run_dir") or obj.get("run_dir_guess") or obj.get("run_dir_resolved") or obj.get("run_dir_path")
            fixed = {
                "ok": True,
                "has_findings": False,
                "warning": obj.get("error"),
                "rid": rid,
                "run_dir": run_dir,
                "file": None,
                "page": int(obj.get("page", 1) or 1),
                "limit": int(obj.get("limit", 200) or 200),
                "total": 0,
                "items": [],
                "facets": {"severity": {}, "tool": {}},
            }
            return json.dumps(fixed, ensure_ascii=False).encode("utf-8")

        return body_bytes
    except Exception:
        return body_bytes

def _vsp_wsgi_wrap_findings_preview_schema(app):
    if getattr(app, "_vsp_wrapped_findprev_guard", False):
        return app
    setattr(app, "_vsp_wrapped_findprev_guard", True)

    def _wrapped(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_findings_preview_v1/"):
            return app(environ, start_response)

        captured = {"status": None, "headers": None, "exc": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            return None

        iterable = app(environ, _sr)

        chunks = []
        try:
            for c in iterable:
                if c:
                    chunks.append(c)
        finally:
            try:
                close = getattr(iterable, "close", None)
                if close:
                    close()
            except Exception:
                pass

        body = b"".join(chunks)
        body2 = _vsp_findings_preview_guard_bytes(body)

        hdrs = captured["headers"] or []
        new_hdrs = []
        for k, v in hdrs:
            if str(k).lower() == "content-length":
                continue
            new_hdrs.append((k, v))
        new_hdrs.append(("Content-Length", str(len(body2))))
        start_response(captured["status"] or "200 OK", new_hdrs, captured["exc"])
        return [body2]

    return _wrapped

try:
    _APP = globals().get("application") or globals().get("app")
    if _APP is not None:
        globals()["application"] = _vsp_wsgi_wrap_findings_preview_schema(_APP)
except Exception:
    pass
# === /VSP_WSGI_FINDINGS_PREVIEW_SCHEMA_GUARD_V1 ===




# === VSP_WSGI_FINDINGS_PREVIEW_HANDLER_V2 ===
def _vsp_wsgi_findings_preview_v2(app):
    if getattr(app, "_vsp_wrapped_findprev_v2", False):
        return app
    setattr(app, "_vsp_wrapped_findprev_v2", True)

    import json, csv
    from pathlib import Path
    from urllib.parse import parse_qs

    # reuse resolver if present (export_v3 uses it)
    _resolve = globals().get("_vsp_resolve_ci_run_dir", None)
    if _resolve is None:
        def _resolve(rid: str):
            key = (rid or "").strip()
            if key.startswith("RUN_"):
                key = key[len("RUN_"):]
            bases = [
                "/home/test/Data/SECURITY-10-10-v4/out_ci",
                "/home/test/Data/SECURITY_BUNDLE/out",
                "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
            ]
            for b in bases:
                d = Path(b) / key
                if d.is_dir():
                    return d
            return None

    def _pick_fields(rec: dict):
        return {
            "severity": rec.get("severity") or rec.get("sev") or rec.get("level") or "",
            "tool": rec.get("tool") or rec.get("source") or "",
            "rule_id": rec.get("rule_id") or rec.get("check_id") or rec.get("id") or "",
            "title": rec.get("title") or rec.get("message") or rec.get("name") or "",
            "file": rec.get("file") or rec.get("path") or rec.get("filename") or "",
            "line": rec.get("line") or rec.get("start_line") or rec.get("startLine") or "",
            "cwe": rec.get("cwe") or rec.get("cwe_id") or "",
        }

    def _load_json_findings(fp: Path):
        obj = json.loads(fp.read_text(encoding="utf-8", errors="ignore"))
        if isinstance(obj, dict):
            for k in ("findings","items","results","data"):
                if k in obj and isinstance(obj[k], list):
                    return obj[k]
            return [obj]
        if isinstance(obj, list):
            return obj
        return []

    def _load_csv_findings(fp: Path):
        rows = []
        with fp.open("r", encoding="utf-8", errors="ignore", newline="") as f:
            r = csv.DictReader(f)
            for row in r:
                rows.append(row)
        return rows

    def _match(rec: dict, sevs:set, tools:set, search:str):
        s = (search or "").lower().strip()
        if sevs:
            sev = str(rec.get("severity","")).upper()
            if sev not in sevs:
                return False
        if tools:
            tool = str(rec.get("tool","")).upper()
            if tool not in tools:
                return False
        if s:
            hay = " ".join([
                str(rec.get("title","")),
                str(rec.get("rule_id","")),
                str(rec.get("file","")),
                str(rec.get("cwe","")),
                str(rec.get("tool","")),
                str(rec.get("severity","")),
            ]).lower()
            if s not in hay:
                return False
        return True

    def _resp(start_response, code:int, payload:dict):
        body = json.dumps(payload, ensure_ascii=False).encode("utf-8")
        start_response(f"{code} OK" if code==200 else f"{code} NOT FOUND", [
            ("Content-Type","application/json; charset=utf-8"),
            ("Content-Length", str(len(body))),
            ("Cache-Control","no-store"),
        ])
        return [body]

    def _wrapped(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_findings_preview_v1/"):
            return app(environ, start_response)

        # parse rid from path
        rid = path.split("/api/vsp/run_findings_preview_v1/", 1)[1].strip("/")
        qs = parse_qs(environ.get("QUERY_STRING","") or "")

        def q1(k, default=""):
            v = qs.get(k, [default])
            return v[0] if v else default

        try:
            limit = int(q1("limit","200") or "200")
        except Exception:
            limit = 200
        limit = max(1, min(limit, 2000))

        try:
            page = int(q1("page","1") or "1")
        except Exception:
            page = 1
        page = max(1, page)

        sev_q = (q1("sev","") or "").strip()
        tool_q = (q1("tool","") or "").strip()
        search = (q1("search","") or "").strip()

        sevs = set([x.strip().upper() for x in sev_q.split(",") if x.strip()]) if sev_q else set()
        tools = set([x.strip().upper() for x in tool_q.split(",") if x.strip()]) if tool_q else set()

        run_dir = _resolve(rid)
        if not run_dir:
            return _resp(start_response, 404, {
                "ok": False,
                "error": "run_not_found",
                "rid": rid,
                "has_findings": False,
                "total": 0,
                "items": [],
                "facets": {"severity": {}, "tool": {}},
            })

        run_dir = Path(run_dir)
        cand = [
            run_dir / "findings_unified.json",
            run_dir / "reports" / "findings_unified.json",
            run_dir / "findings_unified.csv",
            run_dir / "reports" / "findings_unified.csv",
        ]
        fp = next((x for x in cand if x.is_file() and x.stat().st_size>0), None)

        if not fp:
            # COMMERCIAL: stable schema, not an error that breaks UI
            return _resp(start_response, 200, {
                "ok": True,
                "has_findings": False,
                "warning": "findings_file_not_found",
                "rid": rid,
                "run_dir": str(run_dir),
                "file": None,
                "page": page,
                "limit": limit,
                "total": 0,
                "items": [],
                "facets": {"severity": {}, "tool": {}},
            })

        try:
            raw = _load_json_findings(fp) if fp.suffix.lower()==".json" else _load_csv_findings(fp)
        except Exception as e:
            return _resp(start_response, 200, {
                "ok": True,
                "has_findings": False,
                "warning": "findings_parse_error",
                "detail": str(e),
                "rid": rid,
                "run_dir": str(run_dir),
                "file": str(fp),
                "page": page,
                "limit": limit,
                "total": 0,
                "items": [],
                "facets": {"severity": {}, "tool": {}},
            })

        normed = []
        for r in raw:
            if not isinstance(r, dict):
                continue
            rec = _pick_fields(r)
            if _match(rec, sevs, tools, search):
                normed.append(rec)

        total = len(normed)
        start = (page-1)*limit
        end = start + limit
        items = normed[start:end]

        sev_counts = {}
        tool_counts = {}
        for rec in normed[:5000]:
            sv = str(rec.get("severity","")).upper() or "UNKNOWN"
            tl = str(rec.get("tool","")).upper() or "UNKNOWN"
            sev_counts[sv] = sev_counts.get(sv, 0) + 1
            tool_counts[tl] = tool_counts.get(tl, 0) + 1

        return _resp(start_response, 200, {
            "ok": True,
            "has_findings": True,
            "rid": rid,
            "run_dir": str(run_dir),
            "file": str(fp),
            "page": page,
            "limit": limit,
            "total": total,
            "items": items,
            "facets": {"severity": sev_counts, "tool": tool_counts},
        })

    return _wrapped
# === /VSP_WSGI_FINDINGS_PREVIEW_HANDLER_V2 ===

try:
    _APP = globals().get("application") or globals().get("app")
    if _APP is not None:
        globals()["application"] = _vsp_wsgi_findings_preview_v2(_APP)
except Exception:
    pass




# === VSP_WSGI_EXPORT_V3_HEADSHIM_V1 ===
def _vsp_wsgi_export_v3_headshim_v1(app):
    if getattr(app, "_vsp_wrapped_export_headshim_v1", False):
        return app
    setattr(app, "_vsp_wrapped_export_headshim_v1", True)

    import json
    from pathlib import Path
    from urllib.parse import parse_qs

    _resolve = globals().get("_vsp_resolve_ci_run_dir", None)
    if _resolve is None:
        def _resolve(rid: str):
            key = (rid or "").strip()
            if key.startswith("RUN_"):
                key = key[len("RUN_"):]
            bases = [
                "/home/test/Data/SECURITY-10-10-v4/out_ci",
                "/home/test/Data/SECURITY_BUNDLE/out",
                "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
            ]
            for b in bases:
                d = Path(b) / key
                if d.is_dir():
                    return d
            return None

    def _pick_file(run_dir: Path, fmt: str):
        fmt = (fmt or "html").lower().strip()
        # canonical names
        if fmt == "html":
            cands = [run_dir/"reports"/"vsp_run_report_cio_v3.html"]
        elif fmt == "zip":
            cands = [run_dir/"reports"/"report.zip", run_dir/"reports"/"vsp_report.zip"]
        elif fmt == "pdf":
            cands = [run_dir/"reports"/"vsp_run_report_cio_v3.pdf"]
        else:
            cands = []
        for fp in cands:
            try:
                if fp.is_file() and fp.stat().st_size > 0:
                    return fp, fmt
            except Exception:
                pass
        return None, fmt

    def _head_resp(start_response, avail: bool, fmt: str, fp: Path|None, rid: str, run_dir: Path|None):
        hdrs = [
            ("Cache-Control","no-store"),
            ("X-VSP-EXPORT-AVAILABLE", "1" if avail else "0"),
            ("X-VSP-EXPORT-FMT", fmt),
        ]
        if avail and fp is not None:
            if fmt == "html":
                hdrs += [("Content-Type","text/html; charset=utf-8"),
                         ("Content-Disposition", f'inline; filename={fp.name}'),
                         ("Content-Length", str(fp.stat().st_size))]
            elif fmt == "zip":
                hdrs += [("Content-Type","application/zip"),
                         ("Content-Disposition", f'attachment; filename={fp.name}'),
                         ("Content-Length", str(fp.stat().st_size))]
            elif fmt == "pdf":
                hdrs += [("Content-Type","application/pdf"),
                         ("Content-Disposition", f'inline; filename={fp.name}'),
                         ("Content-Length", str(fp.stat().st_size))]
            start_response("200 OK", hdrs)
            return [b""]
        # not available -> still 200, no noise
        start_response("200 OK", hdrs + [("Content-Type","application/json; charset=utf-8")])
        return [b""]

    def _wrapped(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_export_v3/"):
            return app(environ, start_response)

        method = (environ.get("REQUEST_METHOD") or "GET").upper()
        rid = path.split("/api/vsp/run_export_v3/", 1)[1].strip("/")
        qs = parse_qs(environ.get("QUERY_STRING","") or "")
        fmt = (qs.get("fmt", ["html"])[0] or "html").strip()

        run_dir = _resolve(rid)
        if not run_dir:
            # for HEAD, still return 200 to avoid UI spam; available=0
            if method == "HEAD":
                return _head_resp(start_response, False, fmt, None, rid, None)
            body = json.dumps({"ok": False, "http_code": 404, "error":"run_not_found", "rid": rid}).encode("utf-8")
            start_response("404 NOT FOUND", [("Content-Type","application/json; charset=utf-8"),
                                            ("Content-Length", str(len(body))),
                                            ("Cache-Control","no-store")])
            return [body]

        run_dir = Path(run_dir)
        fp, fmt2 = _pick_file(run_dir, fmt)
        avail = fp is not None

        if method == "HEAD":
            return _head_resp(start_response, avail, fmt2, fp, rid, run_dir)

        # GET -> if available serve bytes, else keep 404 json
        if not avail:
            body = json.dumps({
                "ok": False,
                "http_code": 404,
                "error": "export_file_not_found",
                "rid": rid,
                "fmt": fmt2,
                "run_dir": str(run_dir),
            }, ensure_ascii=False).encode("utf-8")
            start_response("404 NOT FOUND", [("Content-Type","application/json; charset=utf-8"),
                                            ("Content-Length", str(len(body))),
                                            ("Cache-Control","no-store")])
            return [body]

        data = fp.read_bytes()
        if fmt2 == "html":
            ct = "text/html; charset=utf-8"
            cd = f'inline; filename={fp.name}'
        elif fmt2 == "zip":
            ct = "application/zip"
            cd = f'attachment; filename={fp.name}'
        else:
            ct = "application/pdf"
            cd = f'inline; filename={fp.name}'
        start_response("200 OK", [("Content-Type", ct),
                                 ("Content-Disposition", cd),
                                 ("Content-Length", str(len(data))),
                                 ("Cache-Control","no-store"),
                                 ("X-VSP-EXPORT-AVAILABLE","1"),
                                 ("X-VSP-EXPORT-FMT", fmt2)])
        return [data]

    return _wrapped
# === /VSP_WSGI_EXPORT_V3_HEADSHIM_V1 ===

try:
    _APP = globals().get("application") or globals().get("app")
    if _APP is not None:
        globals()["application"] = _vsp_wsgi_export_v3_headshim_v1(_APP)
except Exception:
    pass




# === VSP_WSGI_EXPORT_PDF_PREEMPT_V1 ===
import os, glob, json
from urllib.parse import parse_qs

class VspExportPdfPreempt:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        try:
            path = environ.get("PATH_INFO", "") or ""
            if path.startswith("/api/vsp/run_export_v3/"):
                qs = environ.get("QUERY_STRING", "") or ""
                q = parse_qs(qs)
                fmt = (q.get("fmt", ["html"])[0] or "html").lower().strip()

                if fmt == "pdf":
                    rid = path.split("/api/vsp/run_export_v3/", 1)[1].strip("/")
                    rid_norm = rid[4:] if rid.startswith("RUN_") else rid

                    base = os.environ.get("VSP_CI_OUT_ROOT") or "/home/test/Data/SECURITY-10-10-v4/out_ci"
                    ci_dir = os.path.join(base, rid_norm)

                    if not os.path.isdir(ci_dir):
                        ci_dir = ""
                        for d in sorted(glob.glob(os.path.join(base, "VSP_CI_*")), reverse=True):
                            if rid_norm in os.path.basename(d):
                                ci_dir = d
                                break

                    pdf = ""
                    best_m = -1.0
                    if ci_dir:
                        for pat in (os.path.join(ci_dir, "reports", "*.pdf"), os.path.join(ci_dir, "*.pdf")):
                            for f in glob.glob(pat):
                                try:
                                    m = os.path.getmtime(f)
                                except Exception:
                                    continue
                                if m > best_m:
                                    best_m = m
                                    pdf = f

                    if pdf and os.path.isfile(pdf):
                        size = os.path.getsize(pdf)
                        headers = [
                            ("Content-Type", "application/pdf"),
                            ("Content-Disposition", f'attachment; filename="{os.path.basename(pdf)}"'),
                            ("Content-Length", str(size)),
                            ("X-VSP-EXPORT-AVAILABLE", "1"),
                            ("X-VSP-EXPORT-FILE", os.path.basename(pdf)),
                        ]
                        start_response("200 OK", headers)
                        return open(pdf, "rb")

                    body = json.dumps({
                        "ok": False,
                        "http_code": 404,
                        "error": "PDF_NOT_FOUND",
                        "rid": rid,
                        "rid_norm": rid_norm,
                        "ci_run_dir": ci_dir or None
                    }).encode("utf-8")
                    start_response("404 NOT FOUND", [
                        ("Content-Type", "application/json"),
                        ("Content-Length", str(len(body))),
                        ("X-VSP-EXPORT-AVAILABLE", "0"),
                    ])
                    return [body]
        except Exception as e:
            body = json.dumps({"ok": False, "http_code": 500, "error": "EXPORT_PREEMPT_ERR", "detail": str(e)}).encode("utf-8")
            start_response("500 INTERNAL SERVER ERROR", [
                ("Content-Type", "application/json"),
                ("Content-Length", str(len(body))),
                ("X-VSP-EXPORT-AVAILABLE", "0"),
            ])
            return [body]

        return self.app(environ, start_response)

try:
    application = VspExportPdfPreempt(application)
    try:
        print("[VSP_WSGI_EXPORT_PDF_PREEMPT_V1] installed")
    except Exception:
        pass
except Exception:
    pass




# === VSP_WSGI_EXPORT_PDF_PREEMPT_V2 ===
import os, glob, json
from urllib.parse import parse_qs

class VspExportPdfPreemptV2:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        try:
            path = environ.get("PATH_INFO", "") or ""
            if path.startswith("/api/vsp/run_export_v3/"):
                qs = environ.get("QUERY_STRING", "") or ""
                q = parse_qs(qs)
                fmt = (q.get("fmt", ["html"])[0] or "html").lower().strip()
                if fmt == "pdf":
                    rid = path.split("/api/vsp/run_export_v3/", 1)[1].strip("/")
                    rid_norm = rid[4:] if rid.startswith("RUN_") else rid

                    base = os.environ.get("VSP_CI_OUT_ROOT") or "/home/test/Data/SECURITY-10-10-v4/out_ci"
                    ci_dir = os.path.join(base, rid_norm)

                    if not os.path.isdir(ci_dir):
                        ci_dir = ""
                        for d in sorted(glob.glob(os.path.join(base, "VSP_CI_*")), reverse=True):
                            if rid_norm in os.path.basename(d):
                                ci_dir = d
                                break

                    pdf = ""
                    best_m = -1.0
                    if ci_dir:
                        for pat in (os.path.join(ci_dir, "reports", "*.pdf"), os.path.join(ci_dir, "*.pdf")):
                            for f in glob.glob(pat):
                                try:
                                    m = os.path.getmtime(f)
                                except Exception:
                                    continue
                                if m > best_m:
                                    best_m = m
                                    pdf = f

                    if pdf and os.path.isfile(pdf):
                        size = os.path.getsize(pdf)
                        headers = [
                            ("Content-Type", "application/pdf"),
                            ("Content-Disposition", f'attachment; filename="{os.path.basename(pdf)}"'),
                            ("Content-Length", str(size)),
                            ("X-VSP-EXPORT-AVAILABLE", "1"),
                            ("X-VSP-EXPORT-FILE", os.path.basename(pdf)),
                        ]
                        start_response("200 OK", headers)
                        return open(pdf, "rb")

                    body = json.dumps({
                        "ok": False, "http_code": 404, "error": "PDF_NOT_FOUND",
                        "rid": rid, "rid_norm": rid_norm,
                        "ci_run_dir": ci_dir or None
                    }).encode("utf-8")
                    start_response("404 NOT FOUND", [
                        ("Content-Type", "application/json"),
                        ("Content-Length", str(len(body))),
                        ("X-VSP-EXPORT-AVAILABLE", "0"),
                    ])
                    return [body]
        except Exception as e:
            body = json.dumps({"ok": False, "http_code": 500, "error": "EXPORT_PREEMPT_ERR", "detail": str(e)}).encode("utf-8")
            start_response("500 INTERNAL SERVER ERROR", [
                ("Content-Type", "application/json"),
                ("Content-Length", str(len(body))),
                ("X-VSP-EXPORT-AVAILABLE", "0"),
            ])
            return [body]

        return self.app(environ, start_response)

def _vsp_install_export_pdf_preempt_v2():
    g = globals()
    app = g.get("application", None)
    if app is None:
        return False
    # avoid double wrap
    if isinstance(app, VspExportPdfPreemptV2):
        return True
    g["application"] = VspExportPdfPreemptV2(app)
    try:
        print("[VSP_WSGI_EXPORT_PDF_PREEMPT_V2] installed")
    except Exception:
        pass
    return True


try:
    _vsp_install_export_pdf_preempt_v2()
except Exception:
    pass



# === VSP_WSGI_EXPORT_PDF_PREEMPT_FORCE_V3 ===
import os, glob, json
from urllib.parse import parse_qs

class _VspExportPdfPreemptForceV3:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "").strip()
        try:
            if path.startswith("/api/vsp/run_export_v3/"):
                qs = environ.get("QUERY_STRING", "") or ""
                q = parse_qs(qs)
                fmt = (q.get("fmt", ["html"])[0] or "html").lower().strip()
                if fmt == "pdf":
                    rid = path.split("/api/vsp/run_export_v3/", 1)[1].strip("/")
                    rid_norm = rid[4:] if rid.startswith("RUN_") else rid

                    base = os.environ.get("VSP_CI_OUT_ROOT") or "/home/test/Data/SECURITY-10-10-v4/out_ci"
                    ci_dir = os.path.join(base, rid_norm)
                    if not os.path.isdir(ci_dir):
                        ci_dir = ""
                        for d in sorted(glob.glob(os.path.join(base, "VSP_CI_*")), reverse=True):
                            if rid_norm in os.path.basename(d):
                                ci_dir = d
                                break

                    pdf = ""
                    best_m = -1.0
                    if ci_dir:
                        for pat in (os.path.join(ci_dir, "reports", "*.pdf"), os.path.join(ci_dir, "*.pdf")):
                            for f in glob.glob(pat):
                                try:
                                    m = os.path.getmtime(f)
                                except Exception:
                                    continue
                                if m > best_m:
                                    best_m = m
                                    pdf = f

                    if pdf and os.path.isfile(pdf):
                        size = os.path.getsize(pdf)
                        start_response("200 OK", [
                            ("Content-Type", "application/pdf"),
                            ("Content-Disposition", f'attachment; filename="{os.path.basename(pdf)}"'),
                            ("Content-Length", str(size)),
                            ("X-VSP-EXPORT-AVAILABLE", "1"),
                            ("X-VSP-EXPORT-FILE", os.path.basename(pdf)),
                        ])
                        return open(pdf, "rb")

                    body = json.dumps({
                        "ok": False, "http_code": 404,
                        "error": "PDF_NOT_FOUND",
                        "rid": rid, "rid_norm": rid_norm,
                        "ci_run_dir": ci_dir or None
                    }).encode("utf-8")
                    start_response("404 NOT FOUND", [
                        ("Content-Type", "application/json"),
                        ("Content-Length", str(len(body))),
                        ("X-VSP-EXPORT-AVAILABLE", "0"),
                    ])
                    return [body]
        except Exception as e:
            body = json.dumps({"ok": False, "http_code": 500, "error": "EXPORT_PREEMPT_ERR", "detail": str(e)}).encode("utf-8")
            start_response("500 INTERNAL SERVER ERROR", [
                ("Content-Type", "application/json"),
                ("Content-Length", str(len(body))),
                ("X-VSP-EXPORT-AVAILABLE", "0"),
            ])
            return [body]

        return self.app(environ, start_response)

def _vsp__install_export_pdf_preempt_force_v3():
    g = globals()
    app = g.get("application", None)
    if app is None:
        return False
    if isinstance(app, _VspExportPdfPreemptForceV3):
        return True
    g["application"] = _VspExportPdfPreemptForceV3(app)
    try:
        print("[VSP_WSGI_EXPORT_PDF_PREEMPT_FORCE_V3] installed type=", type(g["application"]).__name__)
    except Exception:
        pass
    return True

try:
    _vsp__install_export_pdf_preempt_force_v3()
except Exception:
    pass

