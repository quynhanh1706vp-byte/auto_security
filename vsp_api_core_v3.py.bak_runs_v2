from __future__ import annotations

from flask import Blueprint, jsonify, request
CORE_BASE = "http://localhost:8961"
from pathlib import Path
import json
from typing import Any, Dict, List, Optional

bp_v3 = Blueprint("vsp_api_core_v3", __name__)

# ROOT = /home/test/Data/SECURITY_BUNDLE
ROOT = Path(__file__).resolve().parent.parent
OUT_DIR = ROOT / "out"


def _iter_summary_files():
    """
    Duyệt tất cả summary_unified.json của các RUN_VSP_FULL_EXT_*.
    """
    if not OUT_DIR.exists():
        return []
    return sorted(
        OUT_DIR.glob("RUN_VSP_FULL_EXT_*/report/summary_unified.json"),
        key=lambda p: p.stat().st_mtime,
    )


def _get_latest_run_id() -> Optional[str]:
    """
    Lấy run mới nhất dựa trên mtime của summary_unified.json.
    """
    summaries = _iter_summary_files()
    if not summaries:
        return None
    latest = summaries[-1]
    # .../out/RUN_VSP_FULL_EXT_xxx/report/summary_unified.json
    return latest.parent.parent.name


def _load_json(path: Path) -> Any:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def _load_summary(run_id: str) -> Dict[str, Any]:
    summary_path = OUT_DIR / run_id / "report" / "summary_unified.json"
    if not summary_path.is_file():
        return {}
    data = _load_json(summary_path)
    # Chuẩn hóa total_findings
    if "total_findings" not in data:
        if "total" in data and isinstance(data["total"], int):
            data["total_findings"] = data["total"]
        elif "by_severity" in data and isinstance(data["by_severity"], dict):
            try:
                data["total_findings"] = int(sum(data["by_severity"].values()))
            except Exception:
                data["total_findings"] = 0
        else:
            data["total_findings"] = 0
    return data


def _load_findings(run_id: str) -> List[Dict[str, Any]]:
    findings_path = OUT_DIR / run_id / "report" / "findings_unified.json"
    if not findings_path.is_file():
        return []
    raw = _load_json(findings_path)
    if isinstance(raw, list):
        return raw
    if isinstance(raw, dict):
        # Một số tool unify kiểu {"items": [...]} hoặc {"findings": [...]}
        for key in ("items", "findings", "results"):
            if key in raw and isinstance(raw[key], list):
                return raw[key]
    return []


def _pick_top_key(counts: Dict[str, Any]) -> Optional[str]:
    if not isinstance(counts, dict) or not counts:
        return None
    try:
        return max(counts.items(), key=lambda kv: kv[1])[0]
    except Exception:
        return None


@bp_v3.route("/api/vsp/dashboard_v3", methods=["GET"])
def api_vsp_dashboard_v3():
    """
    Dashboard V3:
      - KPI cho run mới nhất (TOTAL, severity, tool, score, top_*).
      - trend: 10 run gần nhất (cũ → mới) cho line chart.
      - last_runs: 10 run mới nhất (mới → cũ) cho bảng history.
    """
    from flask import jsonify
    from pathlib import Path
    from collections import Counter
    from datetime import datetime
    import json

    root = Path(__file__).resolve().parents[1]   # /home/test/Data/SECURITY_BUNDLE
    out_dir = root / "out"

    def _load_summary(run_dir: Path):
        if not run_dir:
            return None
        for p in [
            run_dir / "report" / "summary_unified.json",
            run_dir / "summary_unified.json",
        ]:
            if p.is_file():
                try:
                    return json.loads(p.read_text(encoding="utf-8"))
                except Exception:
                    pass
        return None

    def _load_findings(run_dir: Path):
        if not run_dir:
            return []
        candidates = [
            run_dir / "report" / "findings_unified.json",
            run_dir / "findings_unified.json",
        ]
        for p in candidates:
            if p.is_file():
                try:
                    data = json.loads(p.read_text(encoding="utf-8"))
                except Exception:
                    continue
                if isinstance(data, list):
                    return data
                if isinstance(data, dict) and isinstance(data.get("items"), list):
                    return data["items"]
        return []

    # ===== Lấy danh sách run =====
    if not out_dir.is_dir():
        return jsonify({
            "ok": True,
            "run_id": None,
            "total_findings": 0,
            "by_severity": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0, "TRACE": 0},
            "by_tool": {},
            "security_score": 0,
            "top_risky_tool": None,
            "top_cwe": None,
            "top_module": None,
            "trend": [],
            "last_runs": [],
        })

    runs = [d for d in out_dir.iterdir() if d.is_dir() and d.name.startswith("RUN_VSP_FULL_EXT_")]
    if not runs:
        return jsonify({
            "ok": True,
            "run_id": None,
            "total_findings": 0,
            "by_severity": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0, "TRACE": 0},
            "by_tool": {},
            "security_score": 0,
            "top_risky_tool": None,
            "top_cwe": None,
            "top_module": None,
            "trend": [],
            "last_runs": [],
        })

    # sort theo timestamp trong tên (…_YYYYmmdd_HHMMSS); fallback mtime → cũ → mới
    from datetime import datetime

    def _run_ts_from_name(p: Path):
        name = p.name
        parts = name.split("_")
        if len(parts) >= 3:
            date_part = parts[-2]
            time_part = parts[-1]
            if date_part.isdigit() and time_part.isdigit():
                try:
                    return datetime.strptime(date_part + time_part, "%Y%m%d%H%M%S")
                except Exception:
                    pass
        # fallback: mtime
        return datetime.fromtimestamp(p.stat().st_mtime)

    runs_sorted = sorted(runs, key=_run_ts_from_name)
    latest_run = runs_sorted[-1]

    summary = _load_summary(latest_run) or {}
    findings_latest = _load_findings(latest_run)

    # KPI chính
    total = summary.get("total_findings") or summary.get("total") or len(findings_latest)
    by_sev = summary.get("by_severity") or summary.get("severity") or {}
    by_tool = summary.get("by_tool") or {}

    # nếu thiếu by_severity hoặc by_tool thì tự tính từ findings
    if (not by_sev or not isinstance(by_sev, dict)) and findings_latest:
        cnt = Counter()
        for it in findings_latest:
            sev = (it.get("severity_effective") or it.get("severity") or "INFO").upper()
            cnt[sev] += 1
        by_sev = dict(cnt)

    if (not by_tool or not isinstance(by_tool, dict)) and findings_latest:
        cnt = Counter()
        for it in findings_latest:
            tool = it.get("tool") or it.get("scanner") or "UNKNOWN"
            cnt[tool] += 1
        by_tool = dict(cnt)

    # đảm bảo đủ 6 bucket (0 nếu thiếu)
    for key in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]:
        by_sev.setdefault(key, 0)

    security_score = summary.get("security_score", 0)
    top_risky_tool = summary.get("top_risky_tool")
    top_cwe_single = summary.get("top_cwe") or summary.get("top_CWE")
    top_module = summary.get("top_module")

    # ===== trend + last_runs =====
    runs_info = []
    for rd in runs_sorted:
        s = _load_summary(rd) or {}
        t = s.get("total_findings") or s.get("total") or 0
        ts = s.get("ts") or s.get("timestamp")

        if not ts:
            parts = rd.name.split("_")
            if len(parts) >= 3:
                date_part = parts[-2]
                time_part = parts[-1]
                try:
                    dt = datetime.strptime(date_part + time_part, "%Y%m%d%H%M%S")
                    ts = dt.isoformat()
                except Exception:
                    ts = None

        runs_info.append({
            "run_id": rd.name,
            "total_findings": t,
            "ts": ts,
        })

    # last_runs: 10 run mới nhất (mới → cũ)
    last_runs = list(reversed(runs_info))[:10]

    # trend: 10 run gần nhất (cũ → mới)
    trend_src = list(reversed(last_runs))
    trend = [
        {
            "index": idx + 1,
            "run_id": r["run_id"],
            "total_findings": r["total_findings"],
            "label": f"Run {idx+1}",
        }
        for idx, r in enumerate(trend_src)
    ]

    resp = {
        "ok": True,
        "run_id": latest_run.name,
        "total_findings": total,
        "by_severity": by_sev,
        "by_tool": by_tool,
        "security_score": security_score,
        "top_risky_tool": top_risky_tool,
        "top_cwe": top_cwe_single,
        "top_module": top_module,
        "trend": trend,
        "last_runs": last_runs,
    }
    return jsonify(resp)

@bp_v3.route("/api/vsp/runs_index_v3", methods=["GET"])
def api_vsp_runs_index_v3():
    """
    Trả về danh sách các RUN_VSP_FULL_EXT_* với tổng findings + by_severity/by_tool để tab Runs dùng.
    """
    max_items = int(request.args.get("limit", "100"))
    items: List[Dict[str, Any]] = []

    for summary_path in _iter_summary_files():
        run_id = summary_path.parent.parent.name
        summary = _load_json(summary_path)
        by_severity = summary.get("by_severity") or {}
        by_tool = summary.get("by_tool") or {}
        total_findings = summary.get("total_findings")
        if not isinstance(total_findings, int):
            try:
                total_findings = int(sum(by_severity.values()))
            except Exception:
                total_findings = 0

        ts = summary.get("ts") or None
        label = summary.get("label") or run_id

        items.append(
            {
                "run_id": run_id,
                "total_findings": total_findings,
                "by_severity": by_severity,
                "by_tool": by_tool,
                "ts": ts,
                "label": label,
            }
        )

    # Sort theo mtime (cùng thứ tự _iter_summary_files) rồi đảo ngược (mới nhất trước)
    items = list(reversed(items))
    if max_items and len(items) > max_items:
        items = items[:max_items]

    return jsonify(items), 200


def _filter_findings(findings: List[Dict[str, Any]], severity: Optional[str], limit: int) -> List[Dict[str, Any]]:
    if not severity:
        return findings[:limit]

    sev_up = severity.upper()
    filtered: List[Dict[str, Any]] = []
    for f in findings:
        eff = (f.get("severity_effective") or f.get("severity") or "").upper()
        if eff == sev_up:
            filtered.append(f)
            if len(filtered) >= limit:
                break
    return filtered


@bp_v3.route("/api/vsp/datasource_v2", methods=["GET"])
def api_vsp_datasource_v2():
    """
    Datasource v2: trả về danh sách findings với bộ lọc đơn giản: severity, limit.
    """
    run_id = request.args.get("run_id") or _get_latest_run_id()
    if not run_id:
        return jsonify(ok=False, error="No VSP runs found for datasource_v2"), 200

    limit = int(request.args.get("limit", "1000"))
    severity = request.args.get("severity")

    findings = _load_findings(run_id)
    filtered = _filter_findings(findings, severity, limit)

    payload = {
        "ok": True,
        "run_id": run_id,
        "total": len(findings),
        "items": filtered,
    }
    return jsonify(payload), 200


@bp_v3.route("/api/vsp/datasource", methods=["GET"])
def api_vsp_datasource_legacy():
    """
    Legacy datasource cho các call:
    - /api/vsp/datasource?mode=dashboard
    - /api/vsp/datasource?severity=CRITICAL&limit=1
    """
    # Dùng chung logic với datasource_v2
    return api_vsp_datasource_v2()


@bp_v3.route("/api/vsp/trend_v1", methods=["GET"])
def api_vsp_trend_v1():
    """
    Trend theo từng run: run_id, total, ts/label.
    """
    points: List[Dict[str, Any]] = []
    for summary_path in _iter_summary_files():
        run_id = summary_path.parent.parent.name
        summary = _load_json(summary_path)
        by_severity = summary.get("by_severity") or {}
        total_findings = summary.get("total_findings")
        if not isinstance(total_findings, int):
            try:
                total_findings = int(sum(by_severity.values()))
            except Exception:
                total_findings = 0

        ts = summary.get("ts") or None
        label = summary.get("label") or run_id

        points.append(
            {
                "run_id": run_id,
                "total": total_findings,
                "ts": ts,
                "label": label,
            }
        )

    # Sort theo ts nếu có, không thì sort theo run_id
    def _key(p: Dict[str, Any]):
        return (p.get("ts") or "", p.get("run_id") or "")

    points = sorted(points, key=_key)
    return jsonify({"ok": True, "points": points}), 200

@bp_v3.route("/api/vsp/top_cwe_v1")
def proxy_top_cwe_v1():
    """
    Proxy Insights Top CWE từ core 8961 ra UI 8910.
    """
    import requests
    from flask import jsonify, request, current_app

    try:
        resp = requests.get(
            f"{CORE_BASE}/api/vsp/insights/top_cwe_v1",
            params=request.args,
            timeout=15,
        )
        return (resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        current_app.logger.warning("[VSP][PROXY] top_cwe_v1 error: %s", e)
        return jsonify({"ok": False, "error": "proxy_failed"}), 502

# ======================= VSP_OVERRIDES_BE_V1 =======================
# API: GET /api/vsp/overrides/list
# Mục tiêu: trả về danh sách rule overrides để UI Rule Overrides tab hiển thị.

@bp_v3.route("/api/vsp/overrides/list", methods=["GET"])
def api_vsp_overrides_list():
    """Stub overrides list - phase 1.
    Trả dữ liệu mẫu, sau này có thể thay bằng load từ file JSON hoặc DB.

    JSON schema (tham khảo):
      {
        "ok": true,
        "profile": "EXT+",
        "total_overrides": 2,
        "items": [ ... ]
      }
    """
    sample = {
        "ok": True,
        "profile": "EXT+",
        "total_overrides": 2,
        "items": [
            {
                "id": "GITLEAKS_GENERIC_SECRET",
                "tool": "gitleaks",
                "current_severity": "HIGH",
                "override_severity": "LOW",
                "scope": "path:^tests/",
                "description": "Giảm mức cho test data",
                "active": True,
                "affected_count": 23,
            },
            {
                "id": "SEMGREP_PYTHON_SQL",
                "tool": "semgrep",
                "current_severity": "MEDIUM",
                "override_severity": "CRITICAL",
                "scope": None,
                "description": "Tăng mức cho SQL injection patterns",
                "active": True,
                "affected_count": 5,
            },
        ],
    }
    return jsonify(sample)

