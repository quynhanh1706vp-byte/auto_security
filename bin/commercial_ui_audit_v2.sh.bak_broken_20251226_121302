#!/usr/bin/env bash
set -euo pipefail

\1
# VSP_AUDIT_BASE_FALLBACK_V1: if BASE not reachable, fallback to IPv4 loopback.
_choose_base(){
  local cand=("$BASE" "http://127.0.0.1:8910" "http://localhost:8910" "http://[::1]:8910")
  for b in "${cand[@]}"; do
    [ -n "$b" ] || continue
    if curl -fsS --connect-timeout 1 --max-time 2 -o /dev/null "$b/vsp5" >/dev/null 2>&1; then
      BASE="$b"
      return 0
    fi
  done
  return 1
}

RID="${RID:-}"
TO="${TO:-$(command -v timeout || true)}"

tmp="$(mktemp -d /tmp/vsp_ui_audit_v2_XXXXXX)"
trap 'rm -rf "$tmp"' EXIT

ok(){ echo -e "[GREEN] $*"; }
warn(){ echo -e "[AMBER] $*"; }
fail(){ echo -e "[RED] $*"; }

G=0; A=0; R=0
pass(){ G=$((G+1)); ok "$*"; }
amber(){ A=$((A+1)); warn "$*"; }
red(){ R=$((R+1)); fail "$*"; }

need(){ command -v "$1" >/dev/null 2>&1 || { red "missing: $1"; exit 2; }; }
need curl; need python3; need awk; need grep; need sed; need head; need sort; need uniq

curl_do(){
  # usage: curl_do <max_seconds> <curl args...>
  local maxs="${1:-6}"; shift || true
  if [ -n "$TO" ]; then
    "$TO" "${maxs}s" curl -fsS --connect-timeout 1 --max-time "$maxs" "$@"
  else
    curl -fsS --connect-timeout 1 --max-time "$maxs" "$@"
  fi
}

wait_up(){
  for i in $(seq 1 40); do
    if curl_do 2 -o /dev/null "$BASE/vsp5" >/dev/null 2>&1; then
      pass "UI up: $BASE"
      return 0
    fi
    sleep 0.2
  done
  red "UI not reachable: $BASE"
  return 1
}

hdr_count(){
  # hdr_count <path> <header_regex>
  local p="$1" pat="$2"
  curl_do 4 -o /dev/null -D- "$BASE$p" | grep -Ei "$pat" | wc -l | tr -d ' '
}

check_tab(){
  local p="$1"
  local f="$tmp/tab_$(echo "$p" | tr '/?' '__').html"
  if curl_do 6 --range 0-240000 "$BASE$p" -o "$f" ; then
    local ct
    ct="$(curl_do 6 -o /dev/null -D- "$BASE$p" | awk 'BEGIN{IGNORECASE=1} /^Content-Type:/ {print $0; exit}')"
    if echo "$ct" | grep -qi 'text/html'; then
      pass "TAB $p => 200 + html"
    else
      amber "TAB $p => 200 but Content-Type not html: ${ct:-N/A}"
    fi
  else
    red "TAB $p => fetch failed"
    return 1
  fi

  # Check header singleton constraints (commercial clean)
  local csp rid
  csp="$(hdr_count "$p" '^Content-Security-Policy-Report-Only:')"
  rid="$(hdr_count "$p" '^X-VSP-AUTORID-INJECT:')"
  if [ "$csp" -eq 1 ]; then pass "TAB $p header CSP_RO single"; else amber "TAB $p header CSP_RO count=$csp (expect 1)"; fi
  # AUTORID may be 0 for /vsp5 by design; allow 0/1
  if [ "$p" = "/vsp5" ]; then
    if [ "$rid" -le 1 ]; then pass "TAB /vsp5 AUTORID ok (count=$rid)"; else amber "TAB /vsp5 AUTORID duplicated (count=$rid)"; fi
  else
    if [ "$rid" -eq 1 ]; then pass "TAB $p AUTORID single"; else amber "TAB $p AUTORID count=$rid (expect 1)"; fi
  fi

  # Extract JS srcs & validate
  local jslist="$tmp/js_$(echo "$p" | tr '/?' '__').txt"
  # Match /static/js/*.js or /api/*.js (your app serves /api/vsp_tabs3_common_v3.js)
  grep -Eo 'src="[^"]+"' "$f" \
    | sed -E 's/^src="([^"]+)".*/\1/' \
    | grep -E '(\.js)(\?|$)' \
    | sed -E 's#^https?://[^/]+##' \
    | sort -u > "$jslist" || true

  local n
  n="$(wc -l < "$jslist" | tr -d ' ')"
  if [ "$n" -eq 0 ]; then
    amber "TAB $p: no JS detected (maybe inline bundle)"; return 0
  fi

  pass "TAB $p: js_count=$n"

  local bad=0
  while IFS= read -r u; do
    [ -n "$u" ] || continue
    if curl_do 6 -o /dev/null -D- "$BASE$u" | head -n 1 | grep -q "200" ; then
      :
    else
      bad=$((bad+1))
      echo "[BAD_JS] $p => $u" >> "$tmp/bad_js.log"
    fi
  done < "$jslist"

  if [ "$bad" -eq 0 ]; then pass "TAB $p: all JS 200"; else amber "TAB $p: JS failures=$bad (see $tmp/bad_js.log)"; fi
}

pick_latest_rid(){
  if [ -n "${RID:-}" ]; then
    pass "RID preset: $RID"
    return 0
  fi
  local j="$tmp/latest_rid.json"
  if curl_do 6 "$BASE/api/vsp/latest_rid_v1" -o "$j"; then
    :
  else
    amber "latest_rid_v1 failed; try runs endpoint"
    if ! curl_do 6 "$BASE/api/vsp/runs?limit=5&offset=0" -o "$j"; then
      red "cannot determine RID (latest_rid_v1 and runs both failed)"
      return 1
    fi
  fi

  RID="$(python3 - <<PY
import json,sys
p=sys.argv[1]
try:
  obj=json.load(open(p,'r',encoding='utf-8'))
except Exception:
  print(""); sys.exit(0)

# common shapes
for k in ("rid","run_id","latest_rid","rid_latest","rid_latest_gate"):
  v=obj.get(k) if isinstance(obj,dict) else None
  if isinstance(v,str) and v.strip():
    print(v.strip()); sys.exit(0)

# runs list shapes
runs=None
if isinstance(obj,dict):
  runs=obj.get("runs") or obj.get("items") or obj.get("data")
if isinstance(runs,list) and runs:
  for item in runs:
    if isinstance(item,dict):
      for k in ("rid","run_id","id"):
        v=item.get(k)
        if isinstance(v,str) and v.strip():
          print(v.strip()); sys.exit(0)
print("")
PY
"$j")"

  if [ -n "$RID" ]; then pass "Picked RID=$RID"; else amber "Could not pick RID automatically"; fi
}

check_api_json(){
  local name="$1" path="$2" maxs="${3:-6}"
  local out="$tmp/api_$(echo "$name" | tr ' /' '__').json"
  if ! curl_do "$maxs" "$BASE$path" -o "$out"; then
    amber "API $name FAIL: $path"
    return 1
  fi
  if python3 - <<PY "$out" >/dev/null 2>&1
import json,sys
json.load(open(sys.argv[1],'r',encoding='utf-8'))
PY
  then
    pass "API $name OK: $path"
    return 0
  fi
  amber "API $name not-json/invalid-json: $path"
  return 1
}

check_export(){
  # validate /api/vsp/run_export_v3/<rid>?fmt=...
  local fmt="$1"
  [ -n "${RID:-}" ] || { amber "EXPORT $fmt skipped (no RID)"; return 0; }

  local url1="$BASE/api/vsp/run_export_v3/$RID?fmt=$fmt"
  local url2="$BASE/api/vsp/run_export_v3?rid=$RID&fmt=$fmt"
  local f="$tmp/export_${fmt}.bin"
  local hdr="$tmp/export_${fmt}.hdr"

  # Try url1, fallback url2
  if curl_do 10 --range 0-6000 -D "$hdr" "$url1" -o "$f" >/dev/null 2>&1; then
    :
  elif curl_do 10 --range 0-6000 -D "$hdr" "$url2" -o "$f" >/dev/null 2>&1; then
    :
  else
    amber "EXPORT fmt=$fmt FAIL (both url forms)"
    return 1
  fi

  # Signature checks (best-effort)
  if [ "$fmt" = "pdf" ]; then
    if head -c 4 "$f" | grep -q '%PDF'; then pass "EXPORT pdf OK"; else amber "EXPORT pdf: not PDF signature"; fi
  elif [ "$fmt" = "zip" ]; then
    if head -c 2 "$f" | grep -q 'PK'; then pass "EXPORT zip OK"; else amber "EXPORT zip: not ZIP signature"; fi
  else
    if head -c 200 "$f" | tr -d '\0' | grep -qiE '<html|<!doctype'; then pass "EXPORT html OK"; else amber "EXPORT html: not HTML signature"; fi
  fi
}

echo "== [P28] commercial_ui_audit_v2 =="
echo "BASE=$BASE"
wait_up

echo "== [1] Tabs (HTML + headers + JS) =="
tabs=(/vsp5 /runs /data_source /settings /rule_overrides)
for p in "${tabs[@]}"; do
  check_tab "$p" || true
done

echo "== [2] Pick RID (for export + per-RID endpoints) =="
pick_latest_rid || true
echo "RID=${RID:-N/A}"

echo "== [3] Core APIs =="
check_api_json "selfcheck_p0" "/api/vsp/selfcheck_p0" 6 || true
check_api_json "runs" "/api/vsp/runs?limit=10&offset=0" 8 || true
check_api_json "runs_index_v3" "/api/vsp/runs_index_v3" 8 || true
check_api_json "datasource_v2" "/api/vsp/datasource_v2" 8 || true
check_api_json "findings" "/api/vsp/findings?limit=5" 8 || true
check_api_json "settings_v1" "/api/vsp/settings_v1" 8 || true
check_api_json "settings_ui_v1" "/api/vsp/settings_ui_v1" 8 || true
check_api_json "rule_overrides_v1" "/api/vsp/rule_overrides_v1" 8 || true
check_api_json "rule_overrides_ui_v1" "/api/vsp/rule_overrides_ui_v1" 8 || true
check_api_json "dashboard_v3" "/api/vsp/dashboard_v3" 10 || true
check_api_json "dashboard_commercial_v2" "/api/vsp/dashboard_commercial_v2" 10 || true
check_api_json "dashboard_extras_v1" "/api/vsp/dashboard_extras_v1" 10 || true

echo "== [4] Per-RID APIs (best-effort) =="
if [ -n "${RID:-}" ]; then
  check_api_json "findings_unified_v1" "/api/vsp/findings_unified_v1/$RID" 10 || true
  check_api_json "run_gate_summary_v1" "/api/vsp/run_gate_summary_v1/$RID" 10 || true
else
  amber "Per-RID checks skipped (no RID)"
fi

echo "== [5] Export (fmt=html/pdf/zip) =="
check_export html || true
check_export pdf  || true
check_export zip  || true

echo "== [SUMMARY] =="
echo "GREEN=$G AMBER=$A RED=$R"
[ "$R" -eq 0 ] && echo "[VERDICT] PASS (no RED)" || echo "[VERDICT] FAIL (has RED)"
