#!/usr/bin/env bash
set -euo pipefail
cd /home/test/Data/SECURITY_BUNDLE/ui

F="wsgi_vsp_ui_gateway.py"
SVC="${VSP_UI_SVC:-vsp-ui-8910.service}"

[ -f "$F" ] || { echo "[ERR] missing $F"; exit 2; }

TS="$(date +%Y%m%d_%H%M%S)"
cp -f "$F" "${F}.bak_p30_cache_${TS}"
echo "[BACKUP] ${F}.bak_p30_cache_${TS}"

python3 - <<'PY'
from pathlib import Path
import sys, py_compile

p=Path("wsgi_vsp_ui_gateway.py")
s=p.read_text(encoding="utf-8", errors="replace")

MARK="VSP_P30_FINDINGS_UNIFIED_CACHE_V1"
if MARK in s:
    print("[OK] already patched", MARK)
    py_compile.compile(str(p), doraise=True)
    sys.exit(0)

block = r'''
# ===================== VSP_P30_FINDINGS_UNIFIED_CACHE_V1 =====================
# Commercial: cache heavy endpoint /api/vsp/findings_unified_v1/<RID> (RAM + disk) with TTL.
try:
    import os, time, re, hashlib
    from pathlib import Path as _Path

    _VSP_P30_CACHE_DIR = _Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/cache_api")
    _VSP_P30_CACHE_DIR.mkdir(parents=True, exist_ok=True)

    _VSP_P30_TTL_SEC = int(os.environ.get("VSP_P30_FINDINGS_TTL_SEC", "900"))  # 15 min default
    _VSP_P30_MAX_CACHE_BYTES = int(os.environ.get("VSP_P30_FINDINGS_MAX_BYTES", str(40*1024*1024)))  # 40MB
    _VSP_P30_RAM = {}  # key -> (ts, headers_dict, body_bytes)

    def _vsp_p30__cache_key(environ):
        # key includes PATH + QUERY to avoid mixing variants
        pi = (environ.get("PATH_INFO") or "")
        qs = (environ.get("QUERY_STRING") or "")
        raw = (pi + "?" + qs).encode("utf-8", errors="ignore")
        return hashlib.sha256(raw).hexdigest()

    def _vsp_p30__is_target(environ):
        pi = (environ.get("PATH_INFO") or "")
        return bool(re.match(r"^/api/vsp/findings_unified_v1/[^/]+$", pi))

    def _vsp_p30__disk_paths(key):
        return (_VSP_P30_CACHE_DIR / f"{key}.json", _VSP_P30_CACHE_DIR / f"{key}.meta")

    def _vsp_p30__read_disk(key):
        f, m = _vsp_p30__disk_paths(key)
        if not f.is_file() or not m.is_file():
            return None
        try:
            ts = float(m.read_text(encoding="utf-8", errors="replace").strip() or "0")
            if (time.time() - ts) > _VSP_P30_TTL_SEC:
                return None
            body = f.read_bytes()
            if not body:
                return None
            return (ts, body)
        except Exception:
            return None

    def _vsp_p30__write_disk(key, body: bytes):
        try:
            if len(body) > _VSP_P30_MAX_CACHE_BYTES:
                return
            f, m = _vsp_p30__disk_paths(key)
            f.write_bytes(body)
            m.write_text(str(time.time()), encoding="utf-8")
        except Exception:
            pass

    def _vsp_p30__wrap(_wsgi_app):
        if not callable(_wsgi_app):
            return _wsgi_app

        def _app(environ, start_response):
            try:
                if _vsp_p30__is_target(environ):
                    key = _vsp_p30__cache_key(environ)

                    # 1) RAM cache
                    it = _VSP_P30_RAM.get(key)
                    if it:
                        ts, hdrs, body = it
                        if (time.time() - ts) <= _VSP_P30_TTL_SEC and body:
                            headers = [
                                ("Content-Type", "application/json"),
                                ("Cache-Control", "no-store"),
                                ("X-VSP-P30-CACHE", "HIT-RAM"),
                            ]
                            start_response("200 OK", headers)
                            return [body]

                    # 2) Disk cache
                    dk = _vsp_p30__read_disk(key)
                    if dk:
                        ts, body = dk
                        _VSP_P30_RAM[key] = (ts, {"ct":"application/json"}, body)
                        headers = [
                            ("Content-Type", "application/json"),
                            ("Cache-Control", "no-store"),
                            ("X-VSP-P30-CACHE", "HIT-DISK"),
                        ]
                        start_response("200 OK", headers)
                        return [body]

                    # 3) Miss: call downstream, capture up to max bytes for caching
                    status_box = {"status": None}
                    hdr_box = {"headers": []}

                    def _sr(status, headers, exc_info=None):
                        status_box["status"] = status
                        hdr_box["headers"] = list(headers or [])
                        return start_response(status, headers, exc_info)

                    resp_iter = _wsgi_app(environ, _sr)

                    # Only cache on 200 and JSON-ish content
                    st = (status_box["status"] or "")
                    ok200 = st.startswith("200")
                    # Collect response (bounded)
                    chunks = []
                    total = 0
                    for ch in resp_iter:
                        if ch is None:
                            continue
                        if isinstance(ch, str):
                            ch = ch.encode("utf-8", errors="ignore")
                        chunks.append(ch)
                        total += len(ch)
                        if total > _VSP_P30_MAX_CACHE_BYTES:
                            # too big, don't cache; just return streaming-ish
                            return chunks

                    body = b"".join(chunks)

                    if ok200 and body and (total <= _VSP_P30_MAX_CACHE_BYTES):
                        ts = time.time()
                        _VSP_P30_RAM[key] = (ts, {"ct":"application/json"}, body)
                        _vsp_p30__write_disk(key, body)
                        # annotate header (best-effort)
                        try:
                            # cannot change already-sent headers reliably; leave as is
                            pass
                        except Exception:
                            pass

                    return [body]
            except Exception:
                pass

            return _wsgi_app(environ, start_response)

        return _app

    # Wrap exported WSGI callables once
    if "application" in globals() and callable(globals().get("application")):
        globals()["application"] = _vsp_p30__wrap(globals()["application"])
    if "app" in globals() and callable(globals().get("app")):
        globals()["app"] = _vsp_p30__wrap(globals()["app"])

    print("[VSP_P30] findings_unified_v1 cache installed (TTL=%ss)" % _VSP_P30_TTL_SEC)
except Exception as _e:
    print("[VSP_P30] ERROR:", _e)
# ===================== /VSP_P30_FINDINGS_UNIFIED_CACHE_V1 =====================
'''
p.write_text(s.rstrip()+"\n\n"+block+"\n", encoding="utf-8")
print("[OK] appended", MARK)
py_compile.compile(str(p), doraise=True)
print("[OK] py_compile OK")
PY

if command -v systemctl >/dev/null 2>&1; then
  echo "== [RESTART] $SVC =="
  sudo systemctl restart "$SVC"
  sudo systemctl --no-pager --full status "$SVC" | head -n 15 || true
fi

echo "== [SMOKE] cache header check (2 hits) =="
BASE="${BASE:-${VSP_UI_BASE:-http://127.0.0.1:8910}}"
RID="${RID:-VSP_CI_20251219_092640}"

echo "-- first call (expect MISS then cache) --"
curl -sS -D- "$BASE/api/vsp/findings_unified_v1/$RID" -o /dev/null | awk 'BEGIN{IGNORECASE=1} /^HTTP\/|^X-VSP-P30-CACHE:/ {print}'

echo "-- second call (expect HIT-RAM or HIT-DISK) --"
curl -sS -D- "$BASE/api/vsp/findings_unified_v1/$RID" -o /dev/null | awk 'BEGIN{IGNORECASE=1} /^HTTP\/|^X-VSP-P30-CACHE:/ {print}'
