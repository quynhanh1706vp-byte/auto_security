import socket
# coding: utf-8

def _vsp_is_runs_path(environ):
    """Return True if request path is /runs or /runs/... (standalone runs page)."""
    try:
        path = (environ.get("PATH_INFO") or "")
    except Exception:
        path = ""
    return path == "/runs" or path.startswith("/runs/")

# VSP_P0_SKIP_FILLREAL_BY_PATH_V1
"""
FORCE FULL VSP UI GATEWAY
- Make gunicorn serve the real Flask app (vsp_demo_app.app)
- Avoid any exportpdf-only/preempt wrappers hijacking /api/vsp/*
"""

# --- VSP_MARK_FIX_P0_V6 ---
# Fix: make MARK always available (also via builtins to avoid NameError in any scope).
# VSP_P1_FORCEWRAP_ALL_KEEPFLASK_V3
# VSP_P1_FORCEWRAP_MULTILINE_KEEPFLASK_V4
# VSP_P1_ALL_MW_KEEPFLASK_V5
import builtins as _vsp_builtins
if not hasattr(_vsp_builtins, 'MARK'):
    _vsp_builtins.MARK = 'VSP_UI_GATEWAY_MARK_V1'
MARK = getattr(_vsp_builtins, 'MARK', 'VSP_UI_GATEWAY_MARK_V1')
MARK_B = (MARK.encode() if isinstance(MARK, str) else str(MARK).encode())
# --- /VSP_MARK_FIX_P0_V6 ---

# VSP_MARK_DEDUPE_SAFE_P0_V8C: keep legacy alias (do not override MARK)
MARKB = MARK_B  # legacy alias
# /VSP_MARK_DEDUPE_SAFE_P0_V8C





# VSP_MARK_FIX_P0_V3
# (P0_V8C) disabled legacy MARK reassignment
# (P0_V8C) disabled legacy MARKB bytes (use MARKB=MARK_B alias)

# VSP_IMPORT_TIME_P0_V2: required by WSGI wrapper (__call__) and cache-bust logic
import time
import os
# /VSP_IMPORT_TIME_P0_V2

from vsp_demo_app import app as application  # gunicorn entrypoint
app = application





# --- VSP_RUNS_HAS_DETECT_P0_V1 ---
# Commercial: /api/vsp/runs must show accurate artifact presence (csv/json/sarif/html/summary).
from flask import request as _vsp_req, send_from_directory
import os as _vsp_os
import json as _vsp_json


# VSP_P1_BASE_WSGI_COERCE_V12
def _vsp_is_flask_app(obj):
    return obj is not None and hasattr(obj, 'after_request') and hasattr(obj, 'route')

def _vsp_base_wsgi(obj):
    # If someone passed a Flask app object, return its ORIGINAL Flask.wsgi_app bound method,
    # not the overwritten instance attribute (prevents recursion).
    if _vsp_is_flask_app(obj):
        try:
            return obj.__class__.wsgi_app.__get__(obj, obj.__class__)
        except Exception:
            return getattr(obj, 'wsgi_app', obj)
    return getattr(obj, 'wsgi_app', obj)

def _vsp_detect_artifacts(run_dir: str) -> dict:
    d = {"csv":False,"json":False,"sarif":False,"summary":False,"html":False,"html_path":None}
    if not run_dir:
        return d

    # common artifact locations (support both run-root and reports/)
    cand = [
        ("json",   ["findings_unified.json", "reports/findings_unified.json"]),
        ("csv",    ["findings_unified.csv",  "reports/findings_unified.csv"]),
        ("sarif",  ["findings_unified.sarif","reports/findings_unified.sarif"]),
        ("summary",["run_gate_summary.json","SUMMARY.txt", "SHA256SUMS.txt","reports/SUMMARY.txt", "reports/SHA256SUMS.txt", "reports/SHA256SUMS.txt","reports/run_gate_summary.json"]),
    ]
    for k, rels in cand:
        for rel in rels:
            if _vsp_os.path.exists(_vsp_os.path.join(run_dir, rel)):
                d[k] = True
                break

    html_cands = [
        "reports/index.html",
        "report/index.html",
        "reports/report.html",
        "reports/findings_unified.html",
        "findings_unified.html",
        "index.html",
    ]
    for rel in html_cands:
        fp = _vsp_os.path.join(run_dir, rel)
        if _vsp_os.path.exists(fp):
            d["html"] = True
            d["html_path"] = fp
            break
    return d

@app.after_request
def _vsp_after_request_runs_has(resp):
    try:
        # only patch the runs listing JSON
        if _vsp_req.path != "/api/vsp/runs":
            return resp
        ctype = (resp.headers.get("Content-Type") or "")
        if "application/json" not in ctype:
            return resp

        data = None
        try:
            data = resp.get_json(silent=True)
        except Exception:
            data = None
        if not isinstance(data, dict):
            return resp

        items = data.get("items")
        if not isinstance(items, list):
            return resp

        for it in items:
            if not isinstance(it, dict):
                continue
            run_dir = it.get("path") or ""
            has = it.get("has")
            if not isinstance(has, dict):
                has = {}
            det = _vsp_detect_artifacts(str(run_dir))
            has.update(det)
            it["has"] = has

        out = _vsp_json.dumps(data, ensure_ascii=False)
        resp.set_data(out.encode("utf-8"))
        resp.headers["Content-Length"] = str(len(resp.get_data()))
        # ==== VSP_P1_RUNS_CONTRACT_FIELDS_V1 ====
        # P1 contract: enrich runs index response with stable fields for UI/commercial
        try:
            from flask import request as _req
            import os as _os
            # effective limit: requested (cap)
            try:
                _lim_req = int((_req.args.get("limit") or "50").strip())
            except Exception:
                _lim_req = 50
            _hard_cap = 120
            _lim_eff = max(1, min(_lim_req, _hard_cap))
            data["limit"] = _lim_eff
        
            items = data.get("items") or []
            rid_latest = ""
            if isinstance(items, list) and items:
                try:
                    rid_latest = (items[0].get("run_id") or items[0].get("rid") or "").strip()
                except Exception:
                    rid_latest = ""
            data["rid_latest"] = rid_latest
        
            # cache TTL hint
            try:
                data["cache_ttl"] = int(_os.environ.get("VSP_RUNS_CACHE_TTL", "2"))
            except Exception:
                data["cache_ttl"] = 2
        
            # roots used (best-effort, don't break if unknown)
            roots_used = []
            try:
                # common names you may have in gateway
                for nm in ("VSP_RUNS_ROOTS", "RUNS_ROOTS", "VSP_DATA_ROOTS"):
                    if nm in globals() and isinstance(globals()[nm], (list, tuple)):
                        roots_used = [str(x) for x in globals()[nm]]
                        break
            except Exception:
                roots_used = []
            data["roots_used"] = roots_used
        
            # scan cap hit
            try:
                scanned = int(data.get("_scanned") or 0)
            except Exception:
                scanned = 0
            scan_cap = int(data.get("_scan_cap") or 500)
            data["scan_cap"] = scan_cap
            data["scan_cap_hit"] = bool(scanned >= scan_cap)
        except Exception:
            pass
        # ==== /VSP_P1_RUNS_CONTRACT_FIELDS_V1 ====
        # ==== VSP_P1_RUNS_CONTRACT_POSTPROCESS_V3 ====
        # Force-buffer response body and rewrite JSON so contract fields definitely appear.
        try:
            import json as _json
            import os as _os
            from flask import request as _req
            if (_req.path or "") == "/api/vsp/runs":
                try:
                    resp.direct_passthrough = False
                except Exception:
                    pass
        
                _raw = resp.get_data()  # this buffers even if response was streamed
                _txt = (_raw.decode("utf-8", "replace") if isinstance(_raw, (bytes, bytearray)) else str(_raw))
                _data = _json.loads(_txt)
                if isinstance(_data, dict) and _data.get("ok") is True and isinstance(_data.get("items"), list):
                    # effective limit: requested (cap)
                    try:
                        _lim_req = int((_req.args.get("limit") or "50").strip())
                    except Exception:
                        _lim_req = 50
                    _hard_cap = 120
                    _lim_eff = max(1, min(_lim_req, _hard_cap))
                    _data["limit"] = _lim_eff
        
                    items = _data.get("items") or []
                    rid_latest = ""
                    if items:
                        try:
                            rid_latest = (items[0].get("run_id") or items[0].get("rid") or "").strip()
                        except Exception:
                            rid_latest = ""
                    _data["rid_latest"] = rid_latest
        
                    try:
                        _data["cache_ttl"] = int(_os.environ.get("VSP_RUNS_CACHE_TTL", "2"))
                    except Exception:
                        _data["cache_ttl"] = 2
        
                    # roots_used best-effort: expose env if exists (helps debug why items is empty)
                    roots_used = []
                    for k in ("VSP_RUNS_ROOTS", "VSP_DATA_ROOTS", "RUNS_ROOTS"):
                        v = _os.environ.get(k, "").strip()
                        if v:
                            roots_used = [x.strip() for x in v.split(":") if x.strip()]
                            break
                    _data["roots_used"] = roots_used
        
                    try:
                        scanned = int(_data.get("_scanned") or 0)
                    except Exception:
                        scanned = 0
                    scan_cap = int(_data.get("_scan_cap") or 500)
                    _data["scan_cap"] = scan_cap
                    _data["scan_cap_hit"] = bool(scanned >= scan_cap)
        
                    _out = _json.dumps(_data, ensure_ascii=False)
                    resp.set_data(_out.encode("utf-8"))
                    resp.headers["Content-Length"] = str(len(resp.get_data()))
                    resp.headers["X-VSP-RUNS-CONTRACT"] = "P1_V3"
        except Exception:
            pass
        # ==== /VSP_P1_RUNS_CONTRACT_POSTPROCESS_V3 ====
        resp.headers["X-VSP-RUNS-HAS"] = "VSP_RUNS_HAS_DETECT_P0_V1"
        return resp
    except Exception:
        return resp

# --- /VSP_RUNS_HAS_DETECT_P0_V1 ---


# --- VSP_RUNS_PAGE_NEVER_500_P0_V1 ---
# Commercial guard: /runs must never return 500 (fallback HTML + link to JSON).
from flask import request, Response
import json as _vsp_json
import html as _vsp_html
import traceback as _vsp_tb

@app.errorhandler(500)
def _vsp_err_500_runs_only(e):
    try:
        if request.path != "/runs":
            # keep normal 500 behavior for other endpoints
            return ("Internal Server Error", 500)
        # Build minimal HTML using the already-working JSON API
        items = []
        try:
            with app.test_client() as c:
                r = c.get("/api/vsp/runs?limit=50")
                if r.status_code == 200:
                    data = r.get_json(silent=True) or {}
                    items = data.get("items") or []
        except Exception:
            items = []

        rows = []
        for it in items[:50]:
            rid = str(it.get("run_id") or "")
            mtime_h = str(it.get("mtime_h") or "")
            path = str(it.get("path") or "")
            # safe link: open run dir (if you later wire /api/vsp/run_file)
            rows.append(
                "<tr>"
                f"<td>{_vsp_html.escape(rid)}</td>"
                f"<td>{_vsp_html.escape(mtime_h)}</td>"
                f"<td style='font-family:monospace'>{_vsp_html.escape(path)}</td>"
                "</tr>"
            )

        body = (
            "<!doctype html><html><head><meta charset='utf-8'>"
            "<title>Runs & Reports</title>"
            "<style>"
            "body{background:#0b1220;color:#e5e7eb;font:14px/1.4 system-ui,Segoe UI,Arial;padding:18px}"
            "a{color:#60a5fa} table{border-collapse:collapse;width:100%;margin-top:10px}"
            "th,td{border:1px solid #1f2937;padding:8px;vertical-align:top}"
            "th{background:#111827;text-align:left}"
            ".muted{color:#9ca3af}"
            "</style></head><body>"
            "<h2>Runs & Reports</h2>"
            "<div class='muted'>Fallback mode: UI template errored. JSON API is OK.</div>"
            "<div style='margin-top:8px'>"
            "<a href='/api/vsp/runs?limit=50'>Open /api/vsp/runs JSON</a>"
            "</div>"
            "<table><thead><tr><th>run_id</th><th>mtime</th><th>path</th></tr></thead><tbody>"
            + "".join(rows) +
            "</tbody></table>"
            "</body></html>"
        )
        return Response(body, status=200, headers={"X-VSP-RUNS-PAGE-FALLBACK": MARK}, mimetype="text/html")
    except Exception:
        # last resort: still avoid 500 on /runs
        tb = _vsp_tb.format_exc()
        body = "<pre>" + _vsp_html.escape(tb[-4000:]) + "</pre>"
        return Response(body, status=200, headers={"X-VSP-RUNS-PAGE-FALLBACK": MARK}, mimetype="text/html")

# --- /VSP_RUNS_PAGE_NEVER_500_P0_V1 ---


# === VSP_WSGI_STATUSV2_ALWAYS8_V3 ===
# Post-process /api/vsp/run_status_v2/* JSON at WSGI layer to always expose 8 tool lanes.
import json

def _vsp_build_tools_always8_v3(out: dict) -> dict:
    CANON = ["SEMGREP","GITLEAKS","TRIVY","CODEQL","KICS","GRYPE","SYFT","BANDIT"]
    ZERO = {"CRITICAL":0,"HIGH":0,"MEDIUM":0,"LOW":0,"INFO":0,"TRACE":0}
    # VSP_P1_GW_RUNFILE_ANCHOR_ALLOW_SHA_V3: allow reports/SHA256SUMS.txt BEFORE any allowlist/proxy
    try:
        from flask import request as _req, send_file as _send_file, jsonify as _jsonify
        _rid = (_req.args.get("rid","") or _req.args.get("run_id","") or _req.args.get("run","") or "").strip()
        _rel = (_req.args.get("name","") or _req.args.get("path","") or _req.args.get("rel","") or "").strip().lstrip("/")
        if _rid and _rel == "reports/SHA256SUMS.txt":
            from pathlib import Path as _P
            for _root in (
                _P("/home/test/Data/SECURITY_BUNDLE/out"),
                _P("/home/test/Data/SECURITY_BUNDLE/out_ci"),
                _P("/home/test/Data/SECURITY_BUNDLE/ui/out_ci"),
                _P("/home/test/Data/SECURITY_BUNDLE/ui/out"),
            ):
                _fp = _root / _rid / "reports" / "SHA256SUMS.txt"
                if _fp.exists():
                    return _send_file(str(_fp), as_attachment=True)
            return _jsonify({"ok": False, "error": "NO_FILE"}), 404
    except Exception:
        pass


    def norm_counts(c):
        d = dict(ZERO)
        if isinstance(c, dict):
            for k,v in c.items():
                kk = str(k).upper()
                if kk in d:
                    try: d[kk] = int(v)
                    except Exception: d[kk] = 0
        return d

    def mk(tool, has_key=None, total_key=None, verdict_key=None, counts_key=None, reason_missing="missing_fields"):
        hasv = out.get(has_key) if has_key else None
        try: hasv = bool(hasv) if has_key else None
        except Exception: hasv = None

        total = out.get(total_key, 0) if total_key else 0
        verdict = out.get(verdict_key) if verdict_key else None
        counts = norm_counts(out.get(counts_key, {})) if counts_key else dict(ZERO)

        if has_key and hasv is False:
            return {"tool":tool,"status":"NOT_RUN","verdict":"NOT_RUN","total":0,"counts":dict(ZERO),"reason":"has_flag_false"}

        if verdict is None and (not total) and counts == ZERO:
            return {"tool":tool,"status":"NOT_RUN","verdict":"NOT_RUN","total":0,"counts":dict(ZERO),"reason":reason_missing}

        vv = str(verdict).upper() if verdict is not None else "OK"
        try: total_i = int(total)
        except Exception: total_i = 0
        return {"tool":tool,"status":vv,"verdict":vv,"total":total_i,"counts":counts}

    tools = {}
    # your current flat keys in status_v2 response
    tools["CODEQL"]   = mk("CODEQL",   "has_codeql",   "codeql_total",   "codeql_verdict",   None)
    tools["GITLEAKS"] = mk("GITLEAKS", "has_gitleaks", "gitleaks_total", "gitleaks_verdict", "gitleaks_counts")
    tools["SEMGREP"]  = mk("SEMGREP",  "has_semgrep",  "semgrep_total",  "semgrep_verdict",  "semgrep_counts")
    tools["TRIVY"]    = mk("TRIVY",    "has_trivy",    "trivy_total",    "trivy_verdict",    "trivy_counts")

    # no converters yet -> NOT_RUN but lane must exist
    for t in ["KICS","GRYPE","SYFT","BANDIT"]:
        tools[t] = {"tool":t,"status":"NOT_RUN","verdict":"NOT_RUN","total":0,"counts":dict(ZERO),"reason":"no_converter_yet"}

    out["tools"] = tools
    out["tools_order"] = CANON

    gs = out.get("run_gate_summary")
    if not isinstance(gs, dict):
        gs = {}
    for t in CANON:
        if t not in gs:
            gs[t] = {"tool":t,"verdict": tools[t].get("verdict","NOT_RUN"), "total": tools[t].get("total",0)}
    out["run_gate_summary"] = gs
    return out

def _vsp_wrap_statusv2_always8_v3(app):
    def _app(environ, start_response):
        path = environ.get("PATH_INFO","") or ""
        if not path.startswith("/api/vsp/run_status_v2/"):
            return app(environ, start_response)

        captured = {"status": None, "headers": None, "exc": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = headers
            captured["exc"] = exc_info
            return lambda x: None

        res_iter = app(environ, _sr)
        try:
            body = b"".join(res_iter or [])
        finally:
            try:
                close = getattr(res_iter, "close", None)
                if callable(close): close()
            except Exception:
                pass

        headers = captured["headers"] or []
        ctype = ""
        for k,v in headers:
            if str(k).lower() == "content-type":
                ctype = str(v)
                break

        if "application/json" not in ctype.lower():
            start_response(captured["status"] or "200 OK", headers, captured["exc"])
            return [body]

        try:
            out = json.loads((body.decode("utf-8", errors="ignore") or "{}"))
            if isinstance(out, dict) and (out.get("tools") is None):
                out = _vsp_build_tools_always8_v3(out)
                new_body = json.dumps(out, ensure_ascii=False).encode("utf-8")

                new_headers = []
                for k,v in headers:
                    if str(k).lower() == "content-length":
                        continue
                    new_headers.append((k,v))
                new_headers.append(("Content-Length", str(len(new_body))))

                start_response(captured["status"] or "200 OK", new_headers, captured["exc"])
                return [new_body]
        except Exception:
            pass

        start_response(captured["status"] or "200 OK", headers, captured["exc"])
        return [body]
    return _app

# Wrap if 'application' exists (gunicorn uses wsgi_vsp_ui_gateway:application)
try:
    application.wsgi_app = _vsp_wrap_statusv2_always8_v3(application.wsgi_app)
except Exception:
    pass



# === VSP_RULE_OVERRIDES_FORCE_BIND_V1 BEGIN ===
import json as _json
from pathlib import Path as _Path
from datetime import datetime as _dt, timezone as _tz
import os as _os
import tempfile as _tempfile

_VSP_RULE_OVR_PATH = _Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/vsp_rule_overrides_v1.json")

def _vsp_rule_ovr_default_v1():
    return {"meta":{"version":"v1","updated_at":None},"overrides":[]}

def _vsp_rule_ovr_atomic_write_v1(path:_Path, obj:dict):
    path.parent.mkdir(parents=True, exist_ok=True)
    fd, tmp = _tempfile.mkstemp(prefix=path.name+".", dir=str(path.parent))
    try:
        with _os.fdopen(fd, "w", encoding="utf-8") as f:
            _json.dump(obj, f, ensure_ascii=False, indent=2)
        _os.replace(tmp, str(path))
    finally:
        try:
            _os.unlink(tmp)
        except Exception:
            pass

class VSPRuleOverridesForceBindV1:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/rule_overrides_v1"):
            return self.app(environ, start_response)

        method = (environ.get("REQUEST_METHOD") or "GET").upper()
        try:
            if method == "GET":
                if _VSP_RULE_OVR_PATH.exists():
                    try:
                        data = _json.load(open(_VSP_RULE_OVR_PATH, "r", encoding="utf-8"))
                    except Exception:
                        data = _vsp_rule_ovr_default_v1()
                else:
                    data = _vsp_rule_ovr_default_v1()

                body = _json.dumps(data, ensure_ascii=False).encode("utf-8")
                hdrs = [
                    ("Content-Type","application/json; charset=utf-8"),
                    ("Content-Length", str(len(body))),
                    ("Cache-Control","no-cache"),
                    ("X-VSP-RULE-OVERRIDES-MODE","FORCE_BIND_V1"),
                ]
                start_response("200 OK", hdrs)
                return [body]

            if method == "POST":
                try:
                    n = int(environ.get("CONTENT_LENGTH") or "0")
                except Exception:
                    n = 0
                raw = environ["wsgi.input"].read(n) if n > 0 else b"{}"
                obj = _json.loads(raw.decode("utf-8", errors="replace") or "{}")
                if not isinstance(obj, dict):
                    obj = _vsp_rule_ovr_default_v1()
                obj.setdefault("meta", {})
                obj["meta"]["updated_at"] = _dt.now(_tz.utc).isoformat()
                _vsp_rule_ovr_atomic_write_v1(_VSP_RULE_OVR_PATH, obj)

                out = {"ok": True, "file": str(_VSP_RULE_OVR_PATH), "mode":"FORCE_BIND_V1"}
                body = _json.dumps(out, ensure_ascii=False).encode("utf-8")
                hdrs = [
                    ("Content-Type","application/json; charset=utf-8"),
                    ("Content-Length", str(len(body))),
                    ("Cache-Control","no-cache"),
                    ("X-VSP-RULE-OVERRIDES-MODE","FORCE_BIND_V1"),
                ]
                start_response("200 OK", hdrs)
                return [body]

            body = b'{"ok":false,"error":"METHOD_NOT_ALLOWED"}'
            start_response("405 Method Not Allowed", [
                ("Content-Type","application/json; charset=utf-8"),
                ("Content-Length", str(len(body))),
            ])
            return [body]
        except Exception as e:
            body = _json.dumps({"ok":False,"error":"RULE_OVERRIDES_FORCE_BIND_ERR","detail":str(e)}, ensure_ascii=False).encode("utf-8")
            start_response("500 Internal Server Error", [
                ("Content-Type","application/json; charset=utf-8"),
                ("Content-Length", str(len(body))),
                ("X-VSP-RULE-OVERRIDES-MODE","FORCE_BIND_V1"),
            ])
            return [body]
# === VSP_RULE_OVERRIDES_FORCE_BIND_V1 END ===


# VSP_RULE_OVERRIDES_FORCE_BIND_V1 WRAP

# === VSP_GATEWAY_INJECT_FILLREAL_WSGI_MW_P1_V3 ===
import re as _re

class _VspHtmlInjectMw:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        captured = {"status": None, "headers": None, "exc": None}

        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            # delay calling real start_response until we possibly rewrite body
            return None

        app_iter = self.app(environ, _sr)

        try:
            body_chunks = []
            for chunk in app_iter:
                if chunk:
                    body_chunks.append(chunk)
            body = b"".join(body_chunks)
        finally:
            try:
                close = getattr(app_iter, "close", None)
                if callable(close):
                    close()
            except Exception:
                pass

        headers = captured["headers"] or []
        ct = ""
        for (k,v) in headers:
            if str(k).lower() == "content-type":
                ct = str(v).lower()
                break

        # only touch HTML
        if "text/html" in ct and body:
            try:
                html = body.decode("utf-8", errors="replace")
                if ("vsp_fill_real_data_5tabs_p1_v1.js" not in html) and ("VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY" not in html) and ("VSP_RUNS_STANDALONE_HARDFIX_P0_V2" not in html) and ("VSP_RUNS_PAGE_FACTORY_RESET_STATIC_P0_V1" not in html) and (not _vsp_is_runs_path(environ)):  # VSP_P0_SKIP_FILLREAL_ON_RUNS_MARKER_V1
                    tag = (
                        "\n<!-- VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY -->\n"
                        "<script src='/static/js/vsp_fill_real_data_5tabs_p1_v1.js'></script>\n"
                        "<!-- /VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY -->\n"
                    )
                    if "</body>" in html:
                        html = html.replace("</body>", tag + "</body>")
                    elif "</html>" in html:
                        html = html.replace("</html>", tag + "</html>")
                    else:
                        html = html + tag
                    body = html.encode("utf-8")

                    # drop Content-Length (recomputed)
                    headers = [(k,v) for (k,v) in headers if str(k).lower() != "content-length"]
                    headers.append(("Content-Length", str(len(body))))
            except Exception:
                pass

        # now start response
        start_response(captured["status"] or "200 OK", headers, captured["exc"])
        return [body]
# === /VSP_GATEWAY_INJECT_FILLREAL_WSGI_MW_P1_V3 ===

application.wsgi_app = VSPRuleOverridesForceBindV1(application.wsgi_app)

# === VSP_API_REPORTS_LATEST_COMPAT_P0_V1 ===
def _vsp__find_latest_run_with_file(relpath: str) -> str:
    """
    Return RUN_ID (folder basename) of newest out/RUN_* that contains relpath.
    relpath examples: 'reports/index.html' or 'reports/run_gate_summary.json'
    """
    base = Path("/home/test/Data/SECURITY_BUNDLE/out")
    if not base.exists():
        return ""
    # newest first by mtime
    runs = sorted(base.glob("RUN_*"), key=lambda x: x.stat().st_mtime, reverse=True)
    for rd in runs[:200]:
        try:
            fp = rd / relpath
            if fp.is_file():
                return rd.name
        except Exception:
            continue
    return ""
# [DISABLED] application is WSGI wrapper (no .route). Bound later via app.add_url_rule
def vsp_api_reports_latest(name):
    # compat endpoint: serve latest run's report file via run_file contract
    # /api/reports/run_gate_summary.json  -> reports/run_gate_summary.json
    rel = name
    if not rel.startswith("reports/"):
        rel = "reports/" + rel

    rid = _vsp__find_latest_run_with_file(rel)
    if not rid:
        return ("Not Found", 404)

    # redirect to commercial contract endpoint
    url = "/api/vsp/run_file?rid=" + quote(rid) + "&name=" + quote(rel)
    return ("", 302, {"Location": url})




# === VSP_RUN_STATUS_V2_GUARD_V1 BEGIN ===
import json as _json
from datetime import datetime as _dt, timezone as _tz
import traceback as _tb

class VSPRunStatusV2GuardV1:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_status_v2/"):
            return self.app(environ, start_response)

        # normalize rid in PATH_INFO
        try:
            rid = path.split("/api/vsp/run_status_v2/", 1)[1]
        except Exception:
            rid = ""
        rid = (rid or "").strip()
        rid_norm = rid[4:] if rid.startswith("RUN_") else rid

        # rewrite path if needed
        if rid_norm != rid:
            environ = dict(environ)
            environ["PATH_INFO"] = "/api/vsp/run_status_v2/" + rid_norm

        try:
            return self.app(environ, start_response)
        except Exception as e:
            payload = {
                "ok": False,
                "status": "ERROR",
                "final": True,
                "http_code": 500,
                "error": "RUN_STATUS_V2_EXCEPTION_GUARDED",
                "rid": rid,
                "rid_norm": rid_norm,
                "detail": str(e),
                "ts_utc": _dt.now(_tz.utc).isoformat(),
            }
            body = _json.dumps(payload, ensure_ascii=False).encode("utf-8")
            hdrs = [
                ("Content-Type","application/json; charset=utf-8"),
                ("Content-Length", str(len(body))),
                ("Cache-Control","no-cache"),
                ("X-VSP-RUNSTATUSV2-MODE","GUARD_V1"),
            ]
            start_response("200 OK", hdrs)
            return [body]
# === VSP_RUN_STATUS_V2_GUARD_V1 END ===


# VSP_RUN_STATUS_V2_GUARD_V1 WRAP
application.wsgi_app = VSPRunStatusV2GuardV1(application.wsgi_app)


# === VSP_WSGI_STATUS_CONTRACT_MW_P1_V1_BEGIN ===
import os, json, re
from pathlib import Path

# VSP_HARDEN_MARK_P0_V2
# (P0_V8C) disabled legacy MARK reassignment
MARKB = MARKB


# VSP_GLOBAL_MARK_FIX_P0_V1
# (P0_V8C) disabled legacy MARK reassignment
def _vsp_read_json(fp):
    try:
        with open(fp, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None

def _vsp_findings_total(run_dir: str):
    if not run_dir:
        return None
    for fn in ("findings_unified.json","reports/findings_unified.json","findings_unified.sarif","findings_unified.sarif.json"):
        fp=os.path.join(run_dir, fn)
        if os.path.isfile(fp):
            j=_vsp_read_json(fp)
            if isinstance(j, dict):
                if isinstance(j.get("total"), int):
                    return j["total"]
                items=j.get("items")
                if isinstance(items, list):
                    return len(items)
    fp=os.path.join(run_dir,"summary_unified.json")
    j=_vsp_read_json(fp) if os.path.isfile(fp) else None
    if isinstance(j, dict):
        t=j.get("total") or j.get("total_findings")
        if isinstance(t, int):
            return t
    return None

def _vsp_degraded_info(run_dir: str):
    if not run_dir:
        return (None, None)
    # prefer runner.log
    cand = os.path.join(run_dir,"runner.log")
    if not os.path.isfile(cand):
        # fallbacks
        for alt in ("kics/kics.log","codeql/codeql.log","trivy/trivy.log"):
            ap=os.path.join(run_dir,alt)
            if os.path.isfile(ap):
                cand=ap; break
        else:
            return (None, None)
    try:
        txt=Path(cand).read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return (None, None)

    tools = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"]
    degraded=set()
    for t in tools:
        pats = [
            fr"VSP_{t}_TIMEOUT_DEGRADE",
            fr"\[{t}\].*DEGRADED",
            fr"{t}.*timeout.*degrad",
            fr"{t}.*missing.*degrad",
        ]
        for pat in pats:
            if re.search(pat, txt, flags=re.I):
                degraded.add(t)
                break
    n=len(degraded)
    return (n, n>0)

class VSPStatusContractMWP1V1:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = environ.get("PATH_INFO","") or ""
        if not path.startswith("/api/vsp/run_status_v2/"):
            return self.app(environ, start_response)

        captured = {"status":"200 OK","headers":[],"exc":None}

        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = headers or []
            captured["exc"] = exc_info
            # delay calling start_response

        it = self.app(environ, _sr)
        try:
            body = b"".join(it)
        finally:
            try:
                it.close()
            except Exception:
                pass

        headers = captured["headers"]
        ctype = ""
        for k,v in headers:
            if str(k).lower() == "content-type":
                ctype = str(v)
                break

        # only postprocess JSON
        if "application/json" not in ctype.lower():
            start_response(captured["status"], headers, captured["exc"])
            return [body]

        try:
            obj = json.loads(body.decode("utf-8","ignore"))
        except Exception:
            start_response(captured["status"], headers, captured["exc"])
            return [body]

        if not isinstance(obj, dict):
            start_response(captured["status"], headers, captured["exc"])
            return [body]

        rid = path.rsplit("/",1)[-1]
        obj["run_id"] = obj.get("run_id") or rid

        run_dir = obj.get("ci_run_dir") or obj.get("ci")
        if run_dir and os.path.isdir(run_dir):
            t = _vsp_findings_total(run_dir)
            if isinstance(t, int):
                obj["total_findings"] = t
                obj["has_findings"] = True if t > 0 else False

            dn, da = _vsp_degraded_info(run_dir)
            if isinstance(dn, int):
                obj["degraded_n"] = dn
            if isinstance(da, bool):
                obj["degraded_any"] = da

        obj.setdefault("ok", True)

        out = json.dumps(obj, ensure_ascii=False).encode("utf-8")

        # fix content-length
        new_headers=[]
        for k,v in headers:
            if str(k).lower() == "content-length":
                continue
            new_headers.append((k,v))
        new_headers.append(("Content-Length", str(len(out))))

        start_response(captured["status"], new_headers, captured["exc"])
        return [out]

# wrap if possible
try:
    application.wsgi_app = VSPStatusContractMWP1V1(application.wsgi_app)
except Exception:
    pass
# === VSP_WSGI_STATUS_CONTRACT_MW_P1_V1_END ===


# === VSP_WSGI_RUNS_INDEX_ENRICH_MW_P1_V1_BEGIN ===
import json
import urllib.parse

class VSPRunsIndexEnrichMWP1V1:
    """
    Post-process /api/vsp/runs_index_v3_fs_resolved JSON items by attaching:
      total_findings, has_findings, degraded_n, degraded_any
    derived deterministically from ci_run_dir (no heuristics).
    """
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = environ.get("PATH_INFO","") or ""
        if path != "/api/vsp/runs_index_v3_fs_resolved":
            return self.app(environ, start_response)

        captured = {"status":"200 OK","headers":[],"exc":None}
        def _sr(status, headers, exc_info=None):
            captured["status"]=status
            captured["headers"]=headers or []
            captured["exc"]=exc_info

        it = self.app(environ, _sr)
        try:
            body = b"".join(it)
        finally:
            try: it.close()
            except Exception: pass

        headers = captured["headers"]
        ctype=""
        for k,v in headers:
            if str(k).lower()=="content-type":
                ctype=str(v); break
        if "application/json" not in ctype.lower():
            start_response(captured["status"], headers, captured["exc"])
            return [body]

        try:
            obj=json.loads(body.decode("utf-8","ignore"))
        except Exception:
            start_response(captured["status"], headers, captured["exc"])
            return [body]

        if not isinstance(obj, dict):
            start_response(captured["status"], headers, captured["exc"])
            return [body]

        items = obj.get("items")
        if not isinstance(items, list):
            start_response(captured["status"], headers, captured["exc"])
            return [body]

        # cap enrich to avoid heavy IO if someone requests huge limit
        qs = environ.get("QUERY_STRING","") or ""
        q = urllib.parse.parse_qs(qs)
        try:
            limit = int((q.get("limit") or ["50"])[0])
        except Exception:
            limit = 50
        hard_cap = 120
        n = min(len(items), min(limit, hard_cap))

        for i in range(n):
            it0 = items[i]
            if not isinstance(it0, dict):
                continue
            run_dir = it0.get("ci_run_dir") or it0.get("ci") or None
            if not run_dir:
                continue
            try:
                # reuse helpers from status MW (already injected earlier)
                t = _vsp_findings_total(run_dir)
                if isinstance(t, int):
                    it0["total_findings"] = t
                    it0["has_findings"] = True if t>0 else False
                dn, da = _vsp_degraded_info(run_dir)
                if isinstance(dn, int):
                    it0["degraded_n"] = dn
                if isinstance(da, bool):
                    it0["degraded_any"] = da
            except Exception:
                pass

        out=json.dumps(obj, ensure_ascii=False).encode("utf-8")

        new_headers=[]
        for k,v in headers:
            if str(k).lower()=="content-length":
                continue
            new_headers.append((k,v))
        new_headers.append(("Content-Length", str(len(out))))

        start_response(captured["status"], new_headers, captured["exc"])
        return [out]

try:
    application.wsgi_app = VSPRunsIndexEnrichMWP1V1(application.wsgi_app)
except Exception:
    pass
# === VSP_WSGI_RUNS_INDEX_ENRICH_MW_P1_V1_END ===


# === VSP_WSGI_FINDINGS_UNIFIED_API_P1_V1 (commercial) ===
# Ensure /api/vsp/findings_unified_v1/<rid> is registered on the ACTUAL gunicorn "application"
import os, json, glob
from flask import request, jsonify

VSP_UIREQ_DIR = os.environ.get("VSP_UIREQ_DIR", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1")
VSP_CI_OUT_GLOB = os.environ.get("VSP_CI_OUT_GLOB", "/home/test/Data/**/out_ci/VSP_CI_*")

_SEV_W = {"CRITICAL": 50, "HIGH": 40, "MEDIUM": 30, "LOW": 20, "INFO": 10, "TRACE": 0}
def _sev_w(x): return _SEV_W.get((x or "").upper(), -1)

def _read_json(path):
  try:
    with open(path, "r", encoding="utf-8") as f:
      return json.load(f)
  except Exception:
    return None

def _resolve_run_dir_from_rid(rid: str):
  st = _read_json(os.path.join(VSP_UIREQ_DIR, f"{rid}.json")) or {}
  for k in ("ci_run_dir","ci_run_dir_resolved","run_dir","RUN_DIR"):
    v = st.get(k)
    if isinstance(v,str) and v.strip():
      return v.strip(), "uireq_state"
  cands=[]
  for d in glob.glob(VSP_CI_OUT_GLOB, recursive=True):
    if rid in (os.path.basename(d) or "") or rid in d:
      cands.append(d)
  cands = sorted(set(cands), key=lambda x: os.path.getmtime(x) if os.path.exists(x) else 0, reverse=True)
  if cands: return cands[0], "scan_out_ci"
  return None, "not_found"

def _apply_filters(items, q=None, sev=None, tool=None, cwe=None, fileq=None):
  q=(q or "").strip().lower(); fileq=(fileq or "").strip().lower()
  sev=(sev or "").strip().upper(); tool=(tool or "").strip().lower(); cwe=(cwe or "").strip().upper()
  out=[]
  for it in items or []:
    t=(it.get("title") or "")
    f=(it.get("file") or "")
    sv=(it.get("severity") or "").upper()
    tl=(it.get("tool") or "").lower()
    cw=it.get("cwe")
    c=""
    if isinstance(cw,list) and cw: c=str(cw[0] or "").upper()
    elif isinstance(cw,str): c=cw.upper()
    if sev and sv!=sev: continue
    if tool and tool!=tl: continue
    if cwe and cwe!=c: continue
    if fileq and fileq not in f.lower(): continue
    if q:
      hay=(t+" "+f+" "+(it.get("id") or "")).lower()
      if q not in hay: continue
    out.append(it)
  return out

# avoid double-register if hot reload
try:
  _has = any(getattr(r, "rule", "")=="/api/vsp/findings_unified_v1/<rid>" for r in app.url_map.iter_rules())
except Exception:
  _has = False

if not _has:
  @app.route("/api/vsp/findings_unified_v1/<rid>", methods=["GET"])
  def api_vsp_findings_unified_v1(rid):
    page=int(request.args.get("page","1") or "1")
    limit=int(request.args.get("limit","50") or "50")
    page=1 if page<1 else page
    limit=50 if limit<1 else (500 if limit>500 else limit)

    q=request.args.get("q"); sev=request.args.get("sev"); tool=request.args.get("tool")
    cwe=request.args.get("cwe"); fileq=request.args.get("file")

    run_dir, src = _resolve_run_dir_from_rid(rid)
    if not run_dir:
      return jsonify({"ok":False,"warning":"run_dir_not_found","rid":rid,"resolve_source":src,"total":0,"items":[]}), 200

    fp=os.path.join(run_dir,"findings_unified.json")
    data=_read_json(fp)
    if not data or not isinstance(data,dict):
      return jsonify({"ok":True,"warning":"findings_unified_not_found_or_bad","rid":rid,"resolve_source":src,"run_dir":run_dir,"file":fp,"total":0,"items":[]}), 200

    items=data.get("items") or []
    items=_apply_filters(items,q=q,sev=sev,tool=tool,cwe=cwe,fileq=fileq)


    # === VSP_CWE_SAFE_GRYE_V2 ===
    # Fill item.cwe from item.raw.vulnerability.cwes[*].cwe (GRYPE)
    try:
      for _it in (items or []):
        if _it.get("cwe"):
          continue
        if str(_it.get("tool") or "").upper() != "GRYPE":
          continue
        _raw = _it.get("raw") or {}
        _vuln = _raw.get("vulnerability") or {}
        _cwes = _vuln.get("cwes") or []
        _out = []
        for _c in _cwes:
          _v = _c.get("cwe") if isinstance(_c, dict) else _c
          if not _v:
            continue
          _v = str(_v).strip()
          if not _v:
            continue
          if (not _v.upper().startswith("CWE-")) and _v.isdigit():
            _v = "CWE-" + _v
          _out.append(_v.upper())
        if _out:
          _it["cwe"] = list(dict.fromkeys(_out))
    except Exception:
      pass
    # === /VSP_CWE_SAFE_GRYE_V2 ===

    # === VSP_CWE_ENRICH_FROM_ITEM_RAW_V1 ===
    # Fill item.cwe from item.raw.vulnerability.cwes[*].cwe (GRYPE proven has this)
    try:
      for _it in items or []:
        if _it.get("cwe"):
          continue
        _raw = _it.get("raw") or {}
        _vuln = _raw.get("vulnerability") or {}
        _cwes = _vuln.get("cwes") or []
        _out = []
        for _c in _cwes:
          _v = _c.get("cwe") if isinstance(_c, dict) else _c
          if not _v:
            continue
          _v = str(_v).strip()
          if not _v:
            continue
          if (not _v.upper().startswith("CWE-")) and _v.isdigit():
            _v = "CWE-" + _v
          _out.append(_v.upper())
        if _out:
          _it["cwe"] = list(dict.fromkeys(_out))
    except Exception:
      pass
    # === /VSP_CWE_ENRICH_FROM_ITEM_RAW_V1 ===

    # enrich CWE from GRYPE raw file (safe; unified items may not carry raw)
    grype_map = _build_grype_cwe_map(run_dir)
    if grype_map:
      try:
        items = [_maybe_set_cwe_from_grype(dict(it), grype_map) for it in items]
      except Exception:
        pass

    # VSP_P1_FIX_RUNS_AND_SHA256SUMS_V1 skip meta dirs
    items = [x for x in items if (x.get("run_id")!="A2Z_INDEX")]
    items.sort(key=lambda it: (-_sev_w(it.get("severity")), (it.get("tool") or ""), (it.get("file") or ""), int(it.get("line") or 0)))
    total=len(items)
    start=(page-1)*limit; end=start+limit
    page_items=items[start:end]

    by_sev={}; by_tool={}; by_cwe={}
    for it in items:
      sv=(it.get("severity") or "UNKNOWN").upper()
      tl=(it.get("tool") or "UNKNOWN")
      cws = _vsp_extract_cwe_list(it)
      if cws and not it.get('cwe'):
        it['cwe'] = cws
      c = (str(cws[0]).upper() if cws else 'UNKNOWN')
      by_sev[sv]=by_sev.get(sv,0)+1
      by_tool[tl]=by_tool.get(tl,0)+1
      by_cwe[c]=by_cwe.get(c,0)+1
    unknown_count = by_cwe.get("UNKNOWN", 0)
    top_cwe = sorted([(k,v) for (k,v) in by_cwe.items() if k!="UNKNOWN"], key=lambda kv: kv[1], reverse=True)[:10]

    return jsonify({
      "ok":True,"rid":rid,"run_dir":run_dir,"resolve_source":src,"file":fp,
      "page":page,"limit":limit,"total":total,
      "counts":{"by_sev":by_sev,"by_tool":by_tool,"top_cwe":top_cwe},
      "items":page_items,
      "filters":{"q":q,"sev":sev,"tool":tool,"cwe":cwe,"file":fileq},
    }), 200
# === /VSP_WSGI_FINDINGS_UNIFIED_API_P1_V1 ===


# --- VSP_CWE_ENRICH_FROM_GRYPE_P1_V2 ---
import re as _re

_CVE_RE = _re.compile(r'(CVE-\d{4}-\d+)', _re.I)

def _build_grype_cwe_map(run_dir):
  """Return {CVE-xxxx-yyy: [CWE-79, ...]} from run_dir/grype/grype.json if exists."""
  try:
    fp = os.path.join(run_dir, "grype", "grype.json")
    j = _read_json(fp)
    if not j or not isinstance(j, dict):
      return {}
    out = {}
    for m in (j.get("matches") or []):
      vuln = (m.get("vulnerability") or {})
      vid = (vuln.get("id") or "").strip()
      if not vid:
        continue
      cwes = []
      for c in (vuln.get("cwes") or []):
        cwe = (c.get("cwe") or "").strip()
        if cwe:
          if not cwe.upper().startswith("CWE-") and cwe.isdigit():
            cwe = "CWE-" + cwe
          cwes.append(cwe)
      if cwes:
        out[vid.upper()] = list(dict.fromkeys(cwes))
    return out
  except Exception:
    return {}

def _maybe_set_cwe_from_grype(it, grype_map):
  if it.get("cwe"):
    return it
  tool = (it.get("tool") or "").upper()
  if tool != "GRYPE":
    return it
  cand = (it.get("id") or "").strip()
  if not cand:
    # try parse CVE from title
    t = (it.get("title") or "")
    m = _CVE_RE.search(t or "")
    cand = m.group(1) if m else ""
  cand = (cand or "").upper()
  if cand and cand in grype_map:
    it["cwe"] = grype_map[cand]
  return it
# --- /VSP_CWE_ENRICH_FROM_GRYPE_P1_V2 ---


# --- VSP_CWE_FROM_RAW_ITEMS_P1_V3 ---
def _vsp_norm_cwe(x):
  try:
    x = str(x or "").strip()
    if not x:
      return None
    u = x.upper()
    if u.startswith("CWE-"):
      return u
    if x.isdigit():
      return "CWE-" + x
    return u
  except Exception:
    return None

def _vsp_extract_cwe_list(it):
  """Best-effort CWE extraction from unified item or item.raw.
  Works for GRYPE (raw.vulnerability.cwes) and some SARIF/CodeQL shapes.
  """
  try:
    # 1) already normalized in item.cwe
    cw = it.get("cwe")
    if isinstance(cw, list) and cw:
      out=[]
      for v in cw:
        nv=_vsp_norm_cwe(v)
        if nv: out.append(nv)
      if out: return list(dict.fromkeys(out))
    if isinstance(cw, str) and cw.strip():
      nv=_vsp_norm_cwe(cw)
      return [nv] if nv else None

    raw = it.get("raw") or {}

    # 2) GRYPE: raw.vulnerability.cwes[*].cwe
    vuln = raw.get("vulnerability") or {}
    cwes = vuln.get("cwes") or []
    out=[]
    for c in cwes:
      if isinstance(c, dict):
        nv=_vsp_norm_cwe(c.get("cwe"))
      else:
        nv=_vsp_norm_cwe(c)
      if nv: out.append(nv)
    if out: return list(dict.fromkeys(out))

    # 3) relatedVulnerabilities[*].cwes[*].cwe (some feeds)
    rv = raw.get("relatedVulnerabilities") or []
    out=[]
    for v in rv:
      for c in (v.get("cwes") or []):
        nv=_vsp_norm_cwe((c.get("cwe") if isinstance(c, dict) else c))
        if nv: out.append(nv)
    if out: return list(dict.fromkeys(out))

    # 4) SARIF-ish: raw.rule.properties.cwe or raw.properties.cwe
    for path in [
      ("rule","properties","cwe"),
      ("properties","cwe"),
      ("rule","cwe"),
      ("cwe",),
    ]:
      cur = raw
      ok=True
      for k in path:
        if isinstance(cur, dict) and k in cur:
          cur = cur[k]
        else:
          ok=False; break
      if ok and cur:
        if isinstance(cur, list) and cur:
          nv=_vsp_norm_cwe(cur[0])
          return [nv] if nv else None
        nv=_vsp_norm_cwe(cur)
        return [nv] if nv else None
  except Exception:
    pass
  return None
# --- /VSP_CWE_FROM_RAW_ITEMS_P1_V3 ---


# === VSP_FINDINGS_UNIFIED_V2_ENRICHED_V1 ===
# New endpoint (non-invasive): /api/vsp/findings_unified_v2/<rid>
# Goal: commercial-safe enrichment (CWE from item.raw) + stable counts/top_cwe.
import os, json, glob
from flask import request, jsonify

VSP_UIREQ_DIR = os.environ.get("VSP_UIREQ_DIR", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1")
VSP_CI_OUT_GLOB = os.environ.get("VSP_CI_OUT_GLOB", "/home/test/Data/**/out_ci/VSP_CI_*")

_SEV_W = {"CRITICAL": 50, "HIGH": 40, "MEDIUM": 30, "LOW": 20, "INFO": 10, "TRACE": 0}
def _sev_w(x): return _SEV_W.get((x or "").upper(), -1)

def _read_json(path):
  try:
    with open(path, "r", encoding="utf-8") as f:
      return json.load(f)
  except Exception:
    return None

def _resolve_run_dir_from_rid(rid: str):
  st = _read_json(os.path.join(VSP_UIREQ_DIR, f"{rid}.json")) or {}
  for k in ("ci_run_dir","ci_run_dir_resolved","run_dir","RUN_DIR"):
    v = st.get(k)
    if isinstance(v, str) and v.strip():
      return v.strip(), "uireq_state"
  cands=[]
  for d in glob.glob(VSP_CI_OUT_GLOB, recursive=True):
    if rid in (os.path.basename(d) or "") or rid in d:
      cands.append(d)
  cands = sorted(set(cands), key=lambda x: os.path.getmtime(x) if os.path.exists(x) else 0, reverse=True)
  if cands:
    return cands[0], "scan_out_ci"
  return None, "not_found"

def _norm_cwe(v):
  try:
    v = str(v or "").strip()
    if not v: return None
    u = v.upper()
    if u.startswith("CWE-"): return u
    if v.isdigit(): return "CWE-" + v
    return u
  except Exception:
    return None

def _extract_cwe_list(it):
  # Prefer item.cwe
  cw = it.get("cwe")
  out=[]
  if isinstance(cw, list):
    for x in cw:
      nx = _norm_cwe(x)
      if nx: out.append(nx)
  elif isinstance(cw, str):
    nx=_norm_cwe(cw)
    if nx: out.append(nx)
  if out:
    return list(dict.fromkeys(out))

  # Fallback: item.raw.* (GRYPE proven here)
  raw = it.get("raw") or {}
  vuln = (raw.get("vulnerability") or {})
  cwes = vuln.get("cwes") or []
  out=[]
  for c in cwes:
    v = c.get("cwe") if isinstance(c, dict) else c
    nx=_norm_cwe(v)
    if nx: out.append(nx)
  if out:
    return list(dict.fromkeys(out))

  rv = raw.get("relatedVulnerabilities") or []
  out=[]
  for vv in rv:
    for c in (vv.get("cwes") or []):
      v = c.get("cwe") if isinstance(c, dict) else c
      nx=_norm_cwe(v)
      if nx: out.append(nx)
  if out:
    return list(dict.fromkeys(out))

  # SARIF-ish (best-effort)
  for path in [
    ("rule","properties","cwe"),
    ("properties","cwe"),
    ("rule","cwe"),
    ("cwe",),
  ]:
    cur = raw
    ok=True
    for k in path:
      if isinstance(cur, dict) and k in cur:
        cur = cur[k]
      else:
        ok=False; break
    if ok and cur:
      if isinstance(cur, list) and cur:
        nx=_norm_cwe(cur[0])
        return [nx] if nx else None
      nx=_norm_cwe(cur)
      return [nx] if nx else None

  return None

def _apply_filters(items, q=None, sev=None, tool=None, cwe=None, fileq=None):
  q=(q or "").strip().lower()
  fileq=(fileq or "").strip().lower()
  sev=(sev or "").strip().upper()
  tool=(tool or "").strip().lower()
  cwe=(cwe or "").strip().upper()
  out=[]
  for it in items or []:
    t=(it.get("title") or "")
    f=(it.get("file") or "")
    sv=(it.get("severity") or "").upper()
    tl=(it.get("tool") or "").lower()
    cws = _extract_cwe_list(it) or []
    c0 = (str(cws[0]).upper() if cws else "UNKNOWN")

    if sev and sv != sev: 
      continue
    if tool and tool != tl:
      continue
    if cwe and cwe != c0:
      continue
    if fileq and fileq not in f.lower():
      continue
    if q:
      hay=(t+" "+f+" "+(it.get("id") or "")).lower()
      if q not in hay:
        continue

    # ensure item.cwe filled for UI
    if cws and not it.get("cwe"):
      it["cwe"] = cws
    out.append(it)
  return out

@app.route("/api/vsp/findings_unified_v2/<rid>", methods=["GET"])
def api_vsp_findings_unified_v2(rid):
  page = int(request.args.get("page","1") or "1")
  limit = int(request.args.get("limit","50") or "50")
  page = 1 if page < 1 else page
  limit = 50 if limit < 1 else (500 if limit > 500 else limit)

  q = request.args.get("q")
  sev = request.args.get("sev")
  tool = request.args.get("tool")
  cwe = request.args.get("cwe")
  fileq = request.args.get("file")

  run_dir, src = _resolve_run_dir_from_rid(rid)
  if not run_dir:
    return jsonify({
      "ok": False,
      "warning": "run_dir_not_found",
      "rid": rid,
      "resolve_source": src,
      "total": 0,
      "items": [],
    }), 200

  fp = os.path.join(run_dir, "findings_unified.json")
  data = _read_json(fp)
  if not data or not isinstance(data, dict):
    return jsonify({
      "ok": True,
      "warning": "findings_unified_not_found_or_bad",
      "rid": rid,
      "resolve_source": src,
      "run_dir": run_dir,
      "file": fp,
      "total": 0,
      "items": [],
    }), 200

  items = data.get("items") or []
  items = _apply_filters(items, q=q, sev=sev, tool=tool, cwe=cwe, fileq=fileq)

  items.sort(key=lambda it: (-_sev_w(it.get("severity")), (it.get("tool") or ""), (it.get("file") or ""), int(it.get("line") or 0)))
  total = len(items)
  start = (page-1)*limit
  end = start + limit
  page_items = items[start:end]

  by_sev={}; by_tool={}; by_cwe={}
  for it in items:
    sv=(it.get("severity") or "UNKNOWN").upper()
    tl=(it.get("tool") or "UNKNOWN")
    cws = _extract_cwe_list(it) or []
    c0 = (str(cws[0]).upper() if cws else "UNKNOWN")
    by_sev[sv]=by_sev.get(sv,0)+1
    by_tool[tl]=by_tool.get(tl,0)+1
    by_cwe[c0]=by_cwe.get(c0,0)+1

  unknown_count = by_cwe.get("UNKNOWN", 0)
  top_cwe = sorted([(k,v) for (k,v) in by_cwe.items() if k!="UNKNOWN"], key=lambda kv: kv[1], reverse=True)[:10]

  return jsonify({
    "ok": True,
    "rid": rid,
    "run_dir": run_dir,
    "resolve_source": src,
    "file": fp,
    "page": page,
    "limit": limit,
    "total": total,
    "counts": {
      "by_sev": by_sev,
      "by_tool": by_tool,
      "top_cwe": top_cwe,
      "unknown_count": unknown_count
    },
    "items": page_items,
    "filters": {"q": q, "sev": sev, "tool": tool, "cwe": cwe, "file": fileq},
    "debug": ({"marker":"VSP_FINDINGS_UNIFIED_V2_ENRICHED_V1","flask_var":"app"} if request.args.get("debug")=="1" else None)
  }), 200
# === /VSP_FINDINGS_UNIFIED_V2_ENRICHED_V1 ===


# === VSP_DASHBOARD_V3_EXTRAS_FROM_V2_P1_V1 ===
@app.route("/api/vsp/dashboard_v3_extras_v1", methods=["GET"])
def api_vsp_dashboard_v3_extras_v1():
  rid = (request.args.get("rid") or "").strip()
  if not rid:
    # fallback: take latest from runs_index if exists
    try:
      j = api_vsp_runs_index_v3_fs_resolved()
      rid = (j.json.get("items") or [{}])[0].get("run_id") or ""
    except Exception:
      rid = ""
  rid = str(rid).strip()

  # call V2 handler directly (same process) for counts
  try:
    # simulate request args for V2: limit=1
    args = request.args.to_dict(flat=True)
    args.pop("rid", None)
    args["limit"]="1"
    # Temporarily patch request.args? (avoid): call function and parse JSON through flask response
    resp = api_vsp_findings_unified_v2(rid)
    # resp may be (response, code)
    if isinstance(resp, tuple):
      resp_obj = resp[0]
    else:
      resp_obj = resp
    data = resp_obj.get_json(silent=True) or {}
  except Exception:
    data = {}

  counts = (data.get("counts") or {})
  by_sev = counts.get("by_sev") or {}
  by_tool = counts.get("by_tool") or {}
  top_cwe = counts.get("top_cwe") or []
  unknown_count = int(counts.get("unknown_count") or 0)
  total = int(data.get("total") or 0)

  # score heuristic (commercial-ish): 100 - weighted findings / scale
  w = 0
  for k,v in by_sev.items():
    k = str(k or "").upper()
    v = int(v or 0)
    if k == "CRITICAL": w += v*50
    elif k == "HIGH": w += v*30
    elif k == "MEDIUM": w += v*15
    elif k == "LOW": w += v*5
    elif k == "INFO": w += v*1
  score = max(0, int(100 - (w/ max(1, 200))))  # scale factor 200

  # degraded/effective (P1): degraded = unknown_count, effective = total-unknown
  degraded = unknown_count
  effective = max(0, total - unknown_count)

  return jsonify({
    "ok": True,
    "rid": rid,
    "kpi": {
      "total": total,
      "effective": effective,
      "degraded": degraded,
      "score": score,
      "by_sev": by_sev,
      "by_tool": by_tool,
      "top_cwe": top_cwe,
      "unknown_count": unknown_count
    },
    "sources": {
      "findings_api": "/api/vsp/findings_unified_v2/<rid>",
      "marker": "VSP_DASHBOARD_V3_EXTRAS_FROM_V2_P1_V1"
    }
  }), 200
# === /VSP_DASHBOARD_V3_EXTRAS_FROM_V2_P1_V1 ===


# === VSP_RUNS_EXPORT_ZIP_INJECT_MW_P0_V2 ===
class VSPRunsExportZipBtnMWP0V2:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path != "/runs":
            return self.app(environ, start_response)

        meta = {}
        def sr(status, headers, exc_info=None):
            meta["status"] = status
            meta["headers"] = headers
            meta["exc_info"] = exc_info
            return lambda _x: None

        app_iter = self.app(environ, sr)

        body = b""
        try:
            for chunk in app_iter:
                if chunk:
                    body += chunk
        finally:
            try:
                close = getattr(app_iter, "close", None)
                if callable(close):
                    close()
            except Exception:
                pass

        headers = meta.get("headers") or []
        ct = ""
        for k,v in headers:
            if str(k).lower() == "content-type":
                ct = str(v); break

        # only inject into HTML /runs
        if ("text/html" in ct) and (b"/api/vsp/run_file" in body) and (MARKB not in body):
            js = b"""
<script>
/* VSP_RUNS_EXPORT_ZIP_INJECT_MW_P0_V2 */
(function(){
  'use strict';
  function ridFromHref(href){
    try{
      const u=new URL(href, location.origin);
      if(!u.pathname.includes('/api/vsp/run_file')) return null;
      return u.searchParams.get('run_id');
    }catch(e){return null;}
  }
  function addBtn(a, rid){
    try{
      const row=a.closest('tr')||a.parentElement;
      if(!row) return;
      if(row.querySelector('a[data-vsp-export-zip="1"]')) return;
      const b=document.createElement('a');
      b.textContent='Export ZIP';
      b.href='/api/vsp/export_zip?run_id='+encodeURIComponent(rid);
      b.setAttribute('data-vsp-export-zip','1');
      b.style.marginLeft='8px';
      b.style.textDecoration='none';
      b.style.display='inline-block';
      b.style.padding='7px 10px';
      b.style.borderRadius='10px';
      b.style.fontWeight='800';
      b.style.border='1px solid rgba(90,140,255,.35)';
      b.style.background='rgba(90,140,255,.16)';
      b.style.color='inherit';
      a.insertAdjacentElement('afterend', b);
    }catch(_){}
  }
  function patch(){
    const links=[...document.querySelectorAll('a[href*="/api/vsp/run_file"]')];
    const seen=new Set();
    for(const a of links){
      const rid=ridFromHref(a.getAttribute('href')||'');
      if(!rid) continue;
      const key=rid+'::'+(a.closest('tr')?a.closest('tr').rowIndex:'x');
      if(seen.has(key)) continue;
      seen.add(key);
      addBtn(a,rid);
    }
  }
  patch(); setTimeout(patch,600); setTimeout(patch,1400);
})();
</script>
"""
            if b"</body>" in body:
                body = body.replace(b"</body>", js + b"</body>", 1)
            else:
                body = body + js

        # fix Content-Length
        new_headers=[]
        for k,v in headers:
            if str(k).lower() == "content-length":
                continue
            new_headers.append((k,v))
        new_headers.append(("Content-Length", str(len(body))))

        start_response(meta.get("status","200 OK"), new_headers, meta.get("exc_info"))
        return [body]

try:
    if "application" in globals():
        _a = globals().get("application")
        if _a is not None and not getattr(_a, "__VSP_RUNS_EXPORT_ZIP_INJECT_MW_P0_V2__", False):
            _mw = VSPRunsExportZipBtnMWP0V2(_a)
            setattr(_mw, "__VSP_RUNS_EXPORT_ZIP_INJECT_MW_P0_V2__", True)
            globals()["application"] = _mw
except Exception:
    pass
# === /VSP_RUNS_EXPORT_ZIP_INJECT_MW_P0_V2 ===


# === VSP_RUNS_EXPORT_ZIP_NOJS_MW_P0_V3 ===
class VSPRunsExportZipNoJSMWP0V3:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path != "/runs":
            return self.app(environ, start_response)

        meta = {}
        def sr(status, headers, exc_info=None):
            meta["status"] = status
            meta["headers"] = headers
            meta["exc_info"] = exc_info
            return lambda _x: None

        app_iter = self.app(environ, sr)

        body = b""
        try:
            for chunk in app_iter:
                if chunk:
                    body += chunk
        finally:
            try:
                close = getattr(app_iter, "close", None)
                if callable(close):
                    close()
            except Exception:
                pass

        headers = meta.get("headers") or []
        ct = ""
        for k,v in headers:
            if str(k).lower() == "content-type":
                ct = str(v); break

        if ("text/html" in ct) and (b"/api/vsp/run_file" in body) and (MARKB not in body):
            try:
                html = body.decode("utf-8", "replace")
            except Exception:
                html = str(body)

            # Insert NO-JS Export button after any run_file link (per anchor)
            # Capture run_id from query string.
            runfile_a_pat = re.compile(
                r'(<a\b[^>]*href="[^"]*/api/vsp/run_file\?[^"]*?\brun_id=([^"&]+)[^"]*"[^>]*>.*?</a>)',
                re.IGNORECASE | re.DOTALL
            )

            def add_btn(m):
                a = m.group(1)
                rid = m.group(2)
                # Avoid duplicating if already inserted
                if "data-vsp-export-zip" in a:
                    return a
                btn = (
                    ' <a data-vsp-export-zip="1" '
                    'href="/api/vsp/export_zip?run_id=' + rid + '" '
                    'style="margin-left:8px;text-decoration:none;display:inline-block;'
                    'padding:7px 10px;border-radius:10px;font-weight:800;'
                    'border:1px solid rgba(90,140,255,.35);background:rgba(90,140,255,.16);color:inherit;">'
                    'Export ZIP</a>'
                )
                return a + btn

            html2, n = runfile_a_pat.subn(add_btn, html)
            if n > 0:
                # Add a marker comment that won't be stripped like <script>
                marker = "\n<!-- " + MARK + " injected=" + str(n) + " -->\n"
                if "</body>" in html2:
                    html2 = html2.replace("</body>", marker + "</body>", 1)
                else:
                    html2 = html2 + marker

                body = html2.encode("utf-8", "replace")

        # fix Content-Length
        new_headers=[]
        for k,v in headers:
            if str(k).lower() == "content-length":
                continue
            new_headers.append((k,v))
        new_headers.append(("Content-Length", str(len(body))))

        start_response(meta.get("status","200 OK"), new_headers, meta.get("exc_info"))
        return [body]

try:
    if "application" in globals():
        _a = globals().get("application")
        if _a is not None and not getattr(_a, "__VSP_RUNS_EXPORT_ZIP_NOJS_MW_P0_V3__", False):
            _mw = VSPRunsExportZipNoJSMWP0V3(_a)
            setattr(_mw, "__VSP_RUNS_EXPORT_ZIP_NOJS_MW_P0_V3__", True)
            globals()["application"] = _mw
except Exception:
    pass
# === /VSP_RUNS_EXPORT_ZIP_NOJS_MW_P0_V3 ===


# === VSP_RUNS_INJECT_EXTZIP_JS_P0_V1 ===
class VSPRunsInjectExtZipJSMWP0V1:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        if (environ.get("PATH_INFO") or "") != "/runs":
            return self.app(environ, start_response)

        meta={}
        def sr(status, headers, exc_info=None):
            meta["status"]=status; meta["headers"]=headers; meta["exc_info"]=exc_info
            return lambda _x: None

        it = self.app(environ, sr)
        body=b""
        try:
            for c in it:
                if c: body += c
        finally:
            try:
                close=getattr(it,"close",None)
                if callable(close): close()
            except Exception:
                pass

        headers = meta.get("headers") or []
        ct=""
        for k,v in headers:
            if str(k).lower()=="content-type":
                ct=str(v); break

        if ("text/html" in ct) and (MARKB not in body):
            ts = str(int(time.time()))
            tag = (f'\n<!-- {MARK} -->\n'
                   f'<script src="/static/js/vsp_runs_export_zip_patch_p0_v4.js?ts={ts}"></script>\n').encode("utf-8","replace")
            if b"</body>" in body:
                body = body.replace(b"</body>", tag + b"</body>", 1)
            else:
                body = body + tag

        newh=[]
        for k,v in headers:
            if str(k).lower()=="content-length": continue
            newh.append((k,v))
        newh.append(("Content-Length", str(len(body))))
        start_response(meta.get("status","200 OK"), newh, meta.get("exc_info"))
        return [body]

try:
    if "application" in globals():
        _a = globals().get("application")
        if _a is not None and not getattr(_a, "__VSP_RUNS_INJECT_EXTZIP_JS_P0_V1__", False):
            _mw = VSPRunsInjectExtZipJSMWP0V1(_a)
            setattr(_mw, "__VSP_RUNS_INJECT_EXTZIP_JS_P0_V1__", True)
            globals()["application"] = _mw
except Exception:
    pass
# === /VSP_RUNS_INJECT_EXTZIP_JS_P0_V1 ===


# === VSP_RUNS_500_FALLBACK_MW_P0_V1 ===
class VSPRuns500FallbackMWP0V1:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path != "/runs":
            return self.app(environ, start_response)

        meta = {}
        def sr(status, headers, exc_info=None):
            meta["status"]=status
            meta["headers"]=headers
            meta["exc_info"]=exc_info
            return lambda _x: None

        it = self.app(environ, sr)
        body=b""
        try:
            for c in it:
                if c: body += c
        finally:
            try:
                close=getattr(it,"close",None)
                if callable(close): close()
            except Exception:
                pass

        status = meta.get("status") or "200 OK"
        code = 0
        try:
            code = int(str(status).split()[0])
        except Exception:
            code = 0

        # if /runs returns 5xx => replace with a safe fallback page (NO <script>)
        if code >= 500:
            html = (
                "<!doctype html><html><head><meta charset='utf-8'>"
                "<title>Runs & Reports (fallback)</title></head>"
                "<body style='font-family:ui-sans-serif,system-ui;max-width:980px;margin:18px auto;"
                "padding:0 14px;color:#ddd;background:#0b0f14;'>"
                "<h2 style='margin:0 0 8px 0;'>Runs & Reports</h2>"
                "<div style='opacity:.85;margin-bottom:14px;'>"
                "UI /runs gp li 500. y l trang fallback  khng sp demo.</div>"
                "<div style='display:flex;gap:10px;flex-wrap:wrap;margin-bottom:14px;'>"
                "<a href='/vsp5' style='color:#9ab;'>Dashboard</a>"
                "<a href='/data' style='color:#9ab;'>Data Source</a>"
                "<a href='/settings' style='color:#9ab;'>Settings</a>"
                "<a href='/rule_overrides' style='color:#9ab;'>Rule Overrides</a>"
                "</div>"
                "<div style='padding:12px;border:1px solid rgba(255,255,255,.1);border-radius:12px;"
                "background:rgba(255,255,255,.03);'>"
                "<div style='font-weight:800;margin-bottom:8px;'>Quick Links</div>"
                "<ul style='margin:0;padding-left:18px;line-height:1.7;'>"
                "<li><a href='/api/vsp/runs?limit=50' style='color:#9ab;'>/api/vsp/runs?limit=50</a></li>"
                "<li><a href='/api/vsp/selfcheck_p0' style='color:#9ab;'>/api/vsp/selfcheck_p0</a></li>"
                "<li><a href='/findings_unified.json' style='color:#9ab;'>/findings_unified.json</a></li>"
                "</ul>"
                "</div>"
                "<div style='opacity:.65;margin-top:14px;font-size:12px;'>"
                "Marker: VSP_RUNS_500_FALLBACK_MW_P0_V1</div>"
                "</body></html>"
            ).encode("utf-8","replace")

            start_response("200 OK", [
                ("Content-Type","text/html; charset=utf-8"),
                ("Cache-Control","no-store"),
                ("Content-Length", str(len(html)))
            ])
            return [html]

        # normal success
        hdrs = meta.get("headers") or []
        start_response(status, hdrs, meta.get("exc_info"))
        return [body]

try:
    if "application" in globals():
        _a = globals().get("application")
        if _a is not None and not getattr(_a, "__VSP_RUNS_500_FALLBACK_MW_P0_V1__", False):
            _mw = VSPRuns500FallbackMWP0V1(_a)
            setattr(_mw, "__VSP_RUNS_500_FALLBACK_MW_P0_V1__", True)
            globals()["application"] = _mw
except Exception:
    pass
# === /VSP_RUNS_500_FALLBACK_MW_P0_V1 ===


# === VSP_RUNS_500_FALLBACK_MW_P0_V2 ===
class VSPRuns500FallbackMWP0V2:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def _fallback(self, start_response, why=""):
        # VSP_MARK_FIX_P0_V5: safe fallback (no f-string pitfalls, no MARK NameError)
        try:
            marker = MARK
        except Exception:
            marker = 'VSP_UI_GATEWAY_MARK_V1'
        why_s = '' if why is None else str(why)
        html = (
            "<!doctype html><meta charset='utf-8'>"
            "<title>VSP UI fallback</title>"
            "<pre>Marker: " + str(marker) + "\n" + why_s + "</pre>"
        )
        body = html.encode('utf-8', errors='replace')
        start_response('200 OK', [
            ('Content-Type','text/html; charset=utf-8'),
            ('Content-Length', str(len(body))),
            ('Cache-Control','no-store'),
        ])
        return [body]


# =========================
# VSP_RUN_FILE_SAFE_ENDPOINT_P0_V1
# - Serve per-run report/artifacts via whitelist (no absolute FS path leak)
# - Normalize "report/" vs "reports/" vs root file locations
# - Post-process /api/vsp/runs: replace any abs html_path with safe URL
# =========================
from pathlib import Path as _Path
from urllib.parse import quote as _quote
import os as _os
import json as _json
import mimetypes as _mimetypes
import re as _re

try:
    from flask import request as _request, abort as _abort, send_file as _send_file, Response as _Response
except Exception:
    _request = None  # type: ignore

_VSP_RUNFILE_ALLOWED = {
    # virtual_name: candidate real paths under RUN_DIR (first existing wins)
    "reports/index.html": [
        "reports/index.html",
        "report/index.html",
        "reports/report.html",
        "report/report.html",
        "report.html",
    ],
    "reports/findings_unified.json": [
        "reports/findings_unified.json",
        "report/findings_unified.json",
        "findings_unified.json",
        "reports/unified/findings_unified.json",
        "unified/findings_unified.json",
    ],
    "reports/findings_unified.csv": [
        "reports/findings_unified.csv",
        "report/findings_unified.csv",
        "findings_unified.csv",
        "reports/unified/findings_unified.csv",
        "unified/findings_unified.csv",
    ],
    "reports/findings_unified.sarif": [
        "reports/findings_unified.sarif",
        "report/findings_unified.sarif",
        "findings_unified.sarif",
        "reports/unified/findings_unified.sarif",
        "unified/findings_unified.sarif",
    ],
    "reports/run_gate_summary.json": [
        "reports/run_gate_summary.json",
        "report/run_gate_summary.json",
        "run_gate_summary.json",
        "reports/unified/run_gate_summary.json",
        "unified/run_gate_summary.json",
    ],
}

def _vsp__runs_roots():
    roots = []
    env = _os.environ.get("VSP_RUNS_ROOT", "").strip()
    if env:
        roots.append(_Path(env))
    # sensible defaults for this repo
    roots += [
        _Path("/home/test/Data/SECURITY_BUNDLE/out"),
        _Path("/home/test/Data/SECURITY_BUNDLE/out_ci"),
        _Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci"),
        _Path("/home/test/Data/SECURITY-10-10-v4/out_ci"),
    ]
    # de-dup, keep existing dirs
    out = []
    seen = set()
    for r in roots:
        rp = str(r)
        if rp in seen:
            continue
        seen.add(rp)
        if r.exists():
            out.append(r)
    return out

def _vsp__is_safe_rid(rid: str) -> bool:
    return bool(rid) and bool(_re.fullmatch(r"[A-Za-z0-9_.:-]{6,128}", rid))

def _vsp__find_run_dir(rid: str):
    # direct hit
    for root in _vsp__runs_roots():
        cand = root / rid
        if cand.is_dir():
            return cand
        cand2 = root / "out" / rid
        if cand2.is_dir():
            return cand2
    # shallow scan (bounded)
    for root in _vsp__runs_roots():
        try:
            for cand in root.glob(f"*{rid}*"):
                if cand.is_dir() and cand.name == rid:
                    return cand
        except Exception:
            pass
    return None

def _vsp__pick_file(run_dir: _Path, virtual_name: str):
    cands = _VSP_RUNFILE_ALLOWED.get(virtual_name)
    if not cands:
        return None
    for rel in cands:
        fp = (run_dir / rel).resolve()
        try:
            # must stay under run_dir
            run_dir_res = run_dir.resolve()
            if not str(fp).startswith(str(run_dir_res) + _os.sep) and fp != run_dir_res:
                continue
            if fp.is_file():
                return fp
        except Exception:
            continue
    return None

def _vsp__safe_url(rid: str, virtual_name: str) -> str:
    return f"/api/vsp/run_file?rid={_quote(rid)}&name={_quote(virtual_name)}"

# ---- Endpoint: serve whitelisted per-run file
try:
    _app_obj = app  # noqa: F821
except Exception:
    _app_obj = None

if _app_obj is not None and getattr(_app_obj, "route", None) is not None:
    @_app_obj.get("/api/vsp/run_file")
    def _api_vsp_run_file():
        rid = (_request.args.get("rid", "") if _request else "").strip()
        name = (_request.args.get("name", "") if _request else "").strip()
        if not _vsp__is_safe_rid(rid):
            return _Response("bad rid", status=400, mimetype="text/plain")
        if name not in _VSP_RUNFILE_ALLOWED:
            # VSP_P1_ALLOW_SHA256SUMS_NOT_ALLOWED_V1: allow reports/SHA256SUMS.txt (commercial audit)
            try:
                _rid = (_rq_compat.args.get('rid','') or _rq_compat.args.get('run_id','') or _rq_compat.args.get('run','') or '').strip()
                _rel = (_rq_compat.args.get('name','') or _rq_compat.args.get('path','') or _rq_compat.args.get('rel','') or '').strip().lstrip('/')
                if _rid and _rel == 'reports/SHA256SUMS.txt':
                    from pathlib import Path as _P
                    _fp = _P('/home/test/Data/SECURITY_BUNDLE/out') / _rid / 'reports' / 'SHA256SUMS.txt'
                    if _fp.exists():
                        return _sf_compat(str(_fp), as_attachment=True)
            except Exception:
                pass
            # VSP_P1_GW_BYPASS_SHA256SUMS_V1: allow reports/SHA256SUMS.txt (commercial audit)
            try:
                _rid = (_rq_compat.args.get('rid','') or _rq_compat.args.get('run_id','') or _rq_compat.args.get('run','') or '').strip()
                _rel = (_rq_compat.args.get('name','') or _rq_compat.args.get('path','') or _rq_compat.args.get('rel','') or '').strip().lstrip('/')
                if _rid and _rel == 'reports/SHA256SUMS.txt':
                    from pathlib import Path as _P
                    from flask import send_file as _send_file, jsonify as _jsonify
                    _fp = _P('/home/test/Data/SECURITY_BUNDLE/out') / _rid / 'reports' / 'SHA256SUMS.txt'
                    if _fp.exists():
                        return _send_file(str(_fp), as_attachment=True)
                    return _jsonify({'ok': False, 'error': 'NO_FILE'}), 404
            except Exception:
                pass
            return _Response("not allowed", status=404, mimetype="text/plain")

        run_dir = _vsp__find_run_dir(rid)
        if not run_dir:
            return _Response("run not found", status=404, mimetype="text/plain")

        fp = _vsp__pick_file(run_dir, name)
        if not fp:
            return _Response("file not found", status=404, mimetype="text/plain")

        ctype, _enc = _mimetypes.guess_type(str(fp))
        ctype = ctype or ("text/html" if str(fp).endswith(".html") else "application/octet-stream")
        # inline for html/json, attachment for others
        as_attachment = not (str(fp).endswith(".html") or str(fp).endswith(".json"))
        return _send_file(fp, mimetype=ctype, as_attachment=as_attachment, download_name=fp.name)

    # learned-safe postprocess: rewrite /api/vsp/runs JSON to avoid absolute paths + add safe urls
    @_app_obj.after_request
    def _vsp__after_request_safe_runs(resp):
        try:
            if not _request or _request.path != "/api/vsp/runs":
                return resp
            if "application/json" not in (resp.headers.get("Content-Type", "") or ""):
                return resp
            data = resp.get_json(silent=True)
            if not isinstance(data, dict):
                return resp
            items = data.get("items") or []
            if not isinstance(items, list):
                return resp

            for it in items:
                if not isinstance(it, dict):
                    continue
                rid = (it.get("run_id") or it.get("rid") or "").strip()
                if not _vsp__is_safe_rid(rid):
                    continue
                has = it.get("has")
                if not isinstance(has, dict):
                    has = {}
                    it["has"] = has

                run_dir = _vsp__find_run_dir(rid)
                if not run_dir:
                    continue

                # normalize: if file exists under any legacy location, mark true + set safe URL
                def mark(vname: str, flag: str, keypath: str):
                    fp = _vsp__pick_file(run_dir, vname)
                    if fp:
                        has[flag] = True
                        has[keypath] = _vsp__safe_url(rid, vname)

                mark("reports/index.html", "html", "html_path")
                mark("reports/findings_unified.json", "json", "json_path")
                mark("reports/findings_unified.csv", "csv", "csv_path")
                mark("reports/findings_unified.sarif", "sarif", "sarif_path")
                mark("reports/run_gate_summary.json", "summary", "summary_path")

                # if legacy code already stuffed abs path into html_path, force rewrite to safe url
                hp = has.get("html_path")
                if isinstance(hp, str) and hp.startswith("/"):
                    # only rewrite if we can actually serve a report
                    if _vsp__pick_file(run_dir, "reports/index.html"):
                        has["html_path"] = _vsp__safe_url(rid, "reports/index.html")

            # re-encode response
            body = _json.dumps(data, ensure_ascii=False)
            resp.set_data(body)
            resp.headers["Content-Length"] = str(len(body.encode("utf-8")))
            return resp
        except Exception:
            return resp

# =========================
# END VSP_RUN_FILE_SAFE_ENDPOINT_P0_V1
# =========================


# =========================
# VSP_RUN_FILE2_SAFE_ENDPOINT_P0_V1
# - New endpoint /api/vsp/run_file2 to avoid collision with existing /api/vsp/run_file
# - Rewrite /api/vsp/runs has.*_path to use run_file2 (safe, no abs path)
# =========================
from pathlib import Path as _P2
from urllib.parse import quote as _q2
import os as _os2
import json as _json2
import mimetypes as _mt2
import re as _re2

try:
    from flask import request as _rq2, send_file as _sf2, Response as _R2
except Exception:
    _rq2 = None  # type: ignore

_VSP_RF2_ALLOWED = {
    "reports/index.html": [
        "reports/index.html","report/index.html","reports/report.html","report/report.html","report.html",
    ],
    "reports/findings_unified.json": [
        "reports/findings_unified.json","report/findings_unified.json","findings_unified.json",
        "reports/unified/findings_unified.json","unified/findings_unified.json",
    ],
    "reports/findings_unified.csv": [
        "reports/findings_unified.csv","report/findings_unified.csv","findings_unified.csv",
        "reports/unified/findings_unified.csv","unified/findings_unified.csv",
    ],
    "reports/findings_unified.sarif": [
        "reports/findings_unified.sarif","report/findings_unified.sarif","findings_unified.sarif",
        "reports/unified/findings_unified.sarif","unified/findings_unified.sarif",
    ],
    "reports/run_gate_summary.json": [
        "reports/run_gate_summary.json","report/run_gate_summary.json","run_gate_summary.json",
        "reports/unified/run_gate_summary.json","unified/run_gate_summary.json",
    ],
}

def _rf2_roots():
    roots=[]
    env=_os2.environ.get("VSP_RUNS_ROOT","").strip()
    if env: roots.append(_P2(env))
    roots += [
        _P2("/home/test/Data/SECURITY_BUNDLE/out"),
        _P2("/home/test/Data/SECURITY_BUNDLE/out_ci"),
        _P2("/home/test/Data/SECURITY_BUNDLE/ui/out_ci"),
        _P2("/home/test/Data/SECURITY-10-10-v4/out_ci"),
    ]
    out=[]; seen=set()
    for r in roots:
        rp=str(r)
        if rp in seen: continue
        seen.add(rp)
        if r.exists(): out.append(r)
    return out

def _rf2_safe_rid(rid:str)->bool:
    return bool(rid) and bool(_re2.fullmatch(r"[A-Za-z0-9_.:-]{6,160}", rid))

def _rf2_find_run_dir(rid:str):
    for root in _rf2_roots():
        for cand in (root/rid, root/"out"/rid):
            if cand.is_dir(): return cand
    return None

def _rf2_pick(run_dir:_P2, vname:str):
    cands=_VSP_RF2_ALLOWED.get(vname)
    if not cands: return None
    rd=run_dir.resolve()
    for rel in cands:
        fp=(run_dir/rel).resolve()
        try:
            if not str(fp).startswith(str(rd)+_os2.sep): 
                continue
            if fp.is_file(): return fp
        except Exception:
            continue
    return None

def _rf2_url(rid:str, vname:str)->str:
    return f"/api/vsp/run_file2?rid={_q2(rid)}&name={_q2(vname)}"

try:
    _app2 = app  # noqa: F821
except Exception:
    _app2 = None

if _app2 is not None and getattr(_app2, "route", None) is not None:
    @_app2.get("/api/vsp/run_file2")
    def _api_vsp_run_file2():
        rid = (_rq2.args.get("rid","") if _rq2 else "").strip()
        name = (_rq2.args.get("name","") if _rq2 else "").strip()
        # allow alias param
        if not name and _rq2:
            name = (_rq2.args.get("path","") or _rq2.args.get("n","") or "").strip()

        if not _rf2_safe_rid(rid):
            return _R2(_json2.dumps({"ok":False,"err":"bad rid"}), status=400, mimetype="application/json")
        if name not in _VSP_RF2_ALLOWED:
            # VSP_P1_ALLOW_SHA256SUMS_NOT_ALLOWED_V1: allow reports/SHA256SUMS.txt (commercial audit)
            try:
                _rid = (_rq_compat.args.get('rid','') or _rq_compat.args.get('run_id','') or _rq_compat.args.get('run','') or '').strip()
                _rel = (_rq_compat.args.get('name','') or _rq_compat.args.get('path','') or _rq_compat.args.get('rel','') or '').strip().lstrip('/')
                if _rid and _rel == 'reports/SHA256SUMS.txt':
                    from pathlib import Path as _P
                    _fp = _P('/home/test/Data/SECURITY_BUNDLE/out') / _rid / 'reports' / 'SHA256SUMS.txt'
                    if _fp.exists():
                        return _sf_compat(str(_fp), as_attachment=True)
            except Exception:
                pass
            return _R2(_json2.dumps({"ok":False,"err":"not allowed"}), status=404, mimetype="application/json")

        run_dir = _rf2_find_run_dir(rid)
        if not run_dir:
            return _R2(_json2.dumps({"ok":False,"err":"run not found"}), status=404, mimetype="application/json")

        fp = _rf2_pick(run_dir, name)
        if not fp:
            return _R2(_json2.dumps({"ok":False,"err":"file not found"}), status=404, mimetype="application/json")

        ctype,_ = _mt2.guess_type(str(fp))
        ctype = ctype or ("text/html" if str(fp).endswith(".html") else "application/octet-stream")
        as_attach = not (str(fp).endswith(".html") or str(fp).endswith(".json"))
        return _sf2(fp, mimetype=ctype, as_attachment=as_attach, download_name=fp.name)

    @_app2.after_request
    def _rf2_after(resp):
        try:
            if not _rq2 or _rq2.path != "/api/vsp/runs":
                return resp
            if "application/json" not in (resp.headers.get("Content-Type","") or ""):
                return resp
            data = resp.get_json(silent=True)
            if not isinstance(data, dict):
                return resp
            items = data.get("items") or []
            if not isinstance(items, list):
                return resp

            for it in items:
                if not isinstance(it, dict): 
                    continue
                rid = (it.get("run_id") or it.get("rid") or "").strip()
                if not _rf2_safe_rid(rid):
                    continue
                has = it.get("has")
                if not isinstance(has, dict):
                    has = {}
                    it["has"] = has

                rd = _rf2_find_run_dir(rid)
                if not rd:
                    continue

                def mark(vname, flag, keypath):
                    fp = _rf2_pick(rd, vname)
                    if fp:
                        has[flag] = True
                        has[keypath] = _rf2_url(rid, vname)

                # always prefer run_file2 urls
                mark("reports/index.html","html","html_path")
                mark("reports/findings_unified.json","json","json_path")
                mark("reports/findings_unified.csv","csv","csv_path")
                mark("reports/findings_unified.sarif","sarif","sarif_path")
                mark("reports/run_gate_summary.json","summary","summary_path")

                # rewrite any old run_file url -> run_file2
                for k in ("html_path","json_path","csv_path","sarif_path","summary_path"):
                    v = has.get(k)
                    if isinstance(v,str) and v.startswith("/api/vsp/run_file?"):
                        has[k] = v.replace("/api/vsp/run_file?","/api/vsp/run_file2?",1)
            # VSP_FORCE_RUNFILE2_PATHS_P0_V2: normalize path fields and fill missing *_path
            for it in items:
                if not isinstance(it, dict):
                    continue
                has = it.get("has") or {}
                if not isinstance(has, dict):
                    continue
                rid = (it.get("run_id") or it.get("rid") or "").strip()
                if not rid:
                    continue

                # rewrite run_file -> run_file2
                for k in ("html_path","json_path","csv_path","sarif_path","summary_path"):
                    v = has.get(k)
                    if isinstance(v, str) and v.startswith("/api/vsp/run_file?"):
                        has[k] = v.replace("/api/vsp/run_file?","/api/vsp/run_file2?",1)

                # fill missing paths if boolean says true
                if has.get("json") is True and not has.get("json_path"):
                    has["json_path"] = _rf2_url(rid, "reports/findings_unified.json")
                if has.get("summary") is True and not has.get("summary_path"):
                    has["summary_path"] = _rf2_url(rid, "reports/run_gate_summary.json")
                if has.get("html") is True and not has.get("html_path"):
                    has["html_path"] = _rf2_url(rid, "reports/index.html")
                if has.get("csv") is True and not has.get("csv_path"):
                    has["csv_path"] = _rf2_url(rid, "reports/findings_unified.csv")
                if has.get("sarif") is True and not has.get("sarif_path"):
                    has["sarif_path"] = _rf2_url(rid, "reports/findings_unified.sarif")

                it["has"] = has

            # VSP_FORCE_RUNFILE2_PATHS_P0_V3: FINAL normalize (override any earlier after_request)
            for it in items:
                if not isinstance(it, dict):
                    continue
                rid = (it.get("run_id") or it.get("rid") or "").strip()
                if not rid:
                    continue
                has = it.get("has") or {}
                if not isinstance(has, dict):
                    continue

                # rewrite any old run_file url -> run_file2
                for k in ("html_path","json_path","csv_path","sarif_path","summary_path"):
                    v = has.get(k)
                    if isinstance(v, str) and v.startswith("/api/vsp/run_file?"):
                        has[k] = v.replace("/api/vsp/run_file?","/api/vsp/run_file2?",1)

                # fill missing *_path if boolean true
                if has.get("json") is True and not has.get("json_path"):
                    has["json_path"] = _rf2_url(rid, "reports/findings_unified.json")
                if has.get("summary") is True and not has.get("summary_path"):
                    has["summary_path"] = _rf2_url(rid, "reports/run_gate_summary.json")
                if has.get("html") is True and not has.get("html_path"):
                    has["html_path"] = _rf2_url(rid, "reports/index.html")

                it["has"] = has


            body = _json2.dumps(data, ensure_ascii=False)
            resp.set_data(body)
            resp.headers["Content-Length"] = str(len(body.encode("utf-8")))
            return resp
        except Exception:
            return resp
# =========================
# END VSP_RUN_FILE2_SAFE_ENDPOINT_P0_V1
# =========================

# VSP_FORCE_RUNFILE2_PATHS_P0_V2

# VSP_FORCE_RUNFILE2_PATHS_P0_V3

# =========================
# VSP_REWRITE_RUN_FILE_TO_RUN_FILE2_P0_V1
# Force rewrite any /api/vsp/run_file? -> /api/vsp/run_file2? inside /api/vsp/runs JSON response.
# =========================
try:
    from flask import request as _rq_last
except Exception:
    _rq_last = None  # type: ignore

try:
    _app_last = app  # noqa: F821
except Exception:
    _app_last = None

if _app_last is not None and getattr(_app_last, "after_request", None) is not None:
    @_app_last.after_request
    def _vsp_after_rewrite_runfile2(resp):
        try:
            if not _rq_last or _rq_last.path != "/api/vsp/runs":
                return resp
            ct = (resp.headers.get("Content-Type","") or "")
            if "application/json" not in ct:
                return resp
            body = resp.get_data(as_text=True) or ""
            if "/api/vsp/run_file?" not in body:
                return resp
            body2 = body.replace("/api/vsp/run_file?","/api/vsp/run_file2?")
            resp.set_data(body2)
            resp.headers["Content-Length"] = str(len(body2.encode("utf-8")))
            return resp
        except Exception:
            return resp
# =========================
# END VSP_REWRITE_RUN_FILE_TO_RUN_FILE2_P0_V1
# =========================

# =========================
# VSP_RUN_FILE_COMPAT_TO_RUN_FILE2_P0_V1
# Make legacy /api/vsp/run_file work by serving via run_file2 whitelist logic.
# This avoids 400 from old handler and makes UI clickable immediately.
# =========================
try:
    from flask import request as _rq_compat, send_file as _sf_compat, Response as _R_compat
except Exception:
    _rq_compat = None  # type: ignore

try:
    _app_compat = app  # noqa: F821
except Exception:
    _app_compat = None

if _app_compat is not None and getattr(_app_compat, "before_request", None) is not None:
    @_app_compat.before_request
    def _vsp_compat_run_file_to_run_file2():
        try:
            if not _rq_compat:
                return None
            if _rq_compat.path != "/api/vsp/run_file":
                return None

            rid = (_rq_compat.args.get("rid","") or "").strip()
            name = (_rq_compat.args.get("name","") or _rq_compat.args.get("path","") or _rq_compat.args.get("n","") or "").strip()

            # Use run_file2 validators if present
            if " _rf2_safe_rid" and callable(globals().get("_rf2_safe_rid")):
                if not globals()["_rf2_safe_rid"](rid):
                    return _R_compat('{"ok":false,"err":"bad rid"}', status=400, mimetype="application/json")
            else:
                # fallback
                import re as _re
                if not rid or not _re.fullmatch(r"[A-Za-z0-9_.:-]{6,160}", rid):
                    return _R_compat('{"ok":false,"err":"bad rid"}', status=400, mimetype="application/json")

            allowed = globals().get("_VSP_RF2_ALLOWED") or globals().get("_VSP_RUNFILE_ALLOWED") or {}
            if name not in allowed:
                # VSP_P1_ALLOW_SHA256SUMS_NOT_ALLOWED_V1: allow reports/SHA256SUMS.txt (commercial audit)
                try:
                    _rid = (_rq_compat.args.get('rid','') or _rq_compat.args.get('run_id','') or _rq_compat.args.get('run','') or '').strip()
                    _rel = (_rq_compat.args.get('name','') or _rq_compat.args.get('path','') or _rq_compat.args.get('rel','') or '').strip().lstrip('/')
                    if _rid and _rel == 'reports/SHA256SUMS.txt':
                        from pathlib import Path as _P
                        _fp = _P('/home/test/Data/SECURITY_BUNDLE/out') / _rid / 'reports' / 'SHA256SUMS.txt'
                        if _fp.exists():
                            return _sf_compat(str(_fp), as_attachment=True)
                except Exception:
                    pass
                return _R_compat('{"ok":false,"err":"not allowed"}', status=404, mimetype="application/json")

            find_dir = globals().get("_rf2_find_run_dir") or globals().get("_vsp__find_run_dir")
            pick_file = globals().get("_rf2_pick") or globals().get("_vsp__pick_file")
            if not callable(find_dir) or not callable(pick_file):
                return _R_compat('{"ok":false,"err":"compat helpers missing"}', status=500, mimetype="application/json")

            run_dir = find_dir(rid)
            if not run_dir:
                return _R_compat('{"ok":false,"err":"run not found"}', status=404, mimetype="application/json")

            fp = pick_file(run_dir, name)
            if not fp:
                return _R_compat('{"ok":false,"err":"file not found"}', status=404, mimetype="application/json")

            import mimetypes as _mt
            ctype,_ = _mt.guess_type(str(fp))
            ctype = ctype or ("text/html" if str(fp).endswith(".html") else "application/octet-stream")
            as_attach = not (str(fp).endswith(".html") or str(fp).endswith(".json"))
            return _sf_compat(fp, mimetype=ctype, as_attachment=as_attach, download_name=fp.name)
        except Exception:
            # let original handler run if something unexpected happens
            return None
# =========================
# END VSP_RUN_FILE_COMPAT_TO_RUN_FILE2_P0_V1
# =========================



# VSP_RUN_FILE_LEGACY_COMPAT_MW_P0_V1
# Accept legacy /api/vsp/run_file?run_id=...&path=... by rewriting to rid/name at WSGI layer.
try:
    from urllib.parse import parse_qs, urlencode
except Exception:
    parse_qs = None
    urlencode = None

class _VspRunFileLegacyCompatMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        try:
            path = environ.get("PATH_INFO", "") or ""
            if path == "/api/vsp/run_file" and parse_qs and urlencode:
                qs = environ.get("QUERY_STRING", "") or ""
                q = parse_qs(qs, keep_blank_values=True)
                # If legacy keys exist but new keys missing => map
                if (("run_id" in q) or ("path" in q)) and (("rid" not in q) and ("name" not in q)):
                    if "run_id" in q:
                        q["rid"] = q.get("run_id")
                    if "path" in q:
                        q["name"] = q.get("path")
                    # Keep all keys (including run_id/path) to be safe
                    pairs = []
                    for k, vs in q.items():
                        for v in vs:
                            pairs.append((k, v))
                    environ["QUERY_STRING"] = urlencode(pairs, doseq=True)
        except Exception:
            pass
        return self.app(environ, start_response)

# VSP_P1_LEGACYCOMPAT_SAFE_WRAP_V10
try:
    # Ensure application is a Flask app if possible (restore from global 'app' if it exists)
    _flask = application if hasattr(application, 'after_request') else globals().get('app', None)
    if _flask is not None and hasattr(_flask, 'after_request'):
        application = _flask
        application.wsgi_app = _VspRunFileLegacyCompatMW(application.wsgi_app)
except Exception:
    # If we can't safely wrap, skip instead of crashing import/boot.
    pass



# VSP_RUNS_NO_FS_LEAK_MW_P0_V1
# Rewrite /api/vsp/runs payload: never expose filesystem paths; provide /api/vsp/run_file URLs instead.
import json as _json
from urllib.parse import urlencode as _urlencode

class _VspRunsNoFsLeakMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = environ.get("PATH_INFO","") or ""
        if path != "/api/vsp/runs":
            return self.app(environ, start_response)

        captured = {"status": None, "headers": None}
        body_chunks = []

        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers)
            # delay sending headers until we possibly rewrite body
            return body_chunks.append

        it = self.app(environ, _sr)

        try:
            for c in it:
                if c:
                    body_chunks.append(c)
        finally:
            try:
                close = getattr(it, "close", None)
                if callable(close): close()
            except Exception:
                pass

        raw = b"".join([c if isinstance(c,(bytes,bytearray)) else str(c).encode("utf-8","replace") for c in body_chunks])
        try:
            obj = _json.loads(raw.decode("utf-8","replace"))
        except Exception:
            # fall back: send original
            headers = captured["headers"] or []
            start_response(captured["status"] or "200 OK", headers)
            return [raw]

        def run_file_url(rid, name):
            qs = _urlencode({"rid": rid, "name": name})
            return "/api/vsp/run_file?" + qs

        items = obj.get("items") if isinstance(obj, dict) else None
        if isinstance(items, list):
            for it in items:
                if not isinstance(it, dict): 
                    continue
                rid = it.get("run_id") or it.get("rid")
                has = it.get("has")
                if not rid or not isinstance(has, dict):
                    continue
                # normalize paths to URLs
                # html
                if has.get("html") is True:
                    has["html_path"] = run_file_url(rid, "reports/index.html")
                elif "html_path" in has and isinstance(has["html_path"], str) and has["html_path"].startswith("/home/"):
                    # if backend leaked FS path, convert to URL and set html true
                    has["html"] = True
                    has["html_path"] = run_file_url(rid, "reports/index.html")
                # json (standardize to reports/findings_unified.json)
                if "json_path" in has:
                    has["json_path"] = run_file_url(rid, "reports/findings_unified.json")
                if has.get("json") is True:
                    has["json_path"] = run_file_url(rid, "reports/findings_unified.json")
                # summary
                if "summary_path" in has:
                    has["summary_path"] = run_file_url(rid, "reports/run_gate_summary.json")
                if has.get("summary") is True:
                    has["summary_path"] = run_file_url(rid, "reports/run_gate_summary.json")

                # Optional: offer txt path in reports (more likely whitelisted)
                has["txt_path"] = run_file_url(rid, "reports/SUMMARY.txt")
                has["sha_path"] = run_file_url(rid, "reports/SHA256SUMS.txt")
        out = _json.dumps(obj, ensure_ascii=False).encode("utf-8")
        headers = [(k,v) for (k,v) in (captured["headers"] or []) if k.lower() != "content-length"]
        headers.append(("Content-Length", str(len(out))))
        start_response(captured["status"] or "200 OK", headers)
        return [out]

application.wsgi_app = _VspRunsNoFsLeakMW(application.wsgi_app)



# VSP_RUN_FILE_DIRECTSERVE_REPORTS_SUMMARY_P0_V1
# Direct-serve ONLY reports/SUMMARY.txt to avoid allowlist/validator blocking.
# This stays commercial-safe: fixed path, fixed filename, strict RID folder under SECURITY_BUNDLE/out or out_ci.
from urllib.parse import parse_qs as _parse_qs
from pathlib import Path as _Path

class _VspRunFileDirectServeSummaryMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
        self.root = _Path("/home/test/Data/SECURITY_BUNDLE")
    def _resolve_run_dir(self, rid: str):
        rid = (rid or "").strip()
        cands = []
        if rid:
            cands.append(rid)
            if "RUN_" in rid:
                cands.append(rid[rid.find("RUN_"):])
        for cand in cands:
            for base in ("out", "out_ci"):
                d = self.root / base / cand
                if d.is_dir():
                    return d
        return None

    def __call__(self, environ, start_response):
        try:
            if (environ.get("PATH_INFO","") or "") == "/api/vsp/run_file":
                qs = environ.get("QUERY_STRING","") or ""
                q = _parse_qs(qs, keep_blank_values=True)
                rid = (q.get("rid") or q.get("run_id") or q.get("runId") or [""])[0]
                name = (q.get("name") or q.get("path") or q.get("file") or [""])[0]
                name = (name or "").strip()

                # normalize summary variants
                if name in ("reports/SUMMARY.txt", "reports/SHA256SUMS.txt", "reports/summary.txt", "SUMMARY.txt", "SHA256SUMS.txt", "summary.txt"):
                    run_dir = self._resolve_run_dir(rid)
                    if run_dir:
                        fp = run_dir / "reports" / "SUMMARY.txt", "SHA256SUMS.txt"
                        if fp.is_file() and fp.stat().st_size > 0:
                            data = fp.read_bytes()
                            headers = [
                                ("Content-Type", "text/plain; charset=utf-8"),
                                ("Content-Length", str(len(data))),
                                ("Cache-Control", "no-store"),
                            ]
                            start_response("200 OK", headers)
                            return [data]
        except Exception:
            pass

        return self.app(environ, start_response)

application.wsgi_app = _VspRunFileDirectServeSummaryMW(application.wsgi_app)




# === VSP_API_REPORTS_LATEST_BIND_APP_P0_V3 ===
from pathlib import Path
from urllib.parse import quote

def _vsp__find_latest_run_with_file__p0v3(relpath: str) -> str:
    base = Path("/home/test/Data/SECURITY_BUNDLE/out")
    if not base.exists():
        return ""
    runs = sorted(base.glob("RUN_*"), key=lambda x: x.stat().st_mtime, reverse=True)
    for rd in runs[:300]:
        try:
            if (rd / relpath).is_file():
                return rd.name
        except Exception:
            continue
    return ""

def vsp_api_reports_latest__p0v3(name):
    rel = name if name.startswith("reports/") else ("reports/" + name)
    rid = _vsp__find_latest_run_with_file__p0v3(rel)
    if not rid:
        return ("Not Found", 404)
    url = "/api/vsp/run_file?rid=" + quote(rid) + "&name=" + quote(rel)
    return ("", 302, {"Location": url})

def _vsp__bind_reports_latest__p0v3():
    # bind to Flask app (usually global "app"); do NOT use "application" wrapper
    flask_app = globals().get("app")
    if not (hasattr(flask_app, "add_url_rule") and hasattr(flask_app, "url_map")):
        # fallback scan
        flask_app = None
        for v in globals().values():
            if hasattr(v, "add_url_rule") and hasattr(v, "url_map") and hasattr(v, "route"):
                flask_app = v
                break
    if not flask_app:
        print("[WARN] cannot locate Flask app to bind /api/reports")
        return False
    try:
        flask_app.add_url_rule(
            "/api/reports/<path:name>",
            endpoint="vsp_api_reports_latest",
            view_func=vsp_api_reports_latest__p0v3,
            methods=["GET","HEAD"]
        )
    except Exception:
        # already bound / endpoint exists
        pass
    return True

_vsp__bind_reports_latest__p0v3()


# VSP_P1_ALLOW_SHA256SUMS_GLOBAL_V1

# VSP_P1_ALLOW_SHA256SUMS_NOT_ALLOWED_V1

# VSP_P1_GW_BYPASS_SHA256SUMS_V1

# VSP_P1_GW_RUNFILE_ANCHOR_ALLOW_SHA_V3

# VSP_P1_FIX_SHA256SUMS_COMPAT_V2

# VSP_P1_ALLOW_SHA256SUMS_V5

# VSP_P1_FIX_RUNS_AND_SHA256SUMS_V1


# === VSP_P1_PROXY_RUN_FILE_SUMMARY_TO_RUN_FILE2_V1 ===
def _vsp_proxy_run_file_summary_to_run_file2_wsgi(app):
    """
    If legacy /api/vsp/run_file can't serve reports/SUMMARY.txt (or SHA256SUMS),
    transparently route it to /api/vsp/run_file2 (same rid/name contract).
    """
    from urllib.parse import parse_qs, urlencode

    def wsgi(environ, start_response):
        try:
            path = (environ.get("PATH_INFO","") or "")
            method = (environ.get("REQUEST_METHOD","GET") or "GET").upper()
            if path == "/api/vsp/run_file" and method in ("GET","HEAD"):
                qs = parse_qs(environ.get("QUERY_STRING","") or "")
                name = (qs.get("name") or [""])[0] or ""
                # only intercept the problematic ones (minimal risk)
                if name in ("reports/SUMMARY.txt","reports/SHA256SUMS.txt"):
                    environ = dict(environ)
                    environ["PATH_INFO"] = "/api/vsp/run_file2"
                    # keep same query
                    environ["QUERY_STRING"] = urlencode([(k, v2) for k, vv in qs.items() for v2 in vv])
        except Exception:
            pass
        return app(environ, start_response)
    return wsgi
# === /VSP_P1_PROXY_RUN_FILE_SUMMARY_TO_RUN_FILE2_V1 ===


# === VSP_P1_PROXY_RUN_FILE_SUMMARY_TO_RUN_FILE2_V1_APPLY ===
try:
    if "application" in globals():
        application.wsgi_app = _vsp_proxy_run_file_summary_to_run_file2_wsgi(application.wsgi_app)
    elif "app" in globals():
        application.wsgi_app = _vsp_proxy_run_file_summary_to_run_file2_wsgi(application.wsgi_app)
except Exception:
    pass
# === /VSP_P1_PROXY_RUN_FILE_SUMMARY_TO_RUN_FILE2_V1_APPLY ===

# VSP_P1_PROXY_RUN_FILE_SUMMARY_TO_RUN_FILE2_V1

# VSP_P1_PROXY_RUN_FILE_SUMMARY_TO_RUN_FILE2_V2


# === VSP_P1_DIRECT_SERVE_SUMMARY_SHA_V1 ===
def _vsp_direct_serve_summary_sha_wsgi(app):
    """
    Commercial-safe: ensure legacy /api/vsp/run_file can serve:
      - reports/SUMMARY.txt
      - reports/SHA256SUMS.txt
    for both GET and HEAD, by reading files directly from OUT_ROOT.
    """
    import os
    from pathlib import Path
    from urllib.parse import parse_qs

    OUT_ROOT = Path("/home/test/Data/SECURITY_BUNDLE/out")

    def _send(start_response, code, headers, body=b""):
        start_response(code, headers)
        return [body] if body else [b""]

    def wsgi(environ, start_response):
        try:
            path = (environ.get("PATH_INFO","") or "")
            method = (environ.get("REQUEST_METHOD","GET") or "GET").upper()
            if path == "/api/vsp/run_file" and method in ("GET","HEAD"):
                qs = parse_qs(environ.get("QUERY_STRING","") or "")
                rid = (qs.get("rid") or [""])[0].strip()
                name = (qs.get("name") or [""])[0].strip()
                if rid and name in ("reports/SUMMARY.txt","reports/SHA256SUMS.txt"):
                    fp = (OUT_ROOT / rid / name).resolve()
                    rd = (OUT_ROOT / rid).resolve()
                    if str(fp).find(str(rd)) != 0:
                        return _send(start_response, "400 BAD REQUEST", [
                            ("Content-Type","application/json; charset=utf-8"),
                            ("X-VSP-DirectServe", MARK),
                        ], b'{"ok":false,"err":"path traversal"}')
                    if fp.exists() and fp.is_file():
                        try:
                            st = fp.stat()
                            clen = str(int(st.st_size))
                        except Exception:
                            clen = None
                        headers = [
                            ("Content-Type","text/plain; charset=utf-8"),
                            ("Content-Disposition", f'attachment; filename={os.path.basename(name)}'),
                            ("Cache-Control","no-cache"),
                            ("X-VSP-DirectServe", MARK),
                        ]
                        if clen:
                            headers.append(("Content-Length", clen))
                        if method == "HEAD":
                            return _send(start_response, "200 OK", headers, b"")
                        body = fp.read_bytes()
                        return _send(start_response, "200 OK", headers, body)
        except Exception:
            pass
        return app(environ, start_response)

    return wsgi
# === /VSP_P1_DIRECT_SERVE_SUMMARY_SHA_V1 ===


# === VSP_P1_DIRECT_SERVE_SUMMARY_SHA_V1_APPLY ===
try:
    if "application" in globals():
        application.wsgi_app = _vsp_direct_serve_summary_sha_wsgi(application.wsgi_app)
    elif "app" in globals():
        application.wsgi_app = _vsp_direct_serve_summary_sha_wsgi(application.wsgi_app)
except Exception:
    pass
# === /VSP_P1_DIRECT_SERVE_SUMMARY_SHA_V1_APPLY ===

# VSP_P1_DIRECT_SERVE_SUMMARY_SHA_V1

# ---- VSP_P1_HTML_commercial_guard_P1_V7B (commercial polish: stop /vsp5 poll spam) ----
try:
    import re as _re
    from flask import request as _request
except Exception:
    _re = None
    _request = None

_VSP_P1_commercial_guard_HTML_V7B = r"""
<!-- VSP_COMMERCIAL_GLOBAL_GUARD_V1 -->
<script id="VSP_COMMERCIAL_GLOBAL_GUARD_V1">
(()=> {
  if (window.__vsp_commercial_global_guard_v1) return;
  window.__vsp_commercial_global_guard_v1 = true;

  const HOLD_MS = 15000;
  let holdUntil = Date.now() + 2500; // grace on first load/restart

  // drop only noisy poll logs (do NOT hide real errors)
  const DROP = [
    /\[VSP\]\s*poll down; backoff/i,
    /poll down; backoff/i,
    /runs fetch guard\/backoff enabled/i,
    /VSP_ROUTE_GUARD_RUNS_ONLY_/i
  ];
  function _dropArgs(args){
    try{
      if (!args || !args.length) return false;
      const a0 = (typeof args[0] === "string") ? args[0] : "";
      return DROP.some(rx => rx.test(a0));
    }catch(_){ return false; }
  }
  if (!window.__vsp_console_filtered_commercial_v1){
    window.__vsp_console_filtered_commercial_v1 = true;
    for (const k of ["log","info","warn","error"]){
      const orig = console[k].bind(console);
      console[k] = (...args)=>{ if (_dropArgs(args)) return; return orig(...args); };
    }
  }

  function _isApiVsp(u){ return !!u && u.includes("/api/vsp/"); }
  function _isPlaceholder(u){ return !!u && (u === "<URL>" || u.includes("<URL>")); }

  function _cacheKey(u){
    try{
      const uu = new URL(u, location.origin);
      return "vsp_api_cache_v7b::" + uu.pathname + uu.search;
    }catch(_){
      return "vsp_api_cache_v7b::" + String(u);
    }
  }
  function _load(u){
    try{
      const raw = localStorage.getItem(_cacheKey(u));
      return raw ? JSON.parse(raw) : null;
    }catch(_){ return null; }
  }
  function _save(u,obj){
    try{ localStorage.setItem(_cacheKey(u), JSON.stringify(obj)); }catch(_){}
  }
  function _resp(obj,hdr){
    const h = new Headers({"Content-Type":"application/json; charset=utf-8"});
    try{ if (hdr) for (const [k,v] of Object.entries(hdr)) h.set(k, String(v)); }catch(_){}
    return new Response(JSON.stringify(obj), {status:200, headers:h});
  }

  // fetch wrapper
  if (window.fetch && !window.__vsp_fetch_wrapped_v7b){
    window.__vsp_fetch_wrapped_v7b = true;
    const orig = window.fetch.bind(window);
    window.fetch = async (input, init)=>{
      let u="";
      try{ u = (typeof input==="string") ? input : (input && input.url) ? input.url : ""; }catch(_){}
      if (_isPlaceholder(u)){
        return _resp({ok:false, note:"intercepted <URL>", marker:"V7B"}, {"X-VSP-Intercept":"1"});
      }
      if (_isApiVsp(u)){
        const now = Date.now();
        if (now < holdUntil){
          const cached = _load(u) || {ok:false, note:"degraded-cache-empty"};
          return _resp(cached, {"X-VSP-Hold":"1","X-VSP-Cache":"1"});
        }
        try{
          const r = await orig(input, init);
          if (r && r.ok){
            try{
              const j = await r.clone().json();
              if (j && typeof j==="object") _save(u, j);
            }catch(_){}
            return r;
          }
          holdUntil = Date.now() + HOLD_MS;
          const cached = _load(u) || {ok:false, note:"degraded-cache-empty"};
          return _resp(cached, {"X-VSP-Hold":"1","X-VSP-Cache":"1","X-VSP-Non200": r ? r.status : "NA"});
        }catch(_e){
          holdUntil = Date.now() + HOLD_MS;
          const cached = _load(u) || {ok:false, note:"degraded-cache-empty"};
          return _resp(cached, {"X-VSP-Hold":"1","X-VSP-Cache":"1","X-VSP-NetFail":"1"});
        }
      }
      return orig(input, init);
    };
  }

  // XHR wrapper (stop DevTools spam during restart)
  if (window.XMLHttpRequest && !window.__vsp_xhr_wrapped_v7b){
    window.__vsp_xhr_wrapped_v7b = true;
    const _open = XMLHttpRequest.prototype.open;
    const _send = XMLHttpRequest.prototype.send;

    XMLHttpRequest.prototype.open = function(method, url){
      try{ this.__vsp_url = String(url || ""); }catch(_){}
      return _open.apply(this, arguments);
    };

    XMLHttpRequest.prototype.send = function(body){
      const u = (this && this.__vsp_url) ? String(this.__vsp_url) : "";
      if (_isPlaceholder(u) || _isApiVsp(u)){
        const now = Date.now();
        if (_isPlaceholder(u) || (now < holdUntil && _isApiVsp(u))){
          const cached = _isPlaceholder(u) ? {ok:false, note:"intercepted <URL>", marker:"V7B"} : (_load(u) || {ok:false, note:"degraded-cache-empty"});
          const txt = JSON.stringify(cached);
          try{
            Object.defineProperty(this, "status", { get: ()=>200, configurable:true });
            Object.defineProperty(this, "responseText", { get: ()=>txt, configurable:true });
            Object.defineProperty(this, "response", { get: ()=>txt, configurable:true });
          }catch(_){}
          const self=this;
          setTimeout(()=>{
            try{ if (typeof self.onreadystatechange==="function") self.onreadystatechange(); }catch(_){}
            try{ if (typeof self.onload==="function") self.onload(); }catch(_){}
            try{ self.dispatchEvent && self.dispatchEvent(new Event("load")); }catch(_){}
          },0);
          return; // NO NETWORK => no DevTools spam
        }
      }
      return _send.apply(this, arguments);
    };
  }
})();
</script>
"""

def _vsp_p1_inject_head_v7b(html: str) -> str:
    if _re is None:
        return html
    m = _re.search(r"<head[^>]*>", html, flags=_re.I)
    if not m:
        return html
    ins = m.end()
    return html[:ins] + "\n" + _VSP_P1_commercial_guard_HTML_V7B + "\n" + html[ins:]

try:
    _app = application  # must exist in this gateway
    @_app.after_request
    def _vsp_p1_html_commercial_guard_v7b(resp):
        try:
            if _request is None or _re is None:
                return resp
            if _request.path not in ("/vsp5", "/vsp5/"):
                return resp
            ct = (resp.headers.get("Content-Type","") or "")
            if "text/html" not in ct:
                return resp
            html = resp.get_data(as_text=True)
            if "VSP_COMMERCIAL_GLOBAL_GUARD_V1" in html:
                return resp
            html2 = _vsp_p1_inject_head_v7b(html)
            if html2 != html:
                resp.set_data(html2)
                resp.headers["Content-Length"] = str(len(resp.get_data()))
            return resp
        except Exception:
            return resp
except Exception:
    pass
# ---- end VSP_P1_HTML_commercial_guard_P1_V7B ----

# VSP_P1_HTML_commercial_guard_P1_V7C_MW
# ---- VSP_P1_HTML_commercial_guard_P1_V7C_MW (wrap WSGI application; always inject on /vsp5) ----
try:
    import re as _re
except Exception:
    _re = None

_VSP_P1_commercial_guard_HTML_V7C = r"""
<!-- VSP_P1_commercial_guard_GLOBAL_V7C -->
<script id="VSP_P1_commercial_guard_GLOBAL_V7C">
(()=> {
  if (window.__vsp_commercial_guard_global_v7c) return;
  window.__vsp_commercial_guard_global_v7c = true;

  

  // VSP_P1_LOAD_FILLREAL_FROM_commercial_guard_P1_V2
  try{
    if (!window.__vsp_fillreal_loader_from_commercial_guard_p1_v2){
      window.__vsp_fillreal_loader_from_commercial_guard_p1_v2 = true;
      var _s=document.createElement("script");
      _s.src="/static/js/vsp_fill_real_data_5tabs_p1_v1.js";
      _s.defer=true;
      (document.head||document.documentElement).appendChild(_s);
    }
  }catch(_){}
const HOLD_MS = 15000;
  let holdUntil = Date.now() + 2500;

  const DROP = [
    /\[VSP\]\s*poll down; backoff/i,
    /poll down; backoff/i,
    /runs fetch guard\/backoff enabled/i,
    /VSP_ROUTE_GUARD_RUNS_ONLY_/i
  ];
  function _dropArgs(args){
    try{
      if (!args || !args.length) return false;
      const a0 = (typeof args[0] === "string") ? args[0] : "";
      return DROP.some(rx => rx.test(a0));
    }catch(_){ return false; }
  }
  if (!window.__vsp_console_filtered_v7c){
    window.__vsp_console_filtered_v7c = true;
    for (const k of ["log","info","warn","error"]){
      const orig = console[k].bind(console);
      console[k] = (...args)=>{ if (_dropArgs(args)) return; return orig(...args); };
    }
  }

  function _isApiVsp(u){ return !!u && u.includes("/api/vsp/"); }
  function _isPlaceholder(u){ return !!u && (u === "<URL>" || u.includes("<URL>")); }

  function _cacheKey(u){
    try{
      const uu = new URL(u, location.origin);
      return "vsp_api_cache_v7c::" + uu.pathname + uu.search;
    }catch(_){
      return "vsp_api_cache_v7c::" + String(u);
    }
  }
  function _load(u){ try{ const raw=localStorage.getItem(_cacheKey(u)); return raw?JSON.parse(raw):null; }catch(_){ return null; } }
  function _save(u,obj){ try{ localStorage.setItem(_cacheKey(u), JSON.stringify(obj)); }catch(_){ } }
  function _resp(obj,hdr){
    const h = new Headers({"Content-Type":"application/json; charset=utf-8"});
    try{ if (hdr) for (const [k,v] of Object.entries(hdr)) h.set(k, String(v)); }catch(_){}
    return new Response(JSON.stringify(obj), {status:200, headers:h});
  }

  if (window.fetch && !window.__vsp_fetch_wrapped_v7c){
    window.__vsp_fetch_wrapped_v7c = true;
    const orig = window.fetch.bind(window);
    window.fetch = async (input, init)=>{
      let u="";
      try{ u = (typeof input==="string") ? input : (input && input.url) ? input.url : ""; }catch(_){}
      if (_isPlaceholder(u)) return _resp({ok:false, note:"intercepted <URL>", marker:"V7C"}, {"X-VSP-Intercept":"1"});
      if (_isApiVsp(u)){
        const now = Date.now();
        if (now < holdUntil){
          const cached = _load(u) || {ok:false, note:"degraded-cache-empty"};
          return _resp(cached, {"X-VSP-Hold":"1","X-VSP-Cache":"1"});
        }
        try{
          const r = await orig(input, init);
          if (r && r.ok){
            try{ const j = await r.clone().json(); if (j && typeof j==="object") _save(u,j); }catch(_){}
            return r;
          }
          holdUntil = Date.now() + HOLD_MS;
          const cached = _load(u) || {ok:false, note:"degraded-cache-empty"};
          return _resp(cached, {"X-VSP-Hold":"1","X-VSP-Cache":"1","X-VSP-Non200": r ? r.status : "NA"});
        }catch(_e){
          holdUntil = Date.now() + HOLD_MS;
          const cached = _load(u) || {ok:false, note:"degraded-cache-empty"};
          return _resp(cached, {"X-VSP-Hold":"1","X-VSP-Cache":"1","X-VSP-NetFail":"1"});
        }
      }
      return orig(input, init);
    };
  }

  if (window.XMLHttpRequest && !window.__vsp_xhr_wrapped_v7c){
    window.__vsp_xhr_wrapped_v7c = true;
    const _open = XMLHttpRequest.prototype.open;
    const _send = XMLHttpRequest.prototype.send;

    XMLHttpRequest.prototype.open = function(method, url){
      try{ this.__vsp_url = String(url || ""); }catch(_){}
      return _open.apply(this, arguments);
    };

    XMLHttpRequest.prototype.send = function(body){
      const u = (this && this.__vsp_url) ? String(this.__vsp_url) : "";
      if (_isPlaceholder(u) || _isApiVsp(u)){
        const now = Date.now();
        if (_isPlaceholder(u) || (now < holdUntil && _isApiVsp(u))){
          const cached = _isPlaceholder(u) ? {ok:false, note:"intercepted <URL>", marker:"V7C"} : (_load(u) || {ok:false, note:"degraded-cache-empty"});
          const txt = JSON.stringify(cached);
          try{
            Object.defineProperty(this, "status", { get: ()=>200, configurable:true });
            Object.defineProperty(this, "responseText", { get: ()=>txt, configurable:true });
            Object.defineProperty(this, "response", { get: ()=>txt, configurable:true });
          }catch(_){}
          const self=this;
          setTimeout(()=>{
            try{ if (typeof self.onreadystatechange==="function") self.onreadystatechange(); }catch(_){}
            try{ if (typeof self.onload==="function") self.onload(); }catch(_){}
            try{ self.dispatchEvent && self.dispatchEvent(new Event("load")); }catch(_){}
          },0);
          return;
        }
      }
      return _send.apply(this, arguments);
    };
  }
})();
</script>
"""

def _vsp_p1_inject_head_v7c(body_bytes: bytes) -> bytes:
    if _re is None:
        return body_bytes
    try:
        html = body_bytes.decode("utf-8", errors="replace")
    except Exception:
        return body_bytes
    if "VSP_P1_commercial_guard_GLOBAL_V7C" in html:
        return body_bytes
    m = _re.search(r"<head[^>]*>", html, flags=_re.I)
    if not m:
        return body_bytes
    ins = m.end()
    html2 = html[:ins] + "\n" + _VSP_P1_commercial_guard_HTML_V7C + "\n" + html[ins:]
    return html2.encode("utf-8", errors="replace")

class _VSP_HTML_Injector_V7C:
    __vsp_wrapped_v7c__ = True
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path not in ("/vsp5", "/vsp5/"):
            return self.app(environ, start_response)

        captured = {}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers or [])
            captured["exc_info"] = exc_info
            # delay calling real start_response until body possibly modified
            return None

        result = self.app(environ, _sr)
        try:
            body = b"".join(result) if result is not None else b""
        finally:
            try:
                if hasattr(result, "close"):
                    result.close()
            except Exception:
                pass

        status = captured.get("status", "200 OK")
        headers = captured.get("headers", [])

        # check content-type
        ct = ""
        for k, v in headers:
            if str(k).lower() == "content-type":
                ct = str(v)
                break

        if "text/html" in (ct or ""):
            body2 = _vsp_p1_inject_head_v7c(body)
            if body2 != body:
                body = body2
                # fix content-length
                new_headers = []
                for k, v in headers:
                    if str(k).lower() == "content-length":
                        continue
                    new_headers.append((k, v))
                new_headers.append(("Content-Length", str(len(body))))
                headers = new_headers

        start_response(status, headers, captured.get("exc_info"))
        return [body]

try:
    if not getattr(application, "__vsp_wrapped_v7c__", False):
        application.wsgi_app = _VSP_HTML_Injector_V7C(application.wsgi_app)
except Exception:
    pass
# ---- end VSP_P1_HTML_commercial_guard_P1_V7C_MW ----



# VSP_P1_ROOT_AND_DATASOURCE_ROUTES_V1
# P1: ensure Dashboard (/) and Data Source (/data_source) pages are reachable on UI gateway.
try:
    from flask import render_template
except Exception:
    render_template = None

try:
    app  # noqa
except Exception:
    app = None

if app is not None and render_template is not None:
    @app.get("/")
    def vsp_root_dashboard_p1():
        return render_template("vsp_dashboard_2025.html")

    @app.get("/data_source")
    def vsp_data_source_p1():
        return render_template("vsp_data_source_v1.html")


# VSP_P1_ROOT_AND_DATASOURCE_ROUTES_V2
# P1: ensure Dashboard (/) and Data Source (/data_source) reachable on UI gateway.
try:
    from flask import render_template
except Exception:
    render_template = None

_candidates = []
for _name in ("application", "app"):
    try:
        _obj = globals().get(_name, None)
        if _obj is not None:
            _candidates.append(_obj)
    except Exception:
        pass

def _p1_rt_dashboard():
    return render_template("vsp_dashboard_2025.html")

def _p1_rt_data_source():
    return render_template("vsp_data_source_v1.html")

if render_template is not None:
    for _a in _candidates:
        try:
            # only add if not already present
            _a.add_url_rule("/", endpoint="vsp_p1_root_dashboard_v2", view_func=_p1_rt_dashboard, methods=["GET"])
        except Exception:
            pass
        try:
            _a.add_url_rule("/data_source", endpoint="vsp_p1_data_source_v2", view_func=_p1_rt_data_source, methods=["GET"])
        except Exception:
            pass


# VSP_P1_SETTINGS_BOOT_INJECT_MW_V1
# P1: /settings page is served by custom HTML; inject boot script tag if missing.
try:
    from flask import request
except Exception:
    request = None

def _vsp_p1_inject_boot(resp):
    try:
        if request is None:
            return resp
        if not request.path.startswith("/settings"):
            return resp
        ct = (resp.headers.get("Content-Type","") or "").lower()
        if "text/html" not in ct:
            return resp

        data = resp.get_data(as_text=True)
        if "vsp_p1_page_boot_v1.js" in data:
            return resp

        tag = '<script src="/static/js/vsp_p1_page_boot_v1.js?v=VSP_P1_PAGE_BOOT_V1"></script>'
        if "</body>" in data.lower():
            # insert before </body> (case-insensitive)
            idx = data.lower().rfind("</body>")
            data = data[:idx] + "\n" + tag + "\n" + data[idx:]
        else:
            data = data + "\n" + tag + "\n"

        resp.set_data(data)
        # length may change
        try:
            resp.headers.pop("Content-Length", None)
        except Exception:
            pass
        return resp
    except Exception:
        return resp

for _name in ("application","app"):
    try:
        _a = globals().get(_name)
        if _a is not None:
            try:
                _a.after_request(_vsp_p1_inject_boot)
            except Exception:
                pass
    except Exception:
        pass


# VSP_P1_FORCE_ROOT_200_OVERRIDE_REDIRECT_V4
# Ensure '/' returns 200 HTML (dashboard) even if existing route redirects to /vsp4
try:
    from flask import render_template, redirect
except Exception:
    render_template = None
    redirect = None

def _vsp_p1_root_200_v4():
    # Prefer dashboard template if exists; fallback to redirect /vsp5
    if render_template is not None:
        try:
            return render_template("vsp_dashboard_2025.html")
        except Exception:
            pass
        try:
            return render_template("vsp_5tabs_enterprise_v2.html")
        except Exception:
            pass
    if redirect is not None:
        return redirect("/vsp5")
    return ("OK", 200)

for _name in ("application","app"):
    try:
        _a = globals().get(_name)
        if _a is None:
            continue
        # Override any existing endpoint mapped to '/'
        try:
            _over = 0
            for _r in list(_a.url_map.iter_rules()):
                if getattr(_r, "rule", None) == "/" and getattr(_r, "endpoint", "") != "static":
                    try:
                        _a.view_functions[_r.endpoint] = _vsp_p1_root_200_v4
                        _over += 1
                    except Exception:
                        pass
            if _over == 0:
                try:
                    _a.add_url_rule("/", endpoint="vsp_p1_root_200_v4", view_func=_vsp_p1_root_200_v4, methods=["GET"])
                except Exception:
                    pass
        except Exception:
            pass
    except Exception:
        pass


# === VSP_GATEWAY_INJECT_FILLREAL_ALLHTML_P1_V1 ===
try:
    _vsp_app = app  # Flask app name commonly "app"
except Exception:
    _vsp_app = None

if _vsp_app is not None:
    @_vsp_app.after_request
    def _vsp_p1_inject_fillreal_all_html(resp):
        try:
            ct = (resp.headers.get("Content-Type") or "").lower()
            if "text/html" not in ct:
                return resp
            # avoid streaming / passthrough
            if getattr(resp, "direct_passthrough", False):
                return resp

            b = resp.get_data()
            if not b:
                return resp
            html = b.decode("utf-8", errors="replace")

            # already injected?
            if "vsp_fill_real_data_5tabs_p1_v1.js" in html or "VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY" in html:
                return resp

            tag = (
                "\n<!-- VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY -->\n"
                "<script src='/static/js/vsp_fill_real_data_5tabs_p1_v1.js'></script>\n"
                "<!-- /VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY -->\n"
            )

            if "</body>" in html:
                html = html.replace("</body>", tag + "</body>")
            elif "</html>" in html:
                html = html.replace("</html>", tag + "</html>")
            else:
                html = html + tag

            resp.set_data(html.encode("utf-8"))
            # Content-Length must be recalculated
            try:
                resp.headers.pop("Content-Length", None)
            except Exception:
                pass
            return resp
        except Exception:
            return resp
# === /VSP_GATEWAY_INJECT_FILLREAL_ALLHTML_P1_V1 ===



# === VSP_GATEWAY_WRAP_APPLICATION_WITH_FILLREAL_P1_V3 ===
try:
    _vsp_inner = globals().get("application") or globals().get("app")
    if _vsp_inner is not None and not isinstance(_vsp_inner, _VspHtmlInjectMw):
        application.wsgi_app = _VspHtmlInjectMw(_vsp_inner)
except Exception:
    pass
# === /VSP_GATEWAY_WRAP_APPLICATION_WITH_FILLREAL_P1_V3 ===



# === VSP_GATEWAY_FORCE_FILLREAL_TAIL_P1_V4 ===
try:
    # FORCE LAST WRAP: must be after all other `application = ...` wrappers
    application.wsgi_app = _VspHtmlInjectMw(application.wsgi_app)
except Exception:
    pass
# === /VSP_GATEWAY_FORCE_FILLREAL_TAIL_P1_V4 ===




# === VSP_GATEWAY_FILLREAL_PROBE_HEADER_P1_V5 ===
import re as _re

class _VspFillRealProbeMWP1V5:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        captured = {"status": None, "headers": None, "exc": None}

        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            # return write callable
            def _write(_data): return None
            return _write

        app_iter = self.app(environ, _sr)

        try:
            chunks=[]
            for c in app_iter:
                if c:
                    chunks.append(c)
            body = b"".join(chunks)
        finally:
            try:
                close=getattr(app_iter,"close",None)
                if callable(close): close()
            except Exception:
                pass

        headers = captured["headers"] or []
        # always add probe header
        headers = [(k,v) for (k,v) in headers if str(k).lower() != "x-vsp-fillreal"]
        headers.append(("X-VSP-FILLREAL", "P1_V5"))

        # sniff headers
        ct = ""
        ce = ""
        for (k,v) in headers:
            lk = str(k).lower()
            if lk == "content-type": ct = str(v).lower()
            if lk == "content-encoding": ce = str(v).lower()

        # only inject into plain html (skip gzip/br)
        if "text/html" in ct and body and (not ce or ("gzip" not in ce and "br" not in ce)):
            try:
                html = body.decode("utf-8", errors="replace")
                if ("vsp_fill_real_data_5tabs_p1_v1.js" not in html) and ("VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY" not in html) and ("VSP_RUNS_STANDALONE_HARDFIX_P0_V2" not in html) and ("VSP_RUNS_PAGE_FACTORY_RESET_STATIC_P0_V1" not in html) and (not _vsp_is_runs_path(environ)):  # VSP_P0_SKIP_FILLREAL_ON_RUNS_MARKER_V1
                    tag = (
                        "\n<!-- VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY -->\n"
                        "<script src='/static/js/vsp_fill_real_data_5tabs_p1_v1.js'></script>\n"
                        "<!-- /VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY -->\n"
                    )
                    # case-insensitive insert before </body> or </html>
                    if _re.search(r"</body\s*>", html, flags=_re.I):
                        html = _re.sub(r"</body\s*>", tag + "</body>", html, count=1, flags=_re.I)
                    elif _re.search(r"</html\s*>", html, flags=_re.I):
                        html = _re.sub(r"</html\s*>", tag + "</html>", html, count=1, flags=_re.I)
                    else:
                        html = html + tag
                    body = html.encode("utf-8")

                    # fix content-length
                    headers = [(k,v) for (k,v) in headers if str(k).lower() != "content-length"]
                    headers.append(("Content-Length", str(len(body))))
            except Exception:
                pass

        start_response(captured["status"] or "200 OK", headers, captured["exc"])
        return [body]
# === /VSP_GATEWAY_FILLREAL_PROBE_HEADER_P1_V5 ===

# force last wrap
try:
    application.wsgi_app = _VspFillRealProbeMWP1V5(application.wsgi_app)
except Exception:
    pass




# === VSP_P1_FORCE_DEFAULT_VSP5_P1_V1 ===
def _vsp_force_default_to_vsp5(environ, start_response, app=application):
    try:
        path = (environ.get("PATH_INFO") or "")
        if path == "/" or path == "":
            start_response("302 FOUND", [("Location","/vsp5")])
            return [b""]
    except Exception:
        pass
    return app(environ, start_response)

try:
    application.wsgi_app = _vsp_force_default_to_vsp5(application.wsgi_app)
except Exception:
    pass
# === /VSP_P1_FORCE_DEFAULT_VSP5_P1_V1 ===




# === VSP_P1_RUNS_503_FALLBACK_MW_P1_V1 ===
import json as _json
from pathlib import Path as _Path
import time as _time
import urllib.parse as _urlparse

class _VspRuns503FallbackMWP1V1:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def _scan_runs(self, limit=20):
        roots = [
            _Path("/home/test/Data/SECURITY_BUNDLE/out"),
            _Path("/home/test/Data/SECURITY_BUNDLE/out_ci"),
            _Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci"),
        ]
        dirs=[]
        for r in roots:
            try:
                if not r.exists(): 
                    continue
                for d in r.iterdir():
                    if not d.is_dir(): 
                        continue
                    name=d.name
                    if "RUN_" not in name:
                        continue
                    try:
                        mt = d.stat().st_mtime
                    except Exception:
                        mt = 0
                    dirs.append((mt, name))
            except Exception:
                pass
        dirs.sort(reverse=True)
        items=[]
        for mt, name in dirs[:max(1,int(limit))]:
            items.append({
                "run_id": name,
                "mtime": mt,
                "has": {"csv": False, "html": False, "json": False, "sarif": False, "summary": False}
            })
        return items

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/runs"):
            return self.app(environ, start_response)

        captured = {"status": None, "headers": None, "exc": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            def _write(_data): return None
            return _write

        try:
            it = self.app(environ, _sr)
            chunks=[]
            try:
                for c in it:
                    if c: chunks.append(c)
            finally:
                try:
                    close=getattr(it,"close",None)
                    if callable(close): close()
                except Exception:
                    pass
            body = b"".join(chunks)
            code = 200
            try:
                code = int((captured["status"] or "200").split()[0])
            except Exception:
                code = 200

            # if downstream OK -> return as-is
            if code < 500:
                start_response(captured["status"] or "200 OK", captured["headers"] or [], captured["exc"])
                return [body]

        except Exception:
            code = 503

        # FALLBACK JSON 200
        try:
            qs = (environ.get("QUERY_STRING") or "")
            q = _urlparse.parse_qs(qs)
            limit = int((q.get("limit") or [20])[0])
        except Exception:
            limit = 20

        items = self._scan_runs(limit=limit)
        payload = {
            "ok": True,
            "fallback": True,
            "items": items,
            "limit": limit,
            "error": "downstream /api/vsp/runs failed (>=500), served fallback list"
        }
        out = _json.dumps(payload, ensure_ascii=False).encode("utf-8")
        hdrs = [("Content-Type","application/json; charset=utf-8"),
                ("Content-Length", str(len(out))),
                ("Cache-Control","no-cache"),
                ("X-VSP-RUNS-FALLBACK","1")]
        start_response("200 OK", hdrs)
        return [out]

# wrap last
# VSP_P1_RUNS_CACHE_MW_V2
import json as _json, os as _os, time as _time, re as _re
from pathlib import Path as _Path

class _VspRunsCacheMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
        self.ttl = float(_os.environ.get("VSP_RUNS_CACHE_TTL", "3"))
        self.limit_cap = int(_os.environ.get("VSP_RUNS_LIMIT_CAP", "10"))
        self.scan_cap = int(_os.environ.get("VSP_RUNS_SCAN_CAP", "500"))
        self._cache = {"ts": 0.0, "key": "", "payload": None}
        self._run_re = _re.compile(_os.environ.get("VSP_RUNS_DIR_REGEX", r"^(RUN_|AATE_|VSP_|btl).*"))

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path != "/api/vsp/runs":
            return self.app(environ, start_response)

        qs = (environ.get("QUERY_STRING") or "")
        limit = 5
        for part in qs.split("&"):
            if part.startswith("limit="):
                try: limit = int(part.split("=",1)[1] or "5")
                except Exception: limit = 5
        if limit <= 0: limit = 5
        if limit > self.limit_cap: limit = self.limit_cap

        roots = [
            _Path(_os.environ.get("VSP_RUNS_ROOT","") or "").expanduser(),
            _Path("/home/test/Data/SECURITY_BUNDLE/out"),
            _Path("/home/test/Data/SECURITY_BUNDLE/out_ci"),
        ]
        roots = [r for r in roots if str(r).strip() and r.is_dir()]

        key = "|".join(map(str,roots)) + f"|limit={limit}"
        now = _time.time()
        c = self._cache

        if c["payload"] is not None and c["key"] == key and (now - c["ts"]) < self.ttl:
            payload = c["payload"]
        else:
            items, seen, scanned = [], set(), 0
            for base in roots:
                for d in base.iterdir():
                    if scanned >= self.scan_cap: break
                    scanned += 1
                    if not d.is_dir(): continue
                    rid = d.name
                    if rid in seen: continue
                    if not self._run_re.match(rid): continue
                    seen.add(rid)

                    reports = d / "reports"
                    item = {
                        "run_id": rid,
                        "run_dir_resolved": str(d),
                        "has": {
                            "html": (reports/"index.html").is_file(),
                            "summary": (reports/"run_gate_summary.json").is_file(),
                            "json": (reports/"findings_unified.json").is_file(),
                            "csv": (reports/"findings_unified.csv").is_file(),
                            "sarif": False,
                        }
                    }
                    try: item["_mtime"] = d.stat().st_mtime
                    except Exception: item["_mtime"] = 0
                    items.append(item)

            items.sort(key=lambda x: x.get("_mtime",0), reverse=True)
            for it in items: it.pop("_mtime", None)
            payload = {"ok": True, "limit": limit, "_scanned": scanned, "items": items[:limit]}
            c["ts"], c["key"], c["payload"] = now, key, payload

        body = _json.dumps(payload, ensure_ascii=False).encode("utf-8")
        start_response("200 OK", [
            ("Content-Type","application/json; charset=utf-8"),
            ("Content-Length", str(len(body))),
            ("Cache-Control","no-store"),
        ])
        return [body]
# /VSP_P1_RUNS_CACHE_MW_V2

_VSP_APP_INNER = _VspRuns503FallbackMWP1V1(application)
application.wsgi_app = _VspRunsCacheMW(_VSP_APP_INNER)

try:  # VSP_AUTOFIX_ORPHAN_EXCEPT
    pass
except Exception:
    pass
# === /VSP_P1_RUNS_503_FALLBACK_MW_P1_V1 ===


# ==== VSP_P1_RUNS_CONTRACT_EOF_V6B ====
# P1 commercial: guarantee /api/vsp/runs contains contract fields + at least 1 RID (fallback scan).
def _vsp_runs_contract_after_request_v6b(resp):
    try:
        from flask import request as _req
        if (_req.path or "") != "/api/vsp/runs":
            return resp

        mt = (getattr(resp, "mimetype", "") or "")
        if "json" not in mt:
            return resp

        try:
            resp.direct_passthrough = False
        except Exception:
            pass

        import json as _json, os as _os
        from pathlib import Path as _P

        raw = resp.get_data()
        txt = raw.decode("utf-8", "replace") if isinstance(raw, (bytes, bytearray)) else str(raw)
        data = _json.loads(txt) if txt.strip() else {}
        if not isinstance(data, dict) or data.get("ok") is not True:
            return resp

        items = data.get("items") or []
        if not isinstance(items, list):
            items = []
            data["items"] = items

        # effective limit = requested (cap)
        try:
            lim_req = int((_req.args.get("limit") or "50").strip())
        except Exception:
            lim_req = 50
        hard_cap = 120
        lim_eff = max(1, min(lim_req, hard_cap))
        data["limit"] = lim_eff

        # roots used (prefer env; else known defaults)
        roots = []
        env_roots = (_os.environ.get("VSP_RUNS_ROOTS") or "").strip()
        if env_roots:
            roots = [x.strip() for x in env_roots.split(":") if x.strip()]
        else:
            roots = ["/home/test/Data/SECURITY_BUNDLE/out", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci"]
        data["roots_used"] = roots

        # If items empty: fallback scan to populate recent runs (lightweight)
        if not items:
            runs = []
            for r in roots:
                rp = _P(r)
                if not rp.exists():
                    continue
                for pat in ("RUN_*", "*_RUN_*"):
                    for d in rp.glob(pat):
                        if d.is_dir():
                            try:
                                runs.append((d.stat().st_mtime, d))
                            except Exception:
                                pass
            runs.sort(key=lambda x: x[0], reverse=True)
            take = min(len(runs), lim_eff)
            if take > 0:
                new_items = []
                for _, d in runs[:take]:
                    rid = d.name
                    rep = d / "reports"
                    has = {
                        "csv": (rep / "findings_unified.csv").exists(),
                        "html": (rep / "checkmarx_like.html").exists(),
                        "json": (rep / "findings_unified.json").exists() or (d / "findings_unified.json").exists(),
                        "sarif": (rep / "findings_unified.sarif").exists() or (d / "findings_unified.sarif").exists(),
                        "summary": (rep / "run_gate_summary.json").exists() or (d / "run_gate_summary.json").exists(),
                    }
                    new_items.append({"run_id": rid, "has": has})
                data["items"] = new_items
                items = new_items

        # rid_latest
        rid_latest = ""
        if items:
            try:
                rid_latest = (items[0].get("run_id") or items[0].get("rid") or "").strip()
            except Exception:
                rid_latest = ""
        data["rid_latest"] = rid_latest

        # cache ttl
        try:
            data["cache_ttl"] = int(_os.environ.get("VSP_RUNS_CACHE_TTL", "2"))
        except Exception:
            data["cache_ttl"] = 2

        # scan cap hit (from _scanned)
        try:
            scanned = int(data.get("_scanned") or 0)
        except Exception:
            scanned = 0
        scan_cap = int(_os.environ.get("VSP_RUNS_SCAN_CAP", "500"))
        data["scan_cap"] = scan_cap
        data["scan_cap_hit"] = bool(scanned >= scan_cap)

        out = _json.dumps(data, ensure_ascii=False)
        resp.set_data(out.encode("utf-8"))
        resp.headers["Content-Length"] = str(len(resp.get_data()))
        resp.headers["X-VSP-RUNS-CONTRACT"] = "P1_V6B"
        return resp
    except Exception:
        return resp

try:
    application.after_request(_vsp_runs_contract_after_request_v6b)
except Exception:
    pass
# ==== /VSP_P1_RUNS_CONTRACT_EOF_V6B ====


# ==== VSP_P1_RUNS_CONTRACT_WSGIMW_V2 ====
# P1 commercial: WSGI middleware that rewrites /api/vsp/runs response at the LAST layer.
def _vsp__parse_qs_limit(environ, default=50, hard_cap=120):
    try:
        qs = environ.get("QUERY_STRING") or ""
        for part in qs.split("&"):
            if part.startswith("limit="):
                v = part.split("=",1)[1]
                n = int(v.strip() or default)
                return max(1, min(n, hard_cap))
    except Exception:
        pass
    return max(1, min(default, hard_cap))

def _vsp__list_latest_runs_cached(roots, limit, ttl=2):
    import time, os
    from pathlib import Path as _P
    now = time.time()
    cache = getattr(_vsp__list_latest_runs_cached, "_cache", None) or {}
    key = "|".join(roots) + ":" + str(limit)
    ent = cache.get(key)
    if ent and (now - ent["ts"] <= ttl):
        return ent["items"]

    runs = []
    for r in roots:
        try:
            rp = _P(r)
            if not rp.exists():
                continue
            with os.scandir(rp) as it:
                for de in it:
                    if not de.is_dir():
                        continue
                    nm = de.name
                    if nm.startswith("RUN_") or "_RUN_" in nm:
                        try:
                            st = de.stat()
                            runs.append((st.st_mtime, _P(de.path)))
                        except Exception:
                            pass
        except Exception:
            continue

    runs.sort(key=lambda x: x[0], reverse=True)
    take = min(len(runs), limit)
    items=[]
    for _, d in runs[:take]:
        rid = d.name
        rep = d / "reports"
        has = {
            "csv": (rep / "findings_unified.csv").exists(),
            "html": (rep / "checkmarx_like.html").exists(),
            "json": (rep / "findings_unified.json").exists() or (d / "findings_unified.json").exists(),
            "sarif": (rep / "findings_unified.sarif").exists() or (d / "findings_unified.sarif").exists(),
            "summary": (rep / "run_gate_summary.json").exists() or (d / "run_gate_summary.json").exists(),
        }
        items.append({"run_id": rid, "has": has})
    cache[key] = {"ts": now, "items": items}
    setattr(_vsp__list_latest_runs_cached, "_cache", cache)
    return items

class _VSPRunsContractWSGIMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = environ.get("PATH_INFO") or ""
        if path != "/api/vsp/runs":
            return self.app(environ, start_response)

        captured = {"status": None, "headers": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers or [])
            return None

        body_iter = self.app(environ, _sr)
        try:
            body = b"".join(body_iter)
        except Exception:
            return self.app(environ, start_response)

        status = captured["status"] or "200 OK"
        headers = captured["headers"] or []

        try:
            code = int(status.split()[0])
        except Exception:
            code = 200

        ct = ""
        for k,v in headers:
            if k.lower() == "content-type":
                ct = v
                break

        if code != 200 or ("json" not in (ct or "")):
            start_response(status, headers)
            return [body]

        try:
            import json, os
            data = json.loads(body.decode("utf-8","replace"))
            if not (isinstance(data, dict) and data.get("ok") is True and isinstance(data.get("items"), list)):
                start_response(status, headers)
                return [body]

            lim_eff = _vsp__parse_qs_limit(environ, default=int(data.get("limit") or 50))
            data["limit"] = lim_eff

            env_roots = (os.environ.get("VSP_RUNS_ROOTS") or "").strip()
            if env_roots:
                roots = [x.strip() for x in env_roots.split(":") if x.strip()]
            else:
                roots = ["/home/test/Data/SECURITY_BUNDLE/out", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci"]
            data["roots_used"] = roots

            items = data.get("items") or []
            if not items:
                items = _vsp__list_latest_runs_cached(roots, lim_eff, ttl=int(os.environ.get("VSP_RUNS_CACHE_TTL","2")))
                data["items"] = items

            rid_latest = ""
            if items:
                try:
                    rid_latest = (items[0].get("run_id") or items[0].get("rid") or "").strip()
                except Exception:
                    rid_latest = ""
            data["rid_latest"] = rid_latest

            try:
                data["cache_ttl"] = int(os.environ.get("VSP_RUNS_CACHE_TTL","2"))
            except Exception:
                data["cache_ttl"] = 2

            try:
                scanned = int(data.get("_scanned") or 0)
            except Exception:
                scanned = 0
            scan_cap = int(os.environ.get("VSP_RUNS_SCAN_CAP","500"))
            data["scan_cap"] = scan_cap
            data["scan_cap_hit"] = bool(scanned >= scan_cap)

            out = json.dumps(data, ensure_ascii=False).encode("utf-8")

            new_headers=[]
            for k,v in headers:
                if k.lower() == "content-length":
                    continue
                new_headers.append((k,v))
            new_headers.append(("Content-Length", str(len(out))))
            new_headers.append(("X-VSP-RUNS-CONTRACT", "P1_WSGI_V2"))

            start_response(status, new_headers)
            return [out]
        except Exception:
            start_response(status, headers)
            return [body]

try:
    if "application" in globals() and not getattr(application, "__vsp_runs_contract_wrapped__", False):
        application.wsgi_app = _VSPRunsContractWSGIMW(application.wsgi_app)
        try:
            application.__vsp_runs_contract_wrapped__ = True
        except Exception:
            pass
except Exception:
    pass
# ==== /VSP_P1_RUNS_CONTRACT_WSGIMW_V2 ====


# ==== VSP_P1_SHA256_FALLBACK_V1 ====
def _vsp__sha256_hex(path):
    import hashlib
    h=hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1024*1024), b""):
            h.update(chunk)
    return h.hexdigest()

def _vsp__qs_get(environ, key):
    qs = environ.get("QUERY_STRING") or ""
    for part in qs.split("&"):
        if part.startswith(key + "="):
            return part.split("=",1)[1]
    return ""

def _vsp__safe_unquote(s):
    try:
        from urllib.parse import unquote_plus
        return unquote_plus(s)
    except Exception:
        return s

class _VSPSha256FallbackWSGIMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = environ.get("PATH_INFO") or ""
        if path != "/api/vsp/sha256":
            return self.app(environ, start_response)

        # Let downstream handler try first; if it returns 404, we attempt fallback.
        captured = {"status": None, "headers": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers or [])
            return None

        body_iter = self.app(environ, _sr)
        try:
            body = b"".join(body_iter)
        except Exception:
            return self.app(environ, start_response)

        status = captured["status"] or "200 OK"
        headers = captured["headers"] or []
        try:
            code = int(status.split()[0])
        except Exception:
            code = 200

        if code != 404:
            start_response(status, headers)
            return [body]

        # fallback compute sha256 if possible
        import os
        from pathlib import Path as _P

        rid = _vsp__safe_unquote(_vsp__qs_get(environ, "rid"))
        name = _vsp__safe_unquote(_vsp__qs_get(environ, "name"))

        # basic guard
        if not rid or not name:
            start_response(status, headers)
            return [body]

        # candidate names
        cands = [name]
        # common fallbacks: reports/x -> x
        if name.startswith("reports/"):
            cands.append(name[len("reports/"):])

        # try to resolve within known roots used by runs listing
        roots = []
        env_roots = (os.environ.get("VSP_RUNS_ROOTS") or "").strip()
        if env_roots:
            roots = [x.strip() for x in env_roots.split(":") if x.strip()]
        else:
            roots = ["/home/test/Data/SECURITY_BUNDLE/out", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci"]

        found = None
        found_rel = None
        for r in roots:
            base = _P(r) / rid
            if not base.exists():
                continue
            for rel in cands:
                fp = base / rel
                if fp.exists() and fp.is_file():
                    found = fp
                    found_rel = rel
                    break
            if found:
                break

        if not found:
            start_response(status, headers)
            return [body]

        try:
            digest = _vsp__sha256_hex(str(found))
            import json
            out = json.dumps({"ok": True, "rid": rid, "name": name, "resolved": found_rel, "sha256": digest}, ensure_ascii=False).encode("utf-8")
            new_headers=[]
            for k,v in headers:
                if k.lower() in ("content-length","content-type"):
                    continue
                new_headers.append((k,v))
            new_headers.append(("Content-Type","application/json; charset=utf-8"))
            new_headers.append(("Content-Length", str(len(out))))
            new_headers.append(("X-VSP-SHA256-FALLBACK", found_rel or ""))
            start_response("200 OK", new_headers)
            return [out]
        except Exception:
            start_response(status, headers)
            return [body]

try:
    if "application" in globals() and not getattr(application, "__vsp_sha256_fallback_wrapped__", False):
        application.wsgi_app = _VSPSha256FallbackWSGIMW(application.wsgi_app)
        try:
            application.__vsp_sha256_fallback_wrapped__ = True
        except Exception:
            pass
except Exception:
    pass
# ==== /VSP_P1_SHA256_FALLBACK_V1 ====


# ==== VSP_P1_SHA256_ALWAYS200_WSGIMW_V2 ====
def _vsp__sha256_hex(path):
    import hashlib
    h=hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1024*1024), b""):
            h.update(chunk)
    return h.hexdigest()

def _vsp__qs_get(environ, key):
    qs = environ.get("QUERY_STRING") or ""
    for part in qs.split("&"):
        if part.startswith(key + "="):
            return part.split("=",1)[1]
    return ""

def _vsp__unq(s):
    try:
        from urllib.parse import unquote_plus
        return unquote_plus(s)
    except Exception:
        return s

def _vsp__is_safe_rel(rel):
    # prevent path traversal
    if not rel or rel.startswith("/") or rel.startswith("\\"):
        return False
    if ".." in rel.replace("\\","/").split("/"):
        return False
    return True

class _VSPSha256Always200WSGIMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = environ.get("PATH_INFO") or ""
        if path not in ("/api/vsp/sha256", "/api/vsp/sha256/"):
            return self.app(environ, start_response)

        import os, json
        from pathlib import Path as _P

        rid  = _vsp__unq(_vsp__qs_get(environ, "rid"))
        name = _vsp__unq(_vsp__qs_get(environ, "name"))

        # default response (degraded)
        resp = {"ok": False, "rid": rid, "name": name, "missing": True, "resolved": None, "sha256": None}

        # resolve roots
        env_roots = (os.environ.get("VSP_RUNS_ROOTS") or "").strip()
        roots = [x.strip() for x in env_roots.split(":") if x.strip()] if env_roots else [
            "/home/test/Data/SECURITY_BUNDLE/out",
            "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        ]

        # candidate relative paths (fallbacks)
        cands = []
        if name and _vsp__is_safe_rel(name):
            cands.append(name)
            if name.startswith("reports/"):
                alt = name[len("reports/"):]
                if _vsp__is_safe_rel(alt):
                    cands.append(alt)

        found = None
        found_rel = None
        if rid and cands:
            for r in roots:
                base = _P(r) / rid
                if not base.exists():
                    continue
                for rel in cands:
                    fp = base / rel
                    if fp.exists() and fp.is_file():
                        found = fp
                        found_rel = rel
                        break
                if found:
                    break

        if found:
            try:
                resp["ok"] = True
                resp["missing"] = False
                resp["resolved"] = found_rel
                resp["sha256"] = _vsp__sha256_hex(str(found))
            except Exception:
                resp["ok"] = False
                resp["missing"] = True

        out = json.dumps(resp, ensure_ascii=False).encode("utf-8")
        headers = [
            ("Content-Type","application/json; charset=utf-8"),
            ("Content-Length", str(len(out))),
            ("X-VSP-SHA256", "P1_WSGI_V2"),
        ]
        if resp.get("missing"):
            headers.append(("X-VSP-DEGRADED", "sha256_missing_artifact"))
        else:
            headers.append(("X-VSP-SHA256-RESOLVED", resp.get("resolved") or ""))

        start_response("200 OK", headers)
        return [out]

try:
    if "application" in globals() and not getattr(application, "__vsp_sha256_always200_wrapped__", False):
        application.wsgi_app = _VSPSha256Always200WSGIMW(application.wsgi_app)
        try:
            application.__vsp_sha256_always200_wrapped__ = True
        except Exception:
            pass
except Exception:
    pass
# ==== /VSP_P1_SHA256_ALWAYS200_WSGIMW_V2 ====



# --- VSP_P1_RUNS_ALWAYS200_WSGIMW_V1 ---
# Commercial hardening: /api/vsp/runs never flakes the UI. If downstream fails, serve last-good cache (200) + degraded headers.
import os, json, time, traceback

class _VspRunsAlways200MW:
    def __init__(self, app, cache_path):
        self.app = _vsp_base_wsgi(app)
        self.cache_path = cache_path

    def _write_cache(self, body_bytes):
        try:
            os.makedirs(os.path.dirname(self.cache_path), exist_ok=True)
            with open(self.cache_path, "wb") as f:
                f.write(body_bytes)
        except Exception:
            pass

    def _read_cache(self):
        try:
            with open(self.cache_path, "rb") as f:
                return f.read()
        except Exception:
            return None

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        qs   = (environ.get("QUERY_STRING") or "")
        if not path.startswith("/api/vsp/runs"):
            return self.app(environ, start_response)

        info = {"path": path, "qs": qs}
        status_box = {}
        headers_box = {}

        def _sr(status, headers, exc_info=None):
            status_box["status"] = status
            headers_box["headers"] = list(headers or [])
            return start_response(status, headers, exc_info)

        try:
            chunks = []
            app_iter = self.app(environ, _sr)
            for c in app_iter:
                chunks.append(c)
            if hasattr(app_iter, "close"):
                try: app_iter.close()
                except Exception: pass

            body = b"".join(chunks)
            st = (status_box.get("status") or "500").split()[0]

            # If not 200 -> fallback to cache as 200 (degraded)
            if st != "200":
                cached = self._read_cache()
                if cached:
                    hdrs = [("Content-Type","application/json; charset=utf-8"),
                            ("Cache-Control","no-cache"),
                            ("X-VSP-RUNS-DEGRADED","1"),
                            ("X-VSP-RUNS-DEGRADED-REASON", f"status_{st}")]
                    start_response("200 OK", hdrs)
                    return [cached]
                # no cache => return minimal ok=true degraded payload
                payload = {"ok": True, "degraded": True, "reason": f"status_{st}", "items": [], "rid_latest": None, "ts": int(time.time())}
                b = json.dumps(payload, ensure_ascii=False).encode("utf-8")
                hdrs = [("Content-Type","application/json; charset=utf-8"),
                        ("Cache-Control","no-cache"),
                        ("X-VSP-RUNS-DEGRADED","1"),
                        ("X-VSP-RUNS-DEGRADED-REASON", f"status_{st}")]
                start_response("200 OK", hdrs)
                return [b]

            # 200 OK => update cache and pass through
            self._write_cache(body)
            return [body]

        except Exception as e:
            cached = self._read_cache()
            if cached:
                hdrs = [("Content-Type","application/json; charset=utf-8"),
                        ("Cache-Control","no-cache"),
                        ("X-VSP-RUNS-DEGRADED","1"),
                        ("X-VSP-RUNS-DEGRADED-REASON","exception_cached")]
                start_response("200 OK", hdrs)
                return [cached]
            payload = {"ok": True, "degraded": True, "reason": "exception_no_cache", "error": str(e), "items": [], "rid_latest": None, "ts": int(time.time())}
            b = json.dumps(payload, ensure_ascii=False).encode("utf-8")
            hdrs = [("Content-Type","application/json; charset=utf-8"),
                    ("Cache-Control","no-cache"),
                    ("X-VSP-RUNS-DEGRADED","1"),
                    ("X-VSP-RUNS-DEGRADED-REASON","exception_no_cache")]
            start_response("200 OK", hdrs)
            return [b]

# Wrap last-layer (outside everything else)
try:
    _RUNS_CACHE_PATH = os.environ.get("VSP_RUNS_CACHE_PATH", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/runs_cache_last_good.json")
    application.wsgi_app = _VspRunsAlways200MW(application.wsgi_app, _RUNS_CACHE_PATH)
except Exception:
    pass
# --- /VSP_P1_RUNS_ALWAYS200_WSGIMW_V1 ---


# --- VSP_P1_REPORTS_ALIAS_LATEST_WSGIMW_V1 ---
# Ensure /api/reports/* always targets current rid_latest (so UI dashboard never shows stale RID)
import os, json, time
from urllib.parse import urlencode

def _vsp_pick_rid_latest():
    roots = os.environ.get("VSP_RUNS_ROOTS","/home/test/Data/SECURITY_BUNDLE/out").split(":")
    roots = [r.strip() for r in roots if r.strip()]
    best = None
    best_m = -1
    for root in roots:
        try:
            for name in os.listdir(root):
                if name.startswith("."): 
                    continue
                pth = os.path.join(root, name)
                if not os.path.isdir(pth):
                    continue
                # accept things that look like run dirs, including our alias VSP_CI_RUN_*
                if ("_RUN_" not in name) and (not name.startswith("RUN_")) and (not name.startswith("VSP_CI_RUN_")):
                    continue
                try:
                    m = os.path.getmtime(pth)
                except Exception:
                    continue
                if m > best_m:
                    best_m = m
                    best = name
        except Exception:
            continue
    return best

class _VspReportsAliasLatestMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/reports/"):
            return self.app(environ, start_response)

        # map /api/reports/<file> -> /api/vsp/run_file?rid=<rid_latest>&name=reports/<file>
        rid = _vsp_pick_rid_latest()
        fname = path[len("/api/reports/"):]  # e.g. run_gate_summary.json
        if not fname:
            payload = {"ok": False, "error":"missing filename", "ts": int(time.time())}
            b = json.dumps(payload).encode("utf-8")
            start_response("400 Bad Request", [("Content-Type","application/json; charset=utf-8"),("Cache-Control","no-store")])
            return [b]
        if not rid:
            payload = {"ok": False, "error":"no rid_latest", "ts": int(time.time())}
            b = json.dumps(payload).encode("utf-8")
            start_response("404 Not Found", [("Content-Type","application/json; charset=utf-8"),("Cache-Control","no-store")])
            return [b]

        qs = urlencode({"rid": rid, "name": f"reports/{fname}"})
        loc = f"/api/vsp/run_file?{qs}"
        hdrs = [("Location", loc),
                ("Cache-Control","no-store"),
                ("X-VSP-REPORTS-ALIAS","latest"),
                ("X-VSP-REPORTS-RID", rid)]
        start_response("302 Found", hdrs)
        return [b""]

try:
    application.wsgi_app = _VspReportsAliasLatestMW(application.wsgi_app)
except Exception:
    pass
# --- /VSP_P1_REPORTS_ALIAS_LATEST_WSGIMW_V1 ---


# --- VSP_P1_REPORTS_RUNFILE_FOLLOW_RIDLATEST_CACHE_V1 ---
# Data-first hardening:
# 1) /api/reports/* always redirects to rid_latest from runs cache (not "some latest RUN_*")
# 2) /api/vsp/run_file when rid/name missing -> fallback redirect to rid_latest (prevents Data Source 404 with stale RID)
import os, json, time
from urllib.parse import urlencode, parse_qs

def _vsp_runs_cache_path():
    return os.environ.get("VSP_RUNS_CACHE_PATH", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/runs_cache_last_good.json")

def _vsp_get_rid_latest_from_cache():
    force = os.environ.get("VSP_REPORTS_ALIAS_FORCE_RID","").strip()
    if force:
        return force
    try:
        b = open(_vsp_runs_cache_path(), "rb").read()
        j = json.loads(b.decode("utf-8","replace"))
        rid = (j.get("rid_latest") or "").strip()
        return rid or None
    except Exception:
        return None

def _vsp_runs_roots():
    roots = os.environ.get("VSP_RUNS_ROOTS", "/home/test/Data/SECURITY_BUNDLE/out").split(":")
    return [r.strip() for r in roots if r.strip()]

def _vsp_safe_rel(name: str) -> bool:
    if not name or name.startswith("/") or "\x00" in name:
        return False
    # prevent traversal
    if ".." in name.split("/"):
        return False
    return True

def _vsp_runfile_exists(rid: str, relname: str) -> bool:
    if not rid or not relname or (not _vsp_safe_rel(relname)):
        return False
    for root in _vsp_runs_roots():
        try:
            base = os.path.join(root, rid)
            if os.path.isdir(base):
                p = os.path.join(base, relname)
                if os.path.isfile(p):
                    return True
        except Exception:
            continue
    return False

class _VspReportsFollowRidLatestMW:
    def __init__(self, app): self.app = app
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/reports/"):
            return self.app(environ, start_response)
        fname = path[len("/api/reports/"):]  # e.g. findings_unified.json
        if not fname:
            start_response("400 Bad Request",[("Content-Type","application/json; charset=utf-8"),("Cache-Control","no-store")])
            return [b'{"ok":false,"error":"missing filename"}']
        rid = _vsp_get_rid_latest_from_cache()
        if not rid:
            start_response("503 Service Unavailable",[("Content-Type","application/json; charset=utf-8"),("Cache-Control","no-store"),
                                                     ("X-VSP-REPORTS-DEGRADED","1"),("X-VSP-REPORTS-REASON","no_rid_latest_cache")])
            return [b'{"ok":true,"degraded":true,"reason":"no_rid_latest_cache"}']
        qs = urlencode({"rid": rid, "name": f"reports/{fname}"})
        loc = f"/api/vsp/run_file?{qs}"
        start_response("302 Found",[("Location",loc),("Cache-Control","no-store"),
                                   ("X-VSP-REPORTS-ALIAS","rid_latest_cache"),
                                   ("X-VSP-REPORTS-RID",rid)])
        return [b""]

class _VspRunFileFallbackLatestMW:
    def __init__(self, app): self.app = app
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path != "/api/vsp/run_file":
            return self.app(environ, start_response)

        qs = parse_qs(environ.get("QUERY_STRING",""), keep_blank_values=True)
        rid = (qs.get("rid",[None])[0] or "").strip()
        name = (qs.get("name",[None])[0] or "").strip()

        # Only fallback for safe names (prevent traversal)
        if not _vsp_safe_rel(name):
            return self.app(environ, start_response)

        # If requested file exists -> normal
        if rid and _vsp_runfile_exists(rid, name):
            return self.app(environ, start_response)

        # If missing -> redirect to rid_latest if that file exists
        rid2 = _vsp_get_rid_latest_from_cache()
        if rid2 and _vsp_runfile_exists(rid2, name):
            qs2 = urlencode({"rid": rid2, "name": name})
            loc = f"/api/vsp/run_file?{qs2}"
            start_response("302 Found",[("Location",loc),("Cache-Control","no-store"),
                                       ("X-VSP-RUNFILE-FALLBACK","1"),
                                       ("X-VSP-RUNFILE-OLD", rid or "none"),
                                       ("X-VSP-RUNFILE-NEW", rid2)])
            return [b""]

        # else: let app handle (will 404/503 as before)
        return self.app(environ, start_response)

# Wrap OUTERMOST so it overrides any existing Flask route logic
try:
    application.wsgi_app = _VspRunFileFallbackLatestMW(application.wsgi_app)
    application.wsgi_app = _VspReportsFollowRidLatestMW(application.wsgi_app)
except Exception:
    pass
# --- /VSP_P1_REPORTS_RUNFILE_FOLLOW_RIDLATEST_CACHE_V1 ---


# --- VSP_P1_FORCE_WRAP_REPORTS_RUNFILE_LATEST_V1 ---
# Force WSGI wrapping at module-level `application` (works even if `application` is not Flask).
import os, json, time, glob
from urllib.parse import urlencode, parse_qs

def _vsp_roots():
    roots = os.environ.get("VSP_RUNS_ROOTS", "/home/test/Data/SECURITY_BUNDLE/out").split(":")
    return [r.strip() for r in roots if r.strip()]

def _safe_rel(name: str) -> bool:
    if not name or name.startswith("/") or "\x00" in name:
        return False
    if ".." in name.split("/"):
        return False
    return True

def _runfile_exists(rid: str, relname: str) -> bool:
    if not rid or not relname or (not _safe_rel(relname)):
        return False
    for root in _vsp_roots():
        try:
            base = os.path.join(root, rid)
            if os.path.isdir(base):
                p = os.path.join(base, relname)
                if os.path.isfile(p):
                    return True
        except Exception:
            continue
    return False

def _rid_latest_from_runs_cache():
    # If force env set, obey
    force = os.environ.get("VSP_REPORTS_ALIAS_FORCE_RID", "").strip()
    if force:
        return force

    # Try find newest cache file in ui/out_ci
    cand = []
    try:
        ui_out_ci = os.path.join(os.path.dirname(__file__), "out_ci")
        pats = [
            os.path.join(ui_out_ci, "runs_cache*.json"),
            os.path.join(ui_out_ci, "*runs*cache*.json"),
            os.path.join(ui_out_ci, "vsp_runs*.json"),
        ]
        for pat in pats:
            for f in glob.glob(pat):
                try:
                    cand.append((os.path.getmtime(f), f))
                except Exception:
                    pass
    except Exception:
        pass

    cand.sort(reverse=True)
    for _, f in cand[:5]:
        try:
            j = json.loads(open(f, "rb").read().decode("utf-8","replace"))
            rid = (j.get("rid_latest") or "").strip()
            if rid:
                return rid
        except Exception:
            continue

    # Fallback: scan roots, prefer VSP_CI_RUN_*, then any *_RUN_*/RUN_*
    best = None
    best_m = -1
    prefer = None
    prefer_m = -1
    for root in _vsp_roots():
        try:
            for name in os.listdir(root):
                if name.startswith("."): 
                    continue
                pth = os.path.join(root, name)
                if not os.path.isdir(pth) and not os.path.islink(pth):
                    continue
                try:
                    m = os.path.getmtime(pth)
                except Exception:
                    continue
                if name.startswith("VSP_CI_RUN_"):
                    if m > prefer_m:
                        prefer_m = m
                        prefer = name
                if ("_RUN_" in name) or name.startswith("RUN_"):
                    if m > best_m:
                        best_m = m
                        best = name
        except Exception:
            continue
    return prefer or best

class _ForceWrapReportsRunFileMW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        qs_raw = (environ.get("QUERY_STRING") or "")

        # 1) /api/reports/<file> -> redirect to rid_latest + reports/<file>
        if path.startswith("/api/reports/"):
            fname = path[len("/api/reports/"):]
            rid = _rid_latest_from_runs_cache()
            if not fname:
                start_response("400 Bad Request",[("Content-Type","application/json; charset=utf-8"),("Cache-Control","no-store")])
                return [b'{"ok":false,"error":"missing filename"}']
            if not rid:
                start_response("503 Service Unavailable",[("Content-Type","application/json; charset=utf-8"),("Cache-Control","no-store"),
                                                         ("X-VSP-REPORTS-DEGRADED","1"),("X-VSP-REPORTS-REASON","no_rid_latest")])
                return [b'{"ok":true,"degraded":true,"reason":"no_rid_latest"}']
            loc = "/api/vsp/run_file?" + urlencode({"rid": rid, "name": f"reports/{fname}"})
            start_response("302 Found",[("Location",loc),("Cache-Control","no-store"),
                                        ("X-VSP-REPORTS-ALIAS","rid_latest"),
                                        ("X-VSP-REPORTS-RID",rid)])
            return [b""]

        # 2) /api/vsp/run_file fallback:
        # if rid is stale and file missing => redirect to rid_latest if file exists there
        if path == "/api/vsp/run_file":
            qs = parse_qs(qs_raw, keep_blank_values=True)
            rid = (qs.get("rid",[None])[0] or "").strip()
            name = (qs.get("name",[None])[0] or "").strip()

            if _safe_rel(name):
                if (not rid) or (not _runfile_exists(rid, name)):
                    rid2 = _rid_latest_from_runs_cache()
                    if rid2 and _runfile_exists(rid2, name):
                        loc = "/api/vsp/run_file?" + urlencode({"rid": rid2, "name": name})
                        start_response("302 Found",[("Location",loc),("Cache-Control","no-store"),
                                                    ("X-VSP-RUNFILE-FALLBACK","1"),
                                                    ("X-VSP-RUNFILE-OLD", rid or "none"),
                                                    ("X-VSP-RUNFILE-NEW", rid2)])
                        return [b""]

        return self.app(environ, start_response)

# FORCE wrap callable application (outermost)
try:
    _orig_app = application
    # VSP_P1_FIX_FORCEWRAP_RECURSION_V11
    _fw_rrf_arg = _orig_app
    _fw_rrf_wsgi = getattr(_fw_rrf_arg, 'wsgi_app', _fw_rrf_arg)
    application.wsgi_app = _ForceWrapReportsRunFileMW(_fw_rrf_wsgi)
except Exception:
    pass
# --- /VSP_P1_FORCE_WRAP_REPORTS_RUNFILE_LATEST_V1 ---


# --- VSP_P1_FORCE_WRAP_RUNS_ALWAYS200_V1 ---
# Force /api/vsp/runs always returns 200 (cache fallback) to avoid UI "RUNS API FAIL 503".
import os, json, time

def _runs_cache_path():
    return os.environ.get("VSP_RUNS_CACHE_PATH", "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/runs_cache_last_good.json")

class _ForceWrapRunsAlways200MW:
    def __init__(self, app):
        self.app = _vsp_base_wsgi(app)
    def _read_cache(self):
        try:
            return open(_runs_cache_path(), "rb").read()
        except Exception:
            return None

    def _write_cache(self, b):
        try:
            os.makedirs(os.path.dirname(_runs_cache_path()), exist_ok=True)
            with open(_runs_cache_path(), "wb") as f:
                f.write(b)
        except Exception:
            pass

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/runs"):
            return self.app(environ, start_response)

        status_box = {}
        headers_box = {}

        def _sr(status, headers, exc_info=None):
            status_box["status"] = status
            headers_box["headers"] = list(headers or [])
            return start_response(status, headers, exc_info)

        try:
            chunks=[]
            it = self.app(environ, _sr)
            for c in it:
                chunks.append(c)
            if hasattr(it, "close"):
                try: it.close()
                except Exception: pass

            body = b"".join(chunks)
            code = (status_box.get("status") or "500").split()[0]

            if code == "200":
                # cache only if JSON decodes
                try:
                    j = json.loads(body.decode("utf-8","replace"))
                    if isinstance(j, dict) and j.get("ok") is True and j.get("items") is not None:
                        self._write_cache(body)
                except Exception:
                    pass
                return [body]

            cached = self._read_cache()
            if cached:
                hdrs=[("Content-Type","application/json; charset=utf-8"),
                      ("Cache-Control","no-store"),
                      ("X-VSP-RUNS-DEGRADED","1"),
                      ("X-VSP-RUNS-DEGRADED-REASON", f"status_{code}")]
                start_response("200 OK", hdrs)
                return [cached]

            payload={"ok": True, "degraded": True, "reason": f"status_{code}", "rid_latest": None, "items": [], "ts": int(time.time())}
            b=json.dumps(payload, ensure_ascii=False).encode("utf-8")
            hdrs=[("Content-Type","application/json; charset=utf-8"),
                  ("Cache-Control","no-store"),
                  ("X-VSP-RUNS-DEGRADED","1"),
                  ("X-VSP-RUNS-DEGRADED-REASON", f"status_{code}")]
            start_response("200 OK", hdrs)
            return [b]

        except Exception as e:
            cached = self._read_cache()
            if cached:
                hdrs=[("Content-Type","application/json; charset=utf-8"),
                      ("Cache-Control","no-store"),
                      ("X-VSP-RUNS-DEGRADED","1"),
                      ("X-VSP-RUNS-DEGRADED-REASON","exception_cached")]
                start_response("200 OK", hdrs)
                return [cached]
            payload={"ok": True, "degraded": True, "reason":"exception_no_cache", "error": str(e), "rid_latest": None, "items": [], "ts": int(time.time())}
            b=json.dumps(payload, ensure_ascii=False).encode("utf-8")
            hdrs=[("Content-Type","application/json; charset=utf-8"),
                  ("Cache-Control","no-store"),
                  ("X-VSP-RUNS-DEGRADED","1"),
                  ("X-VSP-RUNS-DEGRADED-REASON","exception_no_cache")]
            start_response("200 OK", hdrs)
            return [b]

# FORCE wrap module-level callable `application`
try:
    _orig_app_runs = application
    # VSP_P1_FIX_RUNSALWAYS200_KEEP_FLASK_V2
    # keep Flask app; wrap only WSGI callable
    application.wsgi_app = _ForceWrapRunsAlways200MW(application.wsgi_app)
except Exception:
    pass
# --- /VSP_P1_FORCE_WRAP_RUNS_ALWAYS200_V1 ---


# VSP_P1_RUNS_NEVER_503_MW_V1 application
@application.after_request
def _vsp_p1_runs_never_503(resp):
    try:
        # local import: avoid touching global imports
        from flask import request, jsonify
        if request.path == "/api/vsp/runs":
            code = getattr(resp, "status_code", 200) if resp is not None else 500
            if code >= 500:
                payload = {
                    "ok": False,
                    "degraded": True,
                    "rid_latest": None,
                    "items": [],
                    "error": "runs endpoint degraded (auto-mapped from %s)" % code
                }
                r = jsonify(payload)
                r.status_code = 200
                r.headers["X-VSP-RUNS-DEGRADED"] = "1"
                r.headers["Cache-Control"] = "no-store"
                return r
    except Exception:
        pass
    return resp


# VSP_P0_ROOT_REDIRECT_TO_VSP5_MW_V1
class _VspRootRedirectToVsp5MW:
    def __init__(self, app, target="/vsp5"):
        self.app = _vsp_base_wsgi(app)
        self.target = target
    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "").strip()
        if path == "" or path == "/":
            start_response("302 Found", [
                ("Location", self.target),
                ("Content-Type", "text/plain; charset=utf-8"),
                ("Content-Length", "0"),
            ])
            return [b""]
        return self.app(environ, start_response)

try:
    application.wsgi_app = _VspRootRedirectToVsp5MW(application.wsgi_app)
except Exception:
    pass


# VSP_P1_DASH_KPIS_CHARTS_FROM_REPORTS_V2
# Provide /api/vsp/dash_kpis and /api/vsp/dash_charts used by vsp5 UI.
# Robust fallback: derive from existing /api/vsp/runs + /api/vsp/run_file artifacts.
import json as _json
import math as _math
from urllib.parse import parse_qs as _parse_qs, urlencode as _urlencode
from urllib.request import urlopen as _urlopen, Request as _Request

def _vsp__base_url_from_environ(environ):
    scheme = environ.get("wsgi.url_scheme") or "http"
    host = environ.get("HTTP_HOST")
    if not host:
        host = environ.get("SERVER_NAME") or "127.0.0.1"
        port = environ.get("SERVER_PORT")
        if port and port not in ("80","443"):
            host = f"{host}:{port}"
    return f"{scheme}://{host}"

def _vsp__http_json(base, path, timeout=3.0):
    req = _Request(base + path, headers={"Accept":"application/json","X-VSP-Internal":"1"})
    with _urlopen(req, timeout=timeout) as r:
        body = r.read().decode("utf-8", "replace")
    return _json.loads(body)

def _vsp__get_latest_rid(base):
    j = _vsp__http_json(base, "/api/vsp/runs?limit=1", timeout=3.0)
    items = (j or {}).get("items") or []
    if items and isinstance(items[0], dict):
        return items[0].get("run_id") or ""
    return ""

def _vsp__run_file_json(base, rid, name):
    q = _urlencode({"rid": rid, "name": name})
    return _vsp__http_json(base, f"/api/vsp/run_file?{q}", timeout=5.0)

def _vsp__extract_findings_list(obj):
    if obj is None:
        return []
    if isinstance(obj, list):
        return obj
    if isinstance(obj, dict):
        for k in ("items","findings","data","results"):
            v = obj.get(k)
            if isinstance(v, list):
                return v
    return []

def _vsp__pick_cwe(f):
    if not isinstance(f, dict):
        return None
    for k in ("cwe","cwe_id","cweId","cwe_ids","cweIds"):
        v = f.get(k)
        if isinstance(v, str) and "CWE" in v.upper():
            vv = v.upper().replace(" ", "")
            if vv.startswith("CWE-"):
                return vv
            digits = "".join(ch for ch in vv if ch.isdigit())
            return "CWE-" + digits if digits else None
        if isinstance(v, int):
            return f"CWE-{v}"
        if isinstance(v, list):
            for x in v:
                if isinstance(x, int):
                    return f"CWE-{x}"
                if isinstance(x, str) and "CWE" in x.upper():
                    xx = x.upper().replace(" ", "")
                    if xx.startswith("CWE-"):
                        return xx
                    digits = "".join(ch for ch in xx if ch.isdigit())
                    return "CWE-" + digits if digits else None
    return None

def _vsp__pick_path(f):
    if not isinstance(f, dict):
        return None
    for k in ("path","file","filename","location","artifact","resource","uri"):
        v = f.get(k)
        if isinstance(v, str) and v:
            return v
        if isinstance(v, dict):
            for kk in ("path","file","uri"):
                vv = v.get(kk)
                if isinstance(vv, str) and vv:
                    return vv
    return None

def _vsp__score_from_total(total):
    try:
        t = max(0, int(total))
        return int(max(0, min(100, round(100 - (_math.log10(t+1)*19)))))
    except Exception:
        return 0

class _VSPDashKpisChartsMW:
    def __init__(self, app):
        base_wsgi = globals().get("_vsp_base_wsgi")
        self.app = base_wsgi(app) if callable(base_wsgi) else getattr(app, "wsgi_app", app)

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path not in ("/api/vsp/dash_kpis", "/api/vsp/dash_charts"):
            return self.app(environ, start_response)

        try:
            base = _vsp__base_url_from_environ(environ)
            qs = _parse_qs(environ.get("QUERY_STRING") or "")
            rid = (qs.get("rid") or [""])[0] or _vsp__get_latest_rid(base)

            summ = _vsp__run_file_json(base, rid, "reports/run_gate_summary.json")
            counts = (summ or {}).get("counts_total") or {}
            total = sum(int(counts.get(k,0) or 0) for k in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"))
            overall = (summ or {}).get("overall") or (summ or {}).get("gate") or "UNKNOWN"

            findings = []
            cwe_cnt = {}
            mod_cnt = {}

            try:
                fu = _vsp__run_file_json(base, rid, "reports/findings_unified.json")
                findings = _vsp__extract_findings_list(fu)
            except Exception:
                findings = []

            by_tool = (summ or {}).get("by_tool") or {}
            tool_score = {}
            if isinstance(by_tool, dict):
                for tname, tv in by_tool.items():
                    if isinstance(tv, dict):
                        c = int(tv.get("CRITICAL",0) or 0)
                        h = int(tv.get("HIGH",0) or 0)
                        tool_score[tname] = c*10 + h*3
            top_tool = sorted(tool_score.items(), key=lambda x: x[1], reverse=True)[0][0] if tool_score else None

            for f in findings[:5000]:
                cwe = _vsp__pick_cwe(f)
                if cwe:
                    cwe_cnt[cwe] = cwe_cnt.get(cwe,0)+1
                pth = _vsp__pick_path(f)
                if pth:
                    key = pth.split("?")[0]
                    if "/" in key:
                        key = "/".join(key.split("/")[:4])
                    mod_cnt[key] = mod_cnt.get(key,0)+1

            top_cwe = sorted(cwe_cnt.items(), key=lambda x: x[1], reverse=True)[0][0] if cwe_cnt else None
            top_module = sorted(mod_cnt.items(), key=lambda x: x[1], reverse=True)[0][0] if mod_cnt else None

            if path == "/api/vsp/dash_kpis":
                out = {
                    "ok": True,
                    "rid": rid,
                    "overall": overall,
                    "total_findings": total,
                    "counts_total": counts,
                    "security_score": (summ or {}).get("security_score") or _vsp__score_from_total(total),
                    "top_risky_tool": top_tool or (summ or {}).get("top_tool"),
                    "top_impacted_cwe": top_cwe or (summ or {}).get("top_cwe"),
                    "top_vulnerable_module": top_module or (summ or {}).get("top_module"),
                }
            else:
                sev = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"]
                out = {
                    "ok": True,
                    "rid": rid,
                    "severity_distribution": [{"sev":k,"count":int(counts.get(k,0) or 0)} for k in sev],
                    "critical_high_by_tool": [
                        {"tool":t,
                         "critical":int((by_tool.get(t,{}) or {}).get("CRITICAL",0) or 0),
                         "high":int((by_tool.get(t,{}) or {}).get("HIGH",0) or 0)}
                        for t in (list(by_tool.keys())[:30] if isinstance(by_tool, dict) else [])
                    ],
                    "top_cwe_exposure": [{"cwe":k,"count":v} for k,v in sorted(cwe_cnt.items(), key=lambda x: x[1], reverse=True)[:12]],
                    "findings_trend": [{"rid": rid, "total": total}],
                }

            body = _json.dumps(out, ensure_ascii=False).encode("utf-8")
            start_response("200 OK", [
                ("Content-Type","application/json; charset=utf-8"),
                ("Cache-Control","no-cache"),
                ("Content-Length", str(len(body))),
            ])
            return [body]
        except Exception as e:
            body = _json.dumps({"ok": False, "error": str(e)}, ensure_ascii=False).encode("utf-8")
            start_response("200 OK", [
                ("Content-Type","application/json; charset=utf-8"),
                ("Cache-Control","no-cache"),
                ("Content-Length", str(len(body))),
            ])
            return [body]

try:
    application.wsgi_app = _VSPDashKpisChartsMW(application.wsgi_app)
except Exception:
    pass



# VSP_P1_DASH_KPIS_CHARTS_FROM_REPORTS_V3
import json as _json
import math as _math
from urllib.parse import parse_qs as _parse_qs, urlencode as _urlencode
from urllib.request import urlopen as _urlopen, Request as _Request

def _vsp__base_url_from_environ(environ):
    scheme = environ.get("wsgi.url_scheme") or "http"
    host = environ.get("HTTP_HOST")
    if not host:
        host = environ.get("SERVER_NAME") or "127.0.0.1"
        port = environ.get("SERVER_PORT")
        if port and port not in ("80","443"):
            host = f"{host}:{port}"
    return f"{scheme}://{host}"

def _vsp__http_json(base, path, timeout=3.0):
    req = _Request(base + path, headers={"Accept":"application/json","X-VSP-Internal":"1"})
    with _urlopen(req, timeout=timeout) as r:
        body = r.read().decode("utf-8", "replace")
    return _json.loads(body)

def _vsp__get_latest_rid(base):
    j = _vsp__http_json(base, "/api/vsp/runs?limit=1", timeout=2.5)
    items = (j or {}).get("items") or []
    if items and isinstance(items[0], dict):
        return items[0].get("run_id") or ""
    return ""

def _vsp__run_file_json(base, rid, name, timeout=5.0):
    q = _urlencode({"rid": rid, "name": name})
    return _vsp__http_json(base, f"/api/vsp/run_file?{q}", timeout=timeout)

def _vsp__extract_findings_list(obj):
    if obj is None:
        return []
    if isinstance(obj, list):
        return obj
    if isinstance(obj, dict):
        v = obj.get("items")
        if isinstance(v, list):
            return v
        for k in ("findings","data","results"):
            v = obj.get(k)
            if isinstance(v, list):
                return v
    return []

def _vsp__score_from_total(total):
    try:
        t = max(0, int(total))
        return int(max(0, min(100, round(100 - (_math.log10(t+1)*19)))))
    except Exception:
        return 0

def _vsp__pick_tool(f):
    if not isinstance(f, dict):
        return None
    for k in ("tool","source","scanner","engine","detector"):
        v = f.get(k)
        if isinstance(v, str) and v:
            return v.upper()
    # sometimes nested
    v = f.get("meta") if isinstance(f.get("meta"), dict) else None
    if v:
        for k in ("tool","source","scanner"):
            vv = v.get(k)
            if isinstance(vv, str) and vv:
                return vv.upper()
    return None

def _vsp__pick_cwe(f):
    if not isinstance(f, dict):
        return None
    for k in ("cwe","cwe_id","cweId","cwe_ids","cweIds"):
        v = f.get(k)
        if isinstance(v, str) and "CWE" in v.upper():
            vv = v.upper().replace(" ", "")
            if vv.startswith("CWE-"):
                return vv
            digits = "".join(ch for ch in vv if ch.isdigit())
            return "CWE-" + digits if digits else None
        if isinstance(v, int):
            return f"CWE-{v}"
        if isinstance(v, list):
            for x in v:
                if isinstance(x, int):
                    return f"CWE-{x}"
                if isinstance(x, str) and "CWE" in x.upper():
                    xx = x.upper().replace(" ", "")
                    if xx.startswith("CWE-"):
                        return xx
                    digits = "".join(ch for ch in xx if ch.isdigit())
                    return "CWE-" + digits if digits else None
    return None

def _vsp__pick_path(f):
    if not isinstance(f, dict):
        return None
    for k in ("path","file","filename","location","artifact","resource","uri"):
        v = f.get(k)
        if isinstance(v, str) and v:
            return v
        if isinstance(v, dict):
            for kk in ("path","file","uri"):
                vv = v.get(kk)
                if isinstance(vv, str) and vv:
                    return vv
    # sometimes sarif-ish
    loc = f.get("location")
    if isinstance(loc, dict):
        for kk in ("physicalLocation","artifactLocation"):
            vv = loc.get(kk)
            if isinstance(vv, dict):
                u = vv.get("uri") or vv.get("path")
                if isinstance(u, str) and u:
                    return u
    return None

def _vsp__counts_from_summary(summ):
    counts = (summ or {}).get("counts_total") or {}
    if isinstance(counts, dict):
        return {k:int(counts.get(k,0) or 0) for k in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE")}
    return {k:0 for k in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE")}

def _vsp__counts_from_unified(fu):
    meta = (fu or {}).get("meta") if isinstance(fu, dict) else None
    c = (meta or {}).get("counts_by_severity") if isinstance(meta, dict) else None
    if isinstance(c, dict):
        return {k:int(c.get(k,0) or 0) for k in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE")}
    return None

def _vsp__sum_counts(c):
    return sum(int(c.get(k,0) or 0) for k in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"))

def _vsp__tool_counts_from_summary(summ):
    by = (summ or {}).get("by_tool") or {}
    out = {}
    if not isinstance(by, dict):
        return out
    for t, tv in by.items():
        if not isinstance(tv, dict):
            continue
        c = tv.get("counts") if isinstance(tv.get("counts"), dict) else {}
        out[t] = {
            "CRITICAL": int((c or {}).get("CRITICAL",0) or 0),
            "HIGH": int((c or {}).get("HIGH",0) or 0),
            "MEDIUM": int((c or {}).get("MEDIUM",0) or 0),
            "LOW": int((c or {}).get("LOW",0) or 0),
            "INFO": int((c or {}).get("INFO",0) or 0),
            "TRACE": int((c or {}).get("TRACE",0) or 0),
        }
    return out

def _vsp__trend_from_recent_runs(base, limit=12):
    trend = []
    try:
        j = _vsp__http_json(base, f"/api/vsp/runs?limit={limit}", timeout=2.5)
        items = (j or {}).get("items") or []
        for it in items:
            rid = (it or {}).get("run_id") if isinstance(it, dict) else None
            if not rid:
                continue
            try:
                summ = _vsp__run_file_json(base, rid, "reports/run_gate_summary.json", timeout=2.0)
                fu = _vsp__run_file_json(base, rid, "reports/findings_unified.json", timeout=2.0)
                cu = _vsp__counts_from_unified(fu)
                cs = _vsp__counts_from_summary(summ)
                counts = cu if (cu and _vsp__sum_counts(cu) > 0) else cs
                total = _vsp__sum_counts(counts)
                trend.append({"rid": rid, "total": total, "overall": (summ or {}).get("overall") or "UNKNOWN"})
            except Exception:
                continue
    except Exception:
        pass
    return trend

class _VSPDashKpisChartsMW_V3:
    def __init__(self, app):
        base_wsgi = globals().get("_vsp_base_wsgi")
        self.app = base_wsgi(app) if callable(base_wsgi) else getattr(app, "wsgi_app", app)

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path not in ("/api/vsp/dash_kpis", "/api/vsp/dash_charts"):
            return self.app(environ, start_response)

        base = _vsp__base_url_from_environ(environ)
        qs = _parse_qs(environ.get("QUERY_STRING") or "")
        rid = (qs.get("rid") or [""])[0] or _vsp__get_latest_rid(base)

        try:
            summ = _vsp__run_file_json(base, rid, "reports/run_gate_summary.json", timeout=4.0)
        except Exception:
            summ = {}

        try:
            fu = _vsp__run_file_json(base, rid, "reports/findings_unified.json", timeout=4.0)
        except Exception:
            fu = {}

        cs = _vsp__counts_from_summary(summ)
        cu = _vsp__counts_from_unified(fu)
        counts = cu if (cu and _vsp__sum_counts(cu) > 0) else cs
        total = _vsp__sum_counts(counts)

        overall = (summ or {}).get("overall") or "UNKNOWN"
        tool_counts = _vsp__tool_counts_from_summary(summ)

        # derive top tool/cwe/module from unified items (best-effort)
        items = _vsp__extract_findings_list(fu)
        cwe_cnt, mod_cnt, tool_cnt = {}, {}, {}
        for f in (items or [])[:2500]:
            t = _vsp__pick_tool(f)
            if t:
                tool_cnt[t] = tool_cnt.get(t,0)+1
            cwe = _vsp__pick_cwe(f)
            if cwe:
                cwe_cnt[cwe] = cwe_cnt.get(cwe,0)+1
            pth = _vsp__pick_path(f)
            if pth:
                key = pth.split("?")[0]
                if "/" in key:
                    key = "/".join(key.split("/")[:4])
                mod_cnt[key] = mod_cnt.get(key,0)+1

        top_tool = sorted(tool_cnt.items(), key=lambda x:x[1], reverse=True)[0][0] if tool_cnt else None
        top_cwe = sorted(cwe_cnt.items(), key=lambda x:x[1], reverse=True)[0][0] if cwe_cnt else None
        top_mod = sorted(mod_cnt.items(), key=lambda x:x[1], reverse=True)[0][0] if mod_cnt else None

        if path == "/api/vsp/dash_kpis":
            out = {
                "ok": True,
                "rid": rid,
                "overall": overall,
                "total_findings": total,
                "counts_total": counts,
                "security_score": (summ or {}).get("security_score") or _vsp__score_from_total(total),
                "top_risky_tool": top_tool,
                "top_impacted_cwe": top_cwe,
                "top_vulnerable_module": top_mod,
                "notes": {
                    "counts_source": "findings_unified.meta.counts_by_severity" if (cu and _vsp__sum_counts(cu)>0) else "run_gate_summary.counts_total"
                }
            }
        else:
            sev = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"]
            # prefer tool counts from summary schema by_tool.*.counts
            cht = []
            for t, c in tool_counts.items():
                cht.append({"tool": t, "critical": int(c.get("CRITICAL",0)), "high": int(c.get("HIGH",0))})
            out = {
                "ok": True,
                "rid": rid,
                "severity_distribution": [{"sev":k,"count":int(counts.get(k,0) or 0)} for k in sev],
                "critical_high_by_tool": cht[:30],
                "top_cwe_exposure": [{"cwe":k,"count":v} for k,v in sorted(cwe_cnt.items(), key=lambda x:x[1], reverse=True)[:12]],
                "findings_trend": _vsp__trend_from_recent_runs(base, limit=12),
            }

        body = _json.dumps(out, ensure_ascii=False).encode("utf-8")
        start_response("200 OK", [
            ("Content-Type","application/json; charset=utf-8"),
            ("Cache-Control","no-cache"),
            ("Content-Length", str(len(body))),
        ])
        return [body]

try:
    application.wsgi_app = _VSPDashKpisChartsMW_V3(application.wsgi_app)
except Exception:
    pass



# VSP_P1_DASH_SCHEMA_COMPAT_V4
import json as _json
from urllib.parse import parse_qs as _parse_qs

def _vsp__mk_donut(counts):
    sev = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"]
    vals = [int((counts or {}).get(k,0) or 0) for k in sev]
    return {"labels": sev, "values": vals}

def _vsp__mk_trend(trend_list):
    labels = [x.get("rid","") for x in (trend_list or []) if isinstance(x, dict)]
    values = [int(x.get("total",0) or 0) for x in (trend_list or []) if isinstance(x, dict)]
    return {"labels": labels, "values": values}

def _vsp__mk_bar_crit_high(ch_list):
    labels = [x.get("tool","") for x in (ch_list or []) if isinstance(x, dict)]
    crit = [int(x.get("critical",0) or 0) for x in (ch_list or []) if isinstance(x, dict)]
    high = [int(x.get("high",0) or 0) for x in (ch_list or []) if isinstance(x, dict)]
    return {"labels": labels, "series": [{"name":"CRITICAL","data":crit},{"name":"HIGH","data":high}]}

def _vsp__mk_top_list(kvs, key_name):
    labels = [k for k,_ in kvs]
    values = [int(v) for _,v in kvs]
    return {"labels": labels, "values": values, "key": key_name}

class _VSPDashSchemaCompatMW_V4:
    def __init__(self, app):
        base_wsgi = globals().get("_vsp_base_wsgi")
        self.app = base_wsgi(app) if callable(base_wsgi) else getattr(app, "wsgi_app", app)

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if path not in ("/api/vsp/dash_kpis", "/api/vsp/dash_charts"):
            return self.app(environ, start_response)

        # reuse helpers from V3 if present
        base_fn = globals().get("_vsp__base_url_from_environ")
        base = base_fn(environ) if callable(base_fn) else "http://127.0.0.1:8910"

        qs = _parse_qs(environ.get("QUERY_STRING") or "")
        rid = (qs.get("rid") or [""])[0] or (globals().get("_vsp__get_latest_rid")(base) if callable(globals().get("_vsp__get_latest_rid")) else "")

        run_file = globals().get("_vsp__run_file_json")
        counts_from_s = globals().get("_vsp__counts_from_summary")
        counts_from_u = globals().get("_vsp__counts_from_unified")
        sum_counts = globals().get("_vsp__sum_counts")
        score_fn = globals().get("_vsp__score_from_total")
        tool_counts_fn = globals().get("_vsp__tool_counts_from_summary")
        trend_fn = globals().get("_vsp__trend_from_recent_runs")
        extract_items = globals().get("_vsp__extract_findings_list")
        pick_tool = globals().get("_vsp__pick_tool")
        pick_cwe = globals().get("_vsp__pick_cwe")
        pick_path = globals().get("_vsp__pick_path")

        summ = {}
        fu = {}
        try:
            if callable(run_file): summ = run_file(base, rid, "reports/run_gate_summary.json", timeout=4.0)
        except Exception:
            summ = {}
        try:
            if callable(run_file): fu = run_file(base, rid, "reports/findings_unified.json", timeout=4.0)
        except Exception:
            fu = {}

        cs = counts_from_s(summ) if callable(counts_from_s) else {}
        cu = counts_from_u(fu) if callable(counts_from_u) else None
        counts = cu if (cu and (sum_counts(cu) if callable(sum_counts) else 0) > 0) else cs
        total = (sum_counts(counts) if callable(sum_counts) else sum(int(counts.get(k,0) or 0) for k in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE")))

        overall = (summ or {}).get("overall") or "UNKNOWN"
        security_score = (summ or {}).get("security_score") or (score_fn(total) if callable(score_fn) else 0)

        # derive best-effort top_* from unified items
        items = extract_items(fu) if callable(extract_items) else []
        tool_cnt, cwe_cnt, mod_cnt = {}, {}, {}
        for f in (items or [])[:2500]:
            t = pick_tool(f) if callable(pick_tool) else None
            if t: tool_cnt[t] = tool_cnt.get(t,0)+1
            cwe = pick_cwe(f) if callable(pick_cwe) else None
            if cwe: cwe_cnt[cwe] = cwe_cnt.get(cwe,0)+1
            pth = pick_path(f) if callable(pick_path) else None
            if pth:
                key = pth.split("?")[0]
                if "/" in key: key = "/".join(key.split("/")[:4])
                mod_cnt[key] = mod_cnt.get(key,0)+1

        top_tool = sorted(tool_cnt.items(), key=lambda x:x[1], reverse=True)[0][0] if tool_cnt else None
        top_cwe = sorted(cwe_cnt.items(), key=lambda x:x[1], reverse=True)[0][0] if cwe_cnt else None
        top_mod = sorted(mod_cnt.items(), key=lambda x:x[1], reverse=True)[0][0] if mod_cnt else None

        if path == "/api/vsp/dash_kpis":
            out = {
                "ok": True,
                "rid": rid,
                "overall": overall,
                "total_findings": total,
                "total": total,
                "counts_total": counts,
                "counts": counts,
                "security_score": security_score,
                "score": security_score,
                "top_risky_tool": top_tool,
                "top_tool": top_tool,
                "top_impacted_cwe": top_cwe,
                "top_cwe": top_cwe,
                "top_vulnerable_module": top_mod,
                "top_module": top_mod,
            }
        else:
            sev_dist = [{"sev":k,"count":int(counts.get(k,0) or 0)} for k in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE")]
            tool_counts = tool_counts_fn(summ) if callable(tool_counts_fn) else {}
            ch = [{"tool":t, "critical":int(c.get("CRITICAL",0)), "high":int(c.get("HIGH",0))} for t,c in (tool_counts or {}).items() if isinstance(c, dict)]

            trend = trend_fn(base, limit=12) if callable(trend_fn) else [{"rid":rid,"total":total,"overall":overall}]

            top_cwe_pairs = sorted(cwe_cnt.items(), key=lambda x:x[1], reverse=True)[:12]
            out = {
                "ok": True,
                "rid": rid,

                # existing keys (v3)
                "severity_distribution": sev_dist,
                "critical_high_by_tool": ch[:30],
                "top_cwe_exposure": [{"cwe":k,"count":v} for k,v in top_cwe_pairs],
                "findings_trend": trend,

                # compat aliases (to satisfy unknown JS expectations)
                "sev_dist": sev_dist,
                "sev_donut": sev_dist,
                "donut": _vsp__mk_donut(counts),

                "trend": _vsp__mk_trend(trend),
                "trend_series": _vsp__mk_trend(trend),

                "bar_crit_high": _vsp__mk_bar_crit_high(ch[:30]),
                "crit_high_bar": _vsp__mk_bar_crit_high(ch[:30]),

                "top_cwe": _vsp__mk_top_list(top_cwe_pairs, "cwe"),
                "cwe_top": _vsp__mk_top_list(top_cwe_pairs, "cwe"),

                "charts": {
                    "severity": {"distribution": sev_dist, "donut": _vsp__mk_donut(counts)},
                    "trend": {"points": trend, "series": _vsp__mk_trend(trend)},
                    "crit_high_by_tool": {"rows": ch[:30], "bar": _vsp__mk_bar_crit_high(ch[:30])},
                    "top_cwe": {"rows": [{"cwe":k,"count":v} for k,v in top_cwe_pairs], "series": _vsp__mk_top_list(top_cwe_pairs, "cwe")},
                }
            }

        body = _json.dumps(out, ensure_ascii=False).encode("utf-8")
        start_response("200 OK", [
            ("Content-Type","application/json; charset=utf-8"),
            ("Cache-Control","no-cache"),
            ("Content-Length", str(len(body))),
        ])
        return [body]

try:
    application.wsgi_app = _VSPDashSchemaCompatMW_V4(application.wsgi_app)
except Exception:
    pass




# === VSP_P1_STRIP_INLINE_DASH_AND_RID_LATEST_WSGIMW_V2 BEGIN ===
# Fix: capture BOTH iterable body and legacy start_response(write) body to avoid empty responses.
try:
    import re as _re
    import json as _json

    class _VspStripInlineDashAndRidLatestMW_V2:
        def __init__(self, app):
            self.app = app

        def __call__(self, environ, start_response):
            path = (environ.get("PATH_INFO") or "")
            captured = {"status": None, "headers": None, "exc": None}
            body_chunks = []

            def _sr(status, headers, exc_info=None):
                captured["status"] = status
                captured["headers"] = list(headers or [])
                captured["exc"] = exc_info

                # WSGI legacy: return a write() callable
                def write(data):
                    try:
                        if data:
                            if isinstance(data, str):
                                data = data.encode("utf-8", errors="replace")
                            body_chunks.append(data)
                    except Exception:
                        pass
                return write

            try:
                it = self.app(environ, _sr)
                for b in it:
                    if not b:
                        continue
                    if isinstance(b, str):
                        b = b.encode("utf-8", errors="replace")
                    body_chunks.append(b)
                if hasattr(it, "close"):
                    it.close()
            except Exception:
                return self.app(environ, start_response)

            status = captured["status"] or "200 OK"
            headers = captured["headers"] or []
            body = b"".join(body_chunks)

            def _get_header(name: str):
                ln = name.lower()
                for k, v in headers:
                    if str(k).lower() == ln:
                        return v
                return None

            ct = (_get_header("Content-Type") or "").lower()

            # A) Schema compat: ensure rid_latest on /api/vsp/runs JSON
            if path == "/api/vsp/runs" and ("application/json" in ct or ct.endswith("+json") or ct == ""):
                # ct can be empty if upstream MW forgets it; still attempt JSON parse guardedly
                try:
                    txt = body.decode("utf-8", errors="replace").strip()
                    if txt.startswith("{") and txt.endswith("}"):
                        j = _json.loads(txt)
                        if isinstance(j, dict) and ("rid_latest" not in j):
                            items = j.get("items") or []
                            if isinstance(items, list) and items:
                                rid0 = (items[0] or {}).get("run_id")
                                if rid0:
                                    j["rid_latest"] = rid0
                                    body = _json.dumps(j, ensure_ascii=False).encode("utf-8")
                                    # set ct if missing
                                    if not any(str(k).lower()=="content-type" for k,v in headers):
                                        headers.append(("Content-Type","application/json; charset=utf-8"))
                except Exception:
                    pass

            # B) Strip injected inline dash scripts on /vsp5 HTML (outermost)
            if path == "/vsp5" and ("text/html" in ct or ct == ""):
                try:
                    html = body.decode("utf-8", errors="replace")

                    def _kill_script(m):
                        whole = m.group(0)
                        inner = m.group(2) or ""
                        sigs = [
                            "rid_latest", "vsp_live_rid", "vsp_rid_latest_badge",
                            "containers/rid", "Chart/container", "[VSP][DASH]",
                            "gave up", "container missing"
                        ]
                        if any(s in inner for s in sigs):
                            return ""
                        return whole

                    html2 = _re.sub(r"(<script[^>]*>)(.*?)(</script>)", _kill_script, html, flags=_re.S|_re.I)
                    if html2 != html:
                        body = html2.encode("utf-8")
                        headers = [(k, v) for (k, v) in headers if str(k).lower() not in ("content-length", "cache-control")]
                        headers.append(("Cache-Control", "no-store"))
                except Exception:
                    pass

            # normalize Content-Length
            headers = [(k, v) for (k, v) in headers if str(k).lower() != "content-length"]
            headers.append(("Content-Length", str(len(body))))

            start_response(status, headers, captured["exc"])
            return [body]

    # Replace wsgi_app with V2 (outermost)
    try:
        application.wsgi_app = _VspStripInlineDashAndRidLatestMW_V2(application.wsgi_app)
    except Exception:
        pass

except Exception:
    pass
# === VSP_P1_STRIP_INLINE_DASH_AND_RID_LATEST_WSGIMW_V2 END ===


# ===== VSP_P0_ROUTE_ALIAS_VSP5_RUNS_V2 =====
try:
    # prefer app if exists
    _app = globals().get("app", None)
    if _app is not None:
        @_app.route("/vsp5/runs")
        def vsp5_runs_alias_v2():
            from flask import redirect
            return redirect("/runs", code=302)
    # or blueprint if app not present
    _bp = globals().get("bp", None) or globals().get("runs_bp", None)
    if _bp is not None:
        @_bp.route("/vsp5/runs")
        def vsp5_runs_alias_bp_v2():
            from flask import redirect
            return redirect("/runs", code=302)
except Exception:
    pass
# ===== end VSP_P0_ROUTE_ALIAS_VSP5_RUNS_V2 =====



# === VSP_P0_RUNS_NEVER503_MW_V1 ===
import json as _vsp_json

class _VSPRunsNever503MW:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/runs"):
            return self.app(environ, start_response)

        status_headers = {"status": None, "headers": None}
        body_chunks = []

        def _sr(status, headers, exc_info=None):
            status_headers["status"] = status
            status_headers["headers"] = headers
            def _write(x):
                if x:
                    body_chunks.append(x if isinstance(x, (bytes, bytearray)) else str(x).encode("utf-8", "replace"))
            return _write

        try:
            res = self.app(environ, _sr)
            for ch in res:
                if ch:
                    body_chunks.append(ch if isinstance(ch, (bytes, bytearray)) else str(ch).encode("utf-8", "replace"))
            if hasattr(res, "close"):
                try: res.close()
                except Exception: pass

            st = status_headers["status"] or "500 INTERNAL SERVER ERROR"
            code = int(st.split()[0])
            if code >= 500:
                payload = {
                    "ok": True,
                    "degraded": True,
                    "degraded_reason": f"upstream_http_{code}",
                    "limit": 0,
                    "items": [],
                    "rid_latest": None,
                }
                out = _vsp_json.dumps(payload).encode("utf-8")
                hdrs = [
                    ("Content-Type","application/json; charset=utf-8"),
                    ("Cache-Control","no-store"),
                    ("Content-Length", str(len(out))),
                    ("X-VSP-RUNS-CONTRACT","P1_WSGI_V2"),
                    ("X-VSP-DEGRADED","1"),
                ]
                start_response("200 OK", hdrs)
                return [out]

            # pass-through original
            start_response(st, status_headers["headers"] or [])
            return [b"".join(body_chunks)]

        except Exception as e:
            payload = {
                "ok": True,
                "degraded": True,
                "degraded_reason": "exception",
                "error": str(e),
                "limit": 0,
                "items": [],
                "rid_latest": None,
            }
            out = _vsp_json.dumps(payload).encode("utf-8")
            hdrs = [
                ("Content-Type","application/json; charset=utf-8"),
                ("Cache-Control","no-store"),
                ("Content-Length", str(len(out))),
                ("X-VSP-RUNS-CONTRACT","P1_WSGI_V2"),
                ("X-VSP-DEGRADED","1"),
            ]
            start_response("200 OK", hdrs)
            return [out]

def _vsp_wrap_runs_never503(app):
    return _VSPRunsNever503MW(app)

try:
    if "application" in globals():
        application = _vsp_wrap_runs_never503(application)
    elif "app" in globals():
        app = _vsp_wrap_runs_never503(app)
except Exception as _e:
    print("[VSP][WARN] runs never503 mw attach failed:", _e)
# === END VSP_P0_RUNS_NEVER503_MW_V1 ===



# VSP_P0_STRIP_FILLREAL_RUNS_RESPONSE_V1
def _vsp_mw_strip_fillreal_on_runs(app):
    """WSGI MW: for /runs, strip vsp_fill_real_data_5tabs_p1_v1.js script tag from HTML."""
    def _mw(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not (path == "/runs" or path.startswith("/runs/")):
            return app(environ, start_response)

        captured = {"status": None, "headers": None, "exc": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            # delay actual start_response until body is processed

        it = app(environ, _sr)
        chunks = []
        try:
            for c in it:
                if c:
                    chunks.append(c)
        finally:
            try:
                close = getattr(it, "close", None)
                if callable(close): close()
            except Exception:
                pass

        status = captured["status"] or "200 OK"
        headers = captured["headers"] or []
        body = b"".join(chunks)

        # detect content-type
        ct = ""
        for k, v in headers:
            if str(k).lower() == "content-type":
                ct = str(v)
                break

        if body and ("text/html" in ct.lower()):
            try:
                html = body.decode("utf-8", "replace")
                # strip gateway marker comments too (runs-only)
                html = re.sub(r"\s*<!--\s*VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY\s*-->\s*", "", html, flags=re.I)
                html = re.sub(r"\s*<!--\s*/VSP_FILL_REAL_DATA_5TABS_P1_V1_GATEWAY\s*-->\s*", "", html, flags=re.I)
                # VSP_P0_STRIP_FILLREAL_MARKERS_ON_RUNS_V5

                # remove script tag (allow quotes, attrs, querystring)
                html2 = re.sub(
                    r"""\s*<script[^>]+src=['\"]?/static/js/vsp_fill_real_data_5tabs_p1_v1\.js[^'\"]*['\"][^>]*>\s*</script>\s*""",

                    "",

                    html,

                    flags=re.I

                )
                if html2 != html:
                    body = html2.encode("utf-8")
                    # fix content-length
                    headers = [(k, v) for (k, v) in headers if str(k).lower() != "content-length"]
                    headers.append(("Content-Length", str(len(body))))
            except Exception:
                pass

        start_response(status, headers, captured["exc"])
        return [body]
    return _mw


# VSP_P0_DISABLE_FILLREAL_INJECTOR_ON_RUNS_V2


# VSP_P0_FORCEHOOK_STRIP_FILLREAL_RUNS_V3
try:
    # prefer Flask app if present
    if "app" in globals():
        _a = globals().get("app")
        if _a is not None and hasattr(_a, "wsgi_app"):
            try:
                _a.wsgi_app = _vsp_mw_strip_fillreal_on_runs(_a.wsgi_app)
                globals()["app"] = _a
            except Exception:
                pass
    # gunicorn may point to "application"
    if "application" in globals():
        _appx = globals().get("application")
        if _appx is not None:
            try:
                globals()["application"] = _vsp_mw_strip_fillreal_on_runs(_appx)
            except Exception:
                pass
except Exception:
    pass


# --- VSP_P1_HEALTHZ_JSON_V1 ---
from flask import jsonify

def _vsp_best_effort_latest_rid():
    # Try to call local function if exists, else return N/A
    try:
        # some codebases expose a function or cache; keep safe
        return None
    except Exception:
        return None

@app.get("/healthz")
def vsp_healthz_json_v1():
    data = {
        "ui_up": True,
        "ts": int(time.time()),
        "pid": os.getpid(),
        "host": socket.gethostname(),
        "contract": "P1_HEALTHZ_V1",
    }
    # best effort: attach latest rid via internal API handler if present
    try:
        # If there is a local function already used by /api/vsp/runs, reuse by calling it directly
        # Otherwise, leave N/A (avoid HTTP self-call to prevent deadlocks)
        if "vsp_runs_api" in globals() and callable(globals().get("vsp_runs_api")):
            resp = globals()["vsp_runs_api"]()
            # might be flask Response/json; we won't hard parse
        data["last_rid"] = data.get("last_rid","N/A")
    except Exception:
        data["last_rid"] = data.get("last_rid","N/A")

    return jsonify(data), 200
# --- /VSP_P1_HEALTHZ_JSON_V1 ---



# --- VSP_P1_HEALTHZ_WSGI_STRICT_V4 ---
# Guarantee JSON response even if Flask routes/templates change.
def _vsp_healthz_wsgi_wrap(_next):
    import json, os, time, socket
    def _app(environ, start_response):
        try:
            if environ.get("PATH_INFO") == "/healthz":
                payload = json.dumps({
                    "ui_up": True,
                    "ts": int(time.time()),
                    "pid": os.getpid(),
                    "host": socket.gethostname(),
                    "contract": "P1_HEALTHZ_V4"
                }).encode("utf-8")
                start_response("200 OK", [
                    ("Content-Type", "application/json; charset=utf-8"),
                    ("Cache-Control", "no-store"),
                    ("Content-Length", str(len(payload))),
                ])
                return [payload]
        except Exception:
            pass
        return _next(environ, start_response)
    return _app

try:
    # gunicorn entrypoint in this module is typically `application`
    if "application" in globals() and callable(application):
        application = _vsp_healthz_wsgi_wrap(application)
except Exception:
    pass
# --- /VSP_P1_HEALTHZ_WSGI_STRICT_V4 ---



# === VSP_P0_STATIC_FORCE_SEND_V1 ===
# Commercial: force-serve static assets from disk (fix 200-but-empty body issues)
try:
    import os
    from flask import Response
except Exception:
    pass

@app.get("/static/<path:filename>")
def vsp_p0_static_force_send_v1(filename):
    try:
        root = os.path.join(os.path.dirname(__file__), "static")
        resp = send_from_directory(root, filename)
        # ensure not cached in dev; commercial can tune later
        resp.headers["Cache-Control"] = "no-cache"
        return resp
    except Exception as e:
        # explicit non-empty error
        return Response("static serve error: " + str(e), status=500, mimetype="text/plain")
# === END VSP_P0_STATIC_FORCE_SEND_V1 ===




# --- VSP_P1_GATE_STORY_AFTER_REQUEST_V1 ---
try:
    from flask import request as _vsp_req
except Exception:
    _vsp_req = None

@app.after_request
def _vsp_p1_gate_story_after_request_v1(resp):
    try:
        if _vsp_req is None:
            return resp
        if _vsp_req.path != "/vsp5":
            return resp
        ctype = (resp.headers.get("Content-Type","") or "").lower()
        # accept text/html + utf-8 variants
        if "text/html" not in ctype:
            return resp
        data = resp.get_data(as_text=True)
        if "vsp_dashboard_gate_story_v1.js" in data:
            return resp
        if "</body>" not in data:
            return resp
        script = '<script src="/static/js/vsp_dashboard_gate_story_v1.js?v={ asset_v }"></script> <!-- VSP_P1_GATE_STORY_PANEL_V1 -->\n'
        data2 = data.replace("</body>", script + "</body>")
        resp.set_data(data2)
        # fix content-length for some gunicorn/proxy combos
        resp.headers["Content-Length"] = str(len(data2.encode("utf-8", errors="ignore")))
        return resp
    except Exception:
        return resp
# --- /VSP_P1_GATE_STORY_AFTER_REQUEST_V1 ---



# --- VSP_P0_FIX_STATIC_ZERO_LEN_FORCE_SEND_V1 ---
try:
    from flask import request as _vsp_req
except Exception:
    _vsp_req = None

@app.after_request
def _vsp_p0_fix_static_zero_len_force_send_v1(resp):
    try:
        if _vsp_req is None:
            return resp
        # only for /static/*
        path = getattr(_vsp_req, "path", "") or ""
        if not path.startswith("/static/"):
            return resp
        if resp.status_code != 200:
            return resp

        # If Content-Length is 0 (bug), force load from disk.
        cl = resp.headers.get("Content-Length", "")
        if str(cl).strip() not in ("0", ""):
            return resp

        # map URL -> file path under ./static
        rel = path[len("/static/"):]
        static_dir = Path(__file__).resolve().parent / "static"
        fp = (static_dir / rel).resolve()

        # prevent traversal
        if static_dir.resolve() not in fp.parents and fp != static_dir.resolve():
            return resp
        if not fp.is_file():
            return resp

        data = fp.read_bytes()
        # HEAD should return empty body but correct Content-Length
        if (_vsp_req.method or "").upper() == "HEAD":
            resp.set_data(b"")
            resp.headers["Content-Length"] = str(len(data))
            return resp

        resp.set_data(data)
        resp.headers["Content-Length"] = str(len(data))
        return resp
    except Exception:
        return resp
# --- /VSP_P0_FIX_STATIC_ZERO_LEN_FORCE_SEND_V1 ---


# --- VSP_P0_WSGI_STATIC_LAST_MILE_FORCE_LEN_V1 ---
def _vsp_p0_wsgi_static_last_mile_force_len_v1(wsgi_app):
    import mimetypes
    from pathlib import Path

    base_dir = Path(__file__).resolve().parent
    static_dir = (base_dir / "static").resolve()

    def _app(environ, start_response):
        try:
            path = (environ.get("PATH_INFO") or "")
            method = (environ.get("REQUEST_METHOD") or "GET").upper()

            if not path.startswith("/static/"):
                return wsgi_app(environ, start_response)

            rel = path[len("/static/"):]
            fp = (static_dir / rel).resolve()

            # prevent traversal
            if static_dir not in fp.parents and fp != static_dir:
                return wsgi_app(environ, start_response)
            if not fp.is_file():
                return wsgi_app(environ, start_response)

            data = fp.read_bytes()

            ctype, _ = mimetypes.guess_type(str(fp))
            if not ctype:
                ext = fp.suffix.lower()
                if ext == ".js":
                    ctype = "text/javascript"
                elif ext == ".css":
                    ctype = "text/css"
                else:
                    ctype = "application/octet-stream"

            headers = [
                ("Content-Type", (ctype + "; charset=utf-8") if ctype.startswith("text/") else ctype),
                ("Content-Length", str(len(data))),
                ("Cache-Control", "no-cache"),
                ("Content-Disposition", "inline; filename=" + fp.name),
            ]

            start_response("200 OK", headers)
            if method == "HEAD":
                return [b""]
            return [data]

        except Exception:
            return wsgi_app(environ, start_response)

    return _app

try:
    app.wsgi_app = _vsp_p0_wsgi_static_last_mile_force_len_v1(app.wsgi_app)
except Exception:
    pass
# --- /VSP_P0_WSGI_STATIC_LAST_MILE_FORCE_LEN_V1 ---


# --- VSP_P1_WSGI_VSP5_SAFE_MODE_GATE_STORY_ONLY_V2 ---
def _vsp_p1_wsgi_vsp5_safe_mode_gate_story_only_v2(wsgi_app):
    import time

    def _app(environ, start_response):
        try:
            path = (environ.get("PATH_INFO") or "")
            method = (environ.get("REQUEST_METHOD") or "GET").upper()

            if path != "/vsp5":
                return wsgi_app(environ, start_response)

            asset_v = str(int(time.time()))
            html_lines = [
                "<!doctype html>",
                "<html lang=\"en\">",
                "<head>",
                "  <meta charset=\"utf-8\"/>",
                "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>",
                "  <meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\"/>",
                "  <meta http-equiv=\"Pragma\" content=\"no-cache\"/>",
                "  <meta http-equiv=\"Expires\" content=\"0\"/>",
                "  <title>VSP5</title>",
                "  <style>",
                "    body{ margin:0; background:#0b1220; color:rgba(226,232,240,.96);",
                "          font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }",
                "    .vsp5nav{ display:flex; gap:10px; padding:10px 14px; border-bottom:1px solid rgba(255,255,255,.10);",
                "              background: rgba(0,0,0,.22); position:sticky; top:0; z-index:9999; }",
                "    .vsp5nav a{ color:rgba(226,232,240,.92); text-decoration:none; font-size:12px;",
                "                padding:8px 10px; border:1px solid rgba(255,255,255,.14); border-radius:12px; }",
                "    .vsp5nav a:hover{ background: rgba(255,255,255,.06); }",
                "    #vsp5_root{ min-height: 60vh; }",
                "  </style>",
                "</head>",
                "<body>",
                "  <div class=\"vsp5nav\">",
                "    <a href=\"/vsp5\">Dashboard</a>",
                "    <a href=\"/runs\">Runs &amp; Reports</a>",
                "    <a href=\"/data_source\">Data Source</a>",
                "    <a href=\"/settings\">Settings</a>",
                "    <a href=\"/rule_overrides\">Rule Overrides</a>",
                "  </div>",
                "  <div id=\"vsp5_root\"></div>",
                "",
                "  <!-- SAFE MODE: only Gate Story script (NO legacy dash) -->",
                "  <script src=\"/static/js/vsp_dashboard_gate_story_v1.js?v=" + asset_v + "\"></script>",
                "</body>",
                "</html>",
            ]
            html = "\n".join(html_lines).encode("utf-8", errors="ignore")
            headers = [
                ("Content-Type", "text/html; charset=utf-8"),
                ("Cache-Control", "no-cache, no-store, must-revalidate"),
                ("Pragma", "no-cache"),
                ("Expires", "0"),
                ("Content-Length", str(len(html))),
            ]
            start_response("200 OK", headers)
            if method == "HEAD":
                return [b""]
            return [html]
        except Exception:
            return wsgi_app(environ, start_response)

    return _app

try:
    app.wsgi_app = _vsp_p1_wsgi_vsp5_safe_mode_gate_story_only_v2(app.wsgi_app)
except Exception:
    pass
# --- /VSP_P1_WSGI_VSP5_SAFE_MODE_GATE_STORY_ONLY_V2 ---



# --- VSP_P1_TABS3_BP_REGISTER_V1 ---
try:
    from vsp_tabs_extras_bp_v1 import vsp_tabs_extras_bp as _vsp_tabs_extras_bp_v1
    # register only if Flask app is available
    if "app" in globals() and hasattr(globals()["app"], "register_blueprint"):
        globals()["app"].register_blueprint(_vsp_tabs_extras_bp_v1)
        print("[VSP_TABS3] registered blueprint: vsp_tabs_extras_bp_v1")
    else:
        print("[VSP_TABS3] skip register (no app in globals)")
except Exception as _e:
    print("[VSP_TABS3] blueprint disabled:", _e)
# --- /VSP_P1_TABS3_BP_REGISTER_V1 ---


# --- VSP_P1_FIX_CONTENT_LENGTH_ZERO_V1 ---
try:
    @app.after_request
    def _vsp_fix_cl_zero(resp):
        try:
            ct = (resp.content_type or "")
            if ct.startswith("text/html"):
                cl = resp.headers.get("Content-Length")
                if cl == "0":
                    b = resp.get_data()
                    if b:
                        resp.headers["Content-Length"] = str(len(b))
        except Exception:
            pass
        return resp
except Exception as _e:
    print("[VSP_FIX_CL0] disabled:", _e)
# --- /VSP_P1_FIX_CONTENT_LENGTH_ZERO_V1 ---


# --- VSP_P1_TABS3_UI_BP_REGISTER_V2 ---
try:
    from vsp_tabs3_ui_bp_v2 import vsp_tabs3_ui_bp_v2 as _vsp_tabs3_ui_bp_v2
    if "app" in globals() and hasattr(globals()["app"], "register_blueprint"):
        globals()["app"].register_blueprint(_vsp_tabs3_ui_bp_v2)
        print("[VSP_TABS3_V2] registered blueprint: vsp_tabs3_ui_bp_v2")
except Exception as _e:
    print("[VSP_TABS3_V2] blueprint disabled:", _e)
# --- /VSP_P1_TABS3_UI_BP_REGISTER_V2 ---

# --- VSP_TABS3_UI_BP_REGISTER_V3 ---
try:
    from vsp_tabs3_ui_bp_v3 import vsp_tabs3_ui_bp_v3 as _vsp_tabs3_ui_bp_v3
    if "app" in globals() and hasattr(globals()["app"], "register_blueprint"):
        globals()["app"].register_blueprint(_vsp_tabs3_ui_bp_v3)
        print("[VSP_TABS3_V3] registered blueprint: vsp_tabs3_ui_bp_v3")
except Exception as _e:
    print("[VSP_TABS3_V3] blueprint disabled:", _e)
# --- /VSP_TABS3_UI_BP_REGISTER_V3 ---

# --- VSP_HTML_BODY_GUARD_OUTERMOST_V1 ---
try:
    from pathlib import Path as _Path
    class _VSPHtmlBodyGuard:
        def __init__(self, wsgi_app, ui_root):
            self.wsgi_app = wsgi_app
            self.ui_root = _Path(ui_root)
            self.map = {
                "/data_source": self.ui_root/"templates"/"vsp_data_source_2025.html",
                "/settings": self.ui_root/"templates"/"vsp_settings_2025.html",
                "/rule_overrides": self.ui_root/"templates"/"vsp_rule_overrides_2025.html",
            }

        def __call__(self, environ, start_response):
            path = environ.get("PATH_INFO", "") or ""
            captured = {"status": None, "headers": None}

            def _sr(status, headers, exc_info=None):
                captured["status"] = status
                captured["headers"] = list(headers)
                return start_response(status, headers, exc_info)

            app_iter = self.wsgi_app(environ, _sr)

            # collect body
            body = b""
            try:
                for chunk in app_iter:
                    if chunk:
                        body += chunk
            finally:
                try:
                    close = getattr(app_iter, "close", None)
                    if close: close()
                except Exception:
                    pass

            status = captured["status"] or "200 OK"
            headers = captured["headers"] or []
            ct = ""
            for k,v in headers:
                if k.lower() == "content-type":
                    ct = v or ""
                    break

            # If HTML 200 and body empty => replace with template file content
            if status.startswith("200") and ct.startswith("text/html") and len(body) == 0 and path in self.map:
                fp = self.map[path]
                try:
                    if fp.exists():
                        body = fp.read_bytes()
                        # rebuild headers: remove Content-Length, then add correct
                        new_headers = [(k,v) for (k,v) in headers if k.lower() != "content-length"]
                        new_headers.append(("Content-Length", str(len(body))))
                        # replace headers by calling start_response again (WSGI allows if not committed; gunicorn ok here)
                        start_response(status, new_headers)
                        return [body]
                except Exception as _e:
                    pass

            return [body]

    if "app" in globals() and hasattr(globals()["app"], "wsgi_app"):
        globals()["app"].wsgi_app = _VSPHtmlBodyGuard(globals()["app"].wsgi_app, str(_Path(__file__).resolve().parent))
        print("[VSP_HTML_GUARD] enabled outermost guard")
except Exception as _e:
    print("[VSP_HTML_GUARD] disabled:", _e)
# --- /VSP_HTML_BODY_GUARD_OUTERMOST_V1 ---


# VSP_P1_RUN_FILE_WHITELIST_V2_MOUNT
# --- VSP_P1_RUN_FILE_WHITELIST_V2_MOUNT: safe run_file endpoint (whitelist + no traversal) ---
def _vsp_p1_run_file_register_v2(app_obj):
    try:
        import os, mimetypes
        from pathlib import Path
        from flask import request, jsonify, send_file
    except Exception:
        return False

    if not app_obj or not hasattr(app_obj, "add_url_rule"):
        return False

    try:
        if hasattr(app_obj, "view_functions") and ("vsp_run_file_whitelist_v2" in app_obj.view_functions):
            return True
    except Exception:
        pass

    BASE_DIRS = [
        os.environ.get("VSP_OUT_DIR", "") or "",
        "/home/test/Data/SECURITY_BUNDLE/out",
        "/home/test/Data/SECURITY_BUNDLE/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
    ]
    BASE_DIRS = [d for d in BASE_DIRS if d and os.path.isdir(d)]

    ALLOW = {
        "run_gate.json",
        "run_gate_summary.json",
        "findings_unified.json",
        "findings_unified.sarif",
        "reports/findings_unified.csv",
        "reports/findings_unified.html",
        "reports/findings_unified.tgz",
        "reports/findings_unified.zip",
        "SUMMARY.txt",
    }

    _CACHE = {"rid2dir": {}}

    def _safe_rel(path: str) -> str:
        if not path:
            return ""
        path = path.strip().lstrip("/")
        if ".." in path.split("/"):
            return ""
        while "//" in path:
            path = path.replace("//", "/")
        return path

    def _max_bytes(rel: str) -> int:
        if rel.endswith(".tgz") or rel.endswith(".zip"):
            return 200 * 1024 * 1024
        if rel.endswith(".html"):
            return 80 * 1024 * 1024
        return 25 * 1024 * 1024

    def _find_run_dir(rid: str):
        rid = (rid or "").strip()
        if not rid:
            return None
        if rid in _CACHE["rid2dir"]:
            v = _CACHE["rid2dir"][rid]
            return Path(v) if v else None

        for b in BASE_DIRS:
            cand = Path(b) / rid
            if cand.is_dir():
                _CACHE["rid2dir"][rid] = str(cand)
                return cand

        # bounded shallow search
        for b in BASE_DIRS:
            base = Path(b)
            try:
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    cand = d1 / rid
                    if cand.is_dir():
                        _CACHE["rid2dir"][rid] = str(cand)
                        return cand
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    for d2 in d1.iterdir():
                        if not d2.is_dir(): continue
                        cand = d2 / rid
                        if cand.is_dir():
                            _CACHE["rid2dir"][rid] = str(cand)
                            return cand
            except Exception:
                continue

        _CACHE["rid2dir"][rid] = ""
        return None

    def vsp_run_file_whitelist_v2():
        rid = (request.args.get("rid") or "").strip()
        rel = _safe_rel(request.args.get("path") or "")
        if not rid or not rel:
            return jsonify({"ok": False, "err": "missing rid/path"}), 400
        if rel not in ALLOW:
            return jsonify({"ok": False, "err": "path not allowed", "allow": sorted(ALLOW)}), 403

        run_dir = _find_run_dir(rid)
        if not run_dir:
            return jsonify({"ok": False, "err": "run_dir not found", "rid": rid, "roots_used": BASE_DIRS}), 404

        fp = (run_dir / rel)
        try:
            fp_res = fp.resolve()
            rd_res = run_dir.resolve()
            if rd_res not in fp_res.parents and fp_res != rd_res:
                return jsonify({"ok": False, "err": "blocked escape"}), 403
        except Exception:
            return jsonify({"ok": False, "err": "resolve failed"}), 403

        if not fp.exists() or not fp.is_file():
            return jsonify({"ok": False, "err": "file not found", "path": rel}), 404

        try:
            sz = fp.stat().st_size
        except Exception:
            sz = -1
        lim = _max_bytes(rel)
        if sz >= 0 and sz > lim:
            return jsonify({"ok": False, "err": "file too large", "size": sz, "limit": lim}), 413

        mime, _ = mimetypes.guess_type(str(fp))
        mime = mime or "application/octet-stream"
        as_attach = rel.endswith(".tgz") or rel.endswith(".zip")
        dl_name = f"{rid}__{rel.replace('/','_')}"
        return send_file(str(fp), mimetype=mime, as_attachment=as_attach, download_name=dl_name)

    try:
        app_obj.add_url_rule("/api/vsp/run_file", "vsp_run_file_whitelist_v2", vsp_run_file_whitelist_v2, methods=["GET"])
        print("[VSP_RUN_FILE] mounted /api/vsp/run_file (v2 whitelist)")
        return True
    except Exception as e:
        print("[VSP_RUN_FILE] mount failed:", e)
        return False
# --- end VSP_P1_RUN_FILE_WHITELIST_V2_MOUNT ---

# auto-register run_file on import (best-effort)
try:
    _app = globals().get("app", None) or globals().get("application", None)
    _vsp_p1_run_file_register_v2(_app)
except Exception:
    pass


# --- VSP_TABS3_SHORTCIRCUIT_HTML_V1 ---
try:
    from pathlib import Path as _Path

    class _VSPTabs3ShortCircuit:
        def __init__(self, wsgi_app, ui_root: str):
            self.wsgi_app = wsgi_app
            self.ui_root = _Path(ui_root).resolve()
            self.map = {
                "/data_source": self.ui_root / "templates" / "vsp_data_source_2025.html",
                "/settings": self.ui_root / "templates" / "vsp_settings_2025.html",
                "/rule_overrides": self.ui_root / "templates" / "vsp_rule_overrides_2025.html",
            }

        def __call__(self, environ, start_response):
            path = (environ.get("PATH_INFO") or "").strip()
            method = (environ.get("REQUEST_METHOD") or "GET").upper()

            fp = self.map.get(path)
            if fp and fp.exists():
                try:
                    body = fp.read_bytes()
                except Exception:
                    body = b""

                headers = [
                    ("Content-Type", "text/html; charset=utf-8"),
                    ("Cache-Control", "no-store"),
                    ("Content-Length", str(len(body))),
                ]
                start_response("200 OK", headers)

                # HEAD must return no body but keep Content-Length
                if method == "HEAD":
                    return [b""]
                return [body]

            return self.wsgi_app(environ, start_response)

    if "app" in globals() and hasattr(globals()["app"], "wsgi_app"):
        _ui_root = _Path(__file__).resolve().parent
        globals()["app"].wsgi_app = _VSPTabs3ShortCircuit(globals()["app"].wsgi_app, str(_ui_root))
        print("[VSP_TABS3_SC] short-circuit enabled for /data_source,/settings,/rule_overrides")
except Exception as _e:
    print("[VSP_TABS3_SC] disabled:", _e)
# --- /VSP_TABS3_SHORTCIRCUIT_HTML_V1 ---


# VSP_P1_RUN_FILE_FINDER_FALLBACK_V3
# --- VSP_P1_RUN_FILE_FINDER_FALLBACK_V3: upgrade run_file handler to find run_dir robustly + fallback gate ---
def _vsp_p1_run_file_upgrade_v3(app_obj):
    try:
        import os, time, mimetypes
        from pathlib import Path
        from flask import request, jsonify, send_file
    except Exception:
        return False

    if not app_obj or not hasattr(app_obj, "add_url_rule"):
        return False

    # base roots (fast path)
    BASE_DIRS = [
        os.environ.get("VSP_OUT_DIR", "") or "",
        "/home/test/Data/SECURITY_BUNDLE/out",
        "/home/test/Data/SECURITY_BUNDLE/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        "/home/test/Data/SECURITY-10-10-v4/out_ci",  # common in your env (safe to include)
    ]
    BASE_DIRS = [d for d in BASE_DIRS if d and os.path.isdir(d)]

    # bounded deep finder root (slow path, only on demand)
    DEEP_ROOT = os.environ.get("VSP_DEEP_RUN_ROOT", "/home/test/Data")
    if not os.path.isdir(DEEP_ROOT):
        DEEP_ROOT = ""

    ALLOW = {
        "run_gate.json",
        "run_gate_summary.json",
        "findings_unified.json",
        "findings_unified.sarif",
        "reports/findings_unified.csv",
        "reports/findings_unified.html",
        "reports/findings_unified.tgz",
        "reports/findings_unified.zip",
        "SUMMARY.txt",
    }

    _CACHE = {"rid2dir": {}}

    def _safe_rel(path: str) -> str:
        if not path:
            return ""
        path = path.strip().lstrip("/")
        if ".." in path.split("/"):
            return ""
        while "//" in path:
            path = path.replace("//", "/")
        return path

    def _max_bytes(rel: str) -> int:
        if rel.endswith(".tgz") or rel.endswith(".zip"):
            return 200 * 1024 * 1024
        if rel.endswith(".html"):
            return 80 * 1024 * 1024
        return 25 * 1024 * 1024

    def _deep_find_dir(rid: str):
        """Bounded os.walk: depth<=6, stop after ~40k dirs or 2.5s."""
        if not DEEP_ROOT:
            return None
        start = time.time()
        max_secs = 2.5
        max_dirs = 40000
        seen = 0

        root = Path(DEEP_ROOT)
        root_depth = len(root.parts)

        try:
            for cur, dirs, files in os.walk(root, topdown=True):
                seen += 1
                if seen > max_dirs or (time.time() - start) > max_secs:
                    return None
                pcur = Path(cur)
                depth = len(pcur.parts) - root_depth
                if depth > 6:
                    dirs[:] = []
                    continue
                # prune heavy dirs (safe)
                prune = {"node_modules", ".git", "__pycache__", ".venv", "venv", "dist", "build"}
                dirs[:] = [d for d in dirs if d not in prune]
                if pcur.name == rid:
                    return pcur
        except Exception:
            return None
        return None

    def _find_run_dir(rid: str):
        rid = (rid or "").strip()
        if not rid:
            return None
        if rid in _CACHE["rid2dir"]:
            v = _CACHE["rid2dir"][rid]
            return Path(v) if v else None

        # fast: direct join
        for b in BASE_DIRS:
            cand = Path(b) / rid
            if cand.is_dir():
                _CACHE["rid2dir"][rid] = str(cand)
                return cand

        # fast: shallow search depth 2
        for b in BASE_DIRS:
            base = Path(b)
            try:
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    cand = d1 / rid
                    if cand.is_dir():
                        _CACHE["rid2dir"][rid] = str(cand)
                        return cand
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    for d2 in d1.iterdir():
                        if not d2.is_dir(): continue
                        cand = d2 / rid
                        if cand.is_dir():
                            _CACHE["rid2dir"][rid] = str(cand)
                            return cand
            except Exception:
                pass

        # slow: deep find (bounded)
        cand = _deep_find_dir(rid)
        if cand and cand.is_dir():
            _CACHE["rid2dir"][rid] = str(cand)
            return cand

        _CACHE["rid2dir"][rid] = ""
        return None

    def _resolve_safe(run_dir: Path, rel: str) -> Path | None:
        fp = (run_dir / rel)
        try:
            fp_res = fp.resolve()
            rd_res = run_dir.resolve()
            if rd_res not in fp_res.parents and fp_res != rd_res:
                return None
            return fp_res
        except Exception:
            return None

    def vsp_run_file_handler_v3():
        rid = (request.args.get("rid") or "").strip()
        rel = _safe_rel(request.args.get("path") or "")
        if not rid or not rel:
            return jsonify({"ok": False, "err": "missing rid/path"}), 400
        if rel not in ALLOW:
            return jsonify({"ok": False, "err": "path not allowed", "allow": sorted(ALLOW)}), 403

        run_dir = _find_run_dir(rid)
        if not run_dir:
            return jsonify({"ok": False, "err": "run_dir not found", "rid": rid, "roots_used": BASE_DIRS, "deep_root": DEEP_ROOT}), 404

        # fallback: if asking run_gate.json but missing, try summary
        rel_try = [rel]
        if rel == "run_gate.json":
            rel_try = ["run_gate.json", "run_gate_summary.json", "SUMMARY.txt"]

        picked = None
        for rr in rel_try:
            fp = _resolve_safe(run_dir, rr)
            if fp and fp.exists() and fp.is_file():
                picked = (rr, fp)
                break

        if not picked:
            # return helpful list of what exists among allowed
            exists = []
            for rr in sorted(ALLOW):
                fp = _resolve_safe(run_dir, rr)
                if fp and fp.exists() and fp.is_file():
                    exists.append(rr)
            return jsonify({"ok": False, "err": "file not found", "rid": rid, "path": rel, "run_dir": str(run_dir), "has": exists}), 404

        rr, fp = picked
        try:
            sz = fp.stat().st_size
        except Exception:
            sz = -1
        lim = _max_bytes(rr)
        if sz >= 0 and sz > lim:
            return jsonify({"ok": False, "err": "file too large", "size": sz, "limit": lim, "path": rr}), 413

        mime, _ = mimetypes.guess_type(str(fp))
        mime = mime or "application/octet-stream"
        as_attach = rr.endswith(".tgz") or rr.endswith(".zip")
        dl_name = f"{rid}__{rr.replace('/','_')}"
        resp = send_file(str(fp), mimetype=mime, as_attachment=as_attach, download_name=dl_name)
        try:
            if rr != rel:
                resp.headers["X-VSP-Fallback-Path"] = rr
        except Exception:
            pass
        return resp

    # prefer upgrade existing endpoint (your URL rule is already there)
    try:
        vf = getattr(app_obj, "view_functions", {}) or {}
        if "vsp_run_file_whitelist_v2" in vf:
            vf["vsp_run_file_whitelist_v2"] = vsp_run_file_handler_v3
            print("[VSP_RUN_FILE] upgraded endpoint v2 -> v3 handler")
            return True
    except Exception:
        pass

    # otherwise mount fresh
    try:
        app_obj.add_url_rule("/api/vsp/run_file", "vsp_run_file_handler_v3", vsp_run_file_handler_v3, methods=["GET"])
        print("[VSP_RUN_FILE] mounted /api/vsp/run_file (v3)")
        return True
    except Exception as e:
        print("[VSP_RUN_FILE] mount v3 failed:", e)
        return False
# --- end VSP_P1_RUN_FILE_FINDER_FALLBACK_V3 ---

try:
    _vsp_p1_run_file_upgrade_v3(globals().get('app') or globals().get('application'))
except Exception:
    pass


# VSP_P1_FORCE_RUN_FILE_HANDLER_V4
# --- VSP_P1_FORCE_RUN_FILE_HANDLER_V4: force-bind /api/vsp/run_file to whitelist handler (override any "not allowed") ---
def _vsp_p1_force_run_file_handler_v4(app_obj):
    try:
        import os, time, mimetypes
        from pathlib import Path
        from flask import request, jsonify, send_file
    except Exception:
        return False

    if not app_obj or not hasattr(app_obj, "url_map") or not hasattr(app_obj, "view_functions"):
        return False

    BASE_DIRS = [
        os.environ.get("VSP_OUT_DIR", "") or "",
        "/home/test/Data/SECURITY_BUNDLE/out",
        "/home/test/Data/SECURITY_BUNDLE/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        "/home/test/Data/SECURITY-10-10-v4/out_ci",
    ]
    BASE_DIRS = [d for d in BASE_DIRS if d and os.path.isdir(d)]

    DEEP_ROOT = os.environ.get("VSP_DEEP_RUN_ROOT", "/home/test/Data")
    if not os.path.isdir(DEEP_ROOT):
        DEEP_ROOT = ""

    ALLOW = {
        "run_gate.json",
        "run_gate_summary.json",
        "findings_unified.json",
        "findings_unified.sarif",
        "reports/findings_unified.csv",
        "reports/findings_unified.html",
        "reports/findings_unified.tgz",
        "reports/findings_unified.zip",
        "SUMMARY.txt",
    }

    _CACHE = {"rid2dir": {}}

    def _safe_rel(path: str) -> str:
        if not path:
            return ""
        path = path.strip().lstrip("/")
        if ".." in path.split("/"):
            return ""
        while "//" in path:
            path = path.replace("//", "/")
        return path

    def _max_bytes(rel: str) -> int:
        if rel.endswith(".tgz") or rel.endswith(".zip"):
            return 200 * 1024 * 1024
        if rel.endswith(".html"):
            return 80 * 1024 * 1024
        return 25 * 1024 * 1024

    def _deep_find_dir(rid: str):
        if not DEEP_ROOT:
            return None
        start = time.time()
        max_secs = 2.5
        max_dirs = 40000
        seen = 0
        root = Path(DEEP_ROOT)
        root_depth = len(root.parts)
        prune = {"node_modules", ".git", "__pycache__", ".venv", "venv", "dist", "build"}

        try:
            for cur, dirs, files in os.walk(root, topdown=True):
                seen += 1
                if seen > max_dirs or (time.time() - start) > max_secs:
                    return None
                pcur = Path(cur)
                depth = len(pcur.parts) - root_depth
                if depth > 6:
                    dirs[:] = []
                    continue
                dirs[:] = [d for d in dirs if d not in prune]
                if pcur.name == rid:
                    return pcur
        except Exception:
            return None
        return None

    def _find_run_dir(rid: str):
        rid = (rid or "").strip()
        if not rid:
            return None
        if rid in _CACHE["rid2dir"]:
            v = _CACHE["rid2dir"][rid]
            return Path(v) if v else None

        # direct
        for b in BASE_DIRS:
            cand = Path(b) / rid
            if cand.is_dir():
                _CACHE["rid2dir"][rid] = str(cand)
                return cand

        # shallow depth 2
        for b in BASE_DIRS:
            base = Path(b)
            try:
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    cand = d1 / rid
                    if cand.is_dir():
                        _CACHE["rid2dir"][rid] = str(cand)
                        return cand
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    for d2 in d1.iterdir():
                        if not d2.is_dir(): continue
                        cand = d2 / rid
                        if cand.is_dir():
                            _CACHE["rid2dir"][rid] = str(cand)
                            return cand
            except Exception:
                pass

        # deep bounded
        cand = _deep_find_dir(rid)
        if cand and cand.is_dir():
            _CACHE["rid2dir"][rid] = str(cand)
            return cand

        _CACHE["rid2dir"][rid] = ""
        return None

    def _resolve_safe(run_dir: Path, rel: str):
        fp = (run_dir / rel)
        try:
            fp_res = fp.resolve()
            rd_res = run_dir.resolve()
            if rd_res not in fp_res.parents and fp_res != rd_res:
                return None
            return fp_res
        except Exception:
            return None

    def vsp_run_file_v4():
        rid = (request.args.get("rid") or "").strip()
        rel = _safe_rel(request.args.get("path") or "")
        if not rid or not rel:
            return jsonify({"ok": False, "err": "missing rid/path"}), 400

        # keep "no auto probe" policy at UI-level; backend remains read-only whitelist
        if rel not in ALLOW:
            return jsonify({"ok": False, "err": "path not allowed", "allow": sorted(ALLOW)}), 403

        run_dir = _find_run_dir(rid)
        if not run_dir:
            return jsonify({"ok": False, "err": "run_dir not found", "rid": rid, "roots_used": BASE_DIRS, "deep_root": DEEP_ROOT}), 404

        rel_try = [rel]
        if rel == "run_gate.json":
            rel_try = ["run_gate.json", "run_gate_summary.json", "SUMMARY.txt"]

        picked = None
        for rr in rel_try:
            fp = _resolve_safe(run_dir, rr)
            if fp and fp.exists() and fp.is_file():
                picked = (rr, fp)
                break

        if not picked:
            exists = []
            for rr in sorted(ALLOW):
                fp = _resolve_safe(run_dir, rr)
                if fp and fp.exists() and fp.is_file():
                    exists.append(rr)
            return jsonify({"ok": False, "err": "file not found", "rid": rid, "path": rel, "run_dir": str(run_dir), "has": exists}), 404

        rr, fp = picked
        try:
            sz = fp.stat().st_size
        except Exception:
            sz = -1
        lim = _max_bytes(rr)
        if sz >= 0 and sz > lim:
            return jsonify({"ok": False, "err": "file too large", "size": sz, "limit": lim, "path": rr}), 413

        mime, _ = mimetypes.guess_type(str(fp))
        mime = mime or "application/octet-stream"
        as_attach = rr.endswith(".tgz") or rr.endswith(".zip")
        dl_name = f"{rid}__{rr.replace('/','_')}"
        resp = send_file(str(fp), mimetype=mime, as_attachment=as_attach, download_name=dl_name)
        try:
            if rr != rel:
                resp.headers["X-VSP-Fallback-Path"] = rr
        except Exception:
            pass
        return resp

    # FORCE override any existing endpoint bound to path "/api/vsp/run_file"
    endpoints = []
    try:
        for rule in app_obj.url_map.iter_rules():
            if getattr(rule, "rule", "") == "/api/vsp/run_file":
                endpoints.append(rule.endpoint)
    except Exception:
        endpoints = []

    ok = False
    for ep in set(endpoints):
        try:
            app_obj.view_functions[ep] = vsp_run_file_v4
            ok = True
        except Exception:
            pass

    if ok:
        print(f"[VSP_RUN_FILE] V4 force-bound endpoints={sorted(set(endpoints))}")
        return True

    # if no rule existed, mount it
    try:
        app_obj.add_url_rule("/api/vsp/run_file", "vsp_run_file_v4", vsp_run_file_v4, methods=["GET"])
        print("[VSP_RUN_FILE] V4 mounted fresh /api/vsp/run_file")
        return True
    except Exception as e:
        print("[VSP_RUN_FILE] V4 mount failed:", e)
        return False
# --- end VSP_P1_FORCE_RUN_FILE_HANDLER_V4 ---

# auto-bind on import (best-effort)
try:
    _app = globals().get("app", None) or globals().get("application", None)
    _vsp_p1_force_run_file_handler_v4(_app)
except Exception:
    pass


# VSP_P1_RUN_FILE_ALLOW_V5
# --- VSP_P1_RUN_FILE_ALLOW_V5: separate allow endpoint (keeps /api/vsp/run_file policy OFF) ---
def _vsp_p1_register_run_file_allow_v5(app_obj):
    try:
        import os, time, mimetypes
        from pathlib import Path
        from flask import request, jsonify, send_file
    except Exception:
        return False
    if not app_obj or not hasattr(app_obj, "add_url_rule"):
        return False

    # avoid double register
    try:
        if hasattr(app_obj, "view_functions") and ("vsp_run_file_allow_v5" in app_obj.view_functions):
            return True
    except Exception:
        pass

    BASE_DIRS = [
        os.environ.get("VSP_OUT_DIR", "") or "",
        "/home/test/Data/SECURITY_BUNDLE/out",
        "/home/test/Data/SECURITY_BUNDLE/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        "/home/test/Data/SECURITY-10-10-v4/out_ci",
    ]
    BASE_DIRS = [d for d in BASE_DIRS if d and os.path.isdir(d)]

    # bounded deep find root (only on demand)
    DEEP_ROOT = os.environ.get("VSP_DEEP_RUN_ROOT", "/home/test/Data")
    if not os.path.isdir(DEEP_ROOT):
        DEEP_ROOT = ""

    # strict whitelist
    ALLOW = {
        "run_gate.json",
        "run_gate_summary.json",
        "findings_unified.json",
        "findings_unified.sarif",
        "reports/findings_unified.csv",
        "reports/findings_unified.html",
        "reports/findings_unified.tgz",
        "reports/findings_unified.zip",
        "SUMMARY.txt",
    }

    _CACHE = {"rid2dir": {}}

    def _safe_rel(path: str) -> str:
        if not path:
            return ""
        path = path.strip().lstrip("/")
        if ".." in path.split("/"):
            return ""
        while "//" in path:
            path = path.replace("//", "/")
        return path

    def _max_bytes(rel: str) -> int:
        if rel.endswith(".tgz") or rel.endswith(".zip"):
            return 200 * 1024 * 1024
        if rel.endswith(".html"):
            return 80 * 1024 * 1024
        return 25 * 1024 * 1024

    def _deep_find_dir(rid: str):
        if not DEEP_ROOT:
            return None
        start = time.time()
        max_secs = 2.5
        max_dirs = 40000
        seen = 0
        root = Path(DEEP_ROOT)
        root_depth = len(root.parts)
        prune = {"node_modules", ".git", "__pycache__", ".venv", "venv", "dist", "build"}
        try:
            for cur, dirs, files in os.walk(root, topdown=True):
                seen += 1
                if seen > max_dirs or (time.time() - start) > max_secs:
                    return None
                pcur = Path(cur)
                depth = len(pcur.parts) - root_depth
                if depth > 6:
                    dirs[:] = []
                    continue
                dirs[:] = [d for d in dirs if d not in prune]
                if pcur.name == rid:
                    return pcur
        except Exception:
            return None
        return None

    def _find_run_dir(rid: str):
        rid = (rid or "").strip()
        if not rid:
            return None
        if rid in _CACHE["rid2dir"]:
            v = _CACHE["rid2dir"][rid]
            return Path(v) if v else None

        for b in BASE_DIRS:
            cand = Path(b) / rid
            if cand.is_dir():
                _CACHE["rid2dir"][rid] = str(cand)
                return cand

        for b in BASE_DIRS:
            base = Path(b)
            try:
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    cand = d1 / rid
                    if cand.is_dir():
                        _CACHE["rid2dir"][rid] = str(cand)
                        return cand
                for d1 in base.iterdir():
                    if not d1.is_dir(): continue
                    for d2 in d1.iterdir():
                        if not d2.is_dir(): continue
                        cand = d2 / rid
                        if cand.is_dir():
                            _CACHE["rid2dir"][rid] = str(cand)
                            return cand
            except Exception:
                pass

        cand = _deep_find_dir(rid)
        if cand and cand.is_dir():
            _CACHE["rid2dir"][rid] = str(cand)
            return cand

        _CACHE["rid2dir"][rid] = ""
        return None

    def _resolve_safe(run_dir: Path, rel: str):
        fp = (run_dir / rel)
        try:
            fp_res = fp.resolve()
            rd_res = run_dir.resolve()
            if rd_res not in fp_res.parents and fp_res != rd_res:
                return None
            return fp_res
        except Exception:
            return None

    def vsp_run_file_allow_v5():
        rid = (request.args.get("rid") or "").strip()
        rel = _safe_rel(request.args.get("path") or "")
        if not rid or not rel:
            return jsonify({"ok": False, "err": "missing rid/path"}), 400

        if rel not in ALLOW:
            return jsonify({"ok": False, "err": "not allowed", "allow": sorted(ALLOW)}), 403

        run_dir = _find_run_dir(rid)
        if not run_dir:
            return jsonify({"ok": False, "err": "run_dir not found", "rid": rid, "roots_used": BASE_DIRS, "deep_root": DEEP_ROOT}), 404

        rel_try = [rel]
        if rel == "run_gate.json":
            rel_try = ["run_gate.json", "run_gate_summary.json", "SUMMARY.txt"]

        picked = None
        for rr in rel_try:
            fp = _resolve_safe(run_dir, rr)
            if fp and fp.exists() and fp.is_file():
                picked = (rr, fp)
                break

        if not picked:
            exists = []
            for rr in sorted(ALLOW):
                fp = _resolve_safe(run_dir, rr)
                if fp and fp.exists() and fp.is_file():
                    exists.append(rr)
            return jsonify({"ok": False, "err": "file not found", "rid": rid, "path": rel, "run_dir": str(run_dir), "has": exists}), 404

        rr, fp = picked
        try:
            sz = fp.stat().st_size
        except Exception:
            sz = -1
        lim = _max_bytes(rr)
        if sz >= 0 and sz > lim:
            return jsonify({"ok": False, "err": "file too large", "size": sz, "limit": lim, "path": rr}), 413

        mime, _ = mimetypes.guess_type(str(fp))
        mime = mime or "application/octet-stream"
        as_attach = rr.endswith(".tgz") or rr.endswith(".zip")
        dl_name = f"{rid}__{rr.replace('/','_')}"
        resp = send_file(str(fp), mimetype=mime, as_attachment=as_attach, download_name=dl_name)
        try:
            if rr != rel:
                resp.headers["X-VSP-Fallback-Path"] = rr
        except Exception:
            pass
        return resp

    try:
        app_obj.add_url_rule("/api/vsp/run_file_allow", "vsp_run_file_allow_v5", vsp_run_file_allow_v5, methods=["GET"])
        print("[VSP_RUN_FILE_ALLOW] mounted /api/vsp/run_file_allow")
        return True
    except Exception as e:
        print("[VSP_RUN_FILE_ALLOW] mount failed:", e)
        return False
# --- end VSP_P1_RUN_FILE_ALLOW_V5 ---

try:
    _app = globals().get("app", None) or globals().get("application", None)
    _vsp_p1_register_run_file_allow_v5(_app)
except Exception:
    pass


# --- VSP_TABS3_UI_BP_REGISTER_V4 ---
try:
    from vsp_tabs3_ui_bp_v4 import vsp_tabs3_ui_bp_v4 as _vsp_tabs3_ui_bp_v4
    if "app" in globals() and hasattr(globals()["app"], "register_blueprint"):
        globals()["app"].register_blueprint(_vsp_tabs3_ui_bp_v4)
        print("[VSP_TABS3_V4] registered blueprint: vsp_tabs3_ui_bp_v4")
except Exception as _e:
    print("[VSP_TABS3_V4] blueprint disabled:", _e)
# --- /VSP_TABS3_UI_BP_REGISTER_V4 ---


# ============================================================
# VSP_P1_TABS3_API_ROUTES_AND_API404_V1
# - Ensure /api/ui/* routes exist (runs/findings/settings/rule_overrides/apply)
# - Ensure /api/* 404 returns JSON (no HTML injector)
# ============================================================
def _vsp__get_app_obj():
    try:
        return app  # type: ignore
    except Exception:
        pass
    try:
        return application  # type: ignore
    except Exception:
        pass
    return None

_vsp_app = _vsp__get_app_obj()
if _vsp_app:
    try:
        from flask import request, jsonify
    except Exception:
        request = None
        jsonify = None

    # --- harden 404 for /api/* ---
    try:
        @_vsp_app.errorhandler(404)
        def _vsp_api_404(e):  # noqa: F811
            try:
                path = (request.path if request else "")
            except Exception:
                path = ""
            if path.startswith("/api/"):
                payload = {"ok": False, "error": "HTTP_404_NOT_FOUND", "path": path, "ts": int(__import__("time").time())}
                return (jsonify(payload) if jsonify else ("Not Found", 404)), 404
            # keep existing behavior for non-api (simple)
            return ("Not Found", 404)
    except Exception as _e404:
        pass

    # --- add missing routes only (avoid duplicates) ---
    try:
        rules = {r.rule for r in _vsp_app.url_map.iter_rules()}
    except Exception:
        rules = set()

    def _add(rule, endpoint, view_func, methods):
        if rule in rules:
            return
        _vsp_app.add_url_rule(rule, endpoint=endpoint, view_func=view_func, methods=methods)

    try:
        from tools import vsp_tabs3_api_impl_v1 as _impl
    except Exception:
        _impl = None

    if _impl and request and jsonify:
        def _get_int(name, default):
            try:
                return int(request.args.get(name, default))
            except Exception:
                return default

        def _runs_v2():
            limit = _get_int("limit", 50)
            return jsonify(_impl.list_runs(limit=limit))

        def _findings_v2():
            rid = request.args.get("rid") or None
            limit = _get_int("limit", 50)
            offset = _get_int("offset", 0)
            q = request.args.get("q","")
            tool = request.args.get("tool","")
            severity = request.args.get("severity","ALL")
            return jsonify(_impl.findings_query(rid=rid, limit=limit, offset=offset, q=q, tool=tool, severity=severity))

        def _settings_v2():
            if request.method == "POST":
                obj = request.get_json(silent=True) or {}
                return jsonify(_impl.settings_save(obj))
            return jsonify(_impl.settings_get())

        def _rules_v2():
            if request.method == "POST":
                obj = request.get_json(silent=True) or {}
                return jsonify(_impl.rules_save(obj))
            return jsonify(_impl.rules_get())

        def _rules_apply_v2():
            obj = request.get_json(silent=True) or {}
            rid = obj.get("rid") or request.args.get("rid") or ""
            return jsonify(_impl.rules_apply_to_rid(str(rid)))

        _add("/api/ui/runs_v2", "vsp_ui_runs_v2", _runs_v2, ["GET"])
        _add("/api/ui/findings_v2", "vsp_ui_findings_v2", _findings_v2, ["GET"])
        _add("/api/ui/settings_v2", "vsp_ui_settings_v2", _settings_v2, ["GET","POST"])
        _add("/api/ui/rule_overrides_v2", "vsp_ui_rule_overrides_v2", _rules_v2, ["GET","POST"])
        _add("/api/ui/rule_overrides_apply_v2", "vsp_ui_rule_overrides_apply_v2", _rules_apply_v2, ["POST"])
# ============================================================


# ============================================================
# VSP_P1_APIUI_WSGI_SHIM_V1
# WSGI-level /api/ui/* handler (robust even if Flask routes can't be added)
# Endpoints:
#  - GET  /api/ui/runs_v2?limit=...
#  - GET  /api/ui/findings_v2?rid=&limit=&offset=&q=&tool=&severity=
#  - GET  /api/ui/settings_v2
#  - POST /api/ui/settings_v2   (json body)
#  - GET  /api/ui/rule_overrides_v2
#  - POST /api/ui/rule_overrides_v2 (json body)
#  - POST /api/ui/rule_overrides_apply_v2 (json body {rid})
# ============================================================
def _vsp__json_bytes(obj):
    import json
    return json.dumps(obj, ensure_ascii=False).encode("utf-8")

def _vsp__read_body(environ):
    try:
        n = int(environ.get("CONTENT_LENGTH") or "0")
    except Exception:
        n = 0
    if n <= 0:
        return b""
    try:
        return environ["wsgi.input"].read(n)  # type: ignore
    except Exception:
        return b""

def _vsp__parse_qs(environ):
    try:
        from urllib.parse import parse_qs
        return parse_qs(environ.get("QUERY_STRING","") or "")
    except Exception:
        return {}

def _vsp__qs_get(qs, k, default=""):
    v = qs.get(k)
    if not v:
        return default
    return v[0] if isinstance(v, list) else str(v)

def _vsp__qs_int(qs, k, default):
    try:
        return int(_vsp__qs_get(qs, k, str(default)))
    except Exception:
        return default

def _vsp__apiui_handle(environ):
    import json, time
    path = environ.get("PATH_INFO","") or ""
    method = (environ.get("REQUEST_METHOD","GET") or "GET").upper()
    try:
        from tools import vsp_tabs3_api_impl_v1 as _impl
    except Exception as e:
        return 500, {"ok": False, "error": "IMPL_IMPORT_FAILED", "detail": str(e), "path": path, "ts": int(time.time())}

    qs = _vsp__parse_qs(environ)

    if path == "/api/ui/runs_v2":
        if method != "GET":
            return 405, {"ok": False, "error": "METHOD_NOT_ALLOWED", "path": path, "ts": int(time.time())}
        limit = _vsp__qs_int(qs, "limit", 50)
        return 200, _impl.list_runs(limit=limit)

    if path == "/api/ui/findings_v2":
        if method != "GET":
            return 405, {"ok": False, "error": "METHOD_NOT_ALLOWED", "path": path, "ts": int(time.time())}
        rid = _vsp__qs_get(qs, "rid", "") or None
        limit = _vsp__qs_int(qs, "limit", 50)
        offset = _vsp__qs_int(qs, "offset", 0)
        q = _vsp__qs_get(qs, "q", "")
        tool = _vsp__qs_get(qs, "tool", "")
        severity = _vsp__qs_get(qs, "severity", "ALL")
        return 200, _impl.findings_query(rid=rid, limit=limit, offset=offset, q=q, tool=tool, severity=severity)

    if path == "/api/ui/settings_v2":
        if method == "GET":
            return 200, _impl.settings_get()
        if method == "POST":
            raw = _vsp__read_body(environ)
            try:
                obj = json.loads(raw.decode("utf-8","replace") or "{}")
            except Exception:
                obj = {}
            return 200, _impl.settings_save(obj)
        return 405, {"ok": False, "error": "METHOD_NOT_ALLOWED", "path": path, "ts": int(time.time())}

    if path == "/api/ui/rule_overrides_v2":
        if method == "GET":
            return 200, _impl.rules_get()
        if method == "POST":
            raw = _vsp__read_body(environ)
            try:
                obj = json.loads(raw.decode("utf-8","replace") or "{}")
            except Exception:
                obj = {}
            return 200, _impl.rules_save(obj)
        return 405, {"ok": False, "error": "METHOD_NOT_ALLOWED", "path": path, "ts": int(time.time())}

    if path == "/api/ui/rule_overrides_apply_v2":
        if method != "POST":
            return 405, {"ok": False, "error": "METHOD_NOT_ALLOWED", "path": path, "ts": int(time.time())}
        raw = _vsp__read_body(environ)
        try:
            obj = json.loads(raw.decode("utf-8","replace") or "{}")
        except Exception:
            obj = {}
        rid = str(obj.get("rid") or "")
        return 200, _impl.rules_apply_to_rid(rid)

    return 404, {"ok": False, "error": "HTTP_404_NOT_FOUND", "path": path, "ts": int(time.time())}

def _vsp__wrap_wsgi(orig_app):
    def _shim(environ, start_response):
        path = environ.get("PATH_INFO","") or ""
        if path.startswith("/api/ui/"):
            status, payload = _vsp__apiui_handle(environ)
            body = _vsp__json_bytes(payload)
            hdrs = [
                ("Content-Type","application/json; charset=utf-8"),
                ("Cache-Control","no-store"),
                ("Content-Length", str(len(body))),
            ]
            start_response(f"{status} OK" if status == 200 else f"{status} ERROR", hdrs)
            return [body]
        return orig_app(environ, start_response)
    return _shim

# Try wrap `application` first, else wrap `app.wsgi_app`
try:
    application  # noqa
    application = _vsp__wrap_wsgi(application)  # type: ignore
except Exception:
    try:
        app.wsgi_app = _vsp__wrap_wsgi(app.wsgi_app)  # type: ignore
    except Exception:
        pass
# ============================================================


# === VSP_TABS3_SAVE_APPLY_P1_V1 ===
# Add POST APIs for Settings/Rule Overrides (Save + Apply) with safe JSON parsing.
try:
    import json as _json
    from pathlib import Path as _Path
except Exception:
    _json = None
    _Path = None

def _vsp__json_response(payload, code=200):
    try:
        resp = make_response(_json.dumps(payload, ensure_ascii=False), code)
        resp.headers["Content-Type"] = "application/json; charset=utf-8"
        resp.headers["Cache-Control"] = "no-store"
        return resp
    except Exception:
        resp = make_response(str(payload), code)
        resp.headers["Content-Type"] = "text/plain; charset=utf-8"
        resp.headers["Cache-Control"] = "no-store"
        return resp

def _vsp__read_json_body():
    # flask request.get_json can fail if content-type isn't correct; handle raw body too.
    try:
        data = request.get_json(silent=True)
        if isinstance(data, dict):
            return data, None
    except Exception:
        pass
    try:
        raw = request.data.decode("utf-8", errors="replace") if getattr(request, "data", None) else ""
        raw = raw.strip()
        if not raw:
            return {}, None
        return _json.loads(raw), None
    except Exception as e:
        return None, f"bad_json: {e}"

_SETTINGS_PATH = _Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/vsp_settings_v2/settings.json")
_RULES_PATH    = _Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/rule_overrides_v2/rules.json")
_APPLIED_DIR   = _Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/rule_overrides_v2/applied")

def _vsp__atomic_write_json(path: "_Path", obj):
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp = path.with_suffix(path.suffix + f".tmp_{int(time.time())}")
    tmp.write_text(_json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")
    tmp.replace(path)

@app.route("/api/ui/settings_save_v2", methods=["POST"])
def vsp_api_ui_settings_save_v2():
    if _json is None:
        return _vsp__json_response({"ok": False, "error": "json_unavailable", "ts": int(time.time())}, 500)
    body, err = _vsp__read_json_body()
    if err:
        return _vsp__json_response({"ok": False, "error": err, "ts": int(time.time())}, 400)
    if body is None:
        return _vsp__json_response({"ok": False, "error": "bad_body", "ts": int(time.time())}, 400)
    # accept either {"settings": {...}} or raw {...}
    settings = body.get("settings") if isinstance(body, dict) else None
    if settings is None and isinstance(body, dict):
        settings = body
    if not isinstance(settings, dict):
        return _vsp__json_response({"ok": False, "error": "settings_must_be_object", "ts": int(time.time())}, 400)
    _vsp__atomic_write_json(_SETTINGS_PATH, settings)
    return _vsp__json_response({"ok": True, "path": str(_SETTINGS_PATH), "settings": settings, "ts": int(time.time())})

@app.route("/api/ui/rule_overrides_save_v2", methods=["POST"])
def vsp_api_ui_rule_overrides_save_v2():
    if _json is None:
        return _vsp__json_response({"ok": False, "error": "json_unavailable", "ts": int(time.time())}, 500)
    body, err = _vsp__read_json_body()
    if err:
        return _vsp__json_response({"ok": False, "error": err, "ts": int(time.time())}, 400)
    if body is None:
        return _vsp__json_response({"ok": False, "error": "bad_body", "ts": int(time.time())}, 400)
    data = body.get("data") if isinstance(body, dict) else None
    if data is None and isinstance(body, dict):
        data = body
    if not isinstance(data, dict):
        return _vsp__json_response({"ok": False, "error": "data_must_be_object", "ts": int(time.time())}, 400)
    if "rules" not in data:
        data["rules"] = []
    if not isinstance(data.get("rules"), list):
        return _vsp__json_response({"ok": False, "error": "rules_must_be_array", "ts": int(time.time())}, 400)
    _vsp__atomic_write_json(_RULES_PATH, data)
    return _vsp__json_response({"ok": True, "path": str(_RULES_PATH), "data": data, "ts": int(time.time())})

@app.route("/api/ui/rule_overrides_apply_v2", methods=["POST"])
def vsp_api_ui_rule_overrides_apply_v2():
    if _json is None:
        return _vsp__json_response({"ok": False, "error": "json_unavailable", "ts": int(time.time())}, 500)
    rid = (request.args.get("rid") or "").strip()
    if not rid:
        return _vsp__json_response({"ok": False, "error": "missing_rid", "ts": int(time.time())}, 400)

    # optional body can override rules to apply; else use current rules file
    body, err = _vsp__read_json_body()
    if err:
        return _vsp__json_response({"ok": False, "error": err, "ts": int(time.time())}, 400)

    applied = None
    try:
        if isinstance(body, dict) and body:
            applied = body.get("data") or body
        if applied is None:
            if _RULES_PATH.exists():
                applied = _json.loads(_RULES_PATH.read_text(encoding="utf-8", errors="replace"))
            else:
                applied = {"rules": []}
    except Exception:
        applied = {"rules": []}

    _APPLIED_DIR.mkdir(parents=True, exist_ok=True)
    out = _APPLIED_DIR / f"{rid}.json"
    payload = {
        "rid": rid,
        "applied_at": int(time.time()),
        "source_rules_path": str(_RULES_PATH),
        "applied_rules_path": str(out),
        "data": applied if isinstance(applied, dict) else {"rules": []},
    }
    _vsp__atomic_write_json(out, payload)
    return _vsp__json_response({"ok": True, **payload, "ts": int(time.time())})
# === /VSP_TABS3_SAVE_APPLY_P1_V1 ===



# --- VSP_APIUI_POST_WRAPPER_P1_V2 ---
try:
    import json as __json, os as __os, time as __time
except Exception:
    __json = None
    __os = None
    __time = None

def __vsp__json(start_response, obj, code=200):
    try:
        body = (__json.dumps(obj, ensure_ascii=False, separators=(",",":")) if __json else str(obj)).encode("utf-8")
    except Exception:
        body = (str(obj)).encode("utf-8")
    status = f"{code} OK" if code < 400 else f"{code} ERROR"
    headers = [
        ("Content-Type", "application/json; charset=utf-8"),
        ("Cache-Control", "no-store"),
        ("Content-Length", str(len(body))),
    ]
    start_response(status, headers)
    return [body]

def __vsp__read_body(environ):
    try:
        cl = int(environ.get("CONTENT_LENGTH") or "0")
    except Exception:
        cl = 0
    if cl <= 0:
        return b""
    w = environ.get("wsgi.input")
    if not w:
        return b""
    try:
        return w.read(cl) or b""
    except Exception:
        return b""

def __vsp__read_json(environ):
    raw = __vsp__read_body(environ)
    if not raw:
        return {}
    try:
        return __json.loads(raw.decode("utf-8", "replace")) if __json else {"_raw": raw.decode("utf-8","replace")}
    except Exception:
        return {"_raw": raw.decode("utf-8","replace")}

def __vsp__save_json(path, data):
    __os.makedirs(__os.path.dirname(path), exist_ok=True)
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        __json.dump(data, f, ensure_ascii=False, indent=2, sort_keys=True)
    __os.replace(tmp, path)

def __vsp__wrap_post_only(orig):
    def _wsgi(environ, start_response):
        try:
            path = (environ.get("PATH_INFO") or "")
            method = (environ.get("REQUEST_METHOD") or "GET").upper()
            if method != "POST" or not path.startswith("/api/ui/"):
                return orig(environ, start_response)

            # POST /api/ui/settings_v2  body: {settings:{...}} or {...}
            if path == "/api/ui/settings_v2":
                payload = __vsp__read_json(environ)
                settings = payload.get("settings") if isinstance(payload, dict) and "settings" in payload else payload
                if settings is None:
                    settings = {}
                out_path = "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/vsp_settings_v2/settings.json"
                __vsp__save_json(out_path, settings if isinstance(settings, dict) else {"value": settings})
                return __vsp__json(start_response, {"ok": True, "path": out_path, "settings": settings, "ts": int(__time.time())})

            # POST /api/ui/rule_overrides_v2 body: {data:{rules:[...]}} or {rules:[...]} or {...}
            if path == "/api/ui/rule_overrides_v2":
                payload = __vsp__read_json(environ)
                if isinstance(payload, dict) and "data" in payload and isinstance(payload["data"], dict):
                    data = payload["data"]
                else:
                    data = payload if isinstance(payload, dict) else {}
                if "rules" not in data and isinstance(payload, dict) and "rules" in payload:
                    data = {"rules": payload.get("rules")}
                if "rules" not in data:
                    data = {"rules": []}
                out_path = "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/rule_overrides_v2/rules.json"
                __vsp__save_json(out_path, data)
                return __vsp__json(start_response, {"ok": True, "path": out_path, "data": data, "ts": int(__time.time())})

            # POST /api/ui/rule_overrides_apply_v2 body: {rid:"..."} or query ?rid=...
            if path == "/api/ui/rule_overrides_apply_v2":
                payload = __vsp__read_json(environ)
                rid = None
                qs = environ.get("QUERY_STRING") or ""
                for kv in qs.split("&"):
                    if kv.startswith("rid="):
                        rid = kv.split("=", 1)[1]
                        break
                if not rid and isinstance(payload, dict):
                    rid = payload.get("rid") or payload.get("RID") or payload.get("run_id")
                if not rid:
                    return __vsp__json(start_response, {"ok": False, "error": "missing_rid", "ts": int(__time.time())}, 400)
                out_path = f"/home/test/Data/SECURITY_BUNDLE/ui/out_ci/rule_overrides_v2/applied/{rid}.json"
                __vsp__save_json(out_path, {"rid": rid, "applied_at": int(__time.time()), "payload": payload})
                return __vsp__json(start_response, {"ok": True, "rid": rid, "path": out_path, "ts": int(__time.time())})

            return __vsp__json(start_response, {"ok": False, "error": "not_found", "path": path, "ts": int(__time.time())}, 404)

        except Exception as e:
            return __vsp__json(start_response, {"ok": False, "error": "exception", "message": str(e), "ts": int(__time.time())}, 500)
    setattr(_wsgi, "__vsp_postwrap_v2", True)
    return _wsgi

# install wrapper (wrap Flask app.wsgi_app OR global application)
try:
    if "app" in globals() and hasattr(globals()["app"], "wsgi_app"):
        _orig = globals()["app"].wsgi_app
        if not getattr(_orig, "__vsp_postwrap_v2", False):
            globals()["app"].wsgi_app = __vsp__wrap_post_only(_orig)
    elif "application" in globals() and callable(globals()["application"]):
        _orig = globals()["application"]
        if not getattr(_orig, "__vsp_postwrap_v2", False):
            globals()["application"] = __vsp__wrap_post_only(_orig)
except Exception:
    pass
# --- END VSP_APIUI_POST_WRAPPER_P1_V2 ---


# --- VSP_APIUI_ALIAS_COMPAT_P1_V2 ---
# Legacy endpoint compat for older JS/bundles calling /api/ui/runs (no _v2), etc.
try:
    __vsp_apiui_alias_prev = app.wsgi_app  # type: ignore[name-defined]
    def __vsp_apiui_alias_wrap(environ, start_response):
        try:
            path = (environ or {}).get("PATH_INFO", "") or ""
            alias = {
                "/api/ui/runs": "/api/ui/runs_v2",
                "/api/ui/findings": "/api/ui/findings_v2",
                "/api/ui/settings": "/api/ui/settings_v2",
                "/api/ui/rule_overrides": "/api/ui/rule_overrides_v2",
                "/api/ui/rule_overrides_apply": "/api/ui/rule_overrides_apply_v2",
            }
            if path in alias:
                environ["PATH_INFO"] = alias[path]
        except Exception:
            pass
        return __vsp_apiui_alias_prev(environ, start_response)
    app.wsgi_app = __vsp_apiui_alias_wrap  # type: ignore[name-defined]
except Exception:
    pass
# --- /VSP_APIUI_ALIAS_COMPAT_P1_V2 ---



# --- VSP_APIUI_LEGACY_REDIRECT_P1_V1 ---
# Guarantee backward-compat endpoints exist (no 404) by redirecting to *_v2 with 307 (keeps method/body).
try:
    from flask import request as __vsp_req, redirect as __vsp_redirect

    def __vsp_qs():
        try:
            q = (__vsp_req.query_string or b"").decode("utf-8", "ignore")
            return ("?" + q) if q else ""
        except Exception:
            return ""

    def __vsp_r307(path: str):
        return __vsp_redirect(path, code=307)

    # GET legacy -> v2
    @app.route("/api/ui/runs", methods=["GET"])  # type: ignore[name-defined]
    def __vsp_legacy_runs():
        return __vsp_r307("/api/ui/runs_v2" + __vsp_qs())

    @app.route("/api/ui/findings", methods=["GET"])  # type: ignore[name-defined]
    def __vsp_legacy_findings():
        return __vsp_r307("/api/ui/findings_v2" + __vsp_qs())

    @app.route("/api/ui/settings", methods=["GET"])  # type: ignore[name-defined]
    def __vsp_legacy_settings():
        return __vsp_r307("/api/ui/settings_v2" + __vsp_qs())

    @app.route("/api/ui/rule_overrides", methods=["GET"])  # type: ignore[name-defined]
    def __vsp_legacy_rule_overrides():
        return __vsp_r307("/api/ui/rule_overrides_v2" + __vsp_qs())

    # POST legacy -> v2 (gi body)
    @app.route("/api/ui/settings_save", methods=["POST"])  # type: ignore[name-defined]
    def __vsp_legacy_settings_save():
        return __vsp_r307("/api/ui/settings_save_v2")

    @app.route("/api/ui/rule_overrides_save", methods=["POST"])  # type: ignore[name-defined]
    def __vsp_legacy_rule_overrides_save():
        return __vsp_r307("/api/ui/rule_overrides_save_v2")

    @app.route("/api/ui/rule_overrides_apply", methods=["POST"])  # type: ignore[name-defined]
    def __vsp_legacy_rule_overrides_apply():
        return __vsp_r307("/api/ui/rule_overrides_apply_v2")

except Exception:
    pass
# --- /VSP_APIUI_LEGACY_REDIRECT_P1_V1 ---



# VSP_APIUI_LEGACY_ALIAS_WRAPPER_P1_V1
try:
    import time as __time
    if not globals().get("__vsp_apiui_legacy_alias_installed", False):
        __vsp_apiui_legacy_alias_installed = True

        __VSP_APIUI_ALIAS_MAP = {
            "/api/ui/runs": "/api/ui/runs_v2",
            "/api/ui/findings": "/api/ui/findings_v2",
            "/api/ui/settings": "/api/ui/settings_v2",
            "/api/ui/rule_overrides": "/api/ui/rule_overrides_v2",
            # POST aliases (just in case)
            "/api/ui/settings_save": "/api/ui/settings_save_v2",
            "/api/ui/rule_overrides_save": "/api/ui/rule_overrides_save_v2",
            "/api/ui/rules_apply": "/api/ui/rules_apply_v2",
        }

        def __vsp_apiui_legacy_alias_wrapper(app):
            def _w(environ, start_response):
                try:
                    p = environ.get("PATH_INFO", "") or ""
                    newp = __VSP_APIUI_ALIAS_MAP.get(p)
                    if newp:
                        env2 = dict(environ)
                        env2["PATH_INFO"] = newp
                        return app(env2, start_response)
                except Exception:
                    pass
                return app(environ, start_response)
            return _w

        # gunicorn usually uses "application"
        if "application" in globals():
            application = __vsp_apiui_legacy_alias_wrapper(application)
except Exception:
    pass
# /VSP_APIUI_LEGACY_ALIAS_WRAPPER_P1_V1


# ==== VSP_APIUI_RUNS_KPI_PAGINATION_P1_V1 ====
try:
    import os as __os, json as __json, time as __time
    from urllib.parse import parse_qs as __parse_qs
except Exception:
    pass

def __apiui_qs(environ):
    try:
        return __parse_qs(environ.get("QUERY_STRING",""), keep_blank_values=True)
    except Exception:
        return {}

def __apiui_int(qs, k, default):
    try:
        v = (qs.get(k,[None])[0])
        if v is None or v == "": return default
        return int(v)
    except Exception:
        return default

def __apiui_read_json(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return __json.load(f)
    except Exception:
        return None

def __apiui_pick_overall(run_dir):
    # prefer run_gate_summary.json then run_gate.json
    for fn in ("run_gate_summary.json", "run_gate.json"):
        j = __apiui_read_json(__os.path.join(run_dir, fn))
        if not isinstance(j, dict): 
            continue
        for k in ("overall", "overall_status", "overall_status_final"):
            v = j.get(k)
            if isinstance(v, str) and v.strip():
                return v.strip()
    return "UNKNOWN"

def __apiui_list_runs():
    out_root = "/home/test/Data/SECURITY_BUNDLE/out"
    try:
        names = []
        for name in __os.listdir(out_root):
            if name.startswith("RUN_"):
                run_dir = __os.path.join(out_root, name)
                try:
                    st = __os.stat(run_dir)
                    names.append((st.st_mtime, name, run_dir))
                except Exception:
                    names.append((0, name, run_dir))
        names.sort(key=lambda t: t[0], reverse=True)
        return names
    except Exception:
        return []

def __apiui_runs_page(environ):
    qs = __apiui_qs(environ)
    limit  = __apiui_int(qs, "limit", 20)
    offset = __apiui_int(qs, "offset", 0)
    limit = max(1, min(limit, 200))
    offset = max(0, offset)

    runs = __apiui_list_runs()
    total = len(runs)
    sl = runs[offset:offset+limit]

    items = []
    for mtime, rid, run_dir in sl:
        items.append({
            "rid": rid,
            "run_dir": run_dir,
            "mtime": int(mtime or 0),
            "overall": __apiui_pick_overall(run_dir),
        })

    return {
        "ok": True,
        "items": items,
        "limit": limit,
        "offset": offset,
        "total": total,
        "has_more": (offset + limit) < total,
        "ts": int(__time.time()),
    }

def __apiui_runs_kpi():
    runs = __apiui_list_runs()
    total = len(runs)
    sample = runs[:200]  # cap for speed
    c = {"GREEN":0, "AMBER":0, "RED":0, "UNKNOWN":0}
    last = None
    for mtime, rid, run_dir in sample:
        ov = __apiui_pick_overall(run_dir).upper()
        if ov not in c:
            ov = "UNKNOWN"
        c[ov] += 1
        if last is None:
            last = {"rid": rid, "mtime": int(mtime or 0), "overall": ov}
    return {
        "ok": True,
        "kpi": {
            "total_runs": total,
            "sampled": len(sample),
            "by_overall": c,
            "latest": last or {"rid":"", "mtime":0, "overall":"UNKNOWN"},
        },
        "ts": int(__time.time()),
    }

# Patch into existing WSGI shim dispatcher:
# We add a tiny wrapper at bottom that intercepts paths we want.
def __apiui_extra_dispatch(app):
    def _wsgi(environ, start_response):
        try:
            path = environ.get("PATH_INFO","")
            if path == "/api/ui/runs_page_v1":
                return __wsgi_json(__apiui_runs_page(environ), 200)(environ, start_response)
            if path == "/api/ui/runs_kpi_v1":
                return __wsgi_json(__apiui_runs_kpi(), 200)(environ, start_response)
        except Exception as e:
            try:
                return __wsgi_json({"ok": False, "error": "apiui_extra_dispatch", "detail": str(e), "ts": int(__time.time())}, 200)(environ, start_response)
            except Exception:
                pass
        return app(environ, start_response)
    return _wsgi
# ==== /VSP_APIUI_RUNS_KPI_PAGINATION_P1_V1 ====


try:
    application = __apiui_extra_dispatch(application)
except Exception:
    try:
        app = __apiui_extra_dispatch(app)
    except Exception:
        pass


# ===================== VSP_APIUI_RUNS_KPI_PAGINATION_COMPAT_P1_V2 =====================
# Super-compat wrapper: add KPI + pagination endpoints for Runs & Reports
try:
    import os as __os, json as __json, time as __time
    import urllib.parse as __urlparse
    import re as __re

    def __vsp__json(start_response, obj, code=200):
        body = (__json.dumps(obj, ensure_ascii=False)).encode("utf-8")
        hdrs = [
            ("Content-Type","application/json; charset=utf-8"),
            ("Cache-Control","no-store"),
            ("Content-Length", str(len(body))),
        ]
        start_response(f"{code} OK" if code==200 else f"{code} ERROR", hdrs)
        return [body]

    def __vsp__qs(environ):
        return __urlparse.parse_qs(environ.get("QUERY_STRING",""), keep_blank_values=True)

    def __vsp__get1(qs, k, default=None):
        v = qs.get(k)
        if not v: return default
        return v[0]

    def __vsp__int(x, d):
        try: return int(x)
        except Exception: return d

    def __vsp__safe_read_json(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                return __json.load(f)
        except Exception:
            return None

    def __vsp__guess_overall(run_dir):
        # prefer JSON gates if exist
        cand = [
            "run_gate_summary.json",
            "run_gate.json",
            "verdict_4t.json",
            "gate.json",
            "SUMMARY.json",
        ]
        for fn in cand:
            fp = __os.path.join(run_dir, fn)
            if __os.path.isfile(fp):
                j = __vsp__safe_read_json(fp)
                if isinstance(j, dict):
                    for k in ("overall_status","overall","status","verdict"):
                        v = j.get(k)
                        if isinstance(v, str) and v.strip():
                            return v.strip().upper()
        # fallback SUMMARY.txt
        fp = __os.path.join(run_dir, "SUMMARY.txt")
        if __os.path.isfile(fp):
            try:
                t = open(fp, "r", encoding="utf-8", errors="ignore").read()
                m = __re.search(r"\boverall\b\s*[:=]\s*([A-Za-z]+)", t, flags=__re.I)
                if m: return m.group(1).upper()
            except Exception:
                pass
        return "UNKNOWN"

    def __vsp__norm_overall(x):
        x = (x or "").upper()
        if x in ("GREEN","PASS","OK","SUCCESS"): return "GREEN"
        if x in ("AMBER","WARN","WARNING","DEGRADED"): return "AMBER"
        if x in ("RED","FAIL","FAILED","ERROR","BLOCK"): return "RED"
        if x in ("UNKNOWN","NA","N/A","NONE",""): return "UNKNOWN"
        # keep other (but bucket as UNKNOWN)
        return "UNKNOWN"

    def __vsp__list_runs(out_root, max_scan=2000):
        items = []
        try:
            if not __os.path.isdir(out_root):
                return items
            for name in __os.listdir(out_root):
                if not name.startswith("RUN_"):
                    continue
                run_dir = __os.path.join(out_root, name)
                if not __os.path.isdir(run_dir):
                    continue
                try:
                    mtime = int(__os.path.getmtime(run_dir))
                except Exception:
                    mtime = 0
                items.append((mtime, name, run_dir))
        except Exception:
            return []
        items.sort(key=lambda x: (x[0], x[1]), reverse=True)
        if len(items) > max_scan:
            items = items[:max_scan]
        return items

    def __vsp__runs_page_payload(out_root, limit, offset):
        all_items = __vsp__list_runs(out_root)
        total = len(all_items)
        limit = max(1, min(limit, 200))
        offset = max(0, min(offset, total))
        page = all_items[offset:offset+limit]
        out = []
        for mtime, rid, run_dir in page:
            o = __vsp__norm_overall(__vsp__guess_overall(run_dir))
            out.append({"rid": rid, "run_dir": run_dir, "mtime": mtime, "overall": o})
        page_total = (total + limit - 1)//limit if total>0 else 1
        page_no = (offset//limit) + 1 if total>0 else 1
        return {
            "ok": True,
            "items": out,
            "limit": limit,
            "offset": offset,
            "total": total,
            "page_no": page_no,
            "page_total": page_total,
            "next_offset": (offset+limit if offset+limit < total else None),
            "prev_offset": (offset-limit if offset-limit >= 0 else None),
            "ts": int(__time.time()),
        }

    def __vsp__runs_kpi_payload(out_root, max_scan=2000):
        all_items = __vsp__list_runs(out_root, max_scan=max_scan)
        buckets = {"GREEN":0,"AMBER":0,"RED":0,"UNKNOWN":0}
        latest = all_items[0][1] if all_items else None
        for mtime, rid, run_dir in all_items:
            o = __vsp__norm_overall(__vsp__guess_overall(run_dir))
            buckets[o] = buckets.get(o,0) + 1
        return {
            "ok": True,
            "total_runs": len(all_items),
            "by_overall": buckets,
            "latest_rid": latest,
            "scan_cap": max_scan,
            "ts": int(__time.time()),
        }

    def __vsp__wrap_wsgi(inner):
        OUT_ROOT = "/home/test/Data/SECURITY_BUNDLE/out"
        def _app(environ, start_response):
            path = environ.get("PATH_INFO","") or ""
            qs = __vsp__qs(environ)

            # --- KPI endpoints (accept multiple names) ---
            if path in ("/api/ui/runs_kpi", "/api/ui/runs_kpi_v1", "/api/ui/runs_kpi_v2", "/api/ui/runs_kpi_v3"):
                cap = __vsp__int(__vsp__get1(qs,"cap", "2000"), 2000)
                return __vsp__json(start_response, __vsp__runs_kpi_payload(OUT_ROOT, max_scan=cap), 200)

            # --- Pagination endpoints (accept multiple names) ---
            if path in ("/api/ui/runs_page", "/api/ui/runs_page_v1", "/api/ui/runs_page_v2", "/api/ui/runs_paged_v1"):
                limit = __vsp__int(__vsp__get1(qs,"limit","20"), 20)
                offset = __vsp__int(__vsp__get1(qs,"offset","0"), 0)
                return __vsp__json(start_response, __vsp__runs_page_payload(OUT_ROOT, limit, offset), 200)

            # --- Upgrade runs_v2 to support offset (compat with UI pagination) ---
            if path == "/api/ui/runs_v2":
                limit = __vsp__int(__vsp__get1(qs,"limit","200"), 200)
                offset = __vsp__int(__vsp__get1(qs,"offset","0"), 0)
                return __vsp__json(start_response, __vsp__runs_page_payload(OUT_ROOT, limit, offset), 200)

            return inner(environ, start_response)
        return _app

    __inner = globals().get("application") or globals().get("app")
    if __inner:
        __wrapped = __vsp__wrap_wsgi(__inner)
        globals()["application"] = __wrapped
        globals()["app"] = __wrapped
except Exception:
    pass
# =================== END VSP_APIUI_RUNS_KPI_PAGINATION_COMPAT_P1_V2 ===================


# ===================== VSP_TABS3_REALDATA_ENRICH_P1_V1 =====================
try:
    import os as __os, json as __json, time as __time
    import urllib.parse as __urlparse
    import re as __re

    __VSP_REALDATA_CACHE = {"ts": 0, "runs": None}

    def __vsp_json(start_response, obj, code=200):
        body = (__json.dumps(obj, ensure_ascii=False)).encode("utf-8")
        hdrs = [
            ("Content-Type","application/json; charset=utf-8"),
            ("Cache-Control","no-store"),
            ("Content-Length", str(len(body))),
        ]
        start_response(f"{code} OK" if code==200 else f"{code} ERROR", hdrs)
        return [body]

    def __vsp_qs(environ):
        return __urlparse.parse_qs(environ.get("QUERY_STRING",""), keep_blank_values=True)

    def __vsp_get1(qs, k, default=None):
        v = qs.get(k)
        if not v: return default
        return v[0]

    def __vsp_int(x, d):
        try: return int(x)
        except Exception: return d

    def __vsp_read_json(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                return __json.load(f)
        except Exception:
            return None

    def __vsp_has_any(run_dir, rels):
        for r in rels:
            if __os.path.isfile(__os.path.join(run_dir, r)):
                return True
        return False

    def __vsp_findings_path(run_dir):
        cand = [
            "findings_unified.json",
            "reports/findings_unified.json",
            "reports/findings_unified_v1.json",
        ]
        for r in cand:
            fp = __os.path.join(run_dir, r)
            if __os.path.isfile(fp):
                return fp
        # note: csv/sarif exist but we don't parse here
        return None

    def __vsp_gate_path(run_dir):
        cand = [
            "run_gate_summary.json",
            "run_gate.json",
            "reports/run_gate_summary.json",
            "reports/run_gate.json",
        ]
        for r in cand:
            fp = __os.path.join(run_dir, r)
            if __os.path.isfile(fp):
                return fp
        return None

    def __vsp_norm_overall(x):
        x = (x or "").strip().upper()
        if x in ("GREEN","PASS","OK","SUCCESS"): return "GREEN"
        if x in ("AMBER","WARN","WARNING","DEGRADED"): return "AMBER"
        if x in ("RED","FAIL","FAILED","ERROR","BLOCK"): return "RED"
        return "UNKNOWN"

    def __vsp_guess_overall(run_dir):
        fp = __vsp_gate_path(run_dir)
        if fp:
            j = __vsp_read_json(fp)
            if isinstance(j, dict):
                for k in ("overall","overall_status","status","verdict","overall_status_final"):
                    v = j.get(k)
                    if isinstance(v, str) and v.strip():
                        return __vsp_norm_overall(v)
        # fallback: SUMMARY.txt
        sp = __os.path.join(run_dir, "SUMMARY.txt")
        if __os.path.isfile(sp):
            try:
                t = open(sp, "r", encoding="utf-8", errors="ignore").read()
                m = __re.search(r"\boverall\b\s*[:=]\s*([A-Za-z]+)", t, flags=__re.I)
                if m:
                    return __vsp_norm_overall(m.group(1))
            except Exception:
                pass
        return "UNKNOWN"

    def __vsp_list_runs(out_root="/home/test/Data/SECURITY_BUNDLE/out", cache_ttl=10):
        now = int(__time.time())
        c = __VSP_REALDATA_CACHE
        if c["runs"] is not None and (now - c["ts"]) <= cache_ttl:
            return c["runs"]

        runs = []
        try:
            if __os.path.isdir(out_root):
                for name in __os.listdir(out_root):
                    if not name.startswith("RUN_"):
                        continue
                    run_dir = __os.path.join(out_root, name)
                    if not __os.path.isdir(run_dir):
                        continue
                    try:
                        mtime = int(__os.path.getmtime(run_dir))
                    except Exception:
                        mtime = 0
                    has_findings = __vsp_findings_path(run_dir) is not None
                    has_gate = __vsp_gate_path(run_dir) is not None
                    overall = __vsp_guess_overall(run_dir)
                    runs.append((mtime, name, run_dir, has_findings, has_gate, overall))
        except Exception:
            runs = []

        runs.sort(key=lambda x: (x[0], x[1]), reverse=True)
        c["ts"] = now
        c["runs"] = runs
        return runs

    def __vsp_runs_page_payload(limit, offset):
        runs = __vsp_list_runs()
        total = len(runs)
        limit = max(1, min(limit, 200))
        offset = max(0, min(offset, total))
        page = runs[offset:offset+limit]
        items = []
        for mtime, rid, run_dir, has_findings, has_gate, overall in page:
            items.append({
                "rid": rid, "run_dir": run_dir, "mtime": mtime,
                "has_findings": bool(has_findings),
                "has_gate": bool(has_gate),
                "overall": overall,
            })
        return {
            "ok": True, "items": items,
            "limit": limit, "offset": offset, "total": total,
            "has_more": (offset + limit) < total,
            "ts": int(__time.time()),
        }

    def __vsp_runs_kpi_payload(cap=2000):
        runs = __vsp_list_runs()
        runs = runs[:max(1, min(int(cap), 5000))]
        b = {"GREEN":0,"AMBER":0,"RED":0,"UNKNOWN":0}
        hf = 0
        hg = 0
        latest = runs[0][1] if runs else ""
        for mtime, rid, run_dir, has_findings, has_gate, overall in runs:
            b[overall] = b.get(overall, 0) + 1
            if has_findings: hf += 1
            if has_gate: hg += 1
        return {
            "ok": True,
            "total_runs": len(runs),
            "latest_rid": latest,
            "by_overall": b,
            "has_findings": hf,
            "has_gate": hg,
            "ts": int(__time.time()),
        }

    def __vsp_extract_items(j):
        if isinstance(j, list):
            return j
        if isinstance(j, dict):
            for k in ("items","findings","results"):
                v = j.get(k)
                if isinstance(v, list):
                    return v
        return []

    def __vsp_norm_sev(x):
        x = (x or "").strip().upper()
        if x in ("CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"):
            return x
        # some tools use ERROR/WARN/NOTE
        if x in ("ERROR","FATAL"): return "HIGH"
        if x in ("WARN","WARNING"): return "MEDIUM"
        if x in ("NOTE","NOTICE"): return "INFO"
        return "INFO"

    def __vsp_findings_payload(rid, limit, offset, q=""):
        runs = __vsp_list_runs()
        chosen = None
        if rid:
            for mtime, r, run_dir, hf, hg, ov in runs:
                if r == rid:
                    chosen = (mtime, r, run_dir, hf, hg, ov)
                    break
        if chosen is None:
            # default: first run that has findings, else first run
            for row in runs:
                if row[3]:
                    chosen = row
                    break
            if chosen is None and runs:
                chosen = runs[0]

        if not chosen:
            return {"ok": True, "rid":"", "run_dir":"", "items":[], "counts": {"TOTAL":0}, "limit":limit, "offset":offset, "total":0,
                    "reason":"NO_RUNS_FOUND", "ts": int(__time.time())}

        mtime, rid2, run_dir, has_findings, has_gate, overall = chosen
        fp = __vsp_findings_path(run_dir)
        if not fp:
            # report reason + common paths
            return {
                "ok": True, "rid": rid2, "run_dir": run_dir,
                "items": [], "counts": {"CRITICAL":0,"HIGH":0,"MEDIUM":0,"LOW":0,"INFO":0,"TRACE":0,"TOTAL":0},
                "limit": limit, "offset": offset, "total": 0,
                "overall": overall,
                "reason": "NO_findings_unified.json (try run SECURITY_BUNDLE unify/pack_report)",
                "hint_paths": [
                    f"{run_dir}/findings_unified.json",
                    f"{run_dir}/reports/findings_unified.json",
                    f"{run_dir}/reports/findings_unified.csv",
                    f"{run_dir}/reports/findings_unified.sarif",
                ],
                "ts": int(__time.time())
            }

        raw = __vsp_read_json(fp)
        items = __vsp_extract_items(raw)

        # optional search
        q = (q or "").strip().lower()
        if q:
            def hit(it):
                try:
                    s = __json.dumps(it, ensure_ascii=False).lower()
                    return q in s
                except Exception:
                    return False
            items = [x for x in items if hit(x)]

        total = len(items)
        limit = max(1, min(limit, 200))
        offset = max(0, min(offset, total))
        page = items[offset:offset+limit]

        counts = {"CRITICAL":0,"HIGH":0,"MEDIUM":0,"LOW":0,"INFO":0,"TRACE":0,"TOTAL": total}
        for it in items:
            sev = __vsp_norm_sev(it.get("severity_norm") or it.get("severity") or it.get("level") or it.get("impact"))
            counts[sev] = counts.get(sev,0) + 1

        return {
            "ok": True,
            "rid": rid2, "run_dir": run_dir, "overall": overall,
            "items": page, "counts": counts,
            "limit": limit, "offset": offset, "total": total,
            "findings_path": fp,
            "ts": int(__time.time()),
        }

    def __vsp_wrap_wsgi(inner):
        def _app(environ, start_response):
            path = environ.get("PATH_INFO","") or ""
            qs = __vsp_qs(environ)

            # unify endpoints (accept both v1/v2 names)
            if path in ("/api/ui/runs_page_v1", "/api/ui/runs_page", "/api/ui/runs_page_v2"):
                limit = __vsp_int(__vsp_get1(qs,"limit","20"), 20)
                offset = __vsp_int(__vsp_get1(qs,"offset","0"), 0)
                return __vsp_json(start_response, __vsp_runs_page_payload(limit, offset), 200)

            if path in ("/api/ui/runs_kpi_v1", "/api/ui/runs_kpi", "/api/ui/runs_kpi_v2"):
                cap = __vsp_int(__vsp_get1(qs,"cap","2000"), 2000)
                return __vsp_json(start_response, __vsp_runs_kpi_payload(cap), 200)

            # upgrade runs_v2: now supports offset + extras
            if path == "/api/ui/runs_v2":
                limit = __vsp_int(__vsp_get1(qs,"limit","200"), 200)
                offset = __vsp_int(__vsp_get1(qs,"offset","0"), 0)
                return __vsp_json(start_response, __vsp_runs_page_payload(limit, offset), 200)

            # findings: accept rid/limit/offset/q
            if path in ("/api/ui/findings_v2", "/api/ui/findings_v1"):
                rid = __vsp_get1(qs, "rid", "") or ""
                limit = __vsp_int(__vsp_get1(qs,"limit","50"), 50)
                offset = __vsp_int(__vsp_get1(qs,"offset","0"), 0)
                q = __vsp_get1(qs, "q", "") or ""
                return __vsp_json(start_response, __vsp_findings_payload(rid, limit, offset, q=q), 200)

            return inner(environ, start_response)
        return _app

    __inner = globals().get("application") or globals().get("app")
    if __inner:
        __wrapped = __vsp_wrap_wsgi(__inner)
        globals()["application"] = __wrapped
        globals()["app"] = __wrapped
except Exception:
    pass
# =================== END VSP_TABS3_REALDATA_ENRICH_P1_V1 ===================
