from __future__ import annotations

"""
API VSP – Dashboard v2

- Scan thư mục out/ của SECURITY_BUNDLE
- Tìm RUN_VSP_FULL_EXT_* mới nhất
- Đọc report/summary_unified.json
- Trả về:
    ok, run_id, profile, source, total_findings,
    summary.by_severity, summary.by_tool
"""

import json
from pathlib import Path
from typing import Any, Dict, Optional, Tuple
from datetime import datetime, timezone

from flask import Blueprint, jsonify

bp_vsp_dashboard_v2 = Blueprint("vsp_dashboard_v2", __name__)

ROOT = Path("/home/test/Data/SECURITY_BUNDLE")
OUT_DIR = ROOT / "out"


def _safe_read_json(path: Path) -> Any:
    if not path.is_file():
        return None
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None


def _folder_mtime(p: Path) -> float:
    try:
        return p.stat().st_mtime
    except Exception:
        return 0.0


def _find_latest_full_ext_run() -> Optional[Tuple[str, Path]]:
    if not OUT_DIR.is_dir():
        return None

    candidates = []
    for child in OUT_DIR.iterdir():
        if not child.is_dir():
            continue
        name = child.name
        # Ưu tiên RUN_VSP_FULL_EXT_*
        if name.startswith("RUN_VSP_FULL_EXT_"):
            candidates.append(child)

    if not candidates:
        # fallback: mọi RUN_*
        for child in OUT_DIR.iterdir():
            if child.is_dir() and child.name.startswith("RUN_"):
                candidates.append(child)

    if not candidates:
        return None

    latest = max(candidates, key=_folder_mtime)
    return latest.name, latest


@bp_vsp_dashboard_v2.route("/api/vsp/dashboard_v2", methods=["GET"])
def api_vsp_dashboard_v2():
    found = _find_latest_full_ext_run()
    if not found:
        return jsonify(
            {
                "ok": False,
                "error": "No RUN_VSP_FULL_EXT_* found in out/",
            }
        ), 200

    run_id, run_dir = found
    report_dir = run_dir / "report"
    summary_path = report_dir / "summary_unified.json"

    summary_raw = _safe_read_json(summary_path)
    if not isinstance(summary_raw, dict):
        return jsonify(
            {
                "ok": False,
                "run_id": run_id,
                "error": f"summary_unified.json not found or invalid at {summary_path}",
            }
        ), 200

    # Chuẩn hoá một chút
    total = (
        summary_raw.get("summary", {}).get("total_findings")
        or summary_raw.get("total_findings")
        or summary_raw.get("total")
    )

    sev = (
        summary_raw.get("summary", {}).get("by_severity")
        or summary_raw.get("by_severity")
        or summary_raw.get("severity")
        or {}
    )

    by_tool = (
        summary_raw.get("summary", {}).get("by_tool")
        or summary_raw.get("by_tool")
        or {}
    )

    profile = (
        summary_raw.get("profile")
        or summary_raw.get("run_profile")
        or summary_raw.get("scan_profile")
    )

    source = (
        summary_raw.get("source")
        or summary_raw.get("src")
        or summary_raw.get("url")
        or summary_raw.get("app_origin")
    )

    ts = (
        summary_raw.get("ts")
        or summary_raw.get("timestamp")
        or summary_raw.get("time")
        or summary_raw.get("created_at")
    )
    if not ts:
        # fallback: mtime thư mục run
        try:
            dt = datetime.fromtimestamp(run_dir.stat().st_mtime, tz=timezone.utc)
            ts = dt.replace(microsecond=0).isoformat().replace("+00:00", "Z")
        except Exception:
            ts = None

    # Nếu total vẫn None mà đã có sev thì tự tính
    if total is None and isinstance(sev, dict):
        crit = int(sev.get("CRITICAL", 0) or 0)
        high = int(sev.get("HIGH", 0) or 0)
        med = int(sev.get("MEDIUM", 0) or 0)
        low = int(sev.get("LOW", 0) or 0)
        info = int(sev.get("INFO", 0) or 0)
        trace = int(sev.get("TRACE", 0) or 0)
        total = crit + high + med + low + info + trace

    resp: Dict[str, Any] = {
        "ok": True,
        "run_id": run_id,
        "profile": profile,
        "source": source,
        "ts": ts,
        "total_findings": int(total or 0),
        "summary": {
            "by_severity": sev or {},
            "by_tool": by_tool or {},
        },
    }

    return jsonify(resp)


@bp_vsp_dashboard_v2.route("/api/vsp/rule_overrides", methods=["GET"])
def api_vsp_rule_overrides():
    """Return rule overrides config as JSON list.

    Expected file locations (first match wins):
      - config/vsp_rule_overrides.json
      - vsp_rule_overrides.json
    """
    from pathlib import Path
    from flask import jsonify
    import json

    root = Path("/home/test/Data/SECURITY_BUNDLE")
    candidates = [
        root / "config" / "vsp_rule_overrides.json",
        root / "vsp_rule_overrides.json",
    ]

    overrides = []
    path_used = None

    for p in candidates:
        if p.is_file():
            try:
                data = json.loads(p.read_text(encoding="utf-8"))
            except Exception:
                data = None
            if isinstance(data, dict) and "rules" in data and isinstance(data["rules"], list):
                overrides = data["rules"]
            elif isinstance(data, list):
                overrides = data
            else:
                overrides = []
            path_used = str(p)
            break

    resp = {
        "ok": True,
        "source": path_used,
        "items": overrides,
        "total": len(overrides),
    }
    return jsonify(resp)


@bp_vsp_dashboard_v2.route("/api/vsp/settings", methods=["GET"])
def api_vsp_settings():
    """Return environment + tool stack info for Settings tab."""
    from pathlib import Path
    from flask import jsonify
    import json, time

    root = Path("/home/test/Data/SECURITY_BUNDLE")
    out_dir = root / "out"

    latest_run_dir = None
    run_id = None

    if out_dir.is_dir():
        candidates = [
            p for p in out_dir.iterdir()
            if p.is_dir() and p.name.startswith("RUN_VSP_FULL_EXT_")
        ]
        if candidates:
            candidates.sort(key=lambda p: p.name, reverse=True)
            latest_run_dir = candidates[0]
            run_id = latest_run_dir.name

    summary = None
    by_tool = {}
    if latest_run_dir is not None:
        summary_path = latest_run_dir / "report" / "summary_unified.json"
        if summary_path.is_file():
            try:
                summary = json.loads(summary_path.read_text(encoding="utf-8"))
            except Exception:
                summary = None

    if isinstance(summary, dict):
        data = summary.get("summary") or summary
        bt = data.get("by_tool") if isinstance(data, dict) else None

        if isinstance(bt, dict):
            for k, v in bt.items():
                if isinstance(v, dict):
                    by_tool[k] = int(v.get("total") or v.get("findings") or 0)
        elif isinstance(bt, list):
            for item in bt:
                if not isinstance(item, dict):
                    continue
                key = item.get("tool") or item.get("name")
                if not key:
                    continue
                by_tool[key] = int(item.get("total") or item.get("findings") or 0)

    tool_defs = [
        ("gitleaks",  "Gitleaks (Secrets)"),
        ("semgrep",   "Semgrep (SAST)"),
        ("kics",      "KICS (IaC)"),
        ("codeql",    "CodeQL"),
        ("bandit",    "Bandit (Python)"),
        ("trivy_fs",  "Trivy FS"),
        ("syft",      "Syft (SBOM)"),
        ("grype",     "Grype (Vulns)"),
    ]

    tools = []
    for key, label in tool_defs:
        tools.append({
            "key": key,
            "label": label,
            "enabled": True,
            "findings": int(by_tool.get(key, 0)),
            "last_elapsed_sec": None,
        })

    latest_run_time = None
    if latest_run_dir is not None:
        try:
            ts = latest_run_dir.stat().st_mtime
            latest_run_time = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(ts))
        except Exception:
            latest_run_time = None

    env = {
        "profile": "EXT+",
        "root": str(root),
        "latest_run_dir": str(latest_run_dir) if latest_run_dir is not None else None,
        "run_id": run_id,
        "output_dir": str(out_dir),
        "version": "VSP 2025",
        "latest_run_time": latest_run_time,
    }

    resp = {
        "ok": True,
        "env": env,
        "tools": tools,
    }
    return jsonify(resp)


@bp_vsp_dashboard_v2.route("/api/vsp/run_scan", methods=["POST"])
def api_vsp_run_scan():
    """Stub API: nhận config scan và trả về ngay.
    TODO: nối vào script chạy FULL EXT thật (bin/run_vsp_...).
    """
    from flask import request, jsonify

    data = request.get_json(silent=True) or {}
    src = data.get("src") or data.get("source") or ""
    profile = data.get("profile") or "EXT+"

    resp = {
        "ok": True,
        "status": "stub",
        "message": "Run API is a stub – please wire it to your CLI runner script.",
        "src": src,
        "profile": profile,
    }
    return jsonify(resp)


@bp_vsp_dashboard_v2.route("/api/vsp/settings_v2", methods=["GET"])
def api_vsp_settings_v2():
    """Trả về thông tin ENV + tool stack đọc từ summary_unified.json (run mới nhất)."""
    from flask import jsonify

    ROOT = Path(__file__).resolve().parents[2]
    out_dir = ROOT / "out"

    latest_run_dir = None
    if out_dir.is_dir():
        candidates = [
            p for p in out_dir.iterdir()
            if p.is_dir() and p.name.startswith("RUN_VSP_FULL_EXT_")
        ]
        if candidates:
            candidates.sort(key=lambda p: p.name, reverse=True)
            latest_run_dir = candidates[0]

    latest_run_id = latest_run_time = None
    summary = {}
    if latest_run_dir is not None:
        latest_run_id = latest_run_dir.name
        summary_path = latest_run_dir / "report" / "summary_unified.json"
        if summary_path.is_file():
            try:
                summary = json.loads(summary_path.read_text(encoding="utf-8"))
                meta = summary.get("run") or summary.get("meta") or {}
                latest_run_time = meta.get("ts") or meta.get("time") or meta.get("started_at")
            except Exception as e:
                print("[VSP][settings_v2] Lỗi đọc summary_unified.json:", e)

    by_tool = summary.get("by_tool") or {}
    timing = summary.get("timing") or {}

    TOOL_LIST = [
        ("gitleaks",  "Gitleaks (Secrets)"),
        ("semgrep",   "Semgrep (SAST)"),
        ("kics",      "KICS (IaC)"),
        ("codeql",    "CodeQL"),
        ("bandit",    "Bandit (Python)"),
        ("trivy_fs",  "Trivy FS"),
        ("syft",      "Syft (SBOM)"),
        ("grype",     "Grype (Vulns)"),
    ]

    tool_rows = []
    for key, label in TOOL_LIST:
        tdata = by_tool.get(key) or {}
        findings = (
            tdata.get("total")
            or tdata.get("findings")
            or tdata.get("count")
            or 0
        )
        try:
            findings = int(findings)
        except Exception:
            findings = 0

        ttime = timing.get(key) or {}
        elapsed = (
            ttime.get("elapsed")
            or ttime.get("elapsed_sec")
            or ttime.get("seconds")
            or None
        )

        tool_rows.append({
            "key": key,
            "label": label,
            "enabled": True,
            "findings": findings,
            "elapsed": elapsed,
        })

    payload = {
        "ok": True,
        "profile": "EXT+",
        "root": str(ROOT),
        "out_dir": str(out_dir),
        "latest_run_id": latest_run_id,
        "latest_run_time": latest_run_time,
        "version": "VSP 2025",
        "tool_stack": tool_rows,
    }
    return jsonify(payload), 200


@bp_vsp_dashboard_v2.route("/api/vsp/run_scan", methods=["POST"])
def api_vsp_run_scan():
    """Trigger FULL EXT scan từ UI Settings (wrapper shell)."""
    from flask import jsonify, request

    ROOT = Path(__file__).resolve().parents[2]
    wrapper = ROOT / "bin" / "vsp_run_full_ext_from_settings_v1.sh"

    if not wrapper.is_file():
        return jsonify({
            "ok": False,
            "error": f"Wrapper not found: {wrapper}",
        }), 500

    data = request.get_json(silent=True) or {}
    src = data.get("src") or ""
    profile = data.get("profile") or "EXT+"

    env = os.environ.copy()
    env["VSP_SRC"] = src
    env["VSP_PROFILE"] = profile

    try:
        # Chạy background, không block request
        proc = subprocess.Popen(
            ["bash", str(wrapper)],
            cwd=str(ROOT),
            env=env,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
    except Exception as e:
        return jsonify({
            "ok": False,
            "error": f"Failed to start wrapper: {e}",
        }), 500

    return jsonify({
        "ok": True,
        "message": "Scan started via wrapper.",
        "wrapper": str(wrapper),
        "src": src,
        "profile": profile,
        "pid": proc.pid,
    }), 200


@bp_vsp_dashboard_v2.route("/api/vsp/rule_overrides_raw", methods=["GET"])
def api_vsp_rule_overrides_raw():
    """Đọc thô file config/vsp_rule_overrides.json cho editor."""
    from flask import jsonify

    ROOT = Path(__file__).resolve().parents[2]
    cfg = ROOT / "config" / "vsp_rule_overrides.json"

    if not cfg.is_file():
        return jsonify({
            "ok": False,
            "error": f"Config not found: {cfg}",
            "text": "[]",
        }), 404

    try:
        text = cfg.read_text(encoding="utf-8")
    except Exception as e:
        return jsonify({
            "ok": False,
            "error": f"Cannot read overrides: {e}",
            "text": "[]",
        }), 500

    return jsonify({
        "ok": True,
        "text": text,
        "path": str(cfg),
    }), 200


@bp_vsp_dashboard_v2.route("/api/vsp/rule_overrides_validate", methods=["POST"])
def api_vsp_rule_overrides_validate():
    """Validate JSON nội dung overrides (không ghi file)."""
    from flask import jsonify, request

    data = request.get_json(silent=True) or {}
    text = data.get("text") or ""

    try:
        obj = json.loads(text)
        if not isinstance(obj, list):
            return jsonify({
                "ok": False,
                "error": "JSON root must be a list [].",
            }), 400
    except Exception as e:
        return jsonify({
            "ok": False,
            "error": f"JSON parse error: {e}",
        }), 400

    return jsonify({
        "ok": True,
        "items": len(obj),
    }), 200


@bp_vsp_dashboard_v2.route("/api/vsp/rule_overrides_save", methods=["POST"])
def api_vsp_rule_overrides_save():
    """Validate + ghi file overrides JSON (backup bản cũ)."""
    from flask import jsonify, request

    ROOT = Path(__file__).resolve().parents[2]
    cfg = ROOT / "config" / "vsp_rule_overrides.json"
    cfg.parent.mkdir(parents=True, exist_ok=True)

    data = request.get_json(silent=True) or {}
    text = data.get("text") or ""

    try:
        obj = json.loads(text)
        if not isinstance(obj, list):
            return jsonify({
                "ok": False,
                "error": "JSON root must be a list [].",
            }), 400
    except Exception as e:
        return jsonify({
            "ok": False,
            "error": f"JSON parse error: {e}",
        }), 400

    # Backup
    if cfg.is_file():
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup = cfg.with_suffix(cfg.suffix + f".bak_{ts}")
        backup.write_text(cfg.read_text(encoding="utf-8"), encoding="utf-8")

    cfg.write_text(json.dumps(obj, indent=2, ensure_ascii=False), encoding="utf-8")

    return jsonify({
        "ok": True,
        "path": str(cfg),
        "items": len(obj),
    }), 200

