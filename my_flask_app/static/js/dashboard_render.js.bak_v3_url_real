(function () {
  if (!window.VSP) window.VSP = {};

  var SEV_WEIGHT = {
    CRITICAL: 5,
    HIGH: 4,
    MEDIUM: 3,
    LOW: 2,
    INFO: 1,
    TRACE: 0
  };

  // ---- KPI helpers ----
  function setKpi(id, label, value, sub) {
    var el = document.getElementById(id);
    if (!el) return;
    el.innerHTML = `
      <div class="kpi-label">${label}</div>
      <div class="kpi-value">${value != null ? value : '-'}</div>
      <div class="kpi-sub">${sub || ''}</div>
    `;
  }

  function fillTopTable(tableId, rows, columns) {
    var el = document.getElementById(tableId);
    if (!el) return;

    var thead = '<thead><tr>' +
      columns.map(function (c) { return '<th>' + c.label + '</th>'; }).join('') +
      '</tr></thead>';

    var bodyRows = (rows || []).map(function (r) {
      return '<tr>' + columns.map(function (c) {
        var v = r[c.key];
        if (v == null) v = '';
        return '<td>' + v + '</td>';
      }).join('') + '</tr>';
    }).join('');

    el.innerHTML = thead + '<tbody>' + bodyRows + '</tbody>';
  }

  // ---- Aggregate từ findings (datasource?mode=dashboard hoặc full) ----
  function aggregateFromFindings(findings) {
    var severityCounts = {};
    var toolCounts = {};
    var cveCounts = {};
    var moduleRaw = [];

    (findings || []).forEach(function (f) {
      var sev = (f.severity || '').toUpperCase();
      if (!sev) sev = 'INFO';
      severityCounts[sev] = (severityCounts[sev] || 0) + 1;

      var tool = f.tool || 'unknown';
      toolCounts[tool] = (toolCounts[tool] || 0) + 1;

      var cve = f.cve || null;
      if (cve) {
        cveCounts[cve] = (cveCounts[cve] || 0) + 1;
      }

      var mod = f.module || f.package || f.dependency || f.file || null;
      if (mod) {
        moduleRaw.push({ module: mod, severity: sev });
      }
    });

    var topFindings = (findings || []).slice().sort(function (a, b) {
      var wa = SEV_WEIGHT[(a.severity || '').toUpperCase()] || 0;
      var wb = SEV_WEIGHT[(b.severity || '').toUpperCase()] || 0;
      return wb - wa;
    }).slice(0, 5);

    var topCve = Object.keys(cveCounts).map(function (cve) {
      return { cve: cve, count: cveCounts[cve] };
    }).sort(function (a, b) { return b.count - a.count; }).slice(0, 5);

    var modAgg = {};
    moduleRaw.forEach(function (m) {
      var key = m.module;
      var sev = m.severity;
      if (!modAgg[key]) {
        modAgg[key] = { module: key, count: 0, critical: 0 };
      }
      modAgg[key].count += 1;
      var w = SEV_WEIGHT[sev] || 0;
      if (w >= SEV_WEIGHT.HIGH) {
        modAgg[key].critical += 1;
      }
    });

    var topModules = Object.keys(modAgg).map(function (k) { return modAgg[k]; })
      .sort(function (a, b) { return b.count - a.count; })
      .slice(0, 5);

    return {
      total_findings: (findings || []).length,
      severity: severityCounts,
      by_tool: toolCounts,
      top_findings: topFindings,
      top_cve: topCve,
      top_modules: topModules
    };
  }

  // ---- Canvas helpers ----
  function setupCanvas(card, id, height) {
    var old = card.querySelector('canvas#' + id);
    if (old) {
      var ctxOld = old.getContext('2d');
      ctxOld.clearRect(0, 0, old.width, old.height);
      return { canvas: old, ctx: ctxOld, width: old.width, height: old.height };
    }

    var canvas = document.createElement('canvas');
    canvas.id = id;
    canvas.className = 'vsp-chart-canvas';
    canvas.style.width = '100%';
    canvas.style.height = height + 'px';
    card.appendChild(canvas);

    var dpr = window.devicePixelRatio || 1;
    var rect = canvas.getBoundingClientRect();
    var w = rect.width || card.clientWidth || 320;
    canvas.width = w * dpr;
    canvas.height = height * dpr;
    var ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);

    return { canvas: canvas, ctx: ctx, width: w, height: height };
  }

  function getChartCards() {
    var cards = document.querySelectorAll('.dash-chart-row .chart-card');
    return cards || [];
  }

  // ===== 1) SEVERITY DONUT =====
  function renderSeverityBlock(sev) {
    var cards = getChartCards();
    var card = cards[0];
    if (!card) return;

    var order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO', 'TRACE'];
    var colors = {
      CRITICAL: '#fb7185',
      HIGH:     '#fb923c',
      MEDIUM:   '#eab308',
      LOW:      '#22c55e',
      INFO:     '#38bdf8',
      TRACE:    '#a855f7'
    };

    var rows = [];
    var total = 0;
    order.forEach(function (s) {
      var v = sev[s] || sev[s.toLowerCase()] || 0;
      if (!v) return;
      rows.push({ label: s, value: v, color: colors[s] });
      total += v;
    });

    card.innerHTML = `
      <div class="chart-header">
        <div class="chart-title-main">Severity Distribution (6 buckets)</div>
        <div class="chart-sub">Normalized from unified findings.</div>
      </div>
      <div class="chart-legend-row"></div>
    `;
    var legendRow = card.querySelector('.chart-legend-row');
    order.forEach(function (s) {
      var legend = document.createElement('div');
      legend.className = 'chart-legend-item';
      legend.innerHTML =
        '<span class="legend-color" style="background:' + (colors[s] || '#4b5563') + '"></span>' +
        '<span class="legend-label">' + s + '</span>';
      legendRow.appendChild(legend);
    });

    if (!rows.length || total === 0) {
      var emptyDiv = document.createElement('div');
      emptyDiv.className = 'mini-chart-empty';
      emptyDiv.textContent = 'No severity data yet.';
      card.appendChild(emptyDiv);
      return;
    }

    var canvasSetup = setupCanvas(card, 'chart-severity-donut', 170);
    var ctx = canvasSetup.ctx;
    var w = canvasSetup.width;
    var h = canvasSetup.height;
    var cx = w / 2;
    var cy = h / 2 + 4;
    var outerR = Math.min(w, h) * 0.38;
    var innerR = outerR * 0.55;

    ctx.clearRect(0, 0, w, h);

    // nền vòng mờ
    ctx.beginPath();
    ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
    ctx.arc(cx, cy, innerR, Math.PI * 2, 0, true);
    ctx.closePath();
    ctx.fillStyle = 'rgba(15,23,42,0.9)';
    ctx.fill();

    // từng segment
    var start = -Math.PI / 2;
    rows.forEach(function (row) {
      var angle = (row.value / total) * Math.PI * 2;
      var end = start + angle;

      ctx.beginPath();
      ctx.arc(cx, cy, outerR, start, end);
      ctx.arc(cx, cy, innerR, end, start, true);
      ctx.closePath();
      ctx.fillStyle = row.color;
      ctx.fill();

      start = end;
    });

    // text giữa donut cho đẹp hơn khi chỉ có 1 bucket
    var maxLabel = rows[0].label;
    var maxVal = rows[0].value;
    rows.forEach(function (r) {
      if (r.value > maxVal) {
        maxVal = r.value;
        maxLabel = r.label;
      }
    });

    ctx.fillStyle = '#e5e7eb';
    ctx.font = '14px "Inter", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(maxVal), cx, cy - 6);

    ctx.fillStyle = '#9ca3af';
    ctx.font = '11px "Inter", system-ui, sans-serif';
    ctx.fillText(maxLabel, cx, cy + 10);
  }

  // ===== 2) TREND LINE + AREA =====
  function renderTrendBlock(runs) {
    var cards = getChartCards();
    var card = cards[1];
    if (!card) return;

    card.innerHTML = `
      <div class="chart-header">
        <div class="chart-title-main">Trend – Findings Over Time</div>
        <div class="chart-sub">Last ${runs.length || 0} runs.</div>
      </div>
    `;

    if (!runs || !runs.length) {
      var emptyDiv = document.createElement('div');
      emptyDiv.className = 'mini-chart-empty';
      emptyDiv.textContent = 'No historical runs yet.';
      card.appendChild(emptyDiv);
      return;
    }

    var canvasSetup = setupCanvas(card, 'chart-trend', 180);
    var ctx = canvasSetup.ctx;
    var w = canvasSetup.width;
    var h = canvasSetup.height;

    var padding = { top: 24, right: 20, bottom: 26, left: 44 };
    var chartW = w - padding.left - padding.right;
    var chartH = h - padding.top - padding.bottom;

    var values = runs.map(function (r) { return r.total_findings || r.total || 0; });
    var minVal = Math.min.apply(null, values);
    var maxVal = Math.max.apply(null, values);
    if (minVal === maxVal) {
      minVal = 0;
    }

    function yScale(v) {
      if (maxVal === minVal) return padding.top + chartH;
      return padding.top + chartH - (v - minVal) * chartH / (maxVal - minVal);
    }
    function xScale(i) {
      if (runs.length === 1) return padding.left + chartW / 2;
      return padding.left + i * chartW / (runs.length - 1);
    }

    ctx.clearRect(0, 0, w, h);

    // grid ngang
    var gridLines = 4;
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(30,64,175,0.5)';
    for (var g = 0; g <= gridLines; g++) {
      var gy = padding.top + g * chartH / gridLines;
      ctx.moveTo(padding.left, gy);
      ctx.lineTo(padding.left + chartW, gy);
    }
    ctx.stroke();

    // area fill
    ctx.beginPath();
    values.forEach(function (v, i) {
      var x = xScale(i);
      var y = yScale(v);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.lineTo(padding.left + chartW, padding.top + chartH);
    ctx.lineTo(padding.left, padding.top + chartH);
    ctx.closePath();
    ctx.fillStyle = 'rgba(56,189,248,0.18)';
    ctx.fill();

    // line
    ctx.beginPath();
    values.forEach(function (v, i) {
      var x = xScale(i);
      var y = yScale(v);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(56,189,248,0.95)';
    ctx.stroke();

    // points
    ctx.fillStyle = 'rgba(56,189,248,1)';
    values.forEach(function (v, i) {
      var x = xScale(i);
      var y = yScale(v);
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // ===== 3) FINDINGS BY TOOL – bar chart =====
  function renderByToolBlock(byTool) {
    var cards = getChartCards();
    var card = cards[2];
    if (!card) return;

    var arr = Object.keys(byTool || {}).map(function (k) {
      return { tool: k, count: byTool[k] };
    }).sort(function (a, b) { return b.count - a.count; }).slice(0, 6);

    card.innerHTML = `
      <div class="chart-header">
        <div class="chart-title-main">Critical / High by Tool</div>
        <div class="chart-sub">Approx. based on unified findings.</div>
      </div>
    `;

    if (!arr.length) {
      var emptyDiv = document.createElement('div');
      emptyDiv.className = 'mini-chart-empty';
      emptyDiv.textContent = 'No data yet.';
      card.appendChild(emptyDiv);
      return;
    }

    var canvasSetup = setupCanvas(card, 'chart-tools', 180);
    var ctx = canvasSetup.ctx;
    var w = canvasSetup.width;
    var h = canvasSetup.height;

    var padding = { top: 20, right: 16, bottom: 36, left: 40 };
    var chartW = w - padding.left - padding.right;
    var chartH = h - padding.top - padding.bottom;

    var maxVal = arr[0].count || 1;
    var slotW = chartW / arr.length;
    var barWidth = slotW * 0.45;

    function xPos(i) {
      return padding.left + i * slotW + (slotW - barWidth) / 2;
    }
    function yPos(v) {
      return padding.top + chartH - (v * chartH / maxVal);
    }

    ctx.clearRect(0, 0, w, h);

    // grid ngang
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(30,64,175,0.5)';
    for (var g = 0; g <= 4; g++) {
      var gy = padding.top + g * chartH / 4;
      ctx.moveTo(padding.left, gy);
      ctx.lineTo(padding.left + chartW, gy);
    }
    ctx.stroke();

    // bars
    ctx.fillStyle = 'rgba(96,165,250,0.95)';
    arr.forEach(function (t, i) {
      var x = xPos(i);
      var y = yPos(t.count);
      var hBar = padding.top + chartH - y;

      if (ctx.roundRect) {
        ctx.beginPath();
        ctx.roundRect(x, y, barWidth, hBar, 4);
        ctx.fill();
      } else {
        ctx.fillRect(x, y, barWidth, hBar);
      }
    });

    // x labels
    ctx.fillStyle = '#9ca3af';
    ctx.font = '11px system-ui, -apple-system, BlinkMacSystemFont, "Inter", sans-serif';
    ctx.textAlign = 'center';
    arr.forEach(function (t, i) {
      var x = xPos(i) + barWidth / 2;
      var y = padding.top + chartH + 16;
      ctx.fillText(t.tool, x, y);
    });
  }

  // ===== 4) TOP CVE – horizontal bar chart (nếu có dữ liệu) =====
  function renderTopCveChart(topCves) {
    var table = document.getElementById('top-cve');
    if (!table || !table.parentElement) return;
    var card = table.parentElement;

    var header = card.querySelector('.chart-title-main');
    if (!header) {
      var wrap = document.createElement('div');
      wrap.className = 'chart-header';
      wrap.innerHTML = '<div class="chart-title-main">Top CWE / CVE Exposure</div>' +
                       '<div class="chart-sub">Mapped from rules / CVEs.</div>';
      card.insertBefore(wrap, card.firstChild);
    }

    if (!topCves || !topCves.length) {
      return;
    }

    var canvasSetup = setupCanvas(card, 'chart-topcve', 150);
    var ctx = canvasSetup.ctx;
    var w = canvasSetup.width;
    var h = canvasSetup.height;

    var padding = { top: 10, right: 24, bottom: 10, left: 64 };
    var chartW = w - padding.left - padding.right;
    var chartH = h - padding.top - padding.bottom;

    var maxVal = topCves[0].count || 1;
    var slotH = chartH / topCves.length;
    var barH = slotH * 0.55;

    function yPos(i) {
      return padding.top + i * slotH + (slotH - barH) / 2;
    }
    function xPos(v) {
      return padding.left + (v * chartW / maxVal);
    }

    ctx.clearRect(0, 0, w, h);

    // grid dọc
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(30,64,175,0.5)';
    for (var g = 0; g <= 4; g++) {
      var gx = padding.left + g * chartW / 4;
      ctx.moveTo(gx, padding.top);
      ctx.lineTo(gx, padding.top + chartH);
    }
    ctx.stroke();

    ctx.font = '11px system-ui, -apple-system, BlinkMacSystemFont, "Inter", sans-serif';
    topCves.forEach(function (cve, i) {
      var y = yPos(i);
      var xEnd = xPos(cve.count);

      ctx.fillStyle = 'rgba(59,130,246,0.9)';
      if (ctx.roundRect) {
        ctx.beginPath();
        ctx.roundRect(padding.left, y, xEnd - padding.left, barH, 4);
        ctx.fill();
      } else {
        ctx.fillRect(padding.left, y, xEnd - padding.left, barH);
      }

      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'right';
      ctx.fillText(cve.cve, padding.left - 8, y + barH * 0.7);

      ctx.fillStyle = '#9ca3af';
      ctx.textAlign = 'left';
      ctx.fillText(String(cve.count), xEnd + 4, y + barH * 0.7);
    });
  }

  // ===== MAIN ENTRY – initDashboard =====
  window.VSP.initDashboard = async function () {
    console.log('[VSP][UI] initDashboard');

    var dash    = await window.VSP.API.getDashboard();
    var dsDash  = await window.VSP.API.getDashboardDatasource();
    var runsAll = await window.VSP.API.getRunsIndex();

    var kpi = dash && dash.kpi ? dash.kpi : null;

    if ((!kpi || Object.keys(kpi).length === 0) && Array.isArray(dsDash)) {
      console.log('[VSP][UI] Dashboard: dùng aggregate từ datasource?mode=dashboard (no kpi)');
      var agg = aggregateFromFindings(dsDash);
      kpi = {
        total_findings: agg.total_findings,
        severity: agg.severity,
        tool_counts: agg.by_tool,
        security_score: null,
        top_risky_tool: null,
        top_cwe: null,
        top_module: null
      };
      dash = {
        kpi: kpi,
        top_findings: agg.top_findings,
        top_cve: agg.top_cve,
        top_modules: agg.top_modules
      };
    }

    if (!kpi) {
      console.warn('[VSP][UI] /api/vsp/dashboard_v3 không có kpi');
      setKpi('kpi-total', 'Total Findings', 'N/A', 'No dashboard data');
      return;
    }

    var sev = kpi.severity || {};
    var byTool = kpi.tool_counts || {};

    if ((!sev || Object.keys(sev).length === 0 || Object.keys(byTool).length === 0) && Array.isArray(dsDash)) {
      console.log('[VSP][UI] Dashboard: bổ sung severity/by_tool từ datasource?mode=dashboard');
      var agg2 = aggregateFromFindings(dsDash);
      if (!sev || Object.keys(sev).length === 0) {
        sev = agg2.severity;
      }
      if (Object.keys(byTool).length === 0) {
        byTool = agg2.by_tool;
      }
      if (!dash.top_findings) dash.top_findings = agg2.top_findings;
      if (!dash.top_cve)      dash.top_cve      = agg2.top_cve;
      if (!dash.top_modules)  dash.top_modules  = agg2.top_modules;
    }

    var total = kpi.total_findings ||
      Object.values(sev || {}).reduce(function (acc, v) { return acc + (v || 0); }, 0);

    var score     = kpi.security_score != null ? kpi.security_score : null;
    var topTool   = kpi.top_risky_tool || Object.keys(byTool).sort(function (a, b) {
      return (byTool[b] || 0) - (byTool[a] || 0);
    })[0];
    var topCwe    = kpi.top_cwe || null;
    var topModule = kpi.top_module || null;

    setKpi('kpi-total',    'Total Findings', total, '');
    setKpi('kpi-critical', 'Critical', sev.CRITICAL || sev.critical || 0, '');
    setKpi('kpi-high',     'High',     sev.HIGH || sev.high || 0, '');
    setKpi('kpi-medium',   'Medium',   sev.MEDIUM || sev.medium || 0, '');
    setKpi('kpi-low',      'Low',      sev.LOW || sev.low || 0, '');
    var infoTrace = (sev.INFO || sev.info || 0) + (sev.TRACE || sev.trace || 0);
    setKpi('kpi-infotrace','Info / Trace', infoTrace, '');

    setKpi('kpi-score',  'Security Score', score != null ? score : '-', '/100');
    setKpi('kpi-tool',   'Top Risky Tool', topTool || '-', '');
    setKpi('kpi-cwe',    'Top CWE',        topCwe || '-', '');
    setKpi('kpi-module', 'Top Module',     topModule || '-', '');

    var topFindings = dash.top_findings || [];
    var topCves     = dash.top_cve || [];
    var topModules  = dash.top_modules || [];

    if ((!topFindings || !topFindings.length) && Array.isArray(dsDash)) {
      topFindings = aggregateFromFindings(dsDash).top_findings;
    }
    if ((!topCves || !topCves.length) && Array.isArray(dsDash)) {
      topCves = aggregateFromFindings(dsDash).top_cve;
    }
    if ((!topModules || !topModules.length) && Array.isArray(dsDash)) {
      topModules = aggregateFromFindings(dsDash).top_modules;
    }

    fillTopTable('top-findings', topFindings, [
      { key: 'severity', label: 'Sev' },
      { key: 'tool',     label: 'Tool' },
      { key: 'rule_id',  label: 'Rule' },
      { key: 'file',     label: 'File' },
      { key: 'message',  label: 'Message' }
    ]);

    fillTopTable('top-cve', topCves, [
      { key: 'cve',   label: 'CVE' },
      { key: 'count', label: 'Count' }
    ]);

    fillTopTable('top-mod', topModules, [
      { key: 'module',   label: 'Module / Package' },
      { key: 'count',    label: 'Findings' },
      { key: 'critical', label: 'Critical/High' }
    ]);

    // --- vẽ 4 chart ---
    renderSeverityBlock(sev);

    var runs = (runsAll || []).slice().sort(function (a, b) {
      var ta = a.ts || '';
      var tb = b.ts || '';
      if (ta > tb) return -1;
      if (ta < tb) return  1;
      return 0;
    }).slice(0, 10).reverse();  // oldest -> newest
    renderTrendBlock(runs);

    renderByToolBlock(byTool);

    renderTopCveChart(topCves);

    console.log('[VSP][UI] Dashboard charts filled (polished).');
  };
})();
