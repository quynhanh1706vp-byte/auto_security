import json
from collections import Counter
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from flask import Blueprint, jsonify, current_app

bp_vsp_dashboard_v3 = Blueprint("vsp_dashboard_v3", __name__)

SEVERITY_ORDER = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]
SEVERITY_WEIGHT = {
    "CRITICAL": 10.0,
    "HIGH": 5.0,
    "MEDIUM": 2.0,
    "LOW": 1.0,
    "INFO": 0.2,
    "TRACE": 0.0,
}

def _get_root_dir() -> Path:
    # ROOT = /home/test/Data/SECURITY_BUNDLE
    return Path(__file__).resolve().parents[2]

def _find_latest_run_dir() -> Optional[Path]:
    root = _get_root_dir()
    out_dir = root / "out"
    if not out_dir.is_dir():
        return None
    candidates: List[Tuple[float, Path]] = []
    for p in out_dir.iterdir():
        if p.is_dir() and p.name.startswith("RUN_VSP_FULL_EXT_"):
            try:
                candidates.append((p.stat().st_mtime, p))
            except Exception:
                pass
    if not candidates:
        return None
    candidates.sort(key=lambda x: x[0], reverse=True)
    return candidates[0][1]

def _load_findings(run_dir: Optional[Path]) -> Tuple[Optional[str], List[Dict[str, Any]]]:
    if run_dir is None:
        return None, []
    report_dir = run_dir / "report"
    findings_path = report_dir / "findings_unified.json"
    if not findings_path.is_file():
        return run_dir.name, []
    try:
        data = json.loads(findings_path.read_text(encoding="utf-8"))
        if isinstance(data, list):
            return run_dir.name, data
        if isinstance(data, dict) and isinstance(data.get("items"), list):
            return run_dir.name, data["items"]
        return run_dir.name, []
    except Exception as e:
        current_app.logger.exception("[VSP_DASH_V3] Lỗi load findings_unified.json: %s", e)
        return run_dir.name, []

def _norm_sev(val: Any) -> str:
    if not isinstance(val, str):
        return "TRACE"
    v = val.strip().upper()
    return v if v in SEVERITY_ORDER else "TRACE"

def _by_sev(findings: List[Dict[str, Any]]) -> Dict[str, int]:
    counts = {s: 0 for s in SEVERITY_ORDER}
    for f in findings:
        sev = _norm_sev(
            f.get("severity_effective")
            or f.get("severity")
            or f.get("severity_raw")
        )
        if sev in counts:
            counts[sev] += 1
    return counts

def _score(by_sev: Dict[str, int]) -> int:
    if not by_sev:
        return 100
    total_penalty = 0.0
    for sev, count in by_sev.items():
        total_penalty += SEVERITY_WEIGHT.get(sev, 0.0) * count
    score = 100.0 - (total_penalty / 50.0) * 10.0
    score = max(0.0, min(100.0, score))
    return int(round(score))

def _top_tool(findings: List[Dict[str, Any]]) -> str:
    ctr = Counter()
    for f in findings:
        sev = _norm_sev(f.get("severity_effective") or f.get("severity_raw"))
        if sev not in ("CRITICAL", "HIGH", "MEDIUM"):
            continue
        tool = (f.get("tool") or "").strip()
        if tool:
            ctr[tool] += 1
    return ctr.most_common(1)[0][0] if ctr else "-"

def _top_cwe(findings: List[Dict[str, Any]]) -> str:
    ctr = Counter()
    for f in findings:
        sev = _norm_sev(f.get("severity_effective") or f.get("severity_raw"))
        if sev not in ("CRITICAL", "HIGH", "MEDIUM"):
            continue
        vuln = f.get("vuln") or {}
        extra = f.get("extra") or {}
        cwe_ids = vuln.get("cwe_ids")
        if isinstance(cwe_ids, list):
            for c in cwe_ids:
                if isinstance(c, str) and c.strip():
                    ctr[c.strip()] += 1
            continue
        cwe_id = vuln.get("cwe_id") or extra.get("cwe_id") or extra.get("cwe")
        if isinstance(cwe_id, str) and cwe_id.strip():
            ctr[cwe_id.strip()] += 1
    return ctr.most_common(1)[0][0] if ctr else "-"

def _top_module(findings: List[Dict[str, Any]]) -> str:
    ctr = Counter()
    for f in findings:
        sev = _norm_sev(f.get("severity_effective") or f.get("severity_raw"))
        if sev not in ("CRITICAL", "HIGH", "MEDIUM"):
            continue
        ctx = f.get("code_context") or {}
        module = (f.get("module") or ctx.get("module") or "").strip()
        if module:
            ctr[module] += 1
    return ctr.most_common(1)[0][0] if ctr else "-"

@bp_vsp_dashboard_v3.route("/api/vsp/dashboard_v3", methods=["GET"])
def api_vsp_dashboard_v3():
    run_dir = _find_latest_run_dir()
    run_id, findings = _load_findings(run_dir)

    if run_dir is None or not findings:
        return jsonify({
            "ok": False,
            "run_id": run_id,
            "message": "Không tìm thấy RUN_VSP_FULL_EXT_* hoặc findings_unified.json rỗng.",
        })

    by_severity = _by_sev(findings)
    total = sum(by_severity.values())
    security_score = _score(by_severity)

    payload = {
        "ok": True,
        "run_id": run_id,
        "total_findings": total,
        "by_severity": by_severity,
        "severity": by_severity,
        "security_score": security_score,
        "top_risky_tool": _top_tool(findings),
        "top_cwe": _top_cwe(findings),
        "top_module": _top_module(findings),
        "ts": datetime.utcnow().isoformat() + "Z",
    }
    return jsonify(payload)


# === [VSP][EXTRA_API_V1] Trend, Top Findings, Datasource stats, Settings ===
from datetime import datetime, timedelta
from pathlib import Path as _Path
import json as _json
from flask import request

ROOT = _Path(__file__).resolve().parents[3]
OUT_DIR = ROOT / "out"
SETTINGS_PATH = ROOT / "config" / "vsp_settings.json"
SETTINGS_PATH.parent.mkdir(parents=True, exist_ok=True)


def _get_latest_run_dir():
    candidates = sorted(OUT_DIR.glob("RUN_VSP_*"), reverse=True)
    for run_dir in candidates:
        fu = run_dir / "report" / "findings_unified.json"
        if fu.exists():
            return run_dir
    return None


def _load_latest_dashboard_payload():
    run_dir = _get_latest_run_dir()
    if not run_dir:
        return {"total_findings": 0, "by_severity": {}, "by_tool": {}}

    summary_path = run_dir / "report" / "summary_unified.json"
    if summary_path.exists():
        with summary_path.open("r", encoding="utf-8") as f:
            data = _json.load(f)
        return {
            "run_id": run_dir.name,
            "total_findings": data.get("total_findings", 0),
            "by_severity": data.get("by_severity", {}),
            "by_tool": data.get("by_tool", {}),
            "security_score": data.get("security_score", 0),
            "top_risky_tool": data.get("top_risky_tool"),
            "top_cwe": data.get("top_cwe"),
            "top_module": data.get("top_module"),
        }
    return {"total_findings": 0, "by_severity": {}, "by_tool": {}}


@bp_vsp_dashboard_v3.route("/api/vsp/trend_v1", methods=["GET"])
def api_vsp_trend_v1():
    payload = _load_latest_dashboard_payload()
    total = int(payload.get("total_findings", 0))
    today = datetime.utcnow().date()
    series = []
    # Hôm nay -6 -> hôm nay
    for i in range(7):
        d = today - timedelta(days=(6 - i))
        series.append({"date": d.isoformat(), "total": total})
    return jsonify(series)


@bp_vsp_dashboard_v3.route("/api/vsp/top_findings_v1", methods=["GET"])
def api_vsp_top_findings_v1():
    run_dir = _get_latest_run_dir()
    if not run_dir:
        return jsonify({"items": []})
    fu_path = run_dir / "report" / "findings_unified.json"
    if not fu_path.exists():
        return jsonify({"items": []})

    with fu_path.open("r", encoding="utf-8") as f:
        findings = _json.load(f)

    high_crit = [
        f for f in findings
        if str(f.get("severity_effective") or f.get("severity") or "").upper()
        in ("CRITICAL", "HIGH")
    ]
    sev_rank = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "INFO": 4, "TRACE": 5}
    high_crit.sort(
        key=lambda x: sev_rank.get(
            str(x.get("severity_effective") or x.get("severity") or "").upper(), 99
        )
    )

    top = []
    for fitem in high_crit[:10]:
        sev = str(fitem.get("severity_effective") or fitem.get("severity") or "")
        tool = fitem.get("tool") or fitem.get("source_tool") or ""
        rule = fitem.get("rule_id") or fitem.get("id") or ""
        file_path = fitem.get("file") or fitem.get("location") or ""
        line = fitem.get("line") or fitem.get("start_line")
        location = f"{file_path}:{line}" if (file_path and line) else file_path
        top.append(
            {"severity": sev, "rule_id": rule, "location": location, "tool": tool}
        )

    return jsonify({"items": top})


@bp_vsp_dashboard_v3.route("/api/vsp/datasource_stats_v1", methods=["GET"])
def api_vsp_datasource_stats_v1():
    """
    Stats cho tab Data Source: by_severity + by_tool
    reuse từ summary_unified của run mới nhất.
    """
    payload = _load_latest_dashboard_payload()
    return jsonify(
        {
            "by_severity": payload.get("by_severity", {}),
            "by_tool": payload.get("by_tool", {}),
        }
    )


def _load_settings():
    if SETTINGS_PATH.exists():
        with SETTINGS_PATH.open("r", encoding="utf-8") as f:
            return _json.load(f)
    return {
        "profile": "default",
        "tools": {
            "semgrep": True,
            "gitleaks": True,
            "bandit": True,
            "trivy_fs": True,
            "grype": True,
            "kics": True,
            "codeql": True,
            "syft": True,
        },
        "limits": {
            "max_findings_per_tool": 5000,
            "top_findings_limit": 10,
        },
    }


@bp_vsp_dashboard_v3.route("/api/vsp/settings/get", methods=["GET"])
def api_vsp_settings_get():
    cfg = _load_settings()
    return jsonify(cfg)


@bp_vsp_dashboard_v3.route("/api/vsp/settings/save", methods=["POST"])
def api_vsp_settings_save():
    payload = request.get_json(force=True) or {}
    with SETTINGS_PATH.open("w", encoding="utf-8") as f:
        _json.dump(payload, f, indent=2, ensure_ascii=False)
    return jsonify({"ok": True})



@bp_vsp_dashboard_v3.route("/api/vsp/datasource_v2", methods=["GET"])
def api_vsp_datasource_v2():
    """
    Unified findings datasource (v2)
    Query:
      - severity: optional (CRITICAL/HIGH/MEDIUM/LOW/INFO/TRACE)
      - limit: optional, default 200
    Trả về:
      {
        "total": <int>,        # tổng số bản ghi match
        "items": [
          {
            "severity": "...",
            "tool": "...",
            "rule_id": "...",
            "location": "file:line",
            "message": "...",
            "cwe": "CWE-xxx"
          },
          ...
        ]
      }
    """
    from flask import request, jsonify  # đảm bảo import sẵn

    # Dùng helper đã có
    run_dir = _get_latest_run_dir()
    if not run_dir:
        return jsonify({"total": 0, "items": []})

    fu_path = run_dir / "report" / "findings_unified.json"
    if not fu_path.exists():
        return jsonify({"total": 0, "items": []})

    import json as _json
    with fu_path.open("r", encoding="utf-8") as f:
        findings = _json.load(f)

    sev_filter = (request.args.get("severity") or "").upper().strip()
    try:
        limit = int(request.args.get("limit", "200"))
    except ValueError:
        limit = 200
    if limit <= 0:
        limit = 1
    if limit > 1000:
        limit = 1000

    items = []
    total = 0

    for fitem in findings:
        sev = str(fitem.get("severity_effective") or fitem.get("severity") or "").upper()
        if sev_filter and sev != sev_filter:
            continue

        total += 1
        if len(items) >= limit:
            continue

        tool = fitem.get("tool") or fitem.get("source_tool") or ""
        rule = fitem.get("rule_id") or fitem.get("id") or ""
        file_path = fitem.get("file") or fitem.get("location") or ""
        line = fitem.get("line") or fitem.get("start_line")
        if line:
            location = f"{file_path}:{line}"
        else:
            location = file_path

        msg = (
            fitem.get("message")
            or fitem.get("detail")
            or fitem.get("description")
            or ""
        )
        cwe = (
            fitem.get("cwe")
            or fitem.get("cwe_id")
            or fitem.get("cwe_name")
            or ""
        )

        items.append(
            {
                "severity": sev,
                "tool": tool,
                "rule_id": rule,
                "location": location,
                "message": msg,
                "cwe": cwe,
            }
        )

    return jsonify({"total": total, "items": items})
