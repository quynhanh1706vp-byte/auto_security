from __future__ import annotations

import json
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from flask import Blueprint, jsonify, request

# ============================================================
#  VSP 2025 – Backend API (EXT+ Profile)
#  - Đọc dữ liệu từ: out/RUN_.../report/findings_unified.json
#                    out/RUN_.../report/summary_unified.json
#  - Phục vụ cho 5 tab:
#       1) Dashboard
#       2) Runs & Reports
#       3) Data Source
#       4) Settings (read-only)
#       5) Rule Overrides (stub)
# ============================================================

bp = Blueprint("vsp_dashboard_api", __name__, url_prefix="/api/vsp")

# ROOT = /home/test/Data/SECURITY_BUNDLE
ROOT = Path(__file__).resolve().parents[2]
OUT_DIR = ROOT / "out"


# ------------------------- Helpers -------------------------


def _severity_weight(level: str) -> int:
    mapping = {
        "CRITICAL": 5,
        "HIGH": 4,
        "MEDIUM": 3,
        "LOW": 2,
        "INFO": 1,
        "TRACE": 0,
    }
    return mapping.get(level.upper(), 0)


def _load_json(path: Path) -> Any:
    if not path.is_file():
        return None
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return None


def _list_run_dirs() -> List[Path]:
    """
    Lấy danh sách thư mục RUN_* (run full) có summary_unified.json.
    """
    candidates: List[Path] = []
    if not OUT_DIR.is_dir():
        return candidates

    for p in OUT_DIR.iterdir():
        if not p.is_dir():
            continue
        name = p.name
        if not (name.startswith("RUN_") or name.startswith("TEST_")):
            continue
        summary = p / "report" / "summary_unified.json"
        if summary.is_file():
            candidates.append(p)

    return sorted(
        candidates,
        key=lambda d: (d / "report" / "summary_unified.json").stat().st_mtime,
        reverse=True,
    )


def _get_latest_run() -> Optional[Path]:
    runs = _list_run_dirs()
    return runs[0] if runs else None


def _load_summary_for_run(run_dir: Path) -> Tuple[Optional[Dict[str, Any]], Optional[Dict[str, Any]]]:
    """
    Trả về (summary, summary_file_info)
    summary_file_info:
        { "path": ..., "mtime": ..., "ts_iso": ... }
    """
    summary_path = run_dir / "report" / "summary_unified.json"
    summary = _load_json(summary_path)
    if summary is None:
        return None, None

    st = summary_path.stat()
    ts = datetime.fromtimestamp(st.st_mtime)
    info = {
        "path": str(summary_path),
        "mtime": st.st_mtime,
        "ts_iso": ts.isoformat(),
    }
    return summary, info


def _load_findings_for_run(run_dir: Path) -> List[Dict[str, Any]]:
    path = run_dir / "report" / "findings_unified.json"
    data = _load_json(path)
    if isinstance(data, list):
        return data
    return []


def _compute_security_score(summary: Dict[str, Any]) -> int:
    """
    Tính điểm Security Score 0–100 (heuristic đơn giản).
    - Không có findings  -> 100
    - Có CRITICAL/HIGH nhiều -> điểm giảm
    """
    total = int(summary.get("total_findings", 0) or 0)
    by_sev: Dict[str, int] = summary.get("by_severity", {}) or {}

    if total <= 0:
        return 100

    crit = int(by_sev.get("CRITICAL", 0) or 0)
    high = int(by_sev.get("HIGH", 0) or 0)
    med = int(by_sev.get("MEDIUM", 0) or 0)

    # Trọng số: CRITICAL nặng nhất
    penalty = crit * 3 + high * 1.5 + med * 0.5
    # Scale
    score = max(0, 100 - int(penalty / max(1, total) * 100))
    # Kẹp 0–100
    score = max(0, min(100, score))
    return score


def _compute_top_risky_tool(summary: Dict[str, Any]) -> Optional[str]:
    by_tool: Dict[str, int] = summary.get("by_tool", {}) or {}
    if not by_tool:
        return None
    return max(by_tool.items(), key=lambda kv: kv[1])[0]


# ---------------------- API: Dashboard ----------------------


@bp.get("/dashboard_v3")
def api_dashboard_v3() -> Any:
    """
    Dashboard – lấy run mới nhất và trả về tổng quan:
    - total_findings
    - by_severity
    - by_tool
    - security_score
    - top_risky_tool
    (top_cwe, top_module tạm thời null – có thể enrich sau)
    """
    run_dir = _get_latest_run()
    if run_dir is None:
        return jsonify(
            {
                "ok": False,
                "error": "No RUN_* summaries found.",
            }
        ), 200

    summary, info = _load_summary_for_run(run_dir)
    if summary is None:
        return jsonify(
            {
                "ok": False,
                "error": f"summary_unified.json not found in {run_dir}",
            }
        ), 200

    run_id = run_dir.name
    by_sev = summary.get("by_severity", {}) or {}
    by_tool = summary.get("by_tool", {}) or {}

    security_score = _compute_security_score(summary)
    top_risky_tool = _compute_top_risky_tool(summary)

    resp = {
        "ok": True,
        "run_id": run_id,
        "ts": info.get("ts_iso") if info else None,
        "total_findings": int(summary.get("total_findings", 0) or 0),
        "by_severity": by_sev,
        "by_tool": by_tool,
        "security_score": security_score,
        "top_risky_tool": top_risky_tool,
        # placeholder – có thể nâng cấp sau nếu cần phân tích CWE/module
        "top_cwe": None,
        "top_module": None,
    }
    return jsonify(resp)


# ------------------- API: Datasource v2 ---------------------


@bp.get("/datasource_v2")
def api_datasource_v2() -> Any:
    """
    Datasource v2 – feed cho tab Data Source.

    Query params:
      - run_id   (optional, default = run mới nhất)
      - severity (optional, CRITICAL/HIGH/..., default = ALL)
      - tool     (optional, tên tool, default = ALL)
      - search   (optional, text search trong file/message/rule_id)
      - limit    (optional, default=50)
      - offset   (optional, default=0)
    """
    run_id = request.args.get("run_id")
    severity = request.args.get("severity", "").upper().strip()
    tool = request.args.get("tool", "").strip()
    search = request.args.get("search", "").strip()
    limit = int(request.args.get("limit", 50) or 50)
    offset = int(request.args.get("offset", 0) or 0)

    # Lấy run dir
    run_dir: Optional[Path] = None
    if run_id:
        candidate = OUT_DIR / run_id
        if candidate.is_dir():
            run_dir = candidate
    if run_dir is None:
        run_dir = _get_latest_run()

    if run_dir is None:
        return jsonify(
            {
                "ok": False,
                "error": "No RUN_* available.",
                "items": [],
                "total": 0,
            }
        ), 200

    findings = _load_findings_for_run(run_dir)

    # Filter
    severity_filter = severity if severity and severity != "ALL" else None
    tool_filter = tool if tool and tool.lower() != "all" else None
    search_filter = search.lower() if search else None

    filtered: List[Dict[str, Any]] = []
    for f in findings:
        sev = str(f.get("severity", "")).upper()
        t = str(f.get("tool", "")).lower()
        msg = str(f.get("message", "") or "")
        file = str(f.get("file", "") or "")
        rule_id = str(f.get("rule_id", "") or "")

        if severity_filter and sev != severity_filter:
            continue
        if tool_filter and t != tool_filter.lower():
            continue
        if search_filter:
            haystack = " ".join([msg.lower(), file.lower(), rule_id.lower()])
            if search_filter not in haystack:
                continue

        filtered.append(f)

    total = len(filtered)

    # Sắp xếp: ưu tiên severity nặng trước, sau đó theo id
    filtered.sort(
        key=lambda x: (
            -_severity_weight(str(x.get("severity", ""))),
            str(x.get("tool", "")),
            str(x.get("file", "")),
            int(x.get("line", 0) or 0),
        )
    )

    # Phân trang
    page_items = filtered[offset : offset + limit]

    # Chuẩn hoá output gọn cho bảng
    def _normalize_item(f: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "id": f.get("id"),
            "tool": f.get("tool"),
            "tool_family": f.get("tool_family"),
            "severity": f.get("severity"),
            "severity_raw": f.get("severity_raw"),
            "rule_id": f.get("rule_id"),
            "file": f.get("file"),
            "line": f.get("line"),
            "message": f.get("message"),
        }

    items_out = [_normalize_item(f) for f in page_items]

    resp = {
        "ok": True,
        "run_id": run_dir.name,
        "total": total,
        "limit": limit,
        "offset": offset,
        "items": items_out,
    }
    return jsonify(resp)


# ------------------ API: Runs Index v3 ----------------------


@bp.get("/runs_index_v3")
def api_runs_index_v3() -> Any:
    """
    Trả về danh sách các RUN_* (và TEST_*) có summary, dùng cho:
      - Tab Runs & Reports
      - Trend
    """
    runs = _list_run_dirs()
    result: List[Dict[str, Any]] = []

    for run_dir in runs:
        summary, info = _load_summary_for_run(run_dir)
        if summary is None:
            continue
        result.append(
            {
                "run_id": run_dir.name,
                "ts": info.get("ts_iso") if info else None,
                "total_findings": int(summary.get("total_findings", 0) or 0),
                "by_severity": summary.get("by_severity", {}) or {},
                "by_tool": summary.get("by_tool", {}) or {},
            }
        )

    return jsonify(result)


# -------------------- API: Trend v1 -------------------------


@bp.get("/trend_v1")
def api_trend_v1() -> Any:
    """
    Trend – dùng cho biểu đồ line/area trên Dashboard.
    Dữ liệu: mỗi run -> 1 point.
    """
    runs = _list_run_dirs()
    points: List[Dict[str, Any]] = []

    for run_dir in runs:
        summary, info = _load_summary_for_run(run_dir)
        if summary is None:
            continue
        ts_iso = info.get("ts_iso") if info else None
        ts = datetime.fromisoformat(ts_iso) if ts_iso else None

        label = run_dir.name
        if ts is not None:
            # Ví dụ: "2025-12-01 15:44"
            label = ts.strftime("%Y-%m-%d %H:%M")

        points.append(
            {
                "label": label,
                "run_id": run_dir.name,
                "total": int(summary.get("total_findings", 0) or 0),
                "ts": ts_iso,
            }
        )

    resp = {
        "ok": True,
        "points": points,
    }
    return jsonify(resp)


# ------------------ API: Top Findings v1 --------------------


@bp.get("/top_findings_v1")
def api_top_findings_v1() -> Any:
    """
    Top findings – phục vụ bảng "Top 5 findings" trên Dashboard.
    Query:
      - run_id (optional)
      - limit  (default=5)
    """
    limit = int(request.args.get("limit", 5) or 5)
    run_id = request.args.get("run_id")

    run_dir: Optional[Path] = None
    if run_id:
        candidate = OUT_DIR / run_id
        if candidate.is_dir():
            run_dir = candidate

    if run_dir is None:
        run_dir = _get_latest_run()

    if run_dir is None:
        return jsonify({"ok": False, "error": "No runs available", "items": [], "total": 0}), 200

    findings = _load_findings_for_run(run_dir)

    # sort theo severity nặng + message
    findings.sort(
        key=lambda x: (
            -_severity_weight(str(x.get("severity", ""))),
            str(x.get("tool", "")),
            str(x.get("file", "")),
        )
    )

    top_items = findings[:limit]

    def _map_item(f: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "tool": f.get("tool"),
            "severity": f.get("severity"),
            "rule_id": f.get("rule_id"),
            "file": f.get("file"),
            "line": f.get("line"),
            "message": f.get("message"),
        }

    resp = {
        "ok": True,
        "run_id": run_dir.name,
        "total": len(findings),
        "items": [_map_item(f) for f in top_items],
    }
    return jsonify(resp)


# ----------------- API: Settings (read-only) ----------------


@bp.get("/settings_profile_v1")
def api_settings_profile_v1() -> Any:
    """
    Trả về thông tin profile hiện tại của VSP EXT+,
    dùng cho tab Settings (thông tin, không phải config runtime).
    """
    tools = [
        {"name": "gitleaks", "type": "secrets", "profile": "EXT"},
        {"name": "semgrep", "type": "sast", "profile": "EXT"},
        {"name": "bandit", "type": "sast-python", "profile": "EXT"},
        {"name": "trivy_fs", "type": "vuln+misconfig", "profile": "EXT"},
        {"name": "syft", "type": "sbom", "profile": "EXT"},
        {"name": "grype", "type": "vuln-from-sbom", "profile": "EXT"},
        {"name": "kics", "type": "iac", "profile": "EXT"},
        {"name": "codeql", "type": "sast-advanced", "profile": "EXT"},
    ]

    return jsonify(
        {
            "ok": True,
            "profile": "EXT+",
            "root": str(ROOT),
            "out_dir": str(OUT_DIR),
            "tools": tools,
        }
    )


# ------------- API: Rule Overrides (stub) -------------------


RULE_OVERRIDES_FILE = ROOT / "config" / "vsp_rule_overrides.json"


@bp.get("/rule_overrides_v1")
def api_rule_overrides_get() -> Any:
    """
    Lấy danh sách rule overrides hiện tại (nếu có).
    Format file:
      [
        {
          "tool": "semgrep",
          "rule_id": "sb_aggr_eval",
          "action": "suppress",  # hoặc "downgrade"
          "target_severity": "LOW",   # khi action=downgrade
          "comment": "Lý do business..."
        },
        ...
      ]
    """
    data: List[Dict[str, Any]] = []
    if RULE_OVERRIDES_FILE.is_file():
        try:
            data = json.loads(RULE_OVERRIDES_FILE.read_text(encoding="utf-8"))
        except Exception:
            data = []

    return jsonify({"ok": True, "items": data})


@bp.post("/rule_overrides_v1")
def api_rule_overrides_save() -> Any:
    """
    Lưu danh sách rule overrides từ UI.
    Body: JSON { items: [ ... ] }
    (Đơn giản: ghi đè file RULE_OVERRIDES_FILE)
    """
    try:
        payload = request.get_json(force=True, silent=False) or {}
    except Exception as e:
        return jsonify({"ok": False, "error": f"Invalid JSON body: {e}"}), 400

    items = payload.get("items")
    if not isinstance(items, list):
        return jsonify({"ok": False, "error": "Body must contain 'items': [...]"}), 400

    RULE_OVERRIDES_FILE.parent.mkdir(parents=True, exist_ok=True)
    RULE_OVERRIDES_FILE.write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")

    return jsonify({"ok": True, "saved": len(items)})


# ============================================================
# END OF FILE
# ============================================================

@bp.route("/api/vsp/dashboard_v3", methods=["GET"])
def api_vsp_dashboard_v3():
    """
    VSP 2025 – Dashboard v3
    Đọc data thật từ out/vsp_dashboard_v3_latest.json (build từ run FULL-EXT mới nhất).
    """
    from flask import jsonify
    from pathlib import Path
    import json

    # ROOT = .../SECURITY_BUNDLE
    root = Path(__file__).resolve().parents[2]
    data_path = root / "out" / "vsp_dashboard_v3_latest.json"

    if not data_path.exists():
        return jsonify(ok=False, error="vsp_dashboard_v3_latest.json not found"), 500

    try:
        data = json.loads(data_path.read_text(encoding="utf-8"))
    except Exception as e:
        return jsonify(ok=False, error=f"Failed to load dashboard data: {e}"), 500

    return jsonify(data)
