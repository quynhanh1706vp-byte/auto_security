import datetime  # SB_RUN_BACKEND_V1
import uuid  # SB_RUN_BACKEND_V1
import os  # SB_RUN_BACKEND_V1
import subprocess  # SB_RUN_BACKEND_V1
from pathlib import Path
import json

from flask import Flask, render_template, send_from_directory, redirect, url_for, jsonify, request, jsonify

app = Flask(__name__)

APP_ROOT = Path(__file__).resolve().parent
# /home/test/Data/SECURITY_BUNDLE
SB_ROOT = APP_ROOT.parent.parent
RUN_INDEX_FILE = APP_ROOT / "static" / "data" / "summary_runs.json"


def load_runs_index():
    """Đọc summary_runs.json -> list run (dùng cho tab Runs & Reports)."""
    if not RUN_INDEX_FILE.is_file():
        print(f"[WARN] Không tìm thấy {RUN_INDEX_FILE}")
        return []
    try:
        runs = json.loads(RUN_INDEX_FILE.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"[WARN] Lỗi đọc {RUN_INDEX_FILE}: {e}")
        return []

    # Nếu có field timestamp thì sort DESC cho chắc
    try:
        runs.sort(key=lambda r: r.get("timestamp", ""), reverse=True)
    except Exception:
        pass
    return runs


@app.route("/")
def index():
    """Redirect về dashboard SECURITY_BUNDLE."""
    return redirect(url_for("security_bundle"))


@app.route("/security_bundle", methods=["GET"])
def security_bundle():
    # VSP UI – dùng index.html mới 5 TAB (Dashboard, Runs, Data, Settings, Rules)
    return render_template("index.html")

@app.route("/report/<path:path>")
def serve_report_file(path: str):
    """
    Serve file report (HTML / PDF).
    'path' là path tương đối tính từ SB_ROOT (vd: out/RUN_xxx/report/security_resilient.html).
    """
    full = SB_ROOT / path
    if not full.is_file():
        return f"Report not found: {full}", 404
    return send_from_directory(full.parent, full.name)


@app.get("/health")
def health():
    return jsonify({"status": "ok", "app": "SECURITY_BUNDLE_UI"}), 200


if __name__ == "__main__":
    # Chạy UI trên port 8910 như trước giờ bạn dùng
    app.run(host="0.0.0.0", port=8910, debug=True)


# SB_RUN_BACKEND_V1
@app.route("/api/security_bundle/run_ext_v1", methods=["POST"])
def api_security_bundle_run_ext_v1():
    try:
        data = request.get_json(silent=True, force=True) or {}
    except Exception:
        data = {}

    src_path = data.get("src_path") or "/home/tests/Data/CODE_20110225_P"
    target_url = data.get("target_url") or "https://app.example.com"
    profile = data.get("profile") or "EXT"

    root = Path(__file__).resolve().parents[2]  # .../SECURITY_BUNDLE
    out_dir = root / "out"
    out_dir.mkdir(exist_ok=True)

    run_id = datetime.datetime.now().strftime("RUN_%Y%m%d_%H%M%S_") + uuid.uuid4().hex[:6]
    run_dir = out_dir / run_id
    run_dir.mkdir(parents=True, exist_ok=True)

    env = os.environ.copy()
    env.setdefault("SRC", src_path)
    env.setdefault("PROFILE", profile)
    env.setdefault("TARGET_URL", target_url)

    # Ưu tiên dùng run_all_full_ext.sh nếu có, fallback sang run_all_tools_v2.sh
    candidate = None
    for name in ("run_all_full_ext.sh", "run_all_tools_v2.sh", "wrap_run_all_tools_v2.sh"):
        p = root / "bin" / name
        if p.exists():
            candidate = p
            break

    if candidate is None:
        return jsonify(
            status="error",
            message="Không tìm thấy script run_all_full_ext.sh / run_all_tools_v2.sh trong bin/"
        ), 500

    cmd = [str(candidate), src_path, str(run_dir)]
    subprocess.Popen(cmd, cwd=str(root), env=env)

    return jsonify(
        status="ok",
        message=f"SECURITY_BUNDLE EXT+ scan started (run_id={run_id})",
        run_id=run_id,
        src_path=src_path,
        target_url=target_url,
        profile=profile,
    )




# ==========================================
# ### VSP API v1 – Dashboard / Runs / Data Source
# ==========================================
from flask import jsonify, request
from pathlib import Path as _SBPath
import json as _sb_json

_SB_SEVERITY_ORDER = {
    "CRITICAL": 0,
    "HIGH": 1,
    "MEDIUM": 2,
    "LOW": 3,
    "INFO": 4,
    "TRACE": 5,
}


def _sb_root():
    # /home/test/Data/SECURITY_BUNDLE
    return _SBPath(__file__).resolve().parents[2]


def _sb_out():
    return _sb_root() / "out"


def _sb_load_json(p, default=None):
    try:
        with open(p, "r", encoding="utf-8") as f:
            return _sb_json.load(f)
    except FileNotFoundError:
        return default


def _sb_last_run_dir():
    out_dir = _sb_out()
    if not out_dir.exists():
        return None
    candidates = []
    for d in out_dir.iterdir():
        if not d.is_dir():
            continue
        name = d.name
        if not (name.startswith("RUN_") or name.startswith("TEST_")):
            continue
        if (d / "report" / "summary_unified.json").exists():
            candidates.append(d)
    if not candidates:
        return None
    # sort by name (RUN_YYYYmmdd_HHMMSS)
    return sorted(candidates, key=lambda p: p.name)[-1]


def _sb_sev_weight(sev):
    return _SB_SEVERITY_ORDER.get((sev or "INFO").upper(), 9)


def _sb_empty_sev_bucket():
    return {k: 0 for k in _SB_SEVERITY_ORDER.keys()}


@app.route("/api/vsp/dashboard")
def api_vsp_dashboard():
    '''Return dashboard data for the latest (or given) run.'''
    root = _sb_root()
    run_id = request.args.get("run_id")

    if run_id:
        run_dir = root / "out" / run_id
        if not (run_dir / "report" / "summary_unified.json").exists():
            return jsonify({"error": "run_not_found", "run_id": run_id}), 404
    else:
        run_dir = _sb_last_run_dir()
        if run_dir is None:
            return jsonify({"error": "no_run"}), 404
        run_id = run_dir.name

    summary = _sb_load_json(run_dir / "report" / "summary_unified.json", {}) or {}
    findings = _sb_load_json(run_dir / "report" / "findings_unified.json", []) or []

    runs_index = _sb_load_json(root / "out" / "runs_index.json", {"runs": []}) or {"runs": []}

    # by_tool_severity: fallback build from findings
    by_tool_sev = summary.get("by_tool_severity")
    if not by_tool_sev and isinstance(findings, list):
        tmp = {}
        for f in findings:
            tool = f.get("tool") or "Unknown"
            sev = (f.get("severity") or "INFO").upper()
            if sev not in _SB_SEVERITY_ORDER:
                sev = "INFO"
            tmp.setdefault(tool, _sb_empty_sev_bucket())[sev] += 1
        by_tool_sev = tmp

    # Top risk findings (CRITICAL/HIGH) – slim fields
    top_risk = []
    if isinstance(findings, list):
        risky = [
            f
            for f in findings
            if (f.get("severity") or "").upper() in ("CRITICAL", "HIGH")
        ]
        risky_sorted = sorted(
            risky,
            key=lambda f: (
                _sb_sev_weight(f.get("severity")),
                f.get("tool") or "",
                f.get("rule_id") or "",
            ),
        )[:50]

        def slim(f):
            return {
                "tool": f.get("tool"),
                "severity": f.get("severity"),
                "file": f.get("file"),
                "line": f.get("line"),
                "rule_id": f.get("rule_id"),
                "message": f.get("message"),
                "cwe": f.get("cwe"),
                "cve": f.get("cve"),
            }

        top_risk = [slim(f) for f in risky_sorted]

    # Top noisy paths (MED/LOW/INFO/TRACE)
    top_noisy_paths = []
    if isinstance(findings, list):
        noisy = {}
        for f in findings:
            sev = (f.get("severity") or "INFO").upper()
            if sev not in ("MEDIUM", "LOW", "INFO", "TRACE"):
                continue
            path = f.get("file") or "<unknown>"
            entry = noisy.get(path)
            if not entry:
                entry = {
                    "file": path,
                    "total": 0,
                    "by_severity": _sb_empty_sev_bucket(),
                }
                noisy[path] = entry
            entry["total"] += 1
            if sev in entry["by_severity"]:
                entry["by_severity"][sev] += 1

        top_noisy_paths = sorted(
            noisy.values(), key=lambda e: e["total"], reverse=True
        )[:50]

    # Top CVEs
    top_cves = []
    if isinstance(findings, list):
        cves = {}
        for f in findings:
            cve = f.get("cve")
            if not cve:
                continue
            sev = (f.get("severity") or "INFO").upper()
            entry = cves.get(cve)
            if not entry:
                entry = {
                    "cve": cve,
                    "total": 0,
                    "by_severity": _sb_empty_sev_bucket(),
                }
                cves[cve] = entry
            entry["total"] += 1
            if sev in entry["by_severity"]:
                entry["by_severity"][sev] += 1

        top_cves = sorted(
            cves.values(), key=lambda e: e["total"], reverse=True
        )[:50]

    return jsonify(
        {
            "run_id": run_id,
            "summary": summary,
            "by_tool_severity": by_tool_sev,
            "top_risk_findings": top_risk,
            "top_noisy_paths": top_noisy_paths,
            "top_cves": top_cves,
            "runs_index": runs_index,
        }
    )


@app.route("/api/vsp/runs")
def api_vsp_runs():
    '''Return runs index for Runs & Reports tab.'''
    out_dir = _sb_out()

    runs_index = _sb_load_json(out_dir / "runs_index.json")
    if runs_index and isinstance(runs_index, dict):
        return jsonify(runs_index)

    runs = []
    if out_dir.exists():
        for d in out_dir.iterdir():
            if not d.is_dir():
                continue
            name = d.name
            if not (name.startswith("RUN_") or name.startswith("TEST_")):
                continue
            s_path = d / "report" / "summary_unified.json"
            if not s_path.exists():
                continue
            s = _sb_load_json(s_path, {}) or {}
            runs.append(
                {
                    "run_id": name,
                    "created_at": s.get("created_at"),
                    "profile": s.get("profile"),
                    "source": s.get("source"),
                    "url": s.get("url"),
                    "total_findings": s.get("total_findings"),
                    "by_severity": s.get("by_severity"),
                    "tools_enabled": s.get("tools_enabled"),
                }
            )

    def sort_key(r):
        return r.get("created_at") or r.get("run_id") or ""

    runs_sorted = sorted(runs, key=sort_key)
    return jsonify({"runs": runs_sorted})


@app.route("/api/vsp/data-source")
def api_vsp_data_source():
    '''Return flattened findings for Data Source tab.'''
    root = _sb_root()
    run_id = request.args.get("run_id")
    if run_id:
        run_dir = root / "out" / run_id
    else:
        run_dir = _sb_last_run_dir()
        if run_dir is None:
            return jsonify({"error": "no_run"}), 404
        run_id = run_dir.name

    summary = _sb_load_json(
        run_dir / "report" / "summary_unified.json", {}
    ) or {}
    findings = _sb_load_json(
        run_dir / "report" / "findings_unified.json", []
    ) or []

    try:
        limit = int(request.args.get("limit", "1000"))
    except ValueError:
        limit = 1000

    if not isinstance(findings, list):
        findings = []

    total = len(findings)
    truncated = False
    sliced = findings
    if total > limit:
        sliced = findings[:limit]
        truncated = True

    return jsonify(
        {
            "run_id": run_id,
            "summary": summary,
            "total_findings": total,
            "limit": limit,
            "truncated": truncated,
            "findings": sliced,
        }
    )\n\n
# === VSP_BACKEND_DATA_V1 – build VSP_DATA + routes ===
from pathlib import Path as _VSP_Path
import json as _vsp_json
import datetime as _vsp_dt
import subprocess as _vsp_subprocess
from flask import request as _vsp_request, jsonify as _vsp_jsonify, render_template

_VSP_ROOT = _VSP_Path("/home/test/Data/SECURITY_BUNDLE")

def _vsp_load_findings_current():
    run_dir = _VSP_ROOT / "out" / "RUN_CURRENT"
    findings_file = run_dir / "findings_unified_v2.json"
    if not findings_file.exists():
        findings_file = run_dir / "findings_unified.json"
    if not findings_file.exists():
        return run_dir, []
    try:
        data = _vsp_json.loads(findings_file.read_text())
        if isinstance(data, dict) and "findings" in data:
            data = data["findings"]
        if not isinstance(data, list):
            data = []
        return run_dir, data
    except Exception:
        return run_dir, []

def vsp_build_data():
    run_dir, findings = _vsp_load_findings_current()
    sev_keys = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]
    sev = {k: 0 for k in sev_keys}
    for f in findings:
        s = str(f.get("severity", "")).upper()
        if s in sev:
            sev[s] += 1
    total = sum(sev.values())
    return {
        "run_dir": str(run_dir),
        "total": total,
        "severity": sev,
    }

@app.route("/vsp_2025")
def vsp_2025():
    data = vsp_build_data()
    return render_template("vsp_5tabs_full.html", vsp_data=data)

@app.route("/api/vsp/run_full", methods=["POST"])
def vsp_run_full():
    data = _vsp_request.get_json(force=True, silent=True) or {}
    target_url = str(data.get("target_url", "")).strip()
    src_path   = str(data.get("src_path", "")).strip()
    profile    = str(data.get("profile", "EXT") or "EXT").upper()

    if not target_url or not src_path:
        return _vsp_jsonify({"error": "Missing target_url or src_path"}), 400

    now = _vsp_dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    run_id = f"RUN_VSP_{profile}_{now}"
    run_dir = _VSP_ROOT / "out" / run_id
    run_dir.mkdir(parents=True, exist_ok=True)

    # TODO: chỉnh lại tên script scan FULL nếu cần
    cmd = [
        str(_VSP_ROOT / "bin" / "run_all_with_grype_fix.sh"),
        src_path,
        str(run_dir),
        profile.lower()
    ]

    try:
        res = _vsp_subprocess.run(
            cmd,
            cwd=str(_VSP_ROOT),
            stdout=_vsp_subprocess.PIPE,
            stderr=_vsp_subprocess.STDOUT,
            text=True,
            check=False,
        )
        (run_dir / "_vsp_run.log").write_text(res.stdout or "")

        # update RUN_CURRENT -> run mới
        cur = _VSP_ROOT / "out" / "RUN_CURRENT"
        try:
            if cur.is_symlink() or cur.exists():
                cur.unlink()
        except Exception:
            pass
        try:
            cur.symlink_to(run_dir.name)
        except Exception:
            pass

        if res.returncode != 0:
            return _vsp_jsonify({
                "run_id": run_id,
                "status": "failed",
                "error": f"scan exited with code {res.returncode}"
            }), 500

        return _vsp_jsonify({
            "run_id": run_id,
            "status": "ok"
        })
    except Exception as e:
        return _vsp_jsonify({"error": str(e)}), 500

### VSP_BACKEND_DATA_V1
\n