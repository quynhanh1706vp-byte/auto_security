from __future__ import annotations

import datetime
import json
from pathlib import Path
from typing import Optional, Any

from flask import (
    Flask,
    jsonify,
    send_from_directory,
    request,
    render_template,
)

# --------------------------------------------------------------------
# Cấu hình Flask: static + templates của my_flask_app
# --------------------------------------------------------------------
UI_ROOT = Path(__file__).resolve().parent          # .../SECURITY_BUNDLE/ui
ROOT = UI_ROOT.parent                              # .../SECURITY_BUNDLE

app = Flask(
    __name__,
    static_folder="my_flask_app/static",
    template_folder="my_flask_app/templates",
)

OUT = ROOT / "out"
RULES = ROOT / "rules" / "vsp_rule_overrides.json"


# --------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------
def _discover_run_dirs(limit: int = 50):
    if not OUT.exists():
        return []
    dirs = sorted(
        [p for p in OUT.iterdir() if p.is_dir() and p.name.startswith("RUN_")],
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )
    return dirs[:limit]


def _get_latest_run() -> Optional[Path]:
    runs = _discover_run_dirs(limit=50)
    if not runs:
        return None
    # Ưu tiên RUN có report/findings_unified.json và file không rỗng
    for r in runs:
        f = r / "report" / "findings_unified.json"
        if f.exists() and f.stat().st_size > 0:
            return r
    # fallback: run mới nhất bất kỳ
    return runs[0]


def _load_json(path: Path) -> Any:
    if not path.exists():
        return None
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return None


# --------------------------------------------------------------------
# Routes UI
# --------------------------------------------------------------------
@app.route("/")
def home():
    return "<meta http-equiv='refresh' content='0;URL=/security_bundle'>"


@app.route("/security_bundle")
def ui_main():
    # index.html dùng Jinja, url_for('static', ...) hoạt động
    return render_template("index.html")


# --------------------------------------------------------------------
# TAB 1 — DASHBOARD
# --------------------------------------------------------------------
@app.route("/api/vsp/dashboard")
def api_dashboard():
    run_dir = _get_latest_run()
    if not run_dir:
        return jsonify({"error": "no_run"}), 404

    summ = _load_json(run_dir / "report" / "summary_unified.json")
    if not summ:
        return jsonify({"error": "no_summary"}), 404

    return jsonify({
        "run_id": run_dir.name,
        "meta": summ.get("meta", {}),
        "kpi": {
            "total_findings": summ.get("total_findings", 0),
            "severity": summ.get("severity", {}),
            "tool_counts": summ.get("tool_counts", {}),
            "security_score": summ.get("security_score", None),
            "top_risky_tool": summ.get("top_risky_tool"),
            "top_cwe": summ.get("top_cwe"),
            "top_module": summ.get("top_module"),
        },
    })


# --------------------------------------------------------------------
# TAB 2 — RUNS & REPORTS
# --------------------------------------------------------------------
@app.route("/api/vsp/runs_index")
def api_runs_index():
    runs = _discover_run_dirs(limit=50)
    out = []
    for r in runs:
        summ = _load_json(r / "report" / "summary_unified.json")
        if not summ:
            continue
        meta = summ.get("meta", {})
        out.append({
            "run_id": r.name,
            "ts": meta.get("ts"),
            "src_path": meta.get("src_path"),
            "profile": meta.get("profile"),
            "engine_mode": meta.get("engine_mode"),
            "total_findings": summ.get("total_findings"),
            "severity": summ.get("severity", {}),
            "tools": list(summ.get("tool_counts", {}).keys()),
            "report_html": f"/out/{r.name}/report/report.html",
            "report_pdf": f"/out/{r.name}/report/report.pdf",
            "sbom": f"/out/{r.name}/report/sbom_trivy.json",
            "license_report": f"/out/{r.name}/report/license_report.json",
        })
    return jsonify({"runs": out})


# --------------------------------------------------------------------
# TAB 3 — DATA SOURCE
# --------------------------------------------------------------------

def api_datasource():
    """
    mode = dashboard  -> chỉ trả sample ~1000 dòng cho Dashboard (nhanh)
    mode = None       -> trả full (tối đa 60000) cho tab Data Source
    """
    mode = request.args.get("mode")
    rid = request.args.get("run_id")
    run_dir: Optional[Path] = None

    if rid:
        cand = OUT / rid
        if cand.exists():
            run_dir = cand

    if not run_dir:
        run_dir = _get_latest_run()
    if not run_dir:
        return jsonify({"error": "no_run"}), 404

    fpath = run_dir / "report" / "findings_unified.json"
    data = _load_json(fpath)
    if not data:
        return jsonify({"error": "no_data"}), 404

    # hỗ trợ 2 dạng: list[] hoặc {rows: []}
    rows = data if isinstance(data, list) else data.get("rows", [])
    total = len(rows)

    if mode == "dashboard":
        visible = rows[:1000]   # đủ cho top risk / noisy / by tool
    else:
        visible = rows[:60000]  # trần cứng cho Data Source

    return jsonify({
        "run_id": run_dir.name,
        "total_rows": total,
        "rows": visible,
    })


# --------------------------------------------------------------------
# TAB 4 — SETTINGS
# --------------------------------------------------------------------
@app.route("/api/vsp/settings")
def api_settings():
    run_dir = _get_latest_run()
    if not run_dir:
        return jsonify({"error": "no_run"}), 404

    summ = _load_json(run_dir / "report" / "summary_unified.json")
    if not summ:
        return jsonify({"error": "no_summary"}), 404

    meta = summ.get("meta", {})
    return jsonify({
        "profile_label": meta.get("profile"),
        "src_path": meta.get("src_path"),
        "engine_mode": meta.get("engine_mode"),
        "last_run_id": run_dir.name,
        "tools_enabled": list(summ.get("tool_counts", {}).keys()),
        "max_rows_ui": meta.get("max_rows_ui", 300),
        "default_export": meta.get("default_export", "HTML"),
    })


# --------------------------------------------------------------------
# TAB 5 — RULE OVERRIDES
# --------------------------------------------------------------------
@app.route("/api/vsp/rule_overrides")
def api_rule_overrides():
    if not RULES.exists():
        return jsonify({
            "rules": [],
            "note": "nguồn: rules/vsp_rule_overrides.json – hiện chưa có rule override",
        })

    data = _load_json(RULES)
    if not data:
        return jsonify({
            "rules": [],
            "note": "nguồn: rules/vsp_rule_overrides.json – file trống hoặc lỗi",
        })

    # Hỗ trợ 2 format:
    # 1) {"overrides": [ ... ]} hoặc {"rules": [ ... ]}
    # 2) [ ... ]
    if isinstance(data, dict):
        rules = data.get("overrides") or data.get("rules") or []
    elif isinstance(data, list):
        rules = data
    else:
        rules = []
    return jsonify({"rules": rules})


# --------------------------------------------------------------------
# Serve OUT/ (report HTML/PDF/JSON…)
# --------------------------------------------------------------------
@app.route("/out/<path:sub>")
def serve_out(sub: str):
    return send_from_directory(str(OUT), sub)


# --------------------------------------------------------------------


# ================== VSP – API CHO 5 TAB ==================
from pathlib import Path
import json

VSP_ROOT = Path(__file__).resolve().parent.parent
VSP_OUT_DIR = VSP_ROOT / "out"
VSP_RULES_DIR = VSP_ROOT / "rules"


def _vsp_safe_read_json(path: Path, default):
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return default


def _vsp_discover_runs(limit: int = 200):
    """Trả về list Path các thư mục RUN_* trong out/, sort mới -> cũ."""
    if not VSP_OUT_DIR.is_dir():
        return []

    runs = []
    for p in VSP_OUT_DIR.iterdir():
        if p.is_dir() and p.name.startswith("RUN_"):
            runs.append(p)

    runs.sort(key=lambda x: x.stat().st_mtime, reverse=True)
    return runs[:limit]


def _vsp_get_latest_run():
    runs = _vsp_discover_runs(limit=1)
    return runs[0] if runs else None


# ---------- TAB 2 – Runs & Reports ----------
@app.route("/api/vsp/runs_index", methods=["GET"])
def api_vsp_runs_index():
    """Danh sách RUN cho tab 'Runs & Reports'."""
    rows = []

    for run_dir in _vsp_discover_runs(limit=200):
        report_dir = run_dir / "report"
        summary_path = report_dir / "summary_unified.json"

        if not summary_path.is_file():
            continue

        summary = _vsp_safe_read_json(summary_path, {})
        meta = summary.get("meta", {})
        sev = summary.get("severity_counts", {}) or summary.get("severity", {})

        def _i(v):
            try:
                return int(v)
            except Exception:
                try:
                    return int(float(v))
                except Exception:
                    return 0

        total = meta.get("total_findings")
        if total is None:
            total = sum(_i(v) for v in sev.values() or [0])

        row = {
            "run_id": run_dir.name,
            "report_dir": str(report_dir),
            "profile": meta.get("profile", meta.get("scan_profile", "N/A")),
            "source_path": meta.get("source_path", meta.get("src_dir", "N/A")),
            "engine_mode": meta.get("engine_mode", meta.get("mode", "FULL_EXT")),
            "ts": meta.get("timestamp", meta.get("ts", "")),
            "total": _i(total),
            "critical": _i(sev.get("CRITICAL", 0)),
            "high": _i(sev.get("HIGH", 0)),
            "medium": _i(sev.get("MEDIUM", 0)),
            "low": _i(sev.get("LOW", 0)),
            "info": _i(sev.get("INFO", 0)),
            "trace": _i(sev.get("TRACE", 0)),
        }

        rows.append(row)

    return jsonify({"runs": rows})


# ---------- TAB 4 – Settings ----------
@app.route("/api/vsp/settings", methods=["GET"])
def api_vsp_settings():
    """Meta cho tab 'Settings': PROFILE, SOURCE PATH, ENGINE MODE, LAST RUN."""
    latest = _vsp_get_latest_run()

    profile = "FULL_EXT"
    source_path = ""
    engine_mode = "Enterprise Security Profile (EXT+)"
    last_run_id = None
    last_run_ts = None

    if latest:
        last_run_id = latest.name
        report_dir = latest / "report"
        summary_path = report_dir / "summary_unified.json"

        summary = _vsp_safe_read_json(summary_path, {})
        meta = summary.get("meta", {})

        profile = meta.get("profile", meta.get("scan_profile", profile))
        source_path = meta.get("source_path", meta.get("src_dir", source_path))
        engine_mode = meta.get("engine_mode", engine_mode)
        last_run_ts = meta.get("timestamp", meta.get("ts", last_run_ts))

    settings_path = VSP_RULES_DIR / "vsp_settings.json"
    if settings_path.is_file():
        s = _vsp_safe_read_json(settings_path, {})
        profile = s.get("profile", profile)
        source_path = s.get("source_path", source_path)
        engine_mode = s.get("engine_mode", engine_mode)

    payload = {
        "profile": profile,
        "source_path": source_path,
        "engine_mode": engine_mode,
        "last_run": {
            "run_id": last_run_id,
            "timestamp": last_run_ts,
        },
    }

    return jsonify(payload)


# ---------- TAB 5 – Rule Overrides ----------
@app.route("/api/vsp/rule_overrides", methods=["GET"])
def api_vsp_rule_overrides():
    """Danh sách rule override cho tab 'Rule Overrides'."""
    rules_path = VSP_RULES_DIR / "vsp_rule_overrides.json"

    if rules_path.is_file():
        data = _vsp_safe_read_json(rules_path, {})
    else:
        data = {}

    overrides = data.get("overrides", data.get("rules", []))

    return jsonify({
        "overrides": overrides
    })
# ================== END VSP – API CHO 5 TAB ==================
# ================== VSP RUN CENTER BACKEND v1 ==================
from pathlib import Path as _Path_for_run_center
import json as _json_for_run_center

# POST /api/vsp/settings  -> lưu config mặc định vào rules/vsp_settings.json
@app.route("/api/vsp/settings", methods=["POST"])
def api_vsp_settings_save():
    data = request.get_json(force=True, silent=True) or {}
    source_path = str(data.get("source_path", "")).strip()
    profile = str(data.get("profile", "")).strip() or "FULL_EXT"
    engine_mode = str(data.get("engine_mode", "")).strip() or "Enterprise Security Profile (EXT+)"

    settings = {
        "source_path": source_path,
        "profile": profile,
        "engine_mode": engine_mode,
    }

    rules_dir = VSP_RULES_DIR
    rules_dir.mkdir(parents=True, exist_ok=True)
    settings_path = rules_dir / "vsp_settings.json"
    settings_path.write_text(_json_for_run_center.dumps(settings, indent=2), encoding="utf-8")

    print(f"[VSP][SETTINGS] Saved settings -> {settings_path} :: {settings}")
    return jsonify({"status": "ok", "settings": settings})


# POST /api/vsp/run_scan  -> nhận yêu cầu chạy scan
@app.route("/api/vsp/run_scan", methods=["POST"])
def api_vsp_run_scan():
    data = request.get_json(force=True, silent=True) or {}
    source_path = str(data.get("source_path", "")).strip()
    profile = str(data.get("profile", "")).strip() or "FULL_EXT"
    environment = str(data.get("environment", "")).strip() or "local"

    ts = datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    run_id = f"RUN_VSP_{profile}_{ts}"

    # TODO: chỗ này bạn nối vào script scan thật của bạn.
    # Ví dụ:
    #   cmd = [
    #       str(VSP_ROOT / "bin" / "run_vsp_scan_full_ext.sh"),
    #       source_path,
    #       profile,
    #       environment,
    #       run_id,
    #   ]
    #   subprocess.Popen(cmd, stdout=..., stderr=...)
    #
    print("[VSP][RUN] Requested scan:",
          "src=", source_path,
          "profile=", profile,
          "env=", environment,
          "run_id=", run_id)

    return jsonify({
        "status": "accepted",
        "run_id": run_id,
        "source_path": source_path,
        "profile": profile,
        "environment": environment,
    })
# ================== END VSP RUN CENTER BACKEND v1 ==================





# ======= VSP Data Source API v1 (AUTO PATCH) =======
from collections import Counter
from typing import Optional
from pathlib import Path

def _load_run_dir(run_id: Optional[str] = None) -> Optional[Path]:
    """
    Load a specific run directory by run_id, or return the latest run if run_id is None.
    """
    base = RUN_ROOT  # RUN_ROOT đã được khai báo phía trên
    if run_id:
        candidate = base / run_id
        if candidate.is_dir():
            return candidate
        return None

    # Fallback: dùng helper có sẵn (nếu có)
    if "_get_latest_run" in globals():
        return _get_latest_run()
    return None



def api_vsp_datasource():
    """
    Unified findings cho tab Data Source.
    Optional query: run_id=<RUN_ID>
    Trả về:
      - run_id: tên thư mục RUN_...
      - total: tổng số findings
      - severity_counts: đếm theo CRITICAL/HIGH/...
      - tool_counts: đếm theo từng tool
      - findings: list đầy đủ findings_unified
    """
    run_id = request.args.get("run_id") or None
    run_dir = _load_run_dir(run_id)

    if not run_dir:
        return jsonify({
            "ok": False,
            "error": "Run directory not found.",
            "findings": [],
            "severity_counts": {},
            "tool_counts": {}
        }), 404

    findings_path = run_dir / "report" / "findings_unified.json"
    if not findings_path.is_file():
        return jsonify({
            "ok": False,
            "error": f"Missing findings_unified.json in {run_dir}",
            "findings": [],
            "severity_counts": {},
            "tool_counts": {}
        }), 404

    try:
        raw = findings_path.read_text(encoding="utf-8")
        data = json.loads(raw)
    except Exception as exc:
        return jsonify({
            "ok": False,
            "error": f"Cannot parse findings_unified.json: {exc}",
            "findings": [],
            "severity_counts": {},
            "tool_counts": {}
        }), 500

    if not isinstance(data, list):
        return jsonify({
            "ok": False,
            "error": "findings_unified.json must be a list.",
            "findings": [],
            "severity_counts": {},
            "tool_counts": {}
        }), 500

    sev_counter = Counter()
    tool_counter = Counter()
    findings = []

    for item in data:
        if not isinstance(item, dict):
            continue
        sev = (item.get("severity") or "INFO").upper()
        tool = (item.get("tool") or "unknown").lower()
        sev_counter[sev] += 1
        tool_counter[tool] += 1
        findings.append(item)

    return jsonify({
        "ok": True,
        "run_id": run_dir.name,
        "total": len(findings),
        "severity_counts": dict(sev_counter),
        "tool_counts": dict(tool_counter),
        "findings": findings
    })
# ======= END VSP Data Source API v1 =======


# ======= VSP Data Source API v3 (AUTO PATCH – latest RUN_* scan) =======
from collections import Counter
from typing import Optional, List
from pathlib import Path

def _discover_latest_run_for_datasource() -> Optional[Path]:
    """
    Tự quét RUN_ROOT để tìm thư mục RUN_* mới nhất.
    """
    base = RUN_ROOT
    try:
        candidates: List[Path] = sorted(
            [p for p in base.glob("RUN_*") if p.is_dir()],
            key=lambda p: p.name,
            reverse=True,
        )
    except Exception as exc:
        app.logger.error("[VSP][DATASOURCE] error while glob RUN_*: %s", exc)
        return None

    if not candidates:
        app.logger.warning("[VSP][DATASOURCE] no RUN_* folder found under %s", base)
        return None

    latest = candidates[0]
    app.logger.info("[VSP][DATASOURCE] latest run dir detected: %s", latest)
    return latest


def _load_run_dir_for_datasource(run_id: Optional[str] = None) -> Optional[Path]:
    """
    Nếu có run_id -> ưu tiên dùng; nếu không -> dùng RUN_* mới nhất.
    Nếu run_id không tồn tại -> fallback về latest RUN_*.
    """
    base = RUN_ROOT

    if run_id:
        candidate = base / run_id
        if candidate.is_dir():
            app.logger.info("[VSP][DATASOURCE] using explicit run_id=%s", run_id)
            return candidate
        app.logger.warning(
            "[VSP][DATASOURCE] run_id=%s not found, fallback to latest RUN_*", run_id
        )

    return _discover_latest_run_for_datasource()



def api_vsp_datasource():
    """
    Unified findings cho tab Data Source.

    Response:
      - ok: bool
      - run_id: RUN_...
      - summary: { total, severity_counts, tool_counts }
      - severity_chart: { labels, data }
      - tools_chart: { labels, data }
      - rows: list cho table
      - findings: raw findings_unified.json
    Optional query: run_id=<RUN_ID>
    """
    run_id = request.args.get("run_id") or None
    run_dir = _load_run_dir_for_datasource(run_id)

    if not run_dir:
        return jsonify({
            "ok": False,
            "error": "No RUN_* folder found under RUN_ROOT.",
            "rows": [],
            "findings": [],
            "summary": {
                "total": 0,
                "severity_counts": {},
                "tool_counts": {}
            },
            "severity_chart": {"labels": [], "data": []},
            "tools_chart": {"labels": [], "data": []}
        }), 404

    findings_path = run_dir / "report" / "findings_unified.json"
    if not findings_path.is_file():
        app.logger.warning(
            "[VSP][DATASOURCE] missing findings_unified.json in %s", run_dir
        )
        return jsonify({
            "ok": False,
            "error": f"Missing findings_unified.json in {run_dir}",
            "rows": [],
            "findings": [],
            "summary": {
                "total": 0,
                "severity_counts": {},
                "tool_counts": {}
            },
            "severity_chart": {"labels": [], "data": []},
            "tools_chart": {"labels": [], "data": []}
        }), 404

    try:
        raw = findings_path.read_text(encoding="utf-8")
        data = json.loads(raw)
    except Exception as exc:
        app.logger.error(
            "[VSP][DATASOURCE] cannot parse findings_unified.json in %s: %s",
            run_dir,
            exc,
        )
        return jsonify({
            "ok": False,
            "error": f"Cannot parse findings_unified.json: {exc}",
            "rows": [],
            "findings": [],
            "summary": {
                "total": 0,
                "severity_counts": {},
                "tool_counts": {}
            },
            "severity_chart": {"labels": [], "data": []},
            "tools_chart": {"labels": [], "data": []}
        }), 500

    if not isinstance(data, list):
        app.logger.error(
            "[VSP][DATASOURCE] findings_unified.json is not a list in %s", run_dir
        )
        return jsonify({
            "ok": False,
            "error": "findings_unified.json must be a list of findings.",
            "rows": [],
            "findings": [],
            "summary": {
                "total": 0,
                "severity_counts": {},
                "tool_counts": {}
            },
            "severity_chart": {"labels": [], "data": []},
            "tools_chart": {"labels": [], "data": []}
        }), 500

    sev_counter = Counter()
    tool_counter = Counter()

    rows = []
    findings_raw = []

    for idx, item in enumerate(data):
        if not isinstance(item, dict):
            continue

        sev = (item.get("severity") or "INFO").upper()
        tool = (item.get("tool") or "unknown").lower()
        rule = item.get("rule_id") or item.get("rule") or ""
        file_path = item.get("file") or ""
        line_no = item.get("line") or 0
        message = item.get("message") or item.get("description") or ""
        cwe = item.get("cwe") or item.get("cve") or ""

        sev_counter[sev] += 1
        tool_counter[tool] += 1

        findings_raw.append(item)

        rows.append({
            "id": idx + 1,
            "severity": sev,
            "tool": tool,
            "rule": rule,
            "file": file_path,
            "line": line_no,
            "message": message,
            "cwe": cwe
        })

    sev_labels = sorted(sev_counter.keys())
    sev_data = [sev_counter[s] for s in sev_labels]

    top_tools_sorted = sorted(tool_counter.items(), key=lambda kv: kv[1], reverse=True)
    tool_labels = [t for t, _ in top_tools_sorted]
    tool_data = [c for _, c in top_tools_sorted]

    summary = {
        "total": len(rows),
        "severity_counts": dict(sev_counter),
        "tool_counts": dict(tool_counter)
    }

    app.logger.info(
        "[VSP][DATASOURCE] run=%s total_rows=%d",
        run_dir.name,
        len(rows)
    )

    return jsonify({
        "ok": True,
        "run_id": run_dir.name,
        "summary": summary,
        "severity_counts": dict(sev_counter),
        "tool_counts": dict(tool_counter),
        "severity_chart": {
            "labels": sev_labels,
            "data": sev_data
        },
        "tools_chart": {
            "labels": tool_labels,
            "data": tool_data
        },
        "rows": rows,
        "findings": findings_raw
    })
# ======= END VSP Data Source API v3 =======


# ======= VSP Data Source API – FINAL VERSION =======
# ======= END VSP Data Source API – FINAL VERSION =======


# ======= VSP Data Source API – HARDCODED OUT DIR =======
# ======= END VSP Data Source API – HARDCODED OUT DIR =======


# ======= VSP Data Source API – CLEAN /api/vsp/datasource2 (NO RUN_ROOT) =======
@app.route("/api/vsp/datasource2", methods=["GET"])
def api_vsp_datasource2():
    """
    Data Source cho VSP – đọc findings_unified.json từ out/RUN_* mới nhất.

    Response:
      - ok: bool
      - run_id: RUN_...
      - summary: { total, severity_counts, tool_counts }
      - severity_chart: { labels, data }
      - tools_chart: { labels, data }
      - rows: list cho table
      - findings: raw findings_unified.json
      - error: string nếu ok = False
    """
    from collections import Counter
    from pathlib import Path
    import json

    base = Path("/home/test/Data/SECURITY_BUNDLE/out")

    try:
        run_id = request.args.get("run_id") or None
        run_dir = None

        # 1) Nếu có run_id thì ưu tiên dùng
        if run_id:
            cand = base / run_id
            if cand.is_dir():
                run_dir = cand

        # 2) Nếu không có hoặc không tồn tại -> lấy RUN_* mới nhất
        if run_dir is None:
            candidates = sorted(
                [p for p in base.glob("RUN_*") if p.is_dir()],
                key=lambda p: p.name,
                reverse=True,
            )
            if candidates:
                run_dir = candidates[0]

        if run_dir is None:
            return jsonify({
                "ok": False,
                "error": "No RUN_* folder found under /home/test/Data/SECURITY_BUNDLE/out.",
                "run_id": None,
                "rows": [],
                "findings": [],
                "summary": {
                    "total": 0,
                    "severity_counts": {},
                    "tool_counts": {}
                },
                "severity_chart": {"labels": [], "data": []},
                "tools_chart": {"labels": [], "data": []}
            }), 404

        findings_path = run_dir / "report" / "findings_unified.json"
        if not findings_path.is_file():
            return jsonify({
                "ok": False,
                "error": f"Missing findings_unified.json in {run_dir}",
                "run_id": run_dir.name,
                "rows": [],
                "findings": [],
                "summary": {
                    "total": 0,
                    "severity_counts": {},
                    "tool_counts": {}
                },
                "severity_chart": {"labels": [], "data": []},
                "tools_chart": {"labels": [], "data": []}
            }), 404

        raw = findings_path.read_text(encoding="utf-8")
        data = json.loads(raw)

        if not isinstance(data, list):
            return jsonify({
                "ok": False,
                "error": "findings_unified.json must be a list of findings.",
                "run_id": run_dir.name,
                "rows": [],
                "findings": [],
                "summary": {
                    "total": 0,
                    "severity_counts": {},
                    "tool_counts": {}
                },
                "severity_chart": {"labels": [], "data": []},
                "tools_chart": {"labels": [], "data": []}
            }), 500

        sev_counter = Counter()
        tool_counter = Counter()

        rows = []
        findings_raw = []

        for idx, item in enumerate(data):
            if not isinstance(item, dict):
                continue

            sev = (item.get("severity") or "INFO").upper()
            tool = (item.get("tool") or "unknown").lower()
            rule = item.get("rule_id") or item.get("rule") or ""
            file_path = item.get("file") or ""
            line_no = item.get("line") or 0
            message = item.get("message") or item.get("description") or ""
            cwe = item.get("cwe") or item.get("cve") or ""

            sev_counter[sev] += 1
            tool_counter[tool] += 1

            findings_raw.append(item)

            rows.append({
                "id": idx + 1,
                "severity": sev,
                "tool": tool,
                "rule": rule,
                "file": file_path,
                "line": line_no,
                "message": message,
                "cwe": cwe
            })

        # Build chart data
        sev_labels = sorted(sev_counter.keys())
        sev_data = [sev_counter[s] for s in sev_labels]

        top_tools_sorted = sorted(tool_counter.items(), key=lambda kv: kv[1], reverse=True)
        tool_labels = [t for t, _ in top_tools_sorted]
        tool_data = [c for _, c in top_tools_sorted]

        summary = {
            "total": len(rows),
            "severity_counts": dict(sev_counter),
            "tool_counts": dict(tool_counter)
        }

        app.logger.info(
            "[VSP][DATASOURCE2] run=%s total_rows=%d",
            run_dir.name,
            len(rows)
        )

        return jsonify({
            "ok": True,
            "run_id": run_dir.name,
            "summary": summary,
            "severity_counts": dict(sev_counter),
            "tool_counts": dict(tool_counter),
            "severity_chart": {
                "labels": sev_labels,
                "data": sev_data
            },
            "tools_chart": {
                "labels": tool_labels,
                "data": tool_data
            },
            "rows": rows,
            "findings": findings_raw,
            "error": ""
        })

    except Exception as exc:
        app.logger.error("[VSP][DATASOURCE2] unexpected error: %s", exc)
        return jsonify({
            "ok": False,
            "error": str(exc),
            "run_id": None,
            "rows": [],
            "findings": [],
            "summary": {
                "total": 0,
                "severity_counts": {},
                "tool_counts": {}
            },
            "severity_chart": {"labels": [], "data": []},
            "tools_chart": {"labels": [], "data": []}
        }), 500
# ======= END VSP Data Source API – CLEAN /api/vsp/datasource2 =======


# ======= Fallback RUN_ROOT (AUTO PATCH) =======
# Nếu trong file chưa có RUN_ROOT, đoạn này sẽ tạo RUN_ROOT trỏ vào thư mục out/
try:
    RUN_ROOT  # type: ignore[name-defined]
except NameError:
    from pathlib import Path as _PathForRunRoot
    RUN_ROOT = _PathForRunRoot("/home/test/Data/SECURITY_BUNDLE/out")
# ======= END Fallback RUN_ROOT =======
# ======= OVERRIDE /api/vsp/datasource – CLEAN VERSION (NO RUN_ROOT) =======
@app.route("/api/vsp/datasource", methods=["GET"])
def api_vsp_datasource():
    """Data Source cho tab Data:
    - Tự động tìm RUN_* mới nhất trong ./out
    - Lấy file report/findings_unified.json
    - Trả JSON: ok, run_id, summary.total, rows
    """
    import json
    from pathlib import Path as _Path

    try:
        root = _Path(__file__).resolve().parents[1]
        out_dir = root / "out"

        if not out_dir.is_dir():
            return jsonify({
                "ok": False,
                "error": f"Out dir not found: {out_dir}"
            }), 404

        # Lấy list RUN_* theo mtime mới nhất
        run_dirs = sorted(
            [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_")],
            key=lambda p: p.stat().st_mtime,
            reverse=True,
        )

        run_dir = None
        findings_path = None
        for rd in run_dirs:
            cand = rd / "report" / "findings_unified.json"
            if cand.is_file():
                run_dir = rd
                findings_path = cand
                break

        if run_dir is None or findings_path is None:
            return jsonify({
                "ok": False,
                "error": "No RUN_* with report/findings_unified.json found"
            }), 404

        with findings_path.open("r", encoding="utf-8") as fh:
            data = json.load(fh)

        # Chuẩn hóa rows
        if isinstance(data, dict) and "rows" in data:
            rows = data["rows"]
        elif isinstance(data, list):
            rows = data
        else:
            rows = []

        summary = {
            "total": len(rows),
        }

        return jsonify({
            "ok": True,
            "run_id": run_dir.name,
            "summary": summary,
            "rows": rows,
        })
    except Exception as exc:
        app.logger.exception("[VSP][DATASOURCE] Error while building datasource.")
        return jsonify({
            "ok": False,
            "error": str(exc),
        }), 500

