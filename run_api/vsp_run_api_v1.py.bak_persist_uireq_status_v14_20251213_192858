#!/usr/bin/env python3
# VSP Run API v1 (commercial): stage/progress parser + stall/total timeout + unify+sync
import json, os, re, subprocess, uuid, time, datetime
from pathlib import Path

# === VSP_UIREQ_PERSIST_FROM_STATUS_V13 ===
from pathlib import Path as _Path
import json as _json
import time as _time
import os as _os

def _uireq_ui_root_v13():
    # usually ui/run_api/*.py -> parents[1] == ui/
    return _Path(__file__).resolve().parents[1]

def _uireq_state_dir_v13():
    d = _uireq_ui_root_v13() / "out_ci" / "uireq_v1"
    d.mkdir(parents=True, exist_ok=True)
    return d

def _uireq_safe_dict_v13(x):
    return x if isinstance(x, dict) else {}

def _uireq_state_update_v13(req_id: str, patch: dict):
    try:
        fp = _uireq_state_dir_v13() / f"{req_id}.json"
        try:
            cur = _json.loads(fp.read_text(encoding="utf-8"))
        except Exception:
            cur = {"ok": True, "req_id": req_id}

        patch = _uireq_safe_dict_v13(patch)
        for k, v in patch.items():
            if v is None:
                continue
            cur[k] = v

        cur["req_id"] = cur.get("req_id") or req_id
        cur["updated_at"] = _time.strftime("%Y-%m-%dT%H:%M:%SZ", _time.gmtime())

        tmp = str(fp) + ".tmp"
        _Path(tmp).write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding="utf-8")
        _os.replace(tmp, fp)
        return True
    except Exception:
        try:
            app.logger.exception("[UIREQ][V13] persist update failed")
        except Exception:
            pass
        return False
# === END VSP_UIREQ_PERSIST_FROM_STATUS_V13 ===


# === VSP_UIREQ_PERSIST_FROM_STATUS_V12 ===
from pathlib import Path as _Path
import json as _json
import time as _time
import os as _os

def _uireq_ui_root_v12():
    # this file is usually ui/run_api/*.py -> parents[1] == ui/
    return _Path(__file__).resolve().parents[1]

def _uireq_state_dir_v12():
    d = _uireq_ui_root_v12() / "out_ci" / "uireq_v1"
    d.mkdir(parents=True, exist_ok=True)
    return d

def _uireq_safe_dict_v12(obj):
    return obj if isinstance(obj, dict) else {}

def _uireq_state_update_v12(req_id: str, patch: dict):
    try:
        fp = _uireq_state_dir_v12() / f"{req_id}.json"
        try:
            cur = _json.loads(fp.read_text(encoding="utf-8"))
        except Exception:
            cur = {"ok": True, "req_id": req_id}

        patch = _uireq_safe_dict_v12(patch)
        for k, v in patch.items():
            if v is None:
                continue
            cur[k] = v

        cur["req_id"] = cur.get("req_id") or req_id
        cur["updated_at"] = _time.strftime("%Y-%m-%dT%H:%M:%SZ", _time.gmtime())

        tmp = str(fp) + ".tmp"
        _Path(tmp).write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding="utf-8")
        _os.replace(tmp, fp)
        return True
    except Exception:
        try:
            app.logger.exception("[UIREQ][V12] persist update failed")
        except Exception:
            pass
        return False
# === END VSP_UIREQ_PERSIST_FROM_STATUS_V12 ===

from flask import Blueprint, request, jsonify

# === VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 ===
def _vsp_write_uireq_state_v1(req_id: str, req_payload: dict):
  try:
    from pathlib import Path
    import json, time, os
    d = None
    try:
      d = globals().get("_VSP_UIREQ_DIR", None)

      # === VSP_BOOTSTRAP_ON_REQID_CREATION_V1 ===
      try:
        from pathlib import Path
        import json, time, os
        _rid = str(d)
        # write to the SAME dir that run_status reads
        _d = None
        try:
          _d = globals().get("_VSP_UIREQ_DIR", None)
        except Exception:
          _d = None
        st_dir = Path(_d) if _d else (Path(__file__).resolve().parents[1] / "ui" / "out_ci" / "uireq_v1")
        st_dir.mkdir(parents=True, exist_ok=True)
        st_path = st_dir / (str(_rid) + ".json")
        if not st_path.is_file():
          st = {
            "request_id": _rid,
            "synthetic_req_id": True,
            "ci_run_dir": "",
            "runner_log": "",
            "ci_root_from_pid": None,
            "watchdog_pid": 0,
            "stage_sig": "0/0||0",
            "progress_pct": 0,
            "killed": False,
            "kill_reason": "",
            "final": False,
            "stall_timeout_sec": int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")),
            "total_timeout_sec": int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")),
            "state_bootstrap_ts": int(__import__('time').time()),
          }
          st_path.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
          print("[VSP_BOOTSTRAP_ON_REQID_CREATION_V1] wrote", st_path)
      except Exception as e:
        try:
          print("[VSP_BOOTSTRAP_ON_REQID_CREATION_V1] FAILED:", e)
        except Exception:
          pass
      # === END VSP_BOOTSTRAP_ON_REQID_CREATION_V1 ===

    except Exception:
      d = None
    if d:
      st_dir = Path(d)
    else:
      # fallback if _VSP_UIREQ_DIR missing (best effort)
      st_dir = Path(__file__).resolve().parents[1] / "ui" / "out_ci" / "uireq_v1"
    st_dir.mkdir(parents=True, exist_ok=True)
    st = st_dir / (str(req_id) + ".json")

    state0 = {}
    if st.is_file():
      try:
        state0 = json.loads(st.read_text(encoding="utf-8", errors="ignore") or "{}")
        if not isinstance(state0, dict):
          state0 = {}
      except Exception:
        state0 = {}

    state0.setdefault("request_id", str(req_id))
    state0.setdefault("synthetic_req_id", True)
    for k in ("mode","profile","target_type","target"):
      if (not state0.get(k)) and (req_payload.get(k) is not None):
        state0[k] = req_payload.get(k) or ""

    state0.setdefault("ci_run_dir", "")
    state0.setdefault("runner_log", "")
    state0.setdefault("ci_root_from_pid", None)
    state0.setdefault("watchdog_pid", 0)
    state0.setdefault("stage_sig", "0/0||0")
    state0.setdefault("progress_pct", 0)
    state0.setdefault("killed", False)
    state0.setdefault("kill_reason", "")
    state0.setdefault("final", False)

    state0.setdefault("stall_timeout_sec", int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")))
    state0.setdefault("total_timeout_sec", int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")))
    state0["state_bootstrap_ts"] = int(__import__('time').time())

    st.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"[VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1] wrote {st}")
  except Exception as e:
    try:
      print(f"[VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1] FAILED:", e)
    except Exception:
      pass
# === END VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 ===


# === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS ===
def _vsp_bootstrap_statefile_v6(req_id: str, req_payload: dict):
    try:
        from pathlib import Path
        import json, time, os

        # IMPORTANT: write to the SAME dir that run_status_v1 reads from (_VSP_UIREQ_DIR) if present
        st_dir = None
        try:
            st_dir = globals().get("_VSP_UIREQ_DIR", None)
        except Exception:
            st_dir = None

        if st_dir:
            st_dir = Path(st_dir)
        else:
            ui_root = Path(__file__).resolve().parents[1]   # .../SECURITY_BUNDLE/ui
            st_dir = ui_root / "out_ci" / "ui_req_state"

        st_dir.mkdir(parents=True, exist_ok=True)
        st_path = st_dir / (str(req_id) + ".json")

        state0 = {}
        if st_path.is_file():
            try:
                state0 = json.loads(st_path.read_text(encoding="utf-8", errors="ignore") or "{}")
                if not isinstance(state0, dict):
                    state0 = {}
            except Exception:
                state0 = {}

        state0.setdefault("request_id", str(req_id))
        state0.setdefault("synthetic_req_id", True)

        for k in ("mode","profile","target_type","target"):
            if (not state0.get(k)) and (req_payload.get(k) is not None):
                state0[k] = req_payload.get(k) or ""

        state0.setdefault("ci_run_dir", "")
        state0.setdefault("runner_log", "")
        state0.setdefault("ci_root_from_pid", None)
        state0.setdefault("watchdog_pid", 0)
        state0.setdefault("stage_sig", "0/0||0")
        state0.setdefault("progress_pct", 0)
        state0.setdefault("killed", False)
        state0.setdefault("kill_reason", "")
        state0.setdefault("final", False)

        state0.setdefault("stall_timeout_sec", int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")))
        state0.setdefault("total_timeout_sec", int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")))

        state0["state_bootstrap_ts"] = int(__import__('time').time())

        rp = state0.get("req_payload")
        if not isinstance(rp, dict):
            rp = {}
        for k in ("mode","profile","target_type","target"):
            if k in req_payload:
                rp[k] = req_payload.get(k)
        state0["req_payload"] = rp

        st_path.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
        print(f"[BOOTSTRAP_V7] wrote state: {st_path}")
    except Exception as e:
        try:
            print("[BOOTSTRAP_V7] FAILED:", e)
        except Exception:
            pass
        return
# === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS ===
bp = Blueprint("vsp_run_api_v1", __name__)

# In-memory process registry (dev server OK)
PROCS = {}

# Defaults (override via env)
STALL_TIMEOUT_SEC = int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC", "1200"))   # 20m no stage change
TOTAL_TIMEOUT_SEC = int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC", "10800"))  # 3h whole run
TAIL_MAX_LINES    = int(os.environ.get("VSP_UIREQ_TAIL_LINES", "240"))

UI_ROOT = Path(__file__).resolve().parents[1]               # .../SECURITY_BUNDLE/ui
BUNDLE_ROOT = Path(os.environ.get("VSP_BUNDLE_ROOT", str(UI_ROOT.parents[1]))).resolve()  # .../SECURITY_BUNDLE
STATE_DIR = (UI_ROOT / "out_ci" / "uireq_v1")
STATE_DIR.mkdir(parents=True, exist_ok=True)

def now_utc_iso():
  return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

def _safe_read_text(p: Path) -> str:
  try:
    return p.read_text(encoding="utf-8", errors="replace")
  except Exception:
    return ""

def _tail_file(p: Path, n=200) -> str:
  try:
    with p.open("rb") as f:
      f.seek(0, os.SEEK_END)
      size = f.tell()
      # read last ~128KB (enough for logs)
      chunk = 131072
      f.seek(max(0, size - chunk), os.SEEK_SET)
      data = f.read().decode("utf-8", errors="replace")
    lines = data.splitlines()
    return "\n".join(lines[-n:])
  except Exception:
    return ""

def _write_state(req_id: str, st: dict):
  (STATE_DIR / f"{req_id}.json").write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

def _read_state(req_id: str) -> dict:
  p = STATE_DIR / f"{req_id}.json"
  if not p.exists():
    return {}
  try:
    return json.loads(p.read_text(encoding="utf-8", errors="replace"))
  except Exception:
    return {}

def _parse_stage_from_tail(tail: str):
  """
  Detect stage patterns:
    ===== [3/8] KICS (EXT) =====
  """
  m = None
  for line in reversed(tail.splitlines()):
    mm = re.search(r'=\s*\[\s*(\d+)\s*/\s*(\d+)\s*\]\s*([A-Z0-9_\- ]+?)\s*(?:\(|=|$)', line)
    if mm:
      m = mm
      break
  if not m:
    return {"i": 0, "n": 8, "name": "", "progress": 0}
  i = int(m.group(1))
  n = int(m.group(2))
  name = (m.group(3) or "").strip()
  prog = int((i / max(1, n)) * 100)
  return {"i": i, "n": n, "name": name, "progress": prog}

def _parse_run_dir_from_tail(tail: str) -> str:
  # Example: [VSP_CI_OUTER] RUN_DIR    = /home/.../out_ci/VSP_CI_YYYY...
  for line in reversed(tail.splitlines()):
    if "RUN_DIR" in line and "=" in line:
      m = re.search(r'RUN_DIR\s*=\s*(/.+)$', line.strip())
      if m:
        return m.group(1).strip()
  return ""

def _parse_gate_from_tail(tail: str) -> str:
  # Example: [VSP_CI_GATE] GATE RESULT: FAIL
  for line in reversed(tail.splitlines()):
    m = re.search(r'GATE RESULT:\s*(PASS|FAIL)', line)
    if m:
      return m.group(1)
  return "UNKNOWN"

def _read_degraded(run_dir: str):
  out = {"degraded": 0, "reasons": ""}
  if not run_dir:
    return out
  p = Path(run_dir) / "vsp_degraded.env"
  if not p.exists():
    return out
  txt = _safe_read_text(p)
  for line in txt.splitlines():
    line=line.strip()
    if not line or line.startswith("#"): continue
    if line.startswith("degraded="):
      try: out["degraded"] = int(line.split("=",1)[1].strip() or "0")
      except Exception: pass
    if line.startswith("reasons="):
      out["reasons"] = line.split("=",1)[1].strip()
  return out

def _read_severity_from_summary(run_dir: str):
  if not run_dir:
    return {}
  p = Path(run_dir) / "report" / "summary_unified.json"
  if not p.exists():
    return {}
  try:
    j = json.loads(p.read_text(encoding="utf-8", errors="replace"))
    # support both keys
    sev = j.get("summary_by_severity") or j.get("by_severity") or {}
    if isinstance(sev, dict):
      return {k: int(sev.get(k,0) or 0) for k in ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"]}
  except Exception:
    return {}
  return {}

def _kill_proc(req_id: str):
  pr = PROCS.get(req_id)
  if not pr:
    return
  try:
    # kill process group if possible
    os.killpg(os.getpgid(pr.pid), 9)
  except Exception:
    try:
      pr.kill()
    except Exception:
      pass

def _finalize_unify_and_sync(run_dir: str) -> dict:
  """
  Best-effort: ensure report exists, unify if missing, then sync to SECURITY_BUNDLE/out.
  """
  res = {"done": False, "ok": None, "vsp_run_id": "", "msg": ""}
  if not run_dir:
    res["ok"] = False
    res["msg"] = "missing run_dir"
    return res

  runp = Path(run_dir)
  summary = runp / "report" / "summary_unified.json"
  findings = runp / "report" / "findings_unified.json"

  try:
    # unify if missing
    if not summary.exists() or not findings.exists():
      unify_sh = BUNDLE_ROOT / "bin" / "vsp_unify_from_run_dir_v1.sh"
      if unify_sh.exists():
        subprocess.run([str(unify_sh), str(runp)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=900)
  except Exception as e:
    res["msg"] += f"unify_err:{e}; "

  try:
    # sync to bundle/out
    sync_sh = BUNDLE_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
    if sync_sh.exists():
      subprocess.run([str(sync_sh), str(runp)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=180)
  except Exception as e:
    res["msg"] += f"sync_err:{e}; "

  # derive vsp_run_id convention: RUN_<VSP_CI_...>
  base = runp.name.strip()
  if base.startswith("VSP_CI_"):
    cand = BUNDLE_ROOT / "out" / f"RUN_{base}"
    if cand.exists():
      res["vsp_run_id"] = f"RUN_{base}"
    else:
      # try find newest matching prefix
      outdir = (BUNDLE_ROOT / "out")
      if outdir.exists():
        matches = sorted([d for d in outdir.iterdir() if d.is_dir() and d.name.startswith(f"RUN_{base}")],
                         key=lambda x: x.stat().st_mtime, reverse=True)
        if matches:
          res["vsp_run_id"] = matches[0].name

  res["done"] = True
  res["ok"] = True
  return res

@bp.route("/api/vsp/run_v1", methods=["POST"])
def run_v1():  # VSP_FIX_RUNV1_PATH_SHADOW_V1
  data = request.get_json(silent=True) or {}
  mode = (data.get("mode") or "local").strip()
  profile = (data.get("profile") or "FULL_EXT").strip()
  target_type = (data.get("target_type") or "path").strip()
  target = (data.get("target") or "").strip()

  if target_type != "path" or not target:

    # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V4 ===
    try:
        import json, time
        try:
            _req_payload = request.get_json(silent=True) or {}
        except Exception:
            _req_payload = {}

        # discover req_id from locals or response dict
        _rid = None
        for _k in ("request_id","req_id","rid","REQ_ID"):
            if _k in locals() and locals().get(_k):
                _rid = str(locals().get(_k))
                break

        # common response variable names (dict contains request_id)
        if not _rid:
            for _name in ("out","resp","result","payload","ret","data","body"):
                v = locals().get(_name)
                if isinstance(v, dict) and v.get("request_id"):
                    _rid = str(v.get("request_id"))
                    break

        if _rid:
            ui_root = Path(__file__).resolve().parents[1]   # .../SECURITY_BUNDLE/ui
            st_dir = ui_root / "out_ci" / "ui_req_state"
            st_dir.mkdir(parents=True, exist_ok=True)
            st_path = st_dir / (_rid + ".json")

            state0 = {}
            if st_path.is_file():
                try:
                    state0 = json.loads(st_path.read_text(encoding="utf-8", errors="ignore") or "{}")
                    if not isinstance(state0, dict):
                        state0 = {}
                except Exception:
                    state0 = {}

            state0.setdefault("request_id", _rid)
            state0.setdefault("synthetic_req_id", True)

            # backfill contract fields early
            for _k in ("mode","profile","target_type","target"):
                if (not state0.get(_k)) and (_req_payload.get(_k) is not None):
                    state0[_k] = _req_payload.get(_k) or ""

            state0.setdefault("ci_run_dir", "")
            state0.setdefault("runner_log", "")
            state0.setdefault("ci_root_from_pid", None)
            state0.setdefault("watchdog_pid", 0)
            state0.setdefault("stage_sig", "0/0||0")
            state0.setdefault("progress_pct", 0)
            state0.setdefault("killed", False)
            state0.setdefault("kill_reason", "")
            state0.setdefault("final", False)
            state0["state_bootstrap_ts"] = int(__import__('time').time())

            # keep minimal payload for debug
            rp = state0.get("req_payload")
            if not isinstance(rp, dict):
                rp = {}
            for _k in ("mode","profile","target_type","target"):
                if _k in _req_payload:
                    rp[_k] = _req_payload.get(_k)
            state0["req_payload"] = rp

            st_path.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception as _e:
        try:
            print("[VSP_RUN_V1_STATEFILE_BOOTSTRAP_V4] bootstrap failed:", _e)
        except Exception:
            pass
    # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V4 ===

    # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===

    __resp = jsonify({"ok": False, "error": "target_type=path and target required"})

    try:

        _payload = __resp.get_json(silent=True) or {}

    except Exception:

        _payload = {}

    try:

        _rid = str(_payload.get("request_id") or "")

        try:

            _req_payload = request.get_json(silent=True) or {}

        except Exception:

            _req_payload = {}

        if _rid:

            _vsp_bootstrap_statefile_v6(_rid, _req_payload)

    except Exception:

        pass

    return __resp, 400

    # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===



  ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
  req_id = f"UIREQ_{ts}_{uuid.uuid4().hex[:6]}"

  log_file = STATE_DIR / f"{req_id}.log"
  created = now_utc_iso()

  # spawn CI OUTER in target repo
  target_path = Path(target).resolve()
  outer = target_path / "ci" / "VSP_CI_OUTER" / "vsp_ci_outer_full_v1.sh"
  if not outer.exists():
    # fallback: still allow, but will fail and be visible in tail
    outer = target_path / "ci" / "VSP_CI_OUTER" / "vsp_ci_gate_core_v1.sh"

  env = os.environ.copy()
  env["VSP_BUNDLE_ROOT"] = str(BUNDLE_ROOT)
  env["BUNDLE_ROOT"] = str(BUNDLE_ROOT)
  env["PROFILE"] = profile
  env["VSP_PROFILE"] = profile
  # VSP_RUNV1_NORMALIZE_REQID_AND_BOOTSTRAP_STATE_V1
  try:
    # normalize legacy UIREQ_* -> VSP_UIREQ_*
    if isinstance(req_id, str) and req_id.startswith('UIREQ_') and not req_id.startswith('VSP_'):
      req_id = 'VSP_' + req_id
  except Exception:
    pass

  # bootstrap uireq state (single source of truth)
  try:
    udir = __import__('pathlib').Path(_VSP_UIREQ_DIR)
    udir.mkdir(parents=True, exist_ok=True)
    state0 = {
      'request_id': req_id,
      'req_id': req_id,
      'profile': locals().get('profile'),
      'target': locals().get('target'),
      'stage_sig': '0/0||0',
      'final': False,
      'killed': False,
    }
    (udir / f"{req_id}.json").write_text(__import__('json').dumps(state0, ensure_ascii=False, indent=2), encoding='utf-8')
    print('[VSP_RUNV1_NORMALIZE_REQID_AND_BOOTSTRAP_STATE_V1] wrote', str(udir / f"{req_id}.json"))
  except Exception as _e:
    print('[VSP_RUNV1_NORMALIZE_REQID_AND_BOOTSTRAP_STATE_V1] WARN', _e)

  env["VSP_UIREQ_ID"] = req_id

  # state
  st = {
    "ok": True,
    "req_id": req_id,
    "created_at": created,
    "started_at": created,
    "finished_at": None,
    "status": "RUNNING",
    "final": False,
    "exit_code": None,
    "gate": "UNKNOWN",
    "stage": {"i":0,"n":8,"name":"","progress":0},
    "ci_run_dir": "",
    "vsp_run_id": "",
    "flag": {"has_findings": None},
    "degraded": 0,
    "degraded_reasons": "",
    "sync": {"done": False, "ok": None, "msg": ""},
    "meta": {"mode": mode, "profile": profile, "target": str(target_path), "outer": str(outer)},
    "watch": {"last_stage_sig": "", "last_stage_at": __import__('time').time(), "start_ts": __import__('time').time()},
    "log_file": str(log_file),
    "tail": ""
  }
  _write_state(req_id, st)

  # spawn
  try:
    f = open(log_file, "ab", buffering=0)
    p = subprocess.Popen(
      [str(outer)],
      cwd=str(target_path),
      env=env,
      stdout=f,
      stderr=subprocess.STDOUT,
      start_new_session=True
    )
    PROCS[req_id] = p
  except Exception as e:
    st["status"] = "ERROR"
    st["final"] = True
    st["exit_code"] = 2
    st["sync"]["ok"] = False
    st["sync"]["msg"] = f"spawn_err:{e}"
    _write_state(req_id, st)
    # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===
    __resp = jsonify(st)
    try:
        _payload = __resp.get_json(silent=True) or {}
    except Exception:
        _payload = {}
    try:
        _rid = str(_payload.get("request_id") or "")
        try:
            _req_payload = request.get_json(silent=True) or {}
        except Exception:
            _req_payload = {}
        if _rid:
            _vsp_bootstrap_statefile_v6(_rid, _req_payload)
    except Exception:
        pass
    return __resp, 500
    # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===



  # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===

  __resp = jsonify({"ok": True, "req_id": req_id, "status_url": f"/api/vsp/run_status_v1/{req_id}"})

  try:

      _payload = __resp.get_json(silent=True) or {}

  except Exception:

      _payload = {}

  try:

      _rid = str(_payload.get("request_id") or "")

      try:

          _req_payload = request.get_json(silent=True) or {}

      except Exception:

          _req_payload = {}

      if _rid:

          _vsp_bootstrap_statefile_v6(_rid, _req_payload)

  except Exception:

      pass

  # VSP_RUNV1_ADD_REQUEST_ID_ALIAS_V3_SAFE
  try:
    if isinstance(__resp, dict):
      __resp.setdefault('request_id', __resp.get('req_id') or locals().get('req_id'))
      __resp.setdefault('req_id', __resp.get('request_id') or locals().get('req_id'))
  except Exception:
    pass
  return __resp, 200

  # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===



# === VSP_FORCE_JSON_STATUS_AST_V3 (auto) ===
@bp.route("/api/vsp/run_status_v1/<req_id>", methods=["GET"])
def run_status_v1(req_id):
  # === VSP_RUN_STATUS_LAZY_BOOTSTRAP_STATE_V1 ===
  try:
    from pathlib import Path
    import json, time, os
    _d = None
    try:
      _d = globals().get("_VSP_UIREQ_DIR", None)
    except Exception:
      _d = None
    _st = (Path(_d) / f"{req_id}.json") if _d else (Path("out_ci/ui_req_state") / f"{req_id}.json")
    if not _st.is_file():
      _st.parent.mkdir(parents=True, exist_ok=True)
      state0 = {
        "request_id": req_id,
        "synthetic_req_id": True,
        "ci_run_dir": "",
        "runner_log": "",
        "ci_root_from_pid": None,
        "watchdog_pid": 0,
        "stage_sig": "0/0||0",
        "progress_pct": 0,
        "killed": False,
        "kill_reason": "",
        "final": False,
        "stall_timeout_sec": int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")),
        "total_timeout_sec": int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")),
        "state_bootstrap_ts": int(__import__('time').time()),
      }
      # === VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 INJECT ===
      try:
        _rid = None
        try:
          _req_payload = request.get_json(silent=True) or {}
        except Exception:
          _req_payload = {}
        # try common vars: out/res/payload + locals
        for _name in ("out","res","resp","payload","data","body"):
          v = locals().get(_name)
          if isinstance(v, dict) and v.get("request_id"):
            _rid = str(v.get("request_id"))
            break
        if not _rid:
          for _k in ("request_id","req_id","rid","REQ_ID"):
            if locals().get(_k):
              _rid = str(locals().get(_k))
              break
        if _rid:
          _vsp_write_uireq_state_v1(_rid, _req_payload)
      except Exception:
        pass
      # === END VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 INJECT ===

      _st.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
  except Exception:
    pass
  # === END VSP_RUN_STATUS_LAZY_BOOTSTRAP_STATE_V1 ===

  # commercial: ALWAYS JSON
  from flask import jsonify
  import json, re, time
  from pathlib import Path
  req_id = req_id
  ui_root = Path(__file__).resolve().parents[1]  # .../ui
  st_dir = ui_root / "out_ci" / "uireq_v1"
  st_path = st_dir / f"{req_id}.json"
  if not st_path.exists():
    # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
    try:
      _json = __import__('json')
      _P = __import__('pathlib').Path
      _payload = None
      try:
        _st = locals().get('st')
        if isinstance(_st, dict): _payload = _st
      except Exception:
        _payload = None
      if _payload is None:
        try:
          _r = locals().get('__resp')
          if isinstance(_r, dict): _payload = _r
        except Exception:
          _payload = None
      if isinstance(_payload, dict):
        _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
        if _req:
          if '_state_file_path_v1' in globals():
            sp = _state_file_path_v1(_req)
          else:
            sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
          try: sp.parent.mkdir(parents=True, exist_ok=True)
          except Exception: pass
          cur = {}
          try:
            if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
          except Exception:
            cur = {}
          cur['request_id'] = cur.get('request_id') or _req
          cur['req_id'] = cur.get('req_id') or _req
          if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
          if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
          if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
          if _payload.get('final') is not None: cur['final'] = _payload.get('final')
          if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
          if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
          sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
    except Exception as _e:
      print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
    # === VSP_UIREQ_PERSIST_FROM_STATUS_V12 hook ===
    try:
        _rid = locals().get("req_id") or locals().get("request_id") or locals().get("rid")
        _payload = (locals().get("resp") or locals().get("out") or locals().get("data") or locals().get("payload") or {})
        if _rid:
            _uireq_state_update_v12(_rid, _uireq_safe_dict_v12(_payload))
    except Exception:
        pass
    # === END VSP_UIREQ_PERSIST_FROM_STATUS_V12 hook ===
    # === VSP_UIREQ_PERSIST_FROM_STATUS_V13 hook ===
    resp = {"ok": False, "req_id": req_id, "error": "not_found"}
    try:
        _rid = locals().get("req_id") or locals().get("req_id") or locals().get("request_id") or (resp.get("req_id") if isinstance(resp, dict) else None)
        if _rid:
            _uireq_state_update_v13(_rid, _uireq_safe_dict_v13(resp))
    except Exception:
        pass
    # === END VSP_UIREQ_PERSIST_FROM_STATUS_V13 hook ===
    return jsonify(resp), 404
  try:
    st = json.loads(st_path.read_text(encoding="utf-8", errors="ignore") or "{}")


  except Exception:
    st = {}
  st["ok"] = True
  st["req_id"] = req_id

  # tail from log_file
  log_file = st.get("log_file") or str(st_dir / f"{req_id}.log")
  st["log_file"] = log_file
  lf = Path(log_file)
  tail = ""
  if lf.exists():
    try:
      arr = lf.read_text(encoding="utf-8", errors="ignore").splitlines()
      tail = "\n".join(arr[-250:])
    except Exception:
      tail = ""
  st["tail"] = tail

  # fill ci_run_dir from log if empty: RUN_DIR    = ...
  if not st.get("ci_run_dir"):
    m = re.search(r"^\[VSP_CI_OUTER\]\s*RUN_DIR\s*=\s*(.+)$", tail, flags=re.M)
    if m:
      st["ci_run_dir"] = m.group(1).strip()

  # stage/progress from tool banner: ===== [i/8] NAME =====
  stage = st.get("stage") or {"i":0,"n":8,"name":"","progress":0}
  st_re = re.compile(r"^=+\s*\[(\d+)\s*/\s*(\d+)\]\s*(.*?)\s*=+$")
  last = None
  for line in (tail or "").splitlines():
    mm = st_re.match(line.strip())
    if mm:
      last = (int(mm.group(1)), int(mm.group(2)), (mm.group(3) or "").strip())
  if last:
    i, n, name = last
    stage["i"] = i
    stage["n"] = n
    stage["name"] = name
    stage["progress"] = int(round((i/n)*100)) if n else 0
  st["stage"] = stage
  st["stage_index"] = int(stage.get("i",0) or 0)
  st["stage_total"] = int(stage.get("n",0) or 0)
  st["stage_name"] = str(stage.get("name","") or "")
  st["progress_pct"] = int(stage.get("progress",0) or 0)

  # mark final if outer ended (success/fail) based on log keywords
  if "=== VSP CI OUTER:" in tail:
    if "THẤT BẠI" in tail:
      st["status"] = "FAIL"
      st["final"] = True
    if "THÀNH CÔNG" in tail:
      st["status"] = "DONE"
      st["final"] = True

  # persist
  
  # commercial finalize: unify + sync once when final
  try:
    if bool(st.get("final")) and st.get("ci_run_dir"):
      sync = st.get("sync") or {"done": False, "ok": None, "msg": ""}
      if not bool(sync.get("done")):
        ok, msg = _vsp_finalize_unify_sync(st["ci_run_dir"])
        sync["done"] = True
        sync["ok"] = bool(ok)
        sync["msg"] = msg
      st["sync"] = sync

      d, reasons = _vsp_read_degraded_env(st["ci_run_dir"])
      st["degraded"] = int(d)
      st["degraded_reasons"] = reasons
      if d and st.get("status","").upper() in ("DONE","OK","SUCCESS"):
        st["status"] = "DEGRADED"
  except Exception as _e:
    # do not break status endpoint
    st["sync"] = st.get("sync") or {"done": False, "ok": None, "msg": ""}
    st["sync"]["msg"] = (st["sync"].get("msg","") + "\n" + str(_e)).strip()

  st_path.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

  # VSP_RUN_STATUS_READ_UIREQDIR_V2_SAFE
  # Fallback: if primary state is empty/partial, read from _VSP_UIREQ_DIR/<req_id>.json (where run_v1 bootstrap writes)
  try:
      if (not isinstance(st, dict)) or (not st) or (not (st.get("request_id") or st.get("req_id"))):
          try:
              f2 = _VSP_UIREQ_DIR / f"{req_id}.json"
          except Exception:
              from pathlib import Path as _P
              f2 = _P(__file__).resolve().parents[1] / "ui" / "out_ci" / "uireq_v1" / f"{req_id}.json"
          if f2 and getattr(f2, "is_file", lambda: False)():
              import json as _json
              st = _json.loads(f2.read_text(encoding="utf-8", errors="replace"))
      if isinstance(st, dict):
          st.setdefault("ok", True)
          st.setdefault("req_id", str(req_id))
          st.setdefault("request_id", st.get("request_id") or str(req_id))
  except Exception:
      pass
  # END VSP_RUN_STATUS_READ_UIREQDIR_V2_SAFE



  # VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG
  try:
    from pathlib import Path as _P
    import json as _json, re as _re
    if isinstance(st, dict):
      _ci = (st.get("ci_run_dir") or "").strip()
      _rl = (st.get("runner_log") or "").strip()
      tgt = (st.get("target") or "").strip()
      rid = (st.get("req_id") or st.get("request_id") or req_id or "").strip()
      if (not _ci) or (not _rl):
        best_dir = None
        best_diff = 10**18
        cand = []
        if tgt:
          oc = _P(tgt) / "out_ci"
          # parse rid time: VSP_UIREQ_YYYYmmdd_HHMMSS_xxxxxx
          m = _re.search(r"VSP_UIREQ_(\d{8})_(\d{6})_", rid)
          rid_key = None
          if m:
            rid_key = m.group(1) + m.group(2)  # yyyymmddhhmmss
          def _to_int(s):
            try: return int(s)
            except Exception: return None
          rid_int = _to_int(rid_key) if rid_key else None
          if oc.is_dir():
            for d in oc.iterdir():
              if not d.is_dir(): 
                continue
              # accept VSP_CI_YYYYmmdd_HHMMSS
              mm = _re.search(r"VSP_CI_(\d{8})_(\d{6})", d.name)
              if mm:
                k = mm.group(1) + mm.group(2)
                di = _to_int(k)
                cand.append((d, di))
            # choose nearest by timestamp if possible
            if rid_int is not None:
              for d, di in cand:
                if di is None: 
                  continue
                diff = abs(di - rid_int)
                if diff < best_diff:
                  best_diff = diff
                  best_dir = d
            # fallback newest mtime
            if best_dir is None and cand:
              try:
                best_dir = max([d for d,_ in cand], key=lambda x: x.stat().st_mtime)
              except Exception:
                best_dir = None
        if best_dir:
          st["ci_run_dir"] = str(best_dir)
          rp = best_dir / "runner.log"
          st["runner_log"] = str(rp)
          try:
            print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] mapped rid=", rid, "->", str(best_dir), "best_diff=", best_diff, "runner_log_exists=", rp.is_file())
          except Exception:
            pass
        else:
          try:
            print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] no ci dir found for rid=", rid, "tgt=", tgt)
          except Exception:
            pass
        # persist back to statefile (uireq dir)
        try:
          udir = globals().get("_VSP_UIREQ_DIR")
          if udir:
            sf = _P(str(udir)) / f"{req_id}.json"
            sf.parent.mkdir(parents=True, exist_ok=True)
            sf.write_text(_json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception as e:
          try: print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] persist failed:", e)
          except Exception: pass
  except Exception as e:
    try: print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] exception:", e)
    except Exception: pass
  # END VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG

  # === VSP_RUN_STATUS_MAP_CI_DIR_V2_DEBUG_SAFE ===
  try:
    from pathlib import Path as _Path
    import re as _re
    import datetime as _dt

    def _rid_ts_epoch(_rid: str):
      # RID format: VSP_UIREQ_YYYYmmdd_HHMMSS_xxxxxx
      m = _re.search(r"VSP_UIREQ_(\d{8})_(\d{6})_", _rid or "")
      if not m:
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return None
      s = m.group(1) + m.group(2)  # YYYYmmddHHMMSS
      try:
        dt = _dt.datetime.strptime(s, "%Y%m%d%H%M%S")
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return dt.timestamp()
      except Exception:
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return None

    def _ci_ts_epoch(_name: str):
      # CI dir: VSP_CI_YYYYmmdd_HHMMSS
      m = _re.search(r"VSP_CI_(\d{8})_(\d{6})$", _name or "")
      if not m:
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return None
      s = m.group(1) + m.group(2)
      try:
        dt = _dt.datetime.strptime(s, "%Y%m%d%H%M%S")
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return dt.timestamp()
      except Exception:
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return None

    def _pick_ci_dir_for_target(_target: str, _rid: str):
      t = (_target or "").strip()
      if not t:
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return None
      out_ci = _Path(t) / "out_ci"
      if not out_ci.is_dir():
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return None

      rid_epoch = _rid_ts_epoch(_rid) or None
      cands = []
      for d in out_ci.iterdir():
        if not d.is_dir():
          continue
        if not d.name.startswith("VSP_CI_"):
          continue
        ep = _ci_ts_epoch(d.name)
        # fallback to mtime if cannot parse
        try:
          mtime = d.stat().st_mtime
        except Exception:
          mtime = None
        cands.append((ep, mtime, str(d)))

      if not cands:
        # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
        try:
          _json = __import__('json')
          _P = __import__('pathlib').Path
          _payload = None
          try:
            _st = locals().get('st')
            if isinstance(_st, dict): _payload = _st
          except Exception:
            _payload = None
          if _payload is None:
            try:
              _r = locals().get('__resp')
              if isinstance(_r, dict): _payload = _r
            except Exception:
              _payload = None
          if isinstance(_payload, dict):
            _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
            if _req:
              if '_state_file_path_v1' in globals():
                sp = _state_file_path_v1(_req)
              else:
                sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
              try: sp.parent.mkdir(parents=True, exist_ok=True)
              except Exception: pass
              cur = {}
              try:
                if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
              except Exception:
                cur = {}
              cur['request_id'] = cur.get('request_id') or _req
              cur['req_id'] = cur.get('req_id') or _req
              if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
              if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
              if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
              if _payload.get('final') is not None: cur['final'] = _payload.get('final')
              if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
              if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
              sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
              print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
        except Exception as _e:
          print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
        return None

      # prefer timestamp >= rid_ts - 120s and close to rid_ts
      if rid_epoch is not None:
        win = []
        for ep, mt, path in cands:
          if ep is None:
            continue
          if ep >= (rid_epoch - 120) and ep <= (rid_epoch + 6*3600):
            win.append((abs(ep - rid_epoch), ep, mt, path))
        if win:
          win.sort(key=lambda x: (x[0], -(x[1] or 0), -(x[2] or 0)))
          # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
          try:
            _json = __import__('json')
            _P = __import__('pathlib').Path
            _payload = None
            try:
              _st = locals().get('st')
              if isinstance(_st, dict): _payload = _st
            except Exception:
              _payload = None
            if _payload is None:
              try:
                _r = locals().get('__resp')
                if isinstance(_r, dict): _payload = _r
              except Exception:
                _payload = None
            if isinstance(_payload, dict):
              _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
              if _req:
                if '_state_file_path_v1' in globals():
                  sp = _state_file_path_v1(_req)
                else:
                  sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
                try: sp.parent.mkdir(parents=True, exist_ok=True)
                except Exception: pass
                cur = {}
                try:
                  if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
                except Exception:
                  cur = {}
                cur['request_id'] = cur.get('request_id') or _req
                cur['req_id'] = cur.get('req_id') or _req
                if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
                if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
                if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
                if _payload.get('final') is not None: cur['final'] = _payload.get('final')
                if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
                if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
                sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
                print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
          except Exception as _e:
            print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
          return win[0][3]

      # else pick newest by (parsed_ts, mtime)
      cands.sort(key=lambda x: ((x[0] or 0), (x[1] or 0)))
      # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
      try:
        _json = __import__('json')
        _P = __import__('pathlib').Path
        _payload = None
        try:
          _st = locals().get('st')
          if isinstance(_st, dict): _payload = _st
        except Exception:
          _payload = None
        if _payload is None:
          try:
            _r = locals().get('__resp')
            if isinstance(_r, dict): _payload = _r
          except Exception:
            _payload = None
        if isinstance(_payload, dict):
          _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
          if _req:
            if '_state_file_path_v1' in globals():
              sp = _state_file_path_v1(_req)
            else:
              sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
            try: sp.parent.mkdir(parents=True, exist_ok=True)
            except Exception: pass
            cur = {}
            try:
              if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
            except Exception:
              cur = {}
            cur['request_id'] = cur.get('request_id') or _req
            cur['req_id'] = cur.get('req_id') or _req
            if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
            if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
            if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
            if _payload.get('final') is not None: cur['final'] = _payload.get('final')
            if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
            if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
            sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
            print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
      except Exception as _e:
        print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
      return cands[-1][2]

    # main
    if isinstance(st, dict):
      _need = (st.get("ci_run_dir") in ("", None)) or (st.get("runner_log") in ("", None))
      _tgt = st.get("target") or st.get("target_path") or ""
      if _need and _tgt:
        _picked = _pick_ci_dir_for_target(_tgt, req_id)
        if _picked:
          _rl = str(_Path(_picked) / "runner.log")
          if not _Path(_rl).is_file():
            _rl = str(_Path(_picked) / "runner.log")  # keep canonical anyway
          st["ci_run_dir"] = _picked
          st["runner_log"] = _rl if _Path(_rl).exists() else _rl
          st["ci_root_from_pid"] = _tgt
          print(f"[VSP_RUN_STATUS_MAP_CI_DIR_V2_DEBUG_SAFE] req_id={req_id} picked_ci={_picked} runner_log={st.get('runner_log')}")

          # persist back to UIREQ_DIR state file if helper exists
          try:
            # use existing helper if present
            sp = None
            try:
              sp = _state_path_uireq_v1(req_id)  # type: ignore
            except Exception:
              sp = None
            if sp is None:
              # fallback: use _VSP_UIREQ_DIR if available
              try:
                sp = _VSP_UIREQ_DIR / f"{req_id}.json"  # type: ignore
              except Exception:
                sp = None
            if sp is not None:
              _Path(str(sp)).write_text(__import__("json").dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
          except Exception as _pe:
            print(f"[VSP_RUN_STATUS_MAP_CI_DIR_V2_DEBUG_SAFE] persist_err={_pe}")
        else:
          print(f"[VSP_RUN_STATUS_MAP_CI_DIR_V2_DEBUG_SAFE] req_id={req_id} no_ci_dir_found target={_tgt}")
  except Exception as _e:
    try:
      print(f"[VSP_RUN_STATUS_MAP_CI_DIR_V2_DEBUG_SAFE] fatal_err={_e}")
    except Exception:
      pass
  # === END VSP_RUN_STATUS_MAP_CI_DIR_V2_DEBUG_SAFE ===

  # VSP_RUN_STATUS_AUTOLINK_CI_DIR_V1
  try:
    # If backend created CI run under target/out_ci/VSP_CI_*/runner.log, link it once.
    _req_id = st.get("req_id") or st.get("request_id") or req_id
    _target = st.get("target") or ""
    if (not st.get("ci_run_dir")) and _target:
      _P = __import__('pathlib').Path
      _json = __import__('json')
      _dt = __import__('datetime')
      _re = __import__('re')
      _os = __import__('os')
      tpath = _P(str(_target))
      out_ci = tpath / "out_ci"
      req_epoch = None
      try:
        mm = _re.search(r"(?:^|_)VSP_UIREQ_(\d{8})_(\d{6})_", str(_req_id))
        if mm:
          ts = mm.group(1) + mm.group(2)  # yyyymmddHHMMSS
          req_epoch = _dt.datetime.strptime(ts, "%Y%m%d%H%M%S").timestamp()
      except Exception:
        req_epoch = None
      
      if out_ci.is_dir():
        cands = []
        for d in out_ci.iterdir():
          if not d.is_dir():
            continue
          if not d.name.startswith("VSP_CI_"):
            continue
          rl = d / "runner.log"
          try:
            mt = rl.stat().st_mtime if rl.exists() else d.stat().st_mtime
          except Exception:
            mt = 0.0
          # filter old runs: accept only near req time if available
          if req_epoch is not None and mt and mt < (req_epoch - 120):
            continue
          cands.append((mt, str(d), str(rl) if rl.exists() else None))
        if cands:
          cands.sort(key=lambda x: x[0], reverse=True)
          _mt, best_dir, best_rl = cands[0]
          st["ci_run_dir"] = best_dir
          st["runner_log"] = best_rl or str(_P(best_dir) / "runner.log")
          # persist back to uireq state file
          try:
            udir = _P(_VSP_UIREQ_DIR)
            sp = udir / f"{_req_id}.json"
            if sp.exists():
              cur = _json.loads(sp.read_text(encoding="utf-8", errors="replace"))
            else:
              cur = {}
            cur["ci_run_dir"] = st.get("ci_run_dir")
            cur["runner_log"] = st.get("runner_log")
            sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding="utf-8")
          except Exception as _pe:
            pass
          try:
            print("[VSP_RUN_STATUS_AUTOLINK_CI_DIR_V1] linked", st.get("ci_run_dir"), "runner_log=", st.get("runner_log"))
          except Exception:
            pass
  except Exception as _e:
    try:
      print("[VSP_RUN_STATUS_AUTOLINK_CI_DIR_V1] WARN", _e)
    except Exception:
      pass

  # VSP_RUN_STATUS_PERSIST_UIREQ_V2
  try:
    _json = __import__('json')
    _P = __import__('pathlib').Path
    _req_id = st.get("req_id") or st.get("request_id") or req_id
    # only persist when we already know ci_run_dir/runner_log
    if _req_id and (st.get("ci_run_dir") or st.get("runner_log")):
      # prefer helper if exists
      if "_state_file_path_v1" in globals():
        sp = _state_file_path_v1(_req_id)
      else:
        sp = _P(_VSP_UIREQ_DIR) / f"{_req_id}.json"
      try:
        sp.parent.mkdir(parents=True, exist_ok=True)
      except Exception:
        pass
      cur = {}
      try:
        if sp.exists():
          cur = _json.loads(sp.read_text(encoding="utf-8", errors="replace"))
      except Exception:
        cur = {}
      cur["request_id"] = cur.get("request_id") or _req_id
      cur["req_id"] = cur.get("req_id") or _req_id
      cur["ci_run_dir"] = st.get("ci_run_dir")
      cur["runner_log"] = st.get("runner_log")
      sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding="utf-8")
      try:
        print("[VSP_RUN_STATUS_PERSIST_UIREQ_V2] persisted", str(sp), "ci_run_dir=", cur.get("ci_run_dir"), "runner_log=", cur.get("runner_log"))
      except Exception:
        pass
  except Exception as _e:
    try:
      print("[VSP_RUN_STATUS_PERSIST_UIREQ_V2] WARN", _e)
    except Exception:
      pass

  # VSP_RUN_STATUS_PERSIST_UIREQ_V3_WRAP_RETURNS
  if not locals().get("_vsp_persisted_uireq_v3"):
    locals()["_vsp_persisted_uireq_v3"] = True
    try:
      _json = __import__('json')
      _P = __import__('pathlib').Path
      _req_id = st.get("req_id") or st.get("request_id") or req_id
      if _req_id and (st.get("ci_run_dir") or st.get("runner_log")):
        if "_state_file_path_v1" in globals():
          sp = _state_file_path_v1(_req_id)
        else:
          sp = _P(_VSP_UIREQ_DIR) / f"{_req_id}.json"
        try:
          sp.parent.mkdir(parents=True, exist_ok=True)
        except Exception:
          pass
        cur = {}
        try:
          if sp.exists():
            cur = _json.loads(sp.read_text(encoding="utf-8", errors="replace"))
        except Exception:
          cur = {}
        cur["request_id"] = cur.get("request_id") or _req_id
        cur["req_id"] = cur.get("req_id") or _req_id
        cur["ci_run_dir"] = st.get("ci_run_dir")
        cur["runner_log"] = st.get("runner_log")
        try:
          sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding="utf-8")
          print("[VSP_RUN_STATUS_PERSIST_UIREQ_V3_WRAP_RETURNS] persisted", str(sp))
        except Exception as _we:
          print("[VSP_RUN_STATUS_PERSIST_UIREQ_V3_WRAP_RETURNS] WARN write_failed", _we)
    except Exception as _e:
      print("[VSP_RUN_STATUS_PERSIST_UIREQ_V3_WRAP_RETURNS] WARN", _e)

  _st = st
  # VSP_RUN_STATUS_PERSIST_UIREQ_V5_1_BEFORE_RETURN_JSONIFY
  try:
    _json = __import__('json')
    _P = __import__('pathlib').Path
    _req = None
    try:
      _req = (_st.get('req_id') if isinstance(_st, dict) else None) or (_st.get('request_id') if isinstance(_st, dict) else None)
    except Exception:
      _req = None
    if not _req:
      _req = locals().get('req_id') or locals().get('REQ_ID') or locals().get('request_id') or locals().get('REQUEST_ID')
    if _req:
      if '_state_file_path_v1' in globals():
        sp = _state_file_path_v1(_req)
      else:
        sp = _P(_VSP_UIREQ_DIR) / f"{_req}.json"
      try:
        sp.parent.mkdir(parents=True, exist_ok=True)
      except Exception:
        pass
      cur = {}
      try:
        if sp.exists():
          cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
      except Exception:
        cur = {}
      cur['request_id'] = cur.get('request_id') or _req
      cur['req_id'] = cur.get('req_id') or _req
      if isinstance(_st, dict):
        if _st.get('ci_run_dir'): cur['ci_run_dir'] = _st.get('ci_run_dir')
        if _st.get('runner_log'): cur['runner_log'] = _st.get('runner_log')
      sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
      print('[VSP_RUN_STATUS_PERSIST_UIREQ_V5_1_BEFORE_RETURN_JSONIFY] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
  except Exception as _e:
    print('[VSP_RUN_STATUS_PERSIST_UIREQ_V5_1_BEFORE_RETURN_JSONIFY] WARN', _e)
  # VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS
  try:
    _json = __import__('json')
    _P = __import__('pathlib').Path
    _payload = None
    try:
      _st = locals().get('st')
      if isinstance(_st, dict): _payload = _st
    except Exception:
      _payload = None
    if _payload is None:
      try:
        _r = locals().get('__resp')
        if isinstance(_r, dict): _payload = _r
      except Exception:
        _payload = None
    if isinstance(_payload, dict):
      _req = (_payload.get('req_id') or _payload.get('request_id') or locals().get('req_id') or locals().get('request_id'))
      if _req:
        if '_state_file_path_v1' in globals():
          sp = _state_file_path_v1(_req)
        else:
          sp = _P(_VSP_UIREQ_DIR) / (_req + '.json')
        try: sp.parent.mkdir(parents=True, exist_ok=True)
        except Exception: pass
        cur = {}
        try:
          if sp.exists(): cur = _json.loads(sp.read_text(encoding='utf-8', errors='replace'))
        except Exception:
          cur = {}
        cur['request_id'] = cur.get('request_id') or _req
        cur['req_id'] = cur.get('req_id') or _req
        if _payload.get('ci_run_dir') is not None: cur['ci_run_dir'] = _payload.get('ci_run_dir')
        if _payload.get('runner_log') is not None: cur['runner_log'] = _payload.get('runner_log')
        if _payload.get('stage_sig') is not None: cur['stage_sig'] = _payload.get('stage_sig')
        if _payload.get('final') is not None: cur['final'] = _payload.get('final')
        if _payload.get('killed') is not None: cur['killed'] = _payload.get('killed')
        if _payload.get('kill_reason') is not None: cur['kill_reason'] = _payload.get('kill_reason')
        sp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding='utf-8')
        print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] persisted', str(sp), 'ci_run_dir=', cur.get('ci_run_dir'))
  except Exception as _e:
    print('[VSP_RUN_STATUS_PERSIST_UIREQ_V7_1_HOOK_ALL_RETURNS] WARN', _e)
  # === VSP_UIREQ_PERSIST_FROM_STATUS_V13 hook ===
  resp = _st
  try:
      _rid = locals().get("req_id") or locals().get("req_id") or locals().get("request_id") or (resp.get("req_id") if isinstance(resp, dict) else None)
      if _rid:
          _uireq_state_update_v13(_rid, _uireq_safe_dict_v13(resp))
  except Exception:
      pass
  # === END VSP_UIREQ_PERSIST_FROM_STATUS_V13 hook ===
  return jsonify(resp)

# === END VSP_FORCE_JSON_STATUS_AST_V3 ===

print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")


# === VSP_COMMERCIAL_BP_EXPORT_ALIAS_V1 ===
# Backward-compatible export name expected by UI gateway:
bp_vsp_run_api_v1 = bp
# Optional: keep old name too (some code may import bp_vsp_run_api)
try:
    bp_vsp_run_api
except NameError:
    bp_vsp_run_api = bp
# === END VSP_COMMERCIAL_BP_EXPORT_ALIAS_V1 ===


# === VSP_COMMERCIAL_RUNAPI_V2 (do not edit manually) ===
import os, re, json, time, signal, subprocess
from pathlib import Path

_VSP_STAGE_RE = re.compile(r"^=+\s*\[(\d+)\s*/\s*(\d+)\]\s*(.*?)\s*=+$")

def _vsp_root_dir_v1():
    cur = Path(__file__).resolve()
    for _ in range(0, 12):
        if (cur / "bin").is_dir():
            return cur
        cur = cur.parent
    return Path.cwd()

_VSP_ROOT = _vsp_root_dir_v1()
_VSP_UIREQ_DIR = _VSP_ROOT / "ui" / "out_ci" / "uireq_v1"
_VSP_UIREQ_DIR.mkdir(parents=True, exist_ok=True)

def _uireq_state_path(req_id: str) -> Path:
    return _VSP_UIREQ_DIR / f"{req_id}.json"

def _load_uireq(req_id: str) -> dict:
    f = _uireq_state_path(req_id)
    if not f.exists():
        return {}
    try:
        return json.loads(f.read_text(encoding="utf-8"))
    except Exception:
        return {}

def _save_uireq(req_id: str, st: dict) -> None:
    f = _uireq_state_path(req_id)
    st = dict(st or {})
    st["req_id"] = req_id
    st["saved_at"] = __import__('time').time()
    f.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

def vsp_commercial_state_register(req_id, ci_run_dir, pid, log_path=None):
    if not req_id or not ci_run_dir or not pid:
        return
    st = _load_uireq(req_id)
    st.setdefault("started_at", __import__('time').time())
    st["pid"] = int(pid)
    st["ci_run_dir"] = str(ci_run_dir)
    if log_path:
        st["log_path"] = str(log_path)
    st.setdefault("last_stage", "")
    st.setdefault("last_stage_ts", __import__('time').time())
    st.setdefault("stall_timeout_sec", int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC", "600")))
    st.setdefault("total_timeout_sec", int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC", "7200")))
    st.setdefault("final", False)
    st.setdefault("finalized", False)
    _save_uireq(req_id, st)

def _extract_stage_from_tail(tail_text: str):
    if not tail_text:
        return None
    last = None
    for line in tail_text.splitlines():
        m = _VSP_STAGE_RE.match(line.strip())
        if m:
            last = (int(m.group(1)), int(m.group(2)), (m.group(3) or "").strip())
    return last

def _read_degraded(ci_run_dir: Path):
    candidates = [ci_run_dir / "vsp_degraded.env", ci_run_dir / "out" / "vsp_degraded.env"]
    for f in candidates:
        if f.exists():
            degraded = 0
            reasons = ""
            for line in f.read_text(encoding="utf-8", errors="ignore").splitlines():
                if line.startswith("degraded="):
                    try: degraded = int(line.split("=",1)[1].strip() or "0")
                    except: degraded = 0
                if line.startswith("degraded_reasons="):
                    reasons = line.split("=",1)[1].strip()
            return degraded, reasons, str(f)
    return 0, "", ""

def _kill_pid_group(pid: int):
    try:
        os.killpg(pid, signal.SIGTERM)
        return True, "SIGTERM(pgid)"
    except Exception:
        try:
            os.kill(pid, signal.SIGTERM)
            return True, "SIGTERM(pid)"
        except Exception as e:
            return False, f"kill_failed:{e}"

def _maybe_finalize(ci_run_dir: Path, st: dict):
    if not ci_run_dir or not ci_run_dir.exists():
        return False, "missing_ci_run_dir"
    if st.get("finalized"):
        return True, "already_finalized"

    unify = _VSP_ROOT / "bin" / "vsp_unify_from_run_dir_v1.sh"
    sync  = _VSP_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"

    ok = True
    logs = []

    if unify.exists():
        r = subprocess.run([str(unify), str(ci_run_dir)], capture_output=True, text=True)
        logs.append(f"[UNIFY rc={r.returncode}]")
        if r.returncode != 0:
            ok = False
            logs.append((r.stdout or "")[-3000:])
            logs.append((r.stderr or "")[-3000:])
    else:
        ok = False
        logs.append("[UNIFY missing]")

    if sync.exists():
        r2 = subprocess.run([str(sync), str(ci_run_dir)], capture_output=True, text=True)
        logs.append(f"[SYNC rc={r2.returncode}]")
        if r2.returncode != 0:
            ok = False
            logs.append((r2.stdout or "")[-3000:])
            logs.append((r2.stderr or "")[-3000:])
    else:
        ok = False
        logs.append("[SYNC missing]")

    st["finalized"] = True
    st["finalize_ok"] = bool(ok)
    st["finalize_log_tail"] = "\n".join([x for x in logs if x])
    return ok, "finalized"

def vsp_commercial_enhance_status_payload(req_id: str, payload: dict):
    payload = dict(payload or {})
    st = _load_uireq(req_id)

    tail = payload.get("tail") or payload.get("log_tail") or ""
    stage = _extract_stage_from_tail(tail)
    if stage:
        i, total, name = stage
        payload["stage_index"] = i
        payload["stage_total"] = total
        payload["stage_name"] = name
        payload["progress_pct"] = int(round((i / total) * 100)) if total else 0
        if st.get("last_stage") != f"{i}/{total}:{name}":
            st["last_stage"] = f"{i}/{total}:{name}"
            st["last_stage_ts"] = __import__('time').time()

    started_at = float(st.get("started_at") or __import__('time').time())
    last_stage_ts = float(st.get("last_stage_ts") or started_at)
    stall_timeout = int(st.get("stall_timeout_sec") or int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC","600")))
    total_timeout = int(st.get("total_timeout_sec") or int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC","7200")))

    payload["started_at"] = started_at
    payload["stall_timeout_sec"] = stall_timeout
    payload["total_timeout_sec"] = total_timeout

    status = (payload.get("status") or "").upper()
    now = __import__('time').time()
    pid = st.get("pid")
    ci_run_dir = Path(st["ci_run_dir"]) if st.get("ci_run_dir") else None

    if status == "RUNNING" and not st.get("final"):
        if total_timeout > 0 and (now - started_at) > total_timeout:
            st["final"] = True
            payload["status"] = "TIMEOUT"
            payload["final"] = True
            if pid:
                ok, how = _kill_pid_group(int(pid))
                payload["killed"] = ok
                payload["kill_reason"] = how
        elif stall_timeout > 0 and (now - last_stage_ts) > stall_timeout:
            st["final"] = True
            payload["status"] = "STALLED"
            payload["final"] = True
            if pid:
                ok, how = _kill_pid_group(int(pid))
                payload["killed"] = ok
                payload["kill_reason"] = how

    if payload.get("final") is True:
        st["final"] = True

    if ci_run_dir and ci_run_dir.exists():
        degraded, reasons, src = _read_degraded(ci_run_dir)
        payload["degraded"] = int(degraded)
        payload["degraded_reasons"] = reasons
        payload["degraded_src"] = src
        if degraded and payload.get("status","").upper() in ("DONE","OK","SUCCESS"):
            payload["status"] = "DEGRADED"

    if st.get("final") and ci_run_dir:
        ok, _ = _maybe_finalize(ci_run_dir, st)
        payload["finalize_ok"] = bool(ok)
        payload["sync_done"] = True if ok else payload.get("sync_done", False)

    _save_uireq(req_id, st)
    return payload

# === END VSP_COMMERCIAL_RUNAPI_V2 ===

# === VSP_FINALIZE_UNIFY_SYNC_V4 ===
def _vsp_read_degraded_env(ci_run_dir: str):
  try:
    from pathlib import Path
    f = Path(ci_run_dir) / "vsp_degraded.env"
    if not f.exists():
      f = Path(ci_run_dir) / "out" / "vsp_degraded.env"
    if not f.exists():
      return 0, ""
    degraded = 0
    reasons = ""
    for line in f.read_text(encoding="utf-8", errors="ignore").splitlines():
      if line.startswith("degraded="):
        try: degraded = int(line.split("=",1)[1].strip() or "0")
        except: degraded = 0
      if line.startswith("degraded_reasons="):
        reasons = line.split("=",1)[1].strip()
    return degraded, reasons
  except Exception:
    return 0, ""

def _vsp_finalize_unify_sync(ci_run_dir: str):
  import subprocess
  from pathlib import Path
  bundle_root = Path(__file__).resolve().parents[2]  # .../SECURITY_BUNDLE
  unify = bundle_root / "bin" / "vsp_unify_from_run_dir_v1.sh"
  sync  = bundle_root / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
  logs = []
  ok = True
  if unify.exists():
    r = subprocess.run([str(unify), str(ci_run_dir)], capture_output=True, text=True)
    logs.append(f"[UNIFY rc={r.returncode}]")
    if r.returncode != 0:
      ok = False
      logs.append((r.stdout or "")[-2000:])
      logs.append((r.stderr or "")[-2000:])
  else:
    ok = False
    logs.append("[UNIFY missing]")
  if sync.exists():
    r2 = subprocess.run([str(sync), str(ci_run_dir)], capture_output=True, text=True)
    logs.append(f"[SYNC rc={r2.returncode}]")
    if r2.returncode != 0:
      ok = False
      logs.append((r2.stdout or "")[-2000:])
      logs.append((r2.stderr or "")[-2000:])
  else:
    ok = False
    logs.append("[SYNC missing]")
  return ok, "\n".join([x for x in logs if x])
# === END VSP_FINALIZE_UNIFY_SYNC_V4 ===

