#!/usr/bin/env python3
import json
import os
import re
import subprocess
import time
import uuid
from datetime import datetime, timezone
from pathlib import Path
from flask import Blueprint, jsonify, request

bp_vsp_run_api_v1 = Blueprint("vsp_run_api_v1", __name__)

# UI root = .../SECURITY_BUNDLE/ui
UI_ROOT = Path(__file__).resolve().parents[1]
BUNDLE_ROOT = Path(os.environ.get("VSP_BUNDLE_ROOT", str(UI_ROOT.parent)))
UI_OUT = UI_ROOT / "out_ci" / "req"
UI_OUT.mkdir(parents=True, exist_ok=True)

def _utc_now_iso():
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")

def _safe_read_json(p: Path):
    try:
        if p.exists():
            return json.loads(p.read_text(encoding="utf-8", errors="replace"))
    except Exception:
        return None
    return None

def _safe_write_json(p: Path, obj):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")

def _tail_text(p: Path, max_bytes: int = 6000) -> str:
    try:
        if not p.exists():
            return ""
        with p.open("rb") as f:
            f.seek(0, os.SEEK_END)
            n = f.tell()
            start = max(0, n - max_bytes)
            f.seek(start, os.SEEK_SET)
            data = f.read()
        return data.decode("utf-8", errors="replace")
    except Exception as e:
        return f"[tail_error] {e}"

def _pid_alive(pid: int) -> bool:
    try:
        os.kill(pid, 0)
        return True
    except Exception:
        return False

def _pick_latest_ci_run_dir(target: str) -> str:
    """Fallback: pick newest target/out_ci/VSP_CI_*"""
    try:
        out_ci = Path(target) / "out_ci"
        if not out_ci.exists():
            return ""
        cands = sorted(out_ci.glob("VSP_CI_*"), key=lambda p: p.stat().st_mtime, reverse=True)
        return str(cands[0]) if cands else ""
    except Exception:
        return ""

def _parse_ci_run_dir_from_log(log_text: str) -> str:
    # Examples:
    # [E2E] Latest RUN_DIR=/home/test/Data/SECURITY-10-10-v4/out_ci/VSP_CI_20251213_085816
    # RUN_DIR    = /home/.../out_ci/VSP_CI_...
    pats = [
        r'Latest\s+RUN_DIR\s*=\s*(/[^ \n]+/out_ci/VSP_CI_[0-9_]+)',
        r'RUN_DIR\s*=\s*(/[^ \n]+/out_ci/VSP_CI_[0-9_]+)',
        r'CI_RUN_DIR\s*=\s*(/[^ \n]+/out_ci/VSP_CI_[0-9_]+)',
    ]
    for pat in pats:
        m = re.search(pat, log_text)
        if m:
            return m.group(1)
    return ""

def _compute_gate_from_summary(summary_path: Path, max_critical: int, max_high: int):
    summary = _safe_read_json(summary_path) or {}
    bysev = (summary.get("summary_by_severity") or summary.get("by_severity") or {})
    c = int(bysev.get("CRITICAL", 0) or 0)
    h = int(bysev.get("HIGH", 0) or 0)
    gate = "PASS"
    reasons = []
    if c > max_critical:
        gate = "FAIL"
        reasons.append(f"CRITICAL({c})>{max_critical}")
    if h > max_high:
        gate = "FAIL"
        reasons.append(f"HIGH({h})>{max_high}")
    return gate, {"CRITICAL": c, "HIGH": h, "MEDIUM": int(bysev.get("MEDIUM", 0) or 0),
                  "LOW": int(bysev.get("LOW", 0) or 0), "INFO": int(bysev.get("INFO", 0) or 0),
                  "TRACE": int(bysev.get("TRACE", 0) or 0)}, reasons

def _sync_ci_to_bundle(ci_run_dir: str) -> dict:
    sync = BUNDLE_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
    if not sync.exists():
        return {"ok": False, "error": f"sync script not found: {sync}"}
    try:
        cp = subprocess.run(["bash", str(sync), ci_run_dir], capture_output=True, text=True, timeout=60*10)
        ok = (cp.returncode == 0)
        # infer VSP_RUN_ID
        run_id = ""
        m = re.search(r'VSP_RUN_DIR\s*=\s*(\S+)', cp.stdout + "\n" + cp.stderr)
        if m:
            # path .../out/RUN_VSP_CI_...
            run_id = Path(m.group(1)).name
        return {"ok": ok, "rc": cp.returncode, "vsp_run_id": run_id, "stdout": cp.stdout[-2000:], "stderr": cp.stderr[-2000:]}
    except Exception as e:
        return {"ok": False, "error": str(e)}

@bp_vsp_run_api_v1.route("/api/vsp/run", methods=["POST"])
def api_vsp_run():
    body = request.get_json(silent=True) or {}
    mode = (body.get("mode") or "local").lower().strip()
    profile = (body.get("profile") or "FULL_EXT").strip()
    target_type = (body.get("target_type") or "path").strip()
    target = (body.get("target") or os.environ.get("VSP_DEFAULT_TARGET") or "/home/test/Data/SECURITY-10-10-v4").strip()

    # Gate thresholds (commercial default)
    max_critical = int(body.get("max_critical", os.environ.get("MAX_CRITICAL", 0)))
    max_high = int(body.get("max_high", os.environ.get("MAX_HIGH", 10)))

    if target_type != "path":
        return jsonify({"ok": False, "error": "Only target_type=path is supported (commercial v1)."}), 400

    # Resolve outer script
    outer_root = os.environ.get("VSP_OUTER_ROOT", "/home/test/Data/SECURITY-10-10-v4/ci/VSP_CI_OUTER")
    outer_script = os.environ.get("VSP_OUTER_SCRIPT", str(Path(outer_root) / "vsp_ci_outer_full_v1.sh"))
    outer_root_p = Path(outer_root)

    req_id = f"UIREQ_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:6]}"
    req_dir = UI_OUT / req_id
    req_dir.mkdir(parents=True, exist_ok=True)

    log_path = req_dir / "outer.log"
    req_path = req_dir / "request.json"
    st_path = req_dir / "status.json"

    req_obj = {
        "req_id": req_id,
        "created_at": _utc_now_iso(),
        "mode": mode,
        "profile": profile,
        "target_type": target_type,
        "target": target,
        "max_critical": max_critical,
        "max_high": max_high,
        "outer_root": outer_root,
        "outer_script": outer_script,
    }
    _safe_write_json(req_path, req_obj)

    st_obj = {
        "ok": True,
        "req_id": req_id,
        "status": "RUNNING",
        "final": False,
        "gate": "UNKNOWN",
        "created_at": _utc_now_iso(),
        "started_at": _utc_now_iso(),
        "finished_at": None,
        "exit_code": None,
        "ci_run_dir": "",
        "vsp_run_id": "",
        "flag": {"has_findings": None},
        "severity": {},
        "reasons": [],
        "sync": {"done": False, "ok": None},
    }
    _safe_write_json(st_path, st_obj)

    env = os.environ.copy()
    env["SRC"] = target
    env["VSP_SRC"] = target
    env["TARGET"] = target
    env["PROFILE"] = profile
    env["VSP_PROFILE"] = profile
    env["MAX_CRITICAL"] = str(max_critical)
    env["MAX_HIGH"] = str(max_high)

    cmd = ["bash", str(outer_script)]
    # We run from outer_root to match your manual runs
    try:
        with log_path.open("w", encoding="utf-8", errors="replace") as lf:
            p = subprocess.Popen(
                cmd,
                cwd=str(outer_root_p),
                env=env,
                stdout=lf,
                stderr=subprocess.STDOUT,
                text=True
            )
        (req_dir / "pid.txt").write_text(str(p.pid), encoding="utf-8")
    except Exception as e:
        st_obj["status"] = "FAILED"
        st_obj["final"] = True
        st_obj["gate"] = "ERROR"
        st_obj["finished_at"] = _utc_now_iso()
        st_obj["exit_code"] = -1
        st_obj["reasons"] = [f"spawn_error: {e}"]
        _safe_write_json(st_path, st_obj)
        return jsonify({"ok": False, "error": str(e), "req_id": req_id}), 500

    return jsonify({
        "ok": True,
        "implemented": True,
        "message": "Scan request accepted. Use /api/vsp/run_status/<REQ_ID> to poll.",
        "req_id": req_id,
        "profile": profile,
        "target": target,
        "max_critical": max_critical,
        "max_high": max_high
    })

@bp_vsp_run_api_v1.route("/api/vsp/run_status/<req_id>", methods=["GET"])
def api_vsp_run_status(req_id: str):
    req_dir = UI_OUT / req_id
    st_path = req_dir / "status.json"
    req_path = req_dir / "request.json"
    log_path = req_dir / "outer.log"
    pid_path = req_dir / "pid.txt"

    req_obj = _safe_read_json(req_path) or {"req_id": req_id}
    st_obj = _safe_read_json(st_path) or {"ok": False, "req_id": req_id, "status": "UNKNOWN", "final": True}

    tail = _tail_text(log_path, max_bytes=9000)

    # If already final, just return tail + status
    if st_obj.get("final"):
        st_obj["tail"] = tail
        return jsonify(st_obj)

    pid = None
    try:
        if pid_path.exists():
            pid = int(pid_path.read_text(encoding="utf-8").strip() or "0")
    except Exception:
        pid = None

    alive = bool(pid and _pid_alive(pid))

    if alive:
        st_obj["tail"] = tail
        st_obj["status"] = "RUNNING"
        st_obj["final"] = False
        _safe_write_json(st_path, st_obj)
        return jsonify(st_obj)

    # Process finished â†’ finalize
    st_obj["finished_at"] = _utc_now_iso()

    # try parse CI_RUN_DIR from log or fallback
    ci_run_dir = _parse_ci_run_dir_from_log(tail) or st_obj.get("ci_run_dir") or _pick_latest_ci_run_dir(req_obj.get("target",""))
    st_obj["ci_run_dir"] = ci_run_dir

    # Determine exit_code best-effort: parse from log
    m = re.search(r'Final RC\s*=\s*([0-9-]+)', tail)
    exit_code = int(m.group(1)) if m else (st_obj.get("exit_code") if st_obj.get("exit_code") is not None else 0)
    st_obj["exit_code"] = exit_code

    # Gate + has_findings from summary if exists
    max_critical = int(req_obj.get("max_critical", 0))
    max_high = int(req_obj.get("max_high", 10))
    if ci_run_dir:
        summary = Path(ci_run_dir) / "report" / "summary_unified.json"
        if summary.exists():
            gate, sev, reasons = _compute_gate_from_summary(summary, max_critical, max_high)
            st_obj["gate"] = gate
            st_obj["severity"] = sev
            st_obj["reasons"] = reasons
            total_findings = sum(int(sev.get(k,0) or 0) for k in ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"])
            st_obj["flag"]["has_findings"] = 1 if total_findings > 0 else 0
        else:
            st_obj["gate"] = "UNKNOWN"
            st_obj["reasons"] = (st_obj.get("reasons") or []) + ["summary_missing"]

    # Auto sync once
    if ci_run_dir and not (st_obj.get("sync") or {}).get("done"):
        sync_res = _sync_ci_to_bundle(ci_run_dir)
        st_obj["sync"] = {"done": True, **sync_res}
        if sync_res.get("vsp_run_id"):
            st_obj["vsp_run_id"] = sync_res["vsp_run_id"]

    # Final status
    # Prefer gate if computed; otherwise use exit_code
    if st_obj.get("gate") == "FAIL" or (st_obj.get("exit_code") not in (0, None)):
        st_obj["status"] = "FAILED"
    else:
        st_obj["status"] = "DONE"

    st_obj["final"] = True
    st_obj["tail"] = tail
    _safe_write_json(st_path, st_obj)
    return jsonify(st_obj)
