#!/usr/bin/env python3
import argparse, json, os, re, signal, subprocess, time
from pathlib import Path
from typing import Dict, Any, Optional, Tuple

STAGE_RE = re.compile(r"\[\s*(\d+)\s*/\s*(\d+)\s*\]\s*([^\]]+?)\s*\]+", re.IGNORECASE)

def _now() -> int:
    return int(time.time())

def _atomic_write_json(p: Path, obj: Dict[str, Any]) -> None:
    p.parent.mkdir(parents=True, exist_ok=True)
    tmp = p.with_suffix(p.suffix + ".tmp")
    tmp.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")
    tmp.replace(p)

def _read_json(p: Path) -> Dict[str, Any]:
    try:
        return json.loads(p.read_text(encoding="utf-8", errors="ignore"))
    except Exception:
        return {}

def _tail_bytes(path: Path, max_bytes: int = 250_000) -> str:
    try:
        if not path.exists():
            return ""
        size = path.stat().st_size
        with path.open("rb") as f:
            if size > max_bytes:
                f.seek(-max_bytes, os.SEEK_END)
            data = f.read()
        return data.decode("utf-8", errors="ignore")
    except Exception:
        return ""

def _parse_last_marker(text: str) -> Tuple[int,int,str]:
    last = None
    for m in STAGE_RE.finditer(text):
        last = m
    if not last:
        return (0, 0, "")
    return (int(last.group(1)), int(last.group(2)), last.group(3).strip())

def _stage_sig(i: int, t: int) -> str:
    seq = i if i > 0 else 0
    return f"{i}/{t}||{seq}"

def _is_alive(pid: int) -> bool:
    try:
        os.kill(pid, 0)
        return True
    except Exception:
        return False

def _guess_ci_run_dir(target: str, start_ts: int) -> Optional[str]:
    roots = []
    if target:
        roots += [
            Path(target) / "out_ci",
            Path(target) / "ci" / "VSP_CI_OUTER" / "out_ci",
            Path(target) / "ci" / "out_ci",
        ]
    roots += [Path.cwd() / "out_ci", Path.cwd().parent / "out_ci"]

    cand = []
    for r in roots:
        if not r.exists():
            continue
        for p in r.glob("VSP_CI_*"):
            try:
                mt = int(p.stat().st_mtime)
            except Exception:
                continue
            if mt >= start_ts - 900:
                cand.append((mt, str(p)))
    if not cand:
        return None
    cand.sort()
    return cand[-1][1]

def _pick_runner_log(ci_run_dir: str) -> Optional[str]:
    d = Path(ci_run_dir)
    if not d.exists():
        return None
    preferred = [
        d / "runner.log",
        d / "run.log",
        d / "vsp_ci.log",
        d / "SUMMARY.txt",
        d / "out.log",
        d / "ci.log",
    ]
    for p in preferred:
        if p.exists():
            return str(p)
    for p in [d / "kics" / "kics.log", d / "codeql" / "codeql.log", d / "semgrep" / "semgrep.log"]:
        if p.exists():
            return str(p)
    return None

def _kill(pid: int) -> None:
    if pid <= 0:
        return
    try:
        os.kill(pid, signal.SIGTERM)
        time.sleep(2)
        os.kill(pid, signal.SIGKILL)
    except Exception:
        pass

def _finalize_sync(ci_run_dir: Optional[str]) -> str:
    if not ci_run_dir:
        return "skip:missing_ci_run_dir"
    sync = Path.cwd().parent / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
    if not sync.exists():
        return "skip:missing_vsp_ci_sync_to_vsp_v1.sh"
    try:
        subprocess.run([str(sync), ci_run_dir], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return "ok"
    except Exception as e:
        return f"err:{e.__class__.__name__}"

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--state", required=True)
    ap.add_argument("--tick", type=int, default=2)
    args = ap.parse_args()

    sp = Path(args.state)
    st = _read_json(sp)
    start_ts = int(st.get("start_ts") or _now())
    stall_timeout = int(st.get("stall_timeout_sec") or 600)
    total_timeout = int(st.get("total_timeout_sec") or 7200)

    while True:
        st = _read_json(sp)
        if not st:
            time.sleep(args.tick)
            continue
        if st.get("final") is True:
            return

        now = _now()
        pid = int(st.get("pid") or 0)
        target = str(st.get("target") or "")
        last_sig = str(st.get("stage_sig") or "0/0||0")
        last_change_ts = int(st.get("last_sig_change_ts") or start_ts)

        if not st.get("ci_run_dir"):
            g = _guess_ci_run_dir(target, start_ts)
            if g:
                st["ci_run_dir"] = g
        if st.get("ci_run_dir") and not st.get("runner_log"):
            rlog = _pick_runner_log(st["ci_run_dir"])
            if rlog:
                st["runner_log"] = rlog

        if st.get("runner_log"):
            txt = _tail_bytes(Path(st["runner_log"]))
            i, t, name = _parse_last_marker(txt)
            sig = _stage_sig(i, t)
            st["stage_index"] = i
            st["stage_total"] = t
            st["stage_name"] = name
            if t > 0:
                st["progress_pct"] = int(((max(i, 1) - 1) / t) * 100)
            st["stage_sig"] = sig
            if sig != last_sig:
                st["last_sig_change_ts"] = now
                last_change_ts = now

        if now - start_ts > total_timeout:
            st["killed"] = True
            st["kill_reason"] = "TOTAL"
        elif now - last_change_ts > stall_timeout:
            st["killed"] = True
            st["kill_reason"] = "STALL"

        if st.get("killed") is True and st.get("final") is not True:
            st["status"] = "KILLED"
            _kill(pid)
            st["finalize_sync"] = _finalize_sync(st.get("ci_run_dir"))
            st["final"] = True
            st["final_ts"] = now
            _atomic_write_json(sp, st)
            return

        if pid > 0 and not _is_alive(pid):
            st["status"] = "FINISHED"
            st["finalize_sync"] = _finalize_sync(st.get("ci_run_dir"))
            st["final"] = True
            st["final_ts"] = now
            _atomic_write_json(sp, st)
            return

        st["status"] = "RUNNING"
        st["last_poll_ts"] = now
        _atomic_write_json(sp, st)
        time.sleep(args.tick)

if __name__ == "__main__":
    main()
