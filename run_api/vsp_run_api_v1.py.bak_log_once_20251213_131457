#!/usr/bin/env python3
# VSP Run API v1 (commercial): stage/progress parser + stall/total timeout + unify+sync
import json, os, re, subprocess, uuid, time, datetime
from pathlib import Path
from flask import Blueprint, request, jsonify

bp = Blueprint("vsp_run_api_v1", __name__)

# In-memory process registry (dev server OK)
PROCS = {}

# Defaults (override via env)
STALL_TIMEOUT_SEC = int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC", "1200"))   # 20m no stage change
TOTAL_TIMEOUT_SEC = int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC", "10800"))  # 3h whole run
TAIL_MAX_LINES    = int(os.environ.get("VSP_UIREQ_TAIL_LINES", "240"))

UI_ROOT = Path(__file__).resolve().parents[1]               # .../SECURITY_BUNDLE/ui
BUNDLE_ROOT = Path(os.environ.get("VSP_BUNDLE_ROOT", str(UI_ROOT.parents[1]))).resolve()  # .../SECURITY_BUNDLE
STATE_DIR = (UI_ROOT / "out_ci" / "uireq_v1")
STATE_DIR.mkdir(parents=True, exist_ok=True)

def now_utc_iso():
  return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

def _safe_read_text(p: Path) -> str:
  try:
    return p.read_text(encoding="utf-8", errors="replace")
  except Exception:
    return ""

def _tail_file(p: Path, n=200) -> str:
  try:
    with p.open("rb") as f:
      f.seek(0, os.SEEK_END)
      size = f.tell()
      # read last ~128KB (enough for logs)
      chunk = 131072
      f.seek(max(0, size - chunk), os.SEEK_SET)
      data = f.read().decode("utf-8", errors="replace")
    lines = data.splitlines()
    return "\n".join(lines[-n:])
  except Exception:
    return ""

def _write_state(req_id: str, st: dict):
  (STATE_DIR / f"{req_id}.json").write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

def _read_state(req_id: str) -> dict:
  p = STATE_DIR / f"{req_id}.json"
  if not p.exists():
    return {}
  try:
    return json.loads(p.read_text(encoding="utf-8", errors="replace"))
  except Exception:
    return {}

def _parse_stage_from_tail(tail: str):
  """
  Detect stage patterns:
    ===== [3/8] KICS (EXT) =====
  """
  m = None
  for line in reversed(tail.splitlines()):
    mm = re.search(r'=\s*\[\s*(\d+)\s*/\s*(\d+)\s*\]\s*([A-Z0-9_\- ]+?)\s*(?:\(|=|$)', line)
    if mm:
      m = mm
      break
  if not m:
    return {"i": 0, "n": 8, "name": "", "progress": 0}
  i = int(m.group(1))
  n = int(m.group(2))
  name = (m.group(3) or "").strip()
  prog = int((i / max(1, n)) * 100)
  return {"i": i, "n": n, "name": name, "progress": prog}

def _parse_run_dir_from_tail(tail: str) -> str:
  # Example: [VSP_CI_OUTER] RUN_DIR    = /home/.../out_ci/VSP_CI_YYYY...
  for line in reversed(tail.splitlines()):
    if "RUN_DIR" in line and "=" in line:
      m = re.search(r'RUN_DIR\s*=\s*(/.+)$', line.strip())
      if m:
        return m.group(1).strip()
  return ""

def _parse_gate_from_tail(tail: str) -> str:
  # Example: [VSP_CI_GATE] GATE RESULT: FAIL
  for line in reversed(tail.splitlines()):
    m = re.search(r'GATE RESULT:\s*(PASS|FAIL)', line)
    if m:
      return m.group(1)
  return "UNKNOWN"

def _read_degraded(run_dir: str):
  out = {"degraded": 0, "reasons": ""}
  if not run_dir:
    return out
  p = Path(run_dir) / "vsp_degraded.env"
  if not p.exists():
    return out
  txt = _safe_read_text(p)
  for line in txt.splitlines():
    line=line.strip()
    if not line or line.startswith("#"): continue
    if line.startswith("degraded="):
      try: out["degraded"] = int(line.split("=",1)[1].strip() or "0")
      except Exception: pass
    if line.startswith("reasons="):
      out["reasons"] = line.split("=",1)[1].strip()
  return out

def _read_severity_from_summary(run_dir: str):
  if not run_dir:
    return {}
  p = Path(run_dir) / "report" / "summary_unified.json"
  if not p.exists():
    return {}
  try:
    j = json.loads(p.read_text(encoding="utf-8", errors="replace"))
    # support both keys
    sev = j.get("summary_by_severity") or j.get("by_severity") or {}
    if isinstance(sev, dict):
      return {k: int(sev.get(k,0) or 0) for k in ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"]}
  except Exception:
    return {}
  return {}

def _kill_proc(req_id: str):
  pr = PROCS.get(req_id)
  if not pr:
    return
  try:
    # kill process group if possible
    os.killpg(os.getpgid(pr.pid), 9)
  except Exception:
    try:
      pr.kill()
    except Exception:
      pass

def _finalize_unify_and_sync(run_dir: str) -> dict:
  """
  Best-effort: ensure report exists, unify if missing, then sync to SECURITY_BUNDLE/out.
  """
  res = {"done": False, "ok": None, "vsp_run_id": "", "msg": ""}
  if not run_dir:
    res["ok"] = False
    res["msg"] = "missing run_dir"
    return res

  runp = Path(run_dir)
  summary = runp / "report" / "summary_unified.json"
  findings = runp / "report" / "findings_unified.json"

  try:
    # unify if missing
    if not summary.exists() or not findings.exists():
      unify_sh = BUNDLE_ROOT / "bin" / "vsp_unify_from_run_dir_v1.sh"
      if unify_sh.exists():
        subprocess.run([str(unify_sh), str(runp)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=900)
  except Exception as e:
    res["msg"] += f"unify_err:{e}; "

  try:
    # sync to bundle/out
    sync_sh = BUNDLE_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
    if sync_sh.exists():
      subprocess.run([str(sync_sh), str(runp)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=180)
  except Exception as e:
    res["msg"] += f"sync_err:{e}; "

  # derive vsp_run_id convention: RUN_<VSP_CI_...>
  base = runp.name.strip()
  if base.startswith("VSP_CI_"):
    cand = BUNDLE_ROOT / "out" / f"RUN_{base}"
    if cand.exists():
      res["vsp_run_id"] = f"RUN_{base}"
    else:
      # try find newest matching prefix
      outdir = (BUNDLE_ROOT / "out")
      if outdir.exists():
        matches = sorted([d for d in outdir.iterdir() if d.is_dir() and d.name.startswith(f"RUN_{base}")],
                         key=lambda x: x.stat().st_mtime, reverse=True)
        if matches:
          res["vsp_run_id"] = matches[0].name

  res["done"] = True
  res["ok"] = True
  return res

@bp.route("/api/vsp/run_v1", methods=["POST"])
def run_v1():
  data = request.get_json(silent=True) or {}
  mode = (data.get("mode") or "local").strip()
  profile = (data.get("profile") or "FULL_EXT").strip()
  target_type = (data.get("target_type") or "path").strip()
  target = (data.get("target") or "").strip()

  if target_type != "path" or not target:
    return jsonify({"ok": False, "error": "target_type=path and target required"}), 400

  ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
  req_id = f"UIREQ_{ts}_{uuid.uuid4().hex[:6]}"

  log_file = STATE_DIR / f"{req_id}.log"
  created = now_utc_iso()

  # spawn CI OUTER in target repo
  target_path = Path(target).resolve()
  outer = target_path / "ci" / "VSP_CI_OUTER" / "vsp_ci_outer_full_v1.sh"
  if not outer.exists():
    # fallback: still allow, but will fail and be visible in tail
    outer = target_path / "ci" / "VSP_CI_OUTER" / "vsp_ci_gate_core_v1.sh"

  env = os.environ.copy()
  env["VSP_BUNDLE_ROOT"] = str(BUNDLE_ROOT)
  env["BUNDLE_ROOT"] = str(BUNDLE_ROOT)
  env["PROFILE"] = profile
  env["VSP_PROFILE"] = profile
  env["VSP_UIREQ_ID"] = req_id

  # state
  st = {
    "ok": True,
    "req_id": req_id,
    "created_at": created,
    "started_at": created,
    "finished_at": None,
    "status": "RUNNING",
    "final": False,
    "exit_code": None,
    "gate": "UNKNOWN",
    "stage": {"i":0,"n":8,"name":"","progress":0},
    "ci_run_dir": "",
    "vsp_run_id": "",
    "flag": {"has_findings": None},
    "degraded": 0,
    "degraded_reasons": "",
    "sync": {"done": False, "ok": None, "msg": ""},
    "meta": {"mode": mode, "profile": profile, "target": str(target_path), "outer": str(outer)},
    "watch": {"last_stage_sig": "", "last_stage_at": time.time(), "start_ts": time.time()},
    "log_file": str(log_file),
    "tail": ""
  }
  _write_state(req_id, st)

  # spawn
  try:
    f = open(log_file, "ab", buffering=0)
    p = subprocess.Popen(
      [str(outer)],
      cwd=str(target_path),
      env=env,
      stdout=f,
      stderr=subprocess.STDOUT,
      start_new_session=True
    )
    PROCS[req_id] = p
  except Exception as e:
    st["status"] = "ERROR"
    st["final"] = True
    st["exit_code"] = 2
    st["sync"]["ok"] = False
    st["sync"]["msg"] = f"spawn_err:{e}"
    _write_state(req_id, st)
    return jsonify(st), 500

  return jsonify({"ok": True, "req_id": req_id, "status_url": f"/api/vsp/run_status_v1/{req_id}"}), 200

# === VSP_FORCE_JSON_STATUS_AST_V3 (auto) ===
@bp.route("/api/vsp/run_status_v1/<req_id>", methods=["GET"])
def run_status_v1(req_id):
  # commercial: ALWAYS JSON
  from flask import jsonify
  import json, re, time
  from pathlib import Path
  req_id = req_id
  ui_root = Path(__file__).resolve().parents[1]  # .../ui
  st_dir = ui_root / "out_ci" / "uireq_v1"
  st_path = st_dir / f"{req_id}.json"
  if not st_path.exists():
    return jsonify({"ok": False, "req_id": req_id, "status": "NOT_FOUND", "final": True, "error": "REQ_ID_NOT_FOUND"}), 200  # VSP_RUN_STATUS_NOTFOUND_JSON200_V1
  try:
    st = json.loads(st_path.read_text(encoding="utf-8", errors="ignore") or "{}")
  except Exception:
    st = {}
  st["ok"] = True
  st["req_id"] = req_id

  # tail from log_file
  log_file = st.get("log_file") or str(st_dir / f"{req_id}.log")
  st["log_file"] = log_file
  lf = Path(log_file)
  tail = ""
  if lf.exists():
    try:
      arr = lf.read_text(encoding="utf-8", errors="ignore").splitlines()
      tail = "\n".join(arr[-250:])
    except Exception:
      tail = ""
  st["tail"] = tail

  # fill ci_run_dir from log if empty: RUN_DIR    = ...
  if not st.get("ci_run_dir"):
    m = re.search(r"^\[VSP_CI_OUTER\]\s*RUN_DIR\s*=\s*(.+)$", tail, flags=re.M)
    if m:
      st["ci_run_dir"] = m.group(1).strip()

  # stage/progress from tool banner: ===== [i/8] NAME =====
  stage = st.get("stage") or {"i":0,"n":8,"name":"","progress":0}
  st_re = re.compile(r"^=+\s*\[(\d+)\s*/\s*(\d+)\]\s*(.*?)\s*=+$")
  last = None
  for line in (tail or "").splitlines():
    mm = st_re.match(line.strip())
    if mm:
      last = (int(mm.group(1)), int(mm.group(2)), (mm.group(3) or "").strip())
  if last:
    i, n, name = last
    stage["i"] = i
    stage["n"] = n
    stage["name"] = name
    stage["progress"] = int(round((i/n)*100)) if n else 0
  st["stage"] = stage
  st["stage_index"] = int(stage.get("i",0) or 0)
  st["stage_total"] = int(stage.get("n",0) or 0)
  st["stage_name"] = str(stage.get("name","") or "")
  st["progress_pct"] = int(stage.get("progress",0) or 0)

  # mark final if outer ended (success/fail) based on log keywords
  if "=== VSP CI OUTER:" in tail:
    if "THẤT BẠI" in tail:
      st["status"] = "FAIL"
      st["final"] = True
    if "THÀNH CÔNG" in tail:
      st["status"] = "DONE"
      st["final"] = True

  # persist
  
  # commercial finalize: unify + sync once when final
  try:
    if bool(st.get("final")) and st.get("ci_run_dir"):
      sync = st.get("sync") or {"done": False, "ok": None, "msg": ""}
      if not bool(sync.get("done")):
        ok, msg = _vsp_finalize_unify_sync(st["ci_run_dir"])
        sync["done"] = True
        sync["ok"] = bool(ok)
        sync["msg"] = msg
      st["sync"] = sync

      d, reasons = _vsp_read_degraded_env(st["ci_run_dir"])
      st["degraded"] = int(d)
      st["degraded_reasons"] = reasons
      if d and st.get("status","").upper() in ("DONE","OK","SUCCESS"):
        st["status"] = "DEGRADED"
  except Exception as _e:
    # do not break status endpoint
    st["sync"] = st.get("sync") or {"done": False, "ok": None, "msg": ""}
    st["sync"]["msg"] = (st["sync"].get("msg","") + "\n" + str(_e)).strip()

  # === VSP_WATCHDOG_FINALIZE_SAFE_V6 ===

  try:

    import os, time, signal, subprocess

    now = time.time()

    st.setdefault("watch", {})

    watch = st.get("watch") or {}

    st["watch"] = watch

    # stage signature

    sig = f"{st.get('stage_index',0)}/{st.get('stage_total',0)}:{st.get('stage_name','')}"

    if sig and sig != watch.get("last_stage_sig",""):

      watch["last_stage_sig"] = sig

      watch["last_stage_at"] = now

    watch.setdefault("start_ts", now)

    watch.setdefault("last_stage_at", watch.get("start_ts", now))

    # timeouts

    stall = int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC", "600"))

    total = int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC", "7200"))

    start_ts = float(watch.get("start_ts") or now)

    last_stage_at = float(watch.get("last_stage_at") or start_ts)

    status_u = str(st.get("status","")).upper()

    # watchdog: if running and not final

    if status_u == "RUNNING" and not bool(st.get("final")):

      if total > 0 and (now - start_ts) > total:

        st["status"] = "TIMEOUT"

        st["final"] = True

      elif stall > 0 and (now - last_stage_at) > stall:

        st["status"] = "STALLED"

        st["final"] = True

      # best-effort kill when final triggered

      if bool(st.get("final")):

        pid = int(st.get("pid", 0) or 0)

        # if no pid stored, try find by ci_run_dir in process cmdline

        if pid == 0 and st.get("ci_run_dir"):

          try:

            r = subprocess.run(["pgrep","-f", str(st["ci_run_dir"])], capture_output=True, text=True)

            out = (r.stdout or "").strip().splitlines()

            if out:

              pid = int(out[0].strip())

          except Exception:

            pid = 0

        if pid:

          try:

            os.killpg(pid, signal.SIGTERM)

            st["killed"] = True

            st["kill_reason"] = "SIGTERM(pgid)"

          except Exception:

            try:

              os.kill(pid, signal.SIGTERM)

              st["killed"] = True

              st["kill_reason"] = "SIGTERM(pid)"

            except Exception as e:

              st["killed"] = False

              st["kill_reason"] = f"kill_failed:{e}"

    # finalize unify+sync once when final

    if bool(st.get("final")) and st.get("ci_run_dir"):

      sync = st.get("sync") or {"done": False, "ok": None, "msg": ""}

      if not bool(sync.get("done")):

        bundle_root = Path(__file__).resolve().parents[2]

        unify = bundle_root / "bin" / "vsp_unify_from_run_dir_v1.sh"

        syncsh = bundle_root / "bin" / "vsp_ci_sync_to_vsp_v1.sh"

        logs = []

        ok = True

        if unify.exists():

          rr = subprocess.run(['bash', str(unify), str(st['ci_run_dir'])], capture_output=True, text=True)

          logs.append(f"[UNIFY rc={rr.returncode}]")

          if rr.returncode != 0:

            ok = False

            logs.append((rr.stdout or "")[-2000:])

            logs.append((rr.stderr or "")[-2000:])

        else:

          ok = False

          logs.append("[UNIFY missing]")

        if syncsh.exists():

          rr2 = subprocess.run(['bash', str(syncsh), str(st['ci_run_dir'])], capture_output=True, text=True)

          logs.append(f"[SYNC rc={rr2.returncode}]")

          if rr2.returncode != 0:

            ok = False

            logs.append((rr2.stdout or "")[-2000:])

            logs.append((rr2.stderr or "")[-2000:])

        else:

          ok = False

          logs.append("[SYNC missing]")

        sync["done"] = True

        sync["ok"] = bool(ok)

        sync["msg"] = "\n".join([x for x in logs if x])

      st["sync"] = sync

      # degraded env (optional)

      try:

        f = Path(st["ci_run_dir"]) / "vsp_degraded.env"

        if not f.exists():

          f = Path(st["ci_run_dir"]) / "out" / "vsp_degraded.env"

        if f.exists():

          degraded = 0

          reasons = ""

          for line in f.read_text(encoding="utf-8", errors="ignore").splitlines():

            if line.startswith("degraded="):

              try: degraded = int(line.split("=",1)[1].strip() or "0")

              except: degraded = 0

            if line.startswith("degraded_reasons="):

              reasons = line.split("=",1)[1].strip()

          st["degraded"] = int(degraded)

          st["degraded_reasons"] = reasons

      except Exception:

        pass

  except Exception as _e:

    st.setdefault("sync", {"done": False, "ok": None, "msg": ""})

    st["sync"]["msg"] = (st["sync"].get("msg","") + "\n" + str(_e)).strip()

  # === END VSP_WATCHDOG_FINALIZE_SAFE_V6 ===


  st_path.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
  return jsonify(st)
# === END VSP_FORCE_JSON_STATUS_AST_V3 ===

print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")


# === VSP_COMMERCIAL_BP_EXPORT_ALIAS_V1 ===
# Backward-compatible export name expected by UI gateway:
bp_vsp_run_api_v1 = bp
# Optional: keep old name too (some code may import bp_vsp_run_api)
try:
    bp_vsp_run_api
except NameError:
    bp_vsp_run_api = bp
# === END VSP_COMMERCIAL_BP_EXPORT_ALIAS_V1 ===


# === VSP_COMMERCIAL_RUNAPI_V2 (do not edit manually) ===
import os, re, json, time, signal, subprocess
from pathlib import Path

_VSP_STAGE_RE = re.compile(r"^=+\s*\[(\d+)\s*/\s*(\d+)\]\s*(.*?)\s*=+$")

def _vsp_root_dir_v1():
    cur = Path(__file__).resolve()
    for _ in range(0, 12):
        if (cur / "bin").is_dir():
            return cur
        cur = cur.parent
    return Path.cwd()

_VSP_ROOT = _vsp_root_dir_v1()
_VSP_UIREQ_DIR = _VSP_ROOT / "ui" / "out_ci" / "uireq_v1"
_VSP_UIREQ_DIR.mkdir(parents=True, exist_ok=True)

def _uireq_state_path(req_id: str) -> Path:
    return _VSP_UIREQ_DIR / f"{req_id}.json"

def _load_uireq(req_id: str) -> dict:
    f = _uireq_state_path(req_id)
    if not f.exists():
        return {}
    try:
        return json.loads(f.read_text(encoding="utf-8"))
    except Exception:
        return {}

def _save_uireq(req_id: str, st: dict) -> None:
    f = _uireq_state_path(req_id)
    st = dict(st or {})
    st["req_id"] = req_id
    st["saved_at"] = time.time()
    f.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

def vsp_commercial_state_register(req_id, ci_run_dir, pid, log_path=None):
    if not req_id or not ci_run_dir or not pid:
        return
    st = _load_uireq(req_id)
    st.setdefault("started_at", time.time())
    st["pid"] = int(pid)
    st["ci_run_dir"] = str(ci_run_dir)
    if log_path:
        st["log_path"] = str(log_path)
    st.setdefault("last_stage", "")
    st.setdefault("last_stage_ts", time.time())
    st.setdefault("stall_timeout_sec", int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC", "600")))
    st.setdefault("total_timeout_sec", int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC", "7200")))
    st.setdefault("final", False)
    st.setdefault("finalized", False)
    _save_uireq(req_id, st)

def _extract_stage_from_tail(tail_text: str):
    if not tail_text:
        return None
    last = None
    for line in tail_text.splitlines():
        m = _VSP_STAGE_RE.match(line.strip())
        if m:
            last = (int(m.group(1)), int(m.group(2)), (m.group(3) or "").strip())
    return last

def _read_degraded(ci_run_dir: Path):
    candidates = [ci_run_dir / "vsp_degraded.env", ci_run_dir / "out" / "vsp_degraded.env"]
    for f in candidates:
        if f.exists():
            degraded = 0
            reasons = ""
            for line in f.read_text(encoding="utf-8", errors="ignore").splitlines():
                if line.startswith("degraded="):
                    try: degraded = int(line.split("=",1)[1].strip() or "0")
                    except: degraded = 0
                if line.startswith("degraded_reasons="):
                    reasons = line.split("=",1)[1].strip()
            return degraded, reasons, str(f)
    return 0, "", ""

def _kill_pid_group(pid: int):
    try:
        os.killpg(pid, signal.SIGTERM)
        return True, "SIGTERM(pgid)"
    except Exception:
        try:
            os.kill(pid, signal.SIGTERM)
            return True, "SIGTERM(pid)"
        except Exception as e:
            return False, f"kill_failed:{e}"

def _maybe_finalize(ci_run_dir: Path, st: dict):
    if not ci_run_dir or not ci_run_dir.exists():
        return False, "missing_ci_run_dir"
    if st.get("finalized"):
        return True, "already_finalized"

    unify = _VSP_ROOT / "bin" / "vsp_unify_from_run_dir_v1.sh"
    sync  = _VSP_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"

    ok = True
    logs = []

    if unify.exists():
        r = subprocess.run([str(unify), str(ci_run_dir)], capture_output=True, text=True)
        logs.append(f"[UNIFY rc={r.returncode}]")
        if r.returncode != 0:
            ok = False
            logs.append((r.stdout or "")[-3000:])
            logs.append((r.stderr or "")[-3000:])
    else:
        ok = False
        logs.append("[UNIFY missing]")

    if sync.exists():
        r2 = subprocess.run(['bash', str(sync), str(ci_run_dir)], capture_output=True, text=True)
        logs.append(f"[SYNC rc={r2.returncode}]")
        if r2.returncode != 0:
            ok = False
            logs.append((r2.stdout or "")[-3000:])
            logs.append((r2.stderr or "")[-3000:])
    else:
        ok = False
        logs.append("[SYNC missing]")

    st["finalized"] = True
    st["finalize_ok"] = bool(ok)
    st["finalize_log_tail"] = "\n".join([x for x in logs if x])
    return ok, "finalized"

def vsp_commercial_enhance_status_payload(req_id: str, payload: dict):
    payload = dict(payload or {})
    st = _load_uireq(req_id)

    tail = payload.get("tail") or payload.get("log_tail") or ""
    stage = _extract_stage_from_tail(tail)
    if stage:
        i, total, name = stage
        payload["stage_index"] = i
        payload["stage_total"] = total
        payload["stage_name"] = name
        payload["progress_pct"] = int(round((i / total) * 100)) if total else 0
        if st.get("last_stage") != f"{i}/{total}:{name}":
            st["last_stage"] = f"{i}/{total}:{name}"
            st["last_stage_ts"] = time.time()

    started_at = float(st.get("started_at") or time.time())
    last_stage_ts = float(st.get("last_stage_ts") or started_at)
    stall_timeout = int(st.get("stall_timeout_sec") or int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC","600")))
    total_timeout = int(st.get("total_timeout_sec") or int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC","7200")))

    payload["started_at"] = started_at
    payload["stall_timeout_sec"] = stall_timeout
    payload["total_timeout_sec"] = total_timeout

    status = (payload.get("status") or "").upper()
    now = time.time()
    pid = st.get("pid")
    ci_run_dir = Path(st["ci_run_dir"]) if st.get("ci_run_dir") else None

    if status == "RUNNING" and not st.get("final"):
        if total_timeout > 0 and (now - started_at) > total_timeout:
            st["final"] = True
            payload["status"] = "TIMEOUT"
            payload["final"] = True
            if pid:
                ok, how = _kill_pid_group(int(pid))
                payload["killed"] = ok
                payload["kill_reason"] = how
        elif stall_timeout > 0 and (now - last_stage_ts) > stall_timeout:
            st["final"] = True
            payload["status"] = "STALLED"
            payload["final"] = True
            if pid:
                ok, how = _kill_pid_group(int(pid))
                payload["killed"] = ok
                payload["kill_reason"] = how

    if payload.get("final") is True:
        st["final"] = True

    if ci_run_dir and ci_run_dir.exists():
        degraded, reasons, src = _read_degraded(ci_run_dir)
        payload["degraded"] = int(degraded)
        payload["degraded_reasons"] = reasons
        payload["degraded_src"] = src
        if degraded and payload.get("status","").upper() in ("DONE","OK","SUCCESS"):
            payload["status"] = "DEGRADED"

    if st.get("final") and ci_run_dir:
        ok, _ = _maybe_finalize(ci_run_dir, st)
        payload["finalize_ok"] = bool(ok)
        payload["sync_done"] = True if ok else payload.get("sync_done", False)

    _save_uireq(req_id, st)
    return payload

# === END VSP_COMMERCIAL_RUNAPI_V2 ===

# === VSP_FINALIZE_UNIFY_SYNC_V4 ===
def _vsp_read_degraded_env(ci_run_dir: str):
  try:
    from pathlib import Path
    f = Path(ci_run_dir) / "vsp_degraded.env"
    if not f.exists():
      f = Path(ci_run_dir) / "out" / "vsp_degraded.env"
    if not f.exists():
      return 0, ""
    degraded = 0
    reasons = ""
    for line in f.read_text(encoding="utf-8", errors="ignore").splitlines():
      if line.startswith("degraded="):
        try: degraded = int(line.split("=",1)[1].strip() or "0")
        except: degraded = 0
      if line.startswith("degraded_reasons="):
        reasons = line.split("=",1)[1].strip()
    return degraded, reasons
  except Exception:
    return 0, ""

def _vsp_finalize_unify_sync(ci_run_dir: str):
  import subprocess
  from pathlib import Path
  bundle_root = Path(__file__).resolve().parents[2]  # .../SECURITY_BUNDLE
  unify = bundle_root / "bin" / "vsp_unify_from_run_dir_v1.sh"
  sync  = bundle_root / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
  logs = []
  ok = True
  if unify.exists():
    r = subprocess.run([str(unify), str(ci_run_dir)], capture_output=True, text=True)
    logs.append(f"[UNIFY rc={r.returncode}]")
    if r.returncode != 0:
      ok = False
      logs.append((r.stdout or "")[-2000:])
      logs.append((r.stderr or "")[-2000:])
  else:
    ok = False
    logs.append("[UNIFY missing]")
  if sync.exists():
    r2 = subprocess.run(['bash', str(sync), str(ci_run_dir)], capture_output=True, text=True)
    logs.append(f"[SYNC rc={r2.returncode}]")
    if r2.returncode != 0:
      ok = False
      logs.append((r2.stdout or "")[-2000:])
      logs.append((r2.stderr or "")[-2000:])
  else:
    ok = False
    logs.append("[SYNC missing]")
  return ok, "\n".join([x for x in logs if x])
# === END VSP_FINALIZE_UNIFY_SYNC_V4 ===

