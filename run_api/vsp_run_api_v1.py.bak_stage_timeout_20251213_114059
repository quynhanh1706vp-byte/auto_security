#!/usr/bin/env python3
import json, os, re, subprocess, uuid
from datetime import datetime, timezone
from pathlib import Path
from flask import Blueprint, jsonify, request

bp_vsp_run_api_v1 = Blueprint("vsp_run_api_v1", __name__)

UI_ROOT = Path(__file__).resolve().parents[1]                 # .../SECURITY_BUNDLE/ui
BUNDLE_ROOT = Path(os.environ.get("VSP_BUNDLE_ROOT", str(UI_ROOT.parent)))  # .../SECURITY_BUNDLE
REQ_ROOT = UI_ROOT / "out_ci" / "req"
REQ_ROOT.mkdir(parents=True, exist_ok=True)

def _utc():
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")

def _write_json(p: Path, obj: dict):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")

def _read_json(p: Path):
    if not p.exists():
        return None
    try:
        return json.loads(p.read_text(encoding="utf-8", errors="replace"))
    except Exception:
        return None

def _tail(p: Path, nbytes=12000) -> str:
    if not p.exists():
        return ""
    b = p.read_bytes()
    return b[-nbytes:].decode("utf-8", errors="replace")

def _parse_run_dir(t: str) -> str:
    # We expect this exact line early in outer
    # [VSP_CI_OUTER] RUN_DIR    = /.../out_ci/VSP_CI_YYYYmmdd_HHMMSS
    pats = [
        r'\[VSP_CI_OUTER\]\s*RUN_DIR\s*=\s*(/[^ \n]+/out_ci/VSP_CI_[0-9_]+)',
        r'RUN_DIR\s*=\s*(/[^ \n]+/out_ci/VSP_CI_[0-9_]+)',
        r'Latest\s+RUN_DIR\s*=\s*(/[^ \n]+/out_ci/VSP_CI_[0-9_]+)',
    ]
    for pat in pats:
        m = re.search(pat, t)
        if m:
            return m.group(1)
    return ""

def _parse_gate(t: str) -> str:
    # Typical line:
    # [VSP_CI_GATE] GATE RESULT: FAIL ...
    m = re.search(r'\bGATE RESULT:\s*(PASS|FAIL)\b', t)
    if m:
        return m.group(1)
    return "UNKNOWN"

def _parse_final_marker(t: str):
    # Outer prints one of:
    # === VSP CI OUTER: THÀNH CÔNG (RC=0) ===
    # === VSP CI OUTER: THẤT BẠI (RC=1) ===
    if "=== VSP CI OUTER:" in t:
        if "THÀNH CÔNG" in t:
            return True, 0
        if "THẤT BẠI" in t:
            return True, 1
    return False, None

def _load_summary(run_dir: str):
    p = Path(run_dir) / "report" / "summary_unified.json"
    j = _read_json(p)
    if not isinstance(j, dict):
        return {}, 0
    sev = j.get("summary_by_severity") or j.get("by_severity") or {}
    if not isinstance(sev, dict):
        sev = {}
    total = 0
    for k, v in sev.items():
        try:
            total += int(v)
        except Exception:
            pass
    return sev, total

def _sync_to_bundle(run_dir: str):
    sync = BUNDLE_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
    if not sync.exists():
        return {"done": True, "ok": False, "error": f"sync not found: {sync}"}

    cp = subprocess.run(["bash", str(sync), run_dir], capture_output=True, text=True)
    out = (cp.stdout or "") + "\n" + (cp.stderr or "")
    vsp_run_id = ""
    m = re.search(r'VSP_RUN_DIR\s*=\s*(\S+)', out)
    if m:
        vsp_run_id = Path(m.group(1)).name

    return {
        "done": True,
        "ok": (cp.returncode == 0),
        "rc": cp.returncode,
        "vsp_run_id": vsp_run_id,
        "stdout": (cp.stdout or "")[-2000:],
        "stderr": (cp.stderr or "")[-2000:],
    }

@bp_vsp_run_api_v1.route("/api/vsp/run_v1", methods=["POST"])
def run_v1():
    body = request.get_json(silent=True) or {}

    target = (body.get("target") or os.environ.get("VSP_DEFAULT_TARGET") or "/home/test/Data/SECURITY-10-10-v4").strip()
    profile = (body.get("profile") or "FULL_EXT").strip()

    outer_root = os.environ.get("VSP_OUTER_ROOT", "/home/test/Data/SECURITY-10-10-v4/ci/VSP_CI_OUTER")
    outer_script = os.environ.get("VSP_OUTER_SCRIPT", str(Path(outer_root) / "vsp_ci_outer_full_v1.sh"))

    req_id = f"UIREQ_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:6]}"
    req_dir = REQ_ROOT / req_id
    req_dir.mkdir(parents=True, exist_ok=True)

    logp = req_dir / "outer.log"
    stp  = req_dir / "status.json"

    st = {
        "ok": True,
        "req_id": req_id,
        "status": "RUNNING",
        "final": False,
        "gate": "UNKNOWN",
        "created_at": _utc(),
        "started_at": _utc(),
        "finished_at": None,
        "exit_code": None,
        "ci_run_dir": "",
        "vsp_run_id": "",
        "severity": {},
        "flag": {"has_findings": None},
        "reasons": [],
        "sync": {"done": False, "ok": None},
        "meta": {"target": target, "profile": profile, "outer_root": outer_root, "outer_script": outer_script},
        "pid": None,
    }
    _write_json(stp, st)

    env = os.environ.copy()
    env["SRC"] = target
    env["PROFILE"] = profile

    # spawn outer; redirect stdout+stderr into log
    with logp.open("w", encoding="utf-8", errors="replace") as lf:
        p = subprocess.Popen(["bash", str(outer_script)], cwd=str(Path(outer_root)), env=env, stdout=lf, stderr=subprocess.STDOUT)
        st["pid"] = p.pid
        _write_json(stp, st)

    return jsonify({"ok": True, "implemented": True, "req_id": req_id, "profile": profile, "target": target})

@bp_vsp_run_api_v1.route("/api/vsp/run_status_v1/<req_id>", methods=["GET"])
def run_status_v1(req_id: str):
    req_dir = REQ_ROOT / req_id
    stp = req_dir / "status.json"
    logp = req_dir / "outer.log"

    st = _read_json(stp) or {"ok": False, "req_id": req_id, "status": "NOT_FOUND", "final": True}
    tail = _tail(logp)

    if st.get("status") == "NOT_FOUND":
        st["tail"] = tail
        return jsonify(st)

    # enrich run_dir early
    if not st.get("ci_run_dir"):
        rd = _parse_run_dir(tail)
        if rd:
            st["ci_run_dir"] = rd

    # finalize when outer prints final marker
    if not st.get("final"):
        is_final, rc = _parse_final_marker(tail)
        if is_final:
            st["final"] = True
            st["finished_at"] = _utc()
            st["exit_code"] = rc
            st["gate"] = _parse_gate(tail)

            # read severity from unified summary if exists
            if st.get("ci_run_dir"):
                sev, total = _load_summary(st["ci_run_dir"])
                st["severity"] = sev
                st["flag"]["has_findings"] = (total > 0)

                # sync into bundle (only once)
                if not (st.get("sync") or {}).get("done"):
                    st["sync"] = _sync_to_bundle(st["ci_run_dir"])
                    st["vsp_run_id"] = st["sync"].get("vsp_run_id","")

            st["status"] = "DONE" if rc == 0 else "FAILED"
            _write_json(stp, st)

    st["tail"] = tail
    return jsonify(st)
