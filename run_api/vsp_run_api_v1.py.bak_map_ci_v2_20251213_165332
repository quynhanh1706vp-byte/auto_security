#!/usr/bin/env python3
# VSP Run API v1 (commercial): stage/progress parser + stall/total timeout + unify+sync
import json, os, re, subprocess, uuid, time, datetime
from pathlib import Path
from flask import Blueprint, request, jsonify

# === VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 ===
def _vsp_write_uireq_state_v1(req_id: str, req_payload: dict):
  try:
    from pathlib import Path
    import json, time, os
    d = None
    try:
      d = globals().get("_VSP_UIREQ_DIR", None)

      # === VSP_BOOTSTRAP_ON_REQID_CREATION_V1 ===
      try:
        from pathlib import Path
        import json, time, os
        _rid = str(d)
        # write to the SAME dir that run_status reads
        _d = None
        try:
          _d = globals().get("_VSP_UIREQ_DIR", None)
        except Exception:
          _d = None
        st_dir = Path(_d) if _d else (Path(__file__).resolve().parents[1] / "ui" / "out_ci" / "uireq_v1")
        st_dir.mkdir(parents=True, exist_ok=True)
        st_path = st_dir / (str(_rid) + ".json")
        if not st_path.is_file():
          st = {
            "request_id": _rid,
            "synthetic_req_id": True,
            "ci_run_dir": "",
            "runner_log": "",
            "ci_root_from_pid": None,
            "watchdog_pid": 0,
            "stage_sig": "0/0||0",
            "progress_pct": 0,
            "killed": False,
            "kill_reason": "",
            "final": False,
            "stall_timeout_sec": int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")),
            "total_timeout_sec": int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")),
            "state_bootstrap_ts": int(time.time()),
          }
          st_path.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
          print("[VSP_BOOTSTRAP_ON_REQID_CREATION_V1] wrote", st_path)
      except Exception as e:
        try:
          print("[VSP_BOOTSTRAP_ON_REQID_CREATION_V1] FAILED:", e)
        except Exception:
          pass
      # === END VSP_BOOTSTRAP_ON_REQID_CREATION_V1 ===

    except Exception:
      d = None
    if d:
      st_dir = Path(d)
    else:
      # fallback if _VSP_UIREQ_DIR missing (best effort)
      st_dir = Path(__file__).resolve().parents[1] / "ui" / "out_ci" / "uireq_v1"
    st_dir.mkdir(parents=True, exist_ok=True)
    st = st_dir / (str(req_id) + ".json")

    state0 = {}
    if st.is_file():
      try:
        state0 = json.loads(st.read_text(encoding="utf-8", errors="ignore") or "{}")
        if not isinstance(state0, dict):
          state0 = {}
      except Exception:
        state0 = {}

    state0.setdefault("request_id", str(req_id))
    state0.setdefault("synthetic_req_id", True)
    for k in ("mode","profile","target_type","target"):
      if (not state0.get(k)) and (req_payload.get(k) is not None):
        state0[k] = req_payload.get(k) or ""

    state0.setdefault("ci_run_dir", "")
    state0.setdefault("runner_log", "")
    state0.setdefault("ci_root_from_pid", None)
    state0.setdefault("watchdog_pid", 0)
    state0.setdefault("stage_sig", "0/0||0")
    state0.setdefault("progress_pct", 0)
    state0.setdefault("killed", False)
    state0.setdefault("kill_reason", "")
    state0.setdefault("final", False)

    state0.setdefault("stall_timeout_sec", int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")))
    state0.setdefault("total_timeout_sec", int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")))
    state0["state_bootstrap_ts"] = int(time.time())

    st.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"[VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1] wrote {st}")
  except Exception as e:
    try:
      print(f"[VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1] FAILED:", e)
    except Exception:
      pass
# === END VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 ===


# === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS ===
def _vsp_bootstrap_statefile_v6(req_id: str, req_payload: dict):
    try:
        from pathlib import Path
        import json, time, os

        # IMPORTANT: write to the SAME dir that run_status_v1 reads from (_VSP_UIREQ_DIR) if present
        st_dir = None
        try:
            st_dir = globals().get("_VSP_UIREQ_DIR", None)
        except Exception:
            st_dir = None

        if st_dir:
            st_dir = Path(st_dir)
        else:
            ui_root = Path(__file__).resolve().parents[1]   # .../SECURITY_BUNDLE/ui
            st_dir = ui_root / "out_ci" / "ui_req_state"

        st_dir.mkdir(parents=True, exist_ok=True)
        st_path = st_dir / (str(req_id) + ".json")

        state0 = {}
        if st_path.is_file():
            try:
                state0 = json.loads(st_path.read_text(encoding="utf-8", errors="ignore") or "{}")
                if not isinstance(state0, dict):
                    state0 = {}
            except Exception:
                state0 = {}

        state0.setdefault("request_id", str(req_id))
        state0.setdefault("synthetic_req_id", True)

        for k in ("mode","profile","target_type","target"):
            if (not state0.get(k)) and (req_payload.get(k) is not None):
                state0[k] = req_payload.get(k) or ""

        state0.setdefault("ci_run_dir", "")
        state0.setdefault("runner_log", "")
        state0.setdefault("ci_root_from_pid", None)
        state0.setdefault("watchdog_pid", 0)
        state0.setdefault("stage_sig", "0/0||0")
        state0.setdefault("progress_pct", 0)
        state0.setdefault("killed", False)
        state0.setdefault("kill_reason", "")
        state0.setdefault("final", False)

        state0.setdefault("stall_timeout_sec", int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")))
        state0.setdefault("total_timeout_sec", int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")))

        state0["state_bootstrap_ts"] = int(time.time())

        rp = state0.get("req_payload")
        if not isinstance(rp, dict):
            rp = {}
        for k in ("mode","profile","target_type","target"):
            if k in req_payload:
                rp[k] = req_payload.get(k)
        state0["req_payload"] = rp

        st_path.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
        print(f"[BOOTSTRAP_V7] wrote state: {st_path}")
    except Exception as e:
        try:
            print("[BOOTSTRAP_V7] FAILED:", e)
        except Exception:
            pass
        return
# === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS ===
bp = Blueprint("vsp_run_api_v1", __name__)

# In-memory process registry (dev server OK)
PROCS = {}

# Defaults (override via env)
STALL_TIMEOUT_SEC = int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC", "1200"))   # 20m no stage change
TOTAL_TIMEOUT_SEC = int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC", "10800"))  # 3h whole run
TAIL_MAX_LINES    = int(os.environ.get("VSP_UIREQ_TAIL_LINES", "240"))

UI_ROOT = Path(__file__).resolve().parents[1]               # .../SECURITY_BUNDLE/ui
BUNDLE_ROOT = Path(os.environ.get("VSP_BUNDLE_ROOT", str(UI_ROOT.parents[1]))).resolve()  # .../SECURITY_BUNDLE
STATE_DIR = (UI_ROOT / "out_ci" / "uireq_v1")
STATE_DIR.mkdir(parents=True, exist_ok=True)

def now_utc_iso():
  return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

def _safe_read_text(p: Path) -> str:
  try:
    return p.read_text(encoding="utf-8", errors="replace")
  except Exception:
    return ""

def _tail_file(p: Path, n=200) -> str:
  try:
    with p.open("rb") as f:
      f.seek(0, os.SEEK_END)
      size = f.tell()
      # read last ~128KB (enough for logs)
      chunk = 131072
      f.seek(max(0, size - chunk), os.SEEK_SET)
      data = f.read().decode("utf-8", errors="replace")
    lines = data.splitlines()
    return "\n".join(lines[-n:])
  except Exception:
    return ""

def _write_state(req_id: str, st: dict):
  (STATE_DIR / f"{req_id}.json").write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

def _read_state(req_id: str) -> dict:
  p = STATE_DIR / f"{req_id}.json"
  if not p.exists():
    return {}
  try:
    return json.loads(p.read_text(encoding="utf-8", errors="replace"))
  except Exception:
    return {}

def _parse_stage_from_tail(tail: str):
  """
  Detect stage patterns:
    ===== [3/8] KICS (EXT) =====
  """
  m = None
  for line in reversed(tail.splitlines()):
    mm = re.search(r'=\s*\[\s*(\d+)\s*/\s*(\d+)\s*\]\s*([A-Z0-9_\- ]+?)\s*(?:\(|=|$)', line)
    if mm:
      m = mm
      break
  if not m:
    return {"i": 0, "n": 8, "name": "", "progress": 0}
  i = int(m.group(1))
  n = int(m.group(2))
  name = (m.group(3) or "").strip()
  prog = int((i / max(1, n)) * 100)
  return {"i": i, "n": n, "name": name, "progress": prog}

def _parse_run_dir_from_tail(tail: str) -> str:
  # Example: [VSP_CI_OUTER] RUN_DIR    = /home/.../out_ci/VSP_CI_YYYY...
  for line in reversed(tail.splitlines()):
    if "RUN_DIR" in line and "=" in line:
      m = re.search(r'RUN_DIR\s*=\s*(/.+)$', line.strip())
      if m:
        return m.group(1).strip()
  return ""

def _parse_gate_from_tail(tail: str) -> str:
  # Example: [VSP_CI_GATE] GATE RESULT: FAIL
  for line in reversed(tail.splitlines()):
    m = re.search(r'GATE RESULT:\s*(PASS|FAIL)', line)
    if m:
      return m.group(1)
  return "UNKNOWN"

def _read_degraded(run_dir: str):
  out = {"degraded": 0, "reasons": ""}
  if not run_dir:
    return out
  p = Path(run_dir) / "vsp_degraded.env"
  if not p.exists():
    return out
  txt = _safe_read_text(p)
  for line in txt.splitlines():
    line=line.strip()
    if not line or line.startswith("#"): continue
    if line.startswith("degraded="):
      try: out["degraded"] = int(line.split("=",1)[1].strip() or "0")
      except Exception: pass
    if line.startswith("reasons="):
      out["reasons"] = line.split("=",1)[1].strip()
  return out

def _read_severity_from_summary(run_dir: str):
  if not run_dir:
    return {}
  p = Path(run_dir) / "report" / "summary_unified.json"
  if not p.exists():
    return {}
  try:
    j = json.loads(p.read_text(encoding="utf-8", errors="replace"))
    # support both keys
    sev = j.get("summary_by_severity") or j.get("by_severity") or {}
    if isinstance(sev, dict):
      return {k: int(sev.get(k,0) or 0) for k in ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"]}
  except Exception:
    return {}
  return {}

def _kill_proc(req_id: str):
  pr = PROCS.get(req_id)
  if not pr:
    return
  try:
    # kill process group if possible
    os.killpg(os.getpgid(pr.pid), 9)
  except Exception:
    try:
      pr.kill()
    except Exception:
      pass

def _finalize_unify_and_sync(run_dir: str) -> dict:
  """
  Best-effort: ensure report exists, unify if missing, then sync to SECURITY_BUNDLE/out.
  """
  res = {"done": False, "ok": None, "vsp_run_id": "", "msg": ""}
  if not run_dir:
    res["ok"] = False
    res["msg"] = "missing run_dir"
    return res

  runp = Path(run_dir)
  summary = runp / "report" / "summary_unified.json"
  findings = runp / "report" / "findings_unified.json"

  try:
    # unify if missing
    if not summary.exists() or not findings.exists():
      unify_sh = BUNDLE_ROOT / "bin" / "vsp_unify_from_run_dir_v1.sh"
      if unify_sh.exists():
        subprocess.run([str(unify_sh), str(runp)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=900)
  except Exception as e:
    res["msg"] += f"unify_err:{e}; "

  try:
    # sync to bundle/out
    sync_sh = BUNDLE_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
    if sync_sh.exists():
      subprocess.run([str(sync_sh), str(runp)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=180)
  except Exception as e:
    res["msg"] += f"sync_err:{e}; "

  # derive vsp_run_id convention: RUN_<VSP_CI_...>
  base = runp.name.strip()
  if base.startswith("VSP_CI_"):
    cand = BUNDLE_ROOT / "out" / f"RUN_{base}"
    if cand.exists():
      res["vsp_run_id"] = f"RUN_{base}"
    else:
      # try find newest matching prefix
      outdir = (BUNDLE_ROOT / "out")
      if outdir.exists():
        matches = sorted([d for d in outdir.iterdir() if d.is_dir() and d.name.startswith(f"RUN_{base}")],
                         key=lambda x: x.stat().st_mtime, reverse=True)
        if matches:
          res["vsp_run_id"] = matches[0].name

  res["done"] = True
  res["ok"] = True
  return res

@bp.route("/api/vsp/run_v1", methods=["POST"])
def run_v1():
  data = request.get_json(silent=True) or {}
  mode = (data.get("mode") or "local").strip()
  profile = (data.get("profile") or "FULL_EXT").strip()
  target_type = (data.get("target_type") or "path").strip()
  target = (data.get("target") or "").strip()

  if target_type != "path" or not target:

    # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V4 ===
    try:
        import json, time
        from pathlib import Path
        # payload from request
        try:
            _req_payload = request.get_json(silent=True) or {}
        except Exception:
            _req_payload = {}

        # discover req_id from locals or response dict
        _rid = None
        for _k in ("request_id","req_id","rid","REQ_ID"):
            if _k in locals() and locals().get(_k):
                _rid = str(locals().get(_k))
                break

        # common response variable names (dict contains request_id)
        if not _rid:
            for _name in ("out","resp","result","payload","ret","data","body"):
                v = locals().get(_name)
                if isinstance(v, dict) and v.get("request_id"):
                    _rid = str(v.get("request_id"))
                    break

        if _rid:
            ui_root = Path(__file__).resolve().parents[1]   # .../SECURITY_BUNDLE/ui
            st_dir = ui_root / "out_ci" / "ui_req_state"
            st_dir.mkdir(parents=True, exist_ok=True)
            st_path = st_dir / (_rid + ".json")

            state0 = {}
            if st_path.is_file():
                try:
                    state0 = json.loads(st_path.read_text(encoding="utf-8", errors="ignore") or "{}")
                    if not isinstance(state0, dict):
                        state0 = {}
                except Exception:
                    state0 = {}

            state0.setdefault("request_id", _rid)
            state0.setdefault("synthetic_req_id", True)

            # backfill contract fields early
            for _k in ("mode","profile","target_type","target"):
                if (not state0.get(_k)) and (_req_payload.get(_k) is not None):
                    state0[_k] = _req_payload.get(_k) or ""

            state0.setdefault("ci_run_dir", "")
            state0.setdefault("runner_log", "")
            state0.setdefault("ci_root_from_pid", None)
            state0.setdefault("watchdog_pid", 0)
            state0.setdefault("stage_sig", "0/0||0")
            state0.setdefault("progress_pct", 0)
            state0.setdefault("killed", False)
            state0.setdefault("kill_reason", "")
            state0.setdefault("final", False)
            state0["state_bootstrap_ts"] = int(time.time())

            # keep minimal payload for debug
            rp = state0.get("req_payload")
            if not isinstance(rp, dict):
                rp = {}
            for _k in ("mode","profile","target_type","target"):
                if _k in _req_payload:
                    rp[_k] = _req_payload.get(_k)
            state0["req_payload"] = rp

            st_path.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception as _e:
        try:
            print("[VSP_RUN_V1_STATEFILE_BOOTSTRAP_V4] bootstrap failed:", _e)
        except Exception:
            pass
    # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V4 ===

    # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===

    __resp = jsonify({"ok": False, "error": "target_type=path and target required"})

    try:

        _payload = __resp.get_json(silent=True) or {}

    except Exception:

        _payload = {}

    try:

        _rid = str(_payload.get("request_id") or "")

        try:

            _req_payload = request.get_json(silent=True) or {}

        except Exception:

            _req_payload = {}

        if _rid:

            _vsp_bootstrap_statefile_v6(_rid, _req_payload)

    except Exception:

        pass

    return __resp, 400

    # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===



  ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
  req_id = f"UIREQ_{ts}_{uuid.uuid4().hex[:6]}"

  log_file = STATE_DIR / f"{req_id}.log"
  created = now_utc_iso()

  # spawn CI OUTER in target repo
  target_path = Path(target).resolve()
  outer = target_path / "ci" / "VSP_CI_OUTER" / "vsp_ci_outer_full_v1.sh"
  if not outer.exists():
    # fallback: still allow, but will fail and be visible in tail
    outer = target_path / "ci" / "VSP_CI_OUTER" / "vsp_ci_gate_core_v1.sh"

  env = os.environ.copy()
  env["VSP_BUNDLE_ROOT"] = str(BUNDLE_ROOT)
  env["BUNDLE_ROOT"] = str(BUNDLE_ROOT)
  env["PROFILE"] = profile
  env["VSP_PROFILE"] = profile
  env["VSP_UIREQ_ID"] = req_id

  # state
  st = {
    "ok": True,
    "req_id": req_id,
    "created_at": created,
    "started_at": created,
    "finished_at": None,
    "status": "RUNNING",
    "final": False,
    "exit_code": None,
    "gate": "UNKNOWN",
    "stage": {"i":0,"n":8,"name":"","progress":0},
    "ci_run_dir": "",
    "vsp_run_id": "",
    "flag": {"has_findings": None},
    "degraded": 0,
    "degraded_reasons": "",
    "sync": {"done": False, "ok": None, "msg": ""},
    "meta": {"mode": mode, "profile": profile, "target": str(target_path), "outer": str(outer)},
    "watch": {"last_stage_sig": "", "last_stage_at": time.time(), "start_ts": time.time()},
    "log_file": str(log_file),
    "tail": ""
  }
  _write_state(req_id, st)

  # spawn
  try:
    f = open(log_file, "ab", buffering=0)
    p = subprocess.Popen(
      [str(outer)],
      cwd=str(target_path),
      env=env,
      stdout=f,
      stderr=subprocess.STDOUT,
      start_new_session=True
    )
    PROCS[req_id] = p
  except Exception as e:
    st["status"] = "ERROR"
    st["final"] = True
    st["exit_code"] = 2
    st["sync"]["ok"] = False
    st["sync"]["msg"] = f"spawn_err:{e}"
    _write_state(req_id, st)
    # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===
    __resp = jsonify(st)
    try:
        _payload = __resp.get_json(silent=True) or {}
    except Exception:
        _payload = {}
    try:
        _rid = str(_payload.get("request_id") or "")
        try:
            _req_payload = request.get_json(silent=True) or {}
        except Exception:
            _req_payload = {}
        if _rid:
            _vsp_bootstrap_statefile_v6(_rid, _req_payload)
    except Exception:
        pass
    return __resp, 500
    # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===



  # === VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===

  __resp = jsonify({"ok": True, "req_id": req_id, "status_url": f"/api/vsp/run_status_v1/{req_id}"})

  try:

      _payload = __resp.get_json(silent=True) or {}

  except Exception:

      _payload = {}

  try:

      _rid = str(_payload.get("request_id") or "")

      try:

          _req_payload = request.get_json(silent=True) or {}

      except Exception:

          _req_payload = {}

      if _rid:

          _vsp_bootstrap_statefile_v6(_rid, _req_payload)

  except Exception:

      pass

  return __resp, 200

  # === END VSP_RUN_V1_STATEFILE_BOOTSTRAP_V6_WRAP_RETURNS APPLY ===



# === VSP_FORCE_JSON_STATUS_AST_V3 (auto) ===
@bp.route("/api/vsp/run_status_v1/<req_id>", methods=["GET"])
def run_status_v1(req_id):
  # === VSP_RUN_STATUS_LAZY_BOOTSTRAP_STATE_V1 ===
  try:
    from pathlib import Path
    import json, time, os
    _d = None
    try:
      _d = globals().get("_VSP_UIREQ_DIR", None)
    except Exception:
      _d = None
    _st = (Path(_d) / f"{req_id}.json") if _d else (Path("out_ci/ui_req_state") / f"{req_id}.json")
    if not _st.is_file():
      _st.parent.mkdir(parents=True, exist_ok=True)
      state0 = {
        "request_id": req_id,
        "synthetic_req_id": True,
        "ci_run_dir": "",
        "runner_log": "",
        "ci_root_from_pid": None,
        "watchdog_pid": 0,
        "stage_sig": "0/0||0",
        "progress_pct": 0,
        "killed": False,
        "kill_reason": "",
        "final": False,
        "stall_timeout_sec": int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")),
        "total_timeout_sec": int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")),
        "state_bootstrap_ts": int(time.time()),
      }
      # === VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 INJECT ===
      try:
        _rid = None
        try:
          _req_payload = request.get_json(silent=True) or {}
        except Exception:
          _req_payload = {}
        # try common vars: out/res/payload + locals
        for _name in ("out","res","resp","payload","data","body"):
          v = locals().get(_name)
          if isinstance(v, dict) and v.get("request_id"):
            _rid = str(v.get("request_id"))
            break
        if not _rid:
          for _k in ("request_id","req_id","rid","REQ_ID"):
            if locals().get(_k):
              _rid = str(locals().get(_k))
              break
        if _rid:
          _vsp_write_uireq_state_v1(_rid, _req_payload)
      except Exception:
        pass
      # === END VSP_SYNTH_RUNV1_BOOTSTRAP_UIREQDIR_V1 INJECT ===

      _st.write_text(json.dumps(state0, ensure_ascii=False, indent=2), encoding="utf-8")
  except Exception:
    pass
  # === END VSP_RUN_STATUS_LAZY_BOOTSTRAP_STATE_V1 ===

  # commercial: ALWAYS JSON
  from flask import jsonify
  import json, re, time
  from pathlib import Path
  req_id = req_id
  ui_root = Path(__file__).resolve().parents[1]  # .../ui
  st_dir = ui_root / "out_ci" / "uireq_v1"
  st_path = st_dir / f"{req_id}.json"
  if not st_path.exists():
    return jsonify({"ok": False, "req_id": req_id, "error": "not_found"}), 404
  try:
    st = json.loads(st_path.read_text(encoding="utf-8", errors="ignore") or "{}")


  except Exception:
    st = {}
  st["ok"] = True
  st["req_id"] = req_id

  # tail from log_file
  log_file = st.get("log_file") or str(st_dir / f"{req_id}.log")
  st["log_file"] = log_file
  lf = Path(log_file)
  tail = ""
  if lf.exists():
    try:
      arr = lf.read_text(encoding="utf-8", errors="ignore").splitlines()
      tail = "\n".join(arr[-250:])
    except Exception:
      tail = ""
  st["tail"] = tail

  # fill ci_run_dir from log if empty: RUN_DIR    = ...
  if not st.get("ci_run_dir"):
    m = re.search(r"^\[VSP_CI_OUTER\]\s*RUN_DIR\s*=\s*(.+)$", tail, flags=re.M)
    if m:
      st["ci_run_dir"] = m.group(1).strip()

  # stage/progress from tool banner: ===== [i/8] NAME =====
  stage = st.get("stage") or {"i":0,"n":8,"name":"","progress":0}
  st_re = re.compile(r"^=+\s*\[(\d+)\s*/\s*(\d+)\]\s*(.*?)\s*=+$")
  last = None
  for line in (tail or "").splitlines():
    mm = st_re.match(line.strip())
    if mm:
      last = (int(mm.group(1)), int(mm.group(2)), (mm.group(3) or "").strip())
  if last:
    i, n, name = last
    stage["i"] = i
    stage["n"] = n
    stage["name"] = name
    stage["progress"] = int(round((i/n)*100)) if n else 0
  st["stage"] = stage
  st["stage_index"] = int(stage.get("i",0) or 0)
  st["stage_total"] = int(stage.get("n",0) or 0)
  st["stage_name"] = str(stage.get("name","") or "")
  st["progress_pct"] = int(stage.get("progress",0) or 0)

  # mark final if outer ended (success/fail) based on log keywords
  if "=== VSP CI OUTER:" in tail:
    if "THẤT BẠI" in tail:
      st["status"] = "FAIL"
      st["final"] = True
    if "THÀNH CÔNG" in tail:
      st["status"] = "DONE"
      st["final"] = True

  # persist
  
  # commercial finalize: unify + sync once when final
  try:
    if bool(st.get("final")) and st.get("ci_run_dir"):
      sync = st.get("sync") or {"done": False, "ok": None, "msg": ""}
      if not bool(sync.get("done")):
        ok, msg = _vsp_finalize_unify_sync(st["ci_run_dir"])
        sync["done"] = True
        sync["ok"] = bool(ok)
        sync["msg"] = msg
      st["sync"] = sync

      d, reasons = _vsp_read_degraded_env(st["ci_run_dir"])
      st["degraded"] = int(d)
      st["degraded_reasons"] = reasons
      if d and st.get("status","").upper() in ("DONE","OK","SUCCESS"):
        st["status"] = "DEGRADED"
  except Exception as _e:
    # do not break status endpoint
    st["sync"] = st.get("sync") or {"done": False, "ok": None, "msg": ""}
    st["sync"]["msg"] = (st["sync"].get("msg","") + "\n" + str(_e)).strip()

  st_path.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

  # VSP_RUN_STATUS_READ_UIREQDIR_V2_SAFE
  # Fallback: if primary state is empty/partial, read from _VSP_UIREQ_DIR/<req_id>.json (where run_v1 bootstrap writes)
  try:
      if (not isinstance(st, dict)) or (not st) or (not (st.get("request_id") or st.get("req_id"))):
          try:
              f2 = _VSP_UIREQ_DIR / f"{req_id}.json"
          except Exception:
              from pathlib import Path as _P
              f2 = _P(__file__).resolve().parents[1] / "ui" / "out_ci" / "uireq_v1" / f"{req_id}.json"
          if f2 and getattr(f2, "is_file", lambda: False)():
              import json as _json
              st = _json.loads(f2.read_text(encoding="utf-8", errors="replace"))
      if isinstance(st, dict):
          st.setdefault("ok", True)
          st.setdefault("req_id", str(req_id))
          st.setdefault("request_id", st.get("request_id") or str(req_id))
  except Exception:
      pass
  # END VSP_RUN_STATUS_READ_UIREQDIR_V2_SAFE



  # VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG
  try:
    from pathlib import Path as _P
    import json as _json, re as _re
    if isinstance(st, dict):
      _ci = (st.get("ci_run_dir") or "").strip()
      _rl = (st.get("runner_log") or "").strip()
      tgt = (st.get("target") or "").strip()
      rid = (st.get("req_id") or st.get("request_id") or req_id or "").strip()
      if (not _ci) or (not _rl):
        best_dir = None
        best_diff = 10**18
        cand = []
        if tgt:
          oc = _P(tgt) / "out_ci"
          # parse rid time: VSP_UIREQ_YYYYmmdd_HHMMSS_xxxxxx
          m = _re.search(r"VSP_UIREQ_(\d{8})_(\d{6})_", rid)
          rid_key = None
          if m:
            rid_key = m.group(1) + m.group(2)  # yyyymmddhhmmss
          def _to_int(s):
            try: return int(s)
            except Exception: return None
          rid_int = _to_int(rid_key) if rid_key else None
          if oc.is_dir():
            for d in oc.iterdir():
              if not d.is_dir(): 
                continue
              # accept VSP_CI_YYYYmmdd_HHMMSS
              mm = _re.search(r"VSP_CI_(\d{8})_(\d{6})", d.name)
              if mm:
                k = mm.group(1) + mm.group(2)
                di = _to_int(k)
                cand.append((d, di))
            # choose nearest by timestamp if possible
            if rid_int is not None:
              for d, di in cand:
                if di is None: 
                  continue
                diff = abs(di - rid_int)
                if diff < best_diff:
                  best_diff = diff
                  best_dir = d
            # fallback newest mtime
            if best_dir is None and cand:
              try:
                best_dir = max([d for d,_ in cand], key=lambda x: x.stat().st_mtime)
              except Exception:
                best_dir = None
        if best_dir:
          st["ci_run_dir"] = str(best_dir)
          rp = best_dir / "runner.log"
          st["runner_log"] = str(rp)
          try:
            print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] mapped rid=", rid, "->", str(best_dir), "best_diff=", best_diff, "runner_log_exists=", rp.is_file())
          except Exception:
            pass
        else:
          try:
            print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] no ci dir found for rid=", rid, "tgt=", tgt)
          except Exception:
            pass
        # persist back to statefile (uireq dir)
        try:
          udir = globals().get("_VSP_UIREQ_DIR")
          if udir:
            sf = _P(str(udir)) / f"{req_id}.json"
            sf.parent.mkdir(parents=True, exist_ok=True)
            sf.write_text(_json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception as e:
          try: print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] persist failed:", e)
          except Exception: pass
  except Exception as e:
    try: print("[VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG] exception:", e)
    except Exception: pass
  # END VSP_RUN_STATUS_MAP_CI_DIR_V3_DEBUG
  return jsonify(st)
# === END VSP_FORCE_JSON_STATUS_AST_V3 ===

print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")


# === VSP_COMMERCIAL_BP_EXPORT_ALIAS_V1 ===
# Backward-compatible export name expected by UI gateway:
bp_vsp_run_api_v1 = bp
# Optional: keep old name too (some code may import bp_vsp_run_api)
try:
    bp_vsp_run_api
except NameError:
    bp_vsp_run_api = bp
# === END VSP_COMMERCIAL_BP_EXPORT_ALIAS_V1 ===


# === VSP_COMMERCIAL_RUNAPI_V2 (do not edit manually) ===
import os, re, json, time, signal, subprocess
from pathlib import Path

_VSP_STAGE_RE = re.compile(r"^=+\s*\[(\d+)\s*/\s*(\d+)\]\s*(.*?)\s*=+$")

def _vsp_root_dir_v1():
    cur = Path(__file__).resolve()
    for _ in range(0, 12):
        if (cur / "bin").is_dir():
            return cur
        cur = cur.parent
    return Path.cwd()

_VSP_ROOT = _vsp_root_dir_v1()
_VSP_UIREQ_DIR = _VSP_ROOT / "ui" / "out_ci" / "uireq_v1"
_VSP_UIREQ_DIR.mkdir(parents=True, exist_ok=True)

def _uireq_state_path(req_id: str) -> Path:
    return _VSP_UIREQ_DIR / f"{req_id}.json"

def _load_uireq(req_id: str) -> dict:
    f = _uireq_state_path(req_id)
    if not f.exists():
        return {}
    try:
        return json.loads(f.read_text(encoding="utf-8"))
    except Exception:
        return {}

def _save_uireq(req_id: str, st: dict) -> None:
    f = _uireq_state_path(req_id)
    st = dict(st or {})
    st["req_id"] = req_id
    st["saved_at"] = time.time()
    f.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

def vsp_commercial_state_register(req_id, ci_run_dir, pid, log_path=None):
    if not req_id or not ci_run_dir or not pid:
        return
    st = _load_uireq(req_id)
    st.setdefault("started_at", time.time())
    st["pid"] = int(pid)
    st["ci_run_dir"] = str(ci_run_dir)
    if log_path:
        st["log_path"] = str(log_path)
    st.setdefault("last_stage", "")
    st.setdefault("last_stage_ts", time.time())
    st.setdefault("stall_timeout_sec", int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC", "600")))
    st.setdefault("total_timeout_sec", int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC", "7200")))
    st.setdefault("final", False)
    st.setdefault("finalized", False)
    _save_uireq(req_id, st)

def _extract_stage_from_tail(tail_text: str):
    if not tail_text:
        return None
    last = None
    for line in tail_text.splitlines():
        m = _VSP_STAGE_RE.match(line.strip())
        if m:
            last = (int(m.group(1)), int(m.group(2)), (m.group(3) or "").strip())
    return last

def _read_degraded(ci_run_dir: Path):
    candidates = [ci_run_dir / "vsp_degraded.env", ci_run_dir / "out" / "vsp_degraded.env"]
    for f in candidates:
        if f.exists():
            degraded = 0
            reasons = ""
            for line in f.read_text(encoding="utf-8", errors="ignore").splitlines():
                if line.startswith("degraded="):
                    try: degraded = int(line.split("=",1)[1].strip() or "0")
                    except: degraded = 0
                if line.startswith("degraded_reasons="):
                    reasons = line.split("=",1)[1].strip()
            return degraded, reasons, str(f)
    return 0, "", ""

def _kill_pid_group(pid: int):
    try:
        os.killpg(pid, signal.SIGTERM)
        return True, "SIGTERM(pgid)"
    except Exception:
        try:
            os.kill(pid, signal.SIGTERM)
            return True, "SIGTERM(pid)"
        except Exception as e:
            return False, f"kill_failed:{e}"

def _maybe_finalize(ci_run_dir: Path, st: dict):
    if not ci_run_dir or not ci_run_dir.exists():
        return False, "missing_ci_run_dir"
    if st.get("finalized"):
        return True, "already_finalized"

    unify = _VSP_ROOT / "bin" / "vsp_unify_from_run_dir_v1.sh"
    sync  = _VSP_ROOT / "bin" / "vsp_ci_sync_to_vsp_v1.sh"

    ok = True
    logs = []

    if unify.exists():
        r = subprocess.run([str(unify), str(ci_run_dir)], capture_output=True, text=True)
        logs.append(f"[UNIFY rc={r.returncode}]")
        if r.returncode != 0:
            ok = False
            logs.append((r.stdout or "")[-3000:])
            logs.append((r.stderr or "")[-3000:])
    else:
        ok = False
        logs.append("[UNIFY missing]")

    if sync.exists():
        r2 = subprocess.run([str(sync), str(ci_run_dir)], capture_output=True, text=True)
        logs.append(f"[SYNC rc={r2.returncode}]")
        if r2.returncode != 0:
            ok = False
            logs.append((r2.stdout or "")[-3000:])
            logs.append((r2.stderr or "")[-3000:])
    else:
        ok = False
        logs.append("[SYNC missing]")

    st["finalized"] = True
    st["finalize_ok"] = bool(ok)
    st["finalize_log_tail"] = "\n".join([x for x in logs if x])
    return ok, "finalized"

def vsp_commercial_enhance_status_payload(req_id: str, payload: dict):
    payload = dict(payload or {})
    st = _load_uireq(req_id)

    tail = payload.get("tail") or payload.get("log_tail") or ""
    stage = _extract_stage_from_tail(tail)
    if stage:
        i, total, name = stage
        payload["stage_index"] = i
        payload["stage_total"] = total
        payload["stage_name"] = name
        payload["progress_pct"] = int(round((i / total) * 100)) if total else 0
        if st.get("last_stage") != f"{i}/{total}:{name}":
            st["last_stage"] = f"{i}/{total}:{name}"
            st["last_stage_ts"] = time.time()

    started_at = float(st.get("started_at") or time.time())
    last_stage_ts = float(st.get("last_stage_ts") or started_at)
    stall_timeout = int(st.get("stall_timeout_sec") or int(os.environ.get("VSP_UIREQ_STALL_TIMEOUT_SEC","600")))
    total_timeout = int(st.get("total_timeout_sec") or int(os.environ.get("VSP_UIREQ_TOTAL_TIMEOUT_SEC","7200")))

    payload["started_at"] = started_at
    payload["stall_timeout_sec"] = stall_timeout
    payload["total_timeout_sec"] = total_timeout

    status = (payload.get("status") or "").upper()
    now = time.time()
    pid = st.get("pid")
    ci_run_dir = Path(st["ci_run_dir"]) if st.get("ci_run_dir") else None

    if status == "RUNNING" and not st.get("final"):
        if total_timeout > 0 and (now - started_at) > total_timeout:
            st["final"] = True
            payload["status"] = "TIMEOUT"
            payload["final"] = True
            if pid:
                ok, how = _kill_pid_group(int(pid))
                payload["killed"] = ok
                payload["kill_reason"] = how
        elif stall_timeout > 0 and (now - last_stage_ts) > stall_timeout:
            st["final"] = True
            payload["status"] = "STALLED"
            payload["final"] = True
            if pid:
                ok, how = _kill_pid_group(int(pid))
                payload["killed"] = ok
                payload["kill_reason"] = how

    if payload.get("final") is True:
        st["final"] = True

    if ci_run_dir and ci_run_dir.exists():
        degraded, reasons, src = _read_degraded(ci_run_dir)
        payload["degraded"] = int(degraded)
        payload["degraded_reasons"] = reasons
        payload["degraded_src"] = src
        if degraded and payload.get("status","").upper() in ("DONE","OK","SUCCESS"):
            payload["status"] = "DEGRADED"

    if st.get("final") and ci_run_dir:
        ok, _ = _maybe_finalize(ci_run_dir, st)
        payload["finalize_ok"] = bool(ok)
        payload["sync_done"] = True if ok else payload.get("sync_done", False)

    _save_uireq(req_id, st)
    return payload

# === END VSP_COMMERCIAL_RUNAPI_V2 ===

# === VSP_FINALIZE_UNIFY_SYNC_V4 ===
def _vsp_read_degraded_env(ci_run_dir: str):
  try:
    from pathlib import Path
    f = Path(ci_run_dir) / "vsp_degraded.env"
    if not f.exists():
      f = Path(ci_run_dir) / "out" / "vsp_degraded.env"
    if not f.exists():
      return 0, ""
    degraded = 0
    reasons = ""
    for line in f.read_text(encoding="utf-8", errors="ignore").splitlines():
      if line.startswith("degraded="):
        try: degraded = int(line.split("=",1)[1].strip() or "0")
        except: degraded = 0
      if line.startswith("degraded_reasons="):
        reasons = line.split("=",1)[1].strip()
    return degraded, reasons
  except Exception:
    return 0, ""

def _vsp_finalize_unify_sync(ci_run_dir: str):
  import subprocess
  from pathlib import Path
  bundle_root = Path(__file__).resolve().parents[2]  # .../SECURITY_BUNDLE
  unify = bundle_root / "bin" / "vsp_unify_from_run_dir_v1.sh"
  sync  = bundle_root / "bin" / "vsp_ci_sync_to_vsp_v1.sh"
  logs = []
  ok = True
  if unify.exists():
    r = subprocess.run([str(unify), str(ci_run_dir)], capture_output=True, text=True)
    logs.append(f"[UNIFY rc={r.returncode}]")
    if r.returncode != 0:
      ok = False
      logs.append((r.stdout or "")[-2000:])
      logs.append((r.stderr or "")[-2000:])
  else:
    ok = False
    logs.append("[UNIFY missing]")
  if sync.exists():
    r2 = subprocess.run([str(sync), str(ci_run_dir)], capture_output=True, text=True)
    logs.append(f"[SYNC rc={r2.returncode}]")
    if r2.returncode != 0:
      ok = False
      logs.append((r2.stdout or "")[-2000:])
      logs.append((r2.stderr or "")[-2000:])
  else:
    ok = False
    logs.append("[SYNC missing]")
  return ok, "\n".join([x for x in logs if x])
# === END VSP_FINALIZE_UNIFY_SYNC_V4 ===

