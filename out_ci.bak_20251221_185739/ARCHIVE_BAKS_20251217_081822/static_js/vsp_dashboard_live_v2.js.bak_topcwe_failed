"use strict";

/**
 * VSP_DASHBOARD_LIVE_V2 – ALL-IN-ONE (datasource + fallback v1/v3)
 */

(function () {
  const API_SUMMARY      = "/api/vsp/datasource?mode=dashboard";
  const API_DS_SEV       = (sev, limit) =>
    "/api/vsp/datasource?severity=" + encodeURIComponent(sev) + "&limit=" + (limit || 1);
  const API_RUNS_V3      = "/api/vsp/runs_index_v3";
  const API_RUNS_V1      = "/api/vsp/runs";
  const API_TREND_V1     = "/api/vsp/trend_v1";
  const API_SETTINGS     = "/api/vsp/settings/get";
  const API_OVERRIDES    = "/api/vsp/overrides/list";
  const API_DASHBOARD_V3 = "/api/vsp/dashboard_v3";

  const SEVERITIES = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"];

  function $(id) {
    return document.getElementById(id);
  }

  async function fetchJson(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) {
      const err = new Error("HTTP " + res.status + " for " + url);
      err.status = res.status;
      throw err;
    }
    return await res.json();
  }

  function safeInt(v) {
    if (v == null) return 0;
    const n = Number(v);
    return Number.isFinite(n) ? n : 0;
  }

  function escHtml(str) {
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  function setNoData(container, msg) {
    if (!container) return;
    container.innerHTML =
      '<p style="font-size:12px;color:#9ca3c7;">' + msg + "</p>";
  }

  /* ========== KPI + DONUT ========== */

  let donutChart = null;

  function renderKpisAndDonut(dash, bySev) {
    const sev = bySev || {};
    const fmt = (n) => n.toLocaleString("en-US");

    const crit  = safeInt(sev.CRITICAL);
    const high  = safeInt(sev.HIGH);
    const med   = safeInt(sev.MEDIUM);
    const low   = safeInt(sev.LOW);
    const info  = safeInt(sev.INFO);
    const trace = safeInt(sev.TRACE);

    const totalFromSev = crit + high + med + low + info + trace;
    const total =
      safeInt(dash.total_findings) ||
      safeInt(dash.total) ||
      totalFromSev;

    const elTotal = $("kpi-total-findings");
    if (elTotal) elTotal.textContent = fmt(total);

    const elCrit = $("kpi-critical");
    if (elCrit) elCrit.textContent = fmt(crit);

    const elHigh = $("kpi-high");
    if (elHigh) elHigh.textContent = fmt(high);

    const elMed = $("kpi-medium");
    if (elMed) elMed.textContent = fmt(med);

    const elLow = $("kpi-low");
    if (elLow) elLow.textContent = fmt(low);

    const elInfoTrace = $("kpi-info-trace");
    if (elInfoTrace) elInfoTrace.textContent = fmt(info + trace);

    const lastRunId = $("vsp-last-run-id");
    if (lastRunId) lastRunId.textContent = dash.run_id || "–";

    const lastRunTs = $("vsp-last-run-ts");
    if (lastRunTs) {
      const ts = dash.ts || dash.last_run_ts || dash.last_ts;
      lastRunTs.textContent = ts ? ts : "Last run: –";
    }

    // Donut
    const canvas = $("severity_donut_chart");
    if (canvas && typeof Chart !== "undefined") {
      if (donutChart) donutChart.destroy();
      donutChart = new Chart(canvas, {
        type: "doughnut",
        data: {
          labels: ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"],
          datasets: [
            {
              data: [crit, high, med, low, info, trace],
              backgroundColor: [
                "#ff4b6a",
                "#ff9f43",
                "#ffd166",
                "#4ade80",
                "#38bdf8",
                "#a855f7",
              ],
              borderWidth: 0,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: "70%",
          plugins: { legend: { display: false } },
        },
      });
    }

    // fallback trend 1 điểm, sẽ bị override nếu initTrend() load được nhiều điểm
    renderTrend([{ label: dash.run_id || "Last run", total }]);
  }

  async function computeSeverityBucketsFromDatasource() {
    const buckets = {
      CRITICAL: 0,
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0,
      INFO: 0,
      TRACE: 0,
    };

    const promises = SEVERITIES.map(async (sev) => {
      try {
        const resp = await fetchJson(API_DS_SEV(sev, 1));
        const total = safeInt(resp.total || resp.total_findings || resp.count);
        buckets[sev] = total;
      } catch (err) {
        console.warn("[VSP] severity", sev, "error:", err);
      }
    });

    await Promise.all(promises);
    return buckets;
  }

  /* ========== TREND ========== */

  let trendChart = null;

  function renderTrend(points) {
    const canvas = $("trend_line_chart");
    if (!canvas || typeof Chart === "undefined") return;
    if (!Array.isArray(points) || !points.length) return;

    const labels = points.map((p) => p.label || "");
    const totals = points.map((p) => safeInt(p.total || p.total_findings));

    // Destroy mọi chart đang gắn với canvas này (kể cả không lưu trong trendChart)
    if (typeof Chart.getChart === "function") {
      try {
        const existing = Chart.getChart(canvas);
        if (existing) existing.destroy();
      } catch (e) {
        console.warn("[VSP][TREND] Chart.getChart destroy error:", e);
      }
    }

    if (trendChart) {
      try {
        trendChart.destroy();
      } catch (e) {
        console.warn("[VSP][TREND] trendChart.destroy error:", e);
      }
      trendChart = null;
    }

    trendChart = new Chart(canvas, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Total findings",
            data: totals,
            tension: 0.35,
            borderWidth: 2,
            pointRadius: 3,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          x: {
            ticks: { maxRotation: 45, minRotation: 45 },
            grid: { display: false },
          },
          y: {
            beginAtZero: true,
            grid: { color: "rgba(148,163,210,0.25)" },
          },
        },
      },
    });
  }

  async function initTrend() {
    // 1) trend_v1 nếu có
    try {
      const t = await fetchJson(API_TREND_V1);
      const pts = Array.isArray(t.points) ? t.points : [];
      if (pts.length) {
        renderTrend(pts);
        return;
      }
    } catch (e) {
      console.warn("[VSP] trend_v1 error:", e);
    }

    // 2) runs_index_v3 nếu có
    try {
      const runs = await fetchJson(API_RUNS_V3);
      if (Array.isArray(runs) && runs.length) {
        const pts = runs
          .slice(0, 10)
          .map((r) => ({
            label: r.run_id || "",
            total: r.total_findings || r.total || 0,
          }))
          .reverse();
        renderTrend(pts);
        return;
      }
    } catch (e) {
      console.warn("[VSP] runs_index_v3 error (trend):", e);
    }
    // fallback = 1 điểm đã vẽ sẵn bởi renderKpisAndDonut
  }

      /* ========== TOP CWE BAR ========== */

  let topCweChart = null;

  function ensureTopCweCanvas() {
    let canvas = $("top_cwe_chart");
    if (canvas) return canvas;

    const table = document.querySelector("#top-cwe-table");
    if (table) {
      table.style.display = "none";
      const parent = table.parentElement || table.parentNode || table;
      canvas = document.createElement("canvas");
      canvas.id = "top_cwe_chart";
      canvas.style.width = "100%";
      canvas.style.height = "210px";
      parent.appendChild(canvas);
      return canvas;
    }
    return null;
  }

  function renderTopCweBarFromInsights(items) {
    const canvas = ensureTopCweCanvas();
    if (!canvas || typeof Chart === "undefined") return;

    const arr = Array.isArray(items) ? items : [];
    if (!arr.length) {
      console.debug("[VSP] renderTopCweBarFromInsights: empty items");
      return;
    }

    const labels = arr.map((it) => it.cwe || "UNKNOWN");
    const totals = arr.map((it) => safeInt(it.count || 0));

    if (topCweChart) {
      topCweChart.destroy();
    }

    topCweChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            label: "Findings",
            data: totals,
            borderWidth: 1,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const v = ctx.parsed.y || 0;
                return `  ${v} findings`;
              },
            },
          },
        },
        scales: {
          x: {
            grid: { display: false },
            ticks: { maxRotation: 45, minRotation: 45 },
          },
          y: {
            beginAtZero: true,
            grid: { color: "rgba(148,163,210,0.25)" },
          },
        },
      },
    });
  }

  async

// ===================== TOP_CWE_PATCH_V2 – clean bridge =====================
// Giữ lại tên hàm global initTopCweFromInsights để các script khác có thể gọi.

// ======================= TOP_CWE_PATCH_V3 =======================
// Bind TOP CWE từ /api/vsp/dashboard_v3 (hoặc window.__vspTopCweInit)

// Hàm bind dữ liệu vào DOM
function vspBindTopCwe(payload) {
  try {
    if (!payload) {
      console.warn("[VSP][TOP_CWE] Không có payload");
      return;
    }

    // Hỗ trợ 2 dạng:
// 1) { run_id, top_cwe: [...] }
// 2) { ok, payload: { run_id, top_cwe: [...] } }
    var topList = null;

    if (Array.isArray(payload.top_cwe)) {
      topList = payload.top_cwe;
    } else if (payload.payload && Array.isArray(payload.payload.top_cwe)) {
      topList = payload.payload.top_cwe;
    }

    if (!topList || !topList.length) {
      console.warn("[VSP][TOP_CWE] Không có top_cwe trong payload");
      return;
    }

    var top = topList[0] || {};
    var label = top.id || "N/A";
    var count = (top.count != null) ? top.count : 0;

    var labelNodes = document.querySelectorAll("[data-vsp-topcwe-label]");
    for (var i = 0; i < labelNodes.length; i++) {
      labelNodes[i].textContent = label;
    }

    var countNodes = document.querySelectorAll("[data-vsp-topcwe-count]");
    for (var j = 0; j < countNodes.length; j++) {
      countNodes[j].textContent = String(count);
    }

    console.log("[VSP][TOP_CWE] Bound TOP CWE =", label, "count =", count);
  } catch (err) {
    console.error("[VSP][TOP_CWE] vspBindTopCwe error:", err);
  }
}

// Hàm init chính, sẽ được gọi khi DOM ready
function initTopCweFromInsights() {
  try {
    // 1) Nếu backend embed sẵn
    if (window.__vspTopCweInit) {
      console.log("[VSP][TOP_CWE] Dùng window.__vspTopCweInit");
      vspBindTopCwe(window.__vspTopCweInit);
      return;
    }

    // 2) Ngược lại fetch từ API dashboard_v3
    fetch("/api/vsp/dashboard_v3")
      .then(function (res) {
        if (!res.ok) {
          throw new Error("HTTP " + res.status);
        }
        return res.json();
      })
      .then(function (data) {
        console.log("[VSP][TOP_CWE] Nhận data từ /api/vsp/dashboard_v3", data);
        vspBindTopCwe(data);
      })
      .catch(function (err) {
        console.error("[VSP][TOP_CWE] Fetch /api/vsp/dashboard_v3 lỗi:", err);
      });
  } catch (err) {
    console.error("[VSP][TOP_CWE] initTopCweFromInsights error:", err);
  }
}

// Auto init khi DOM đã sẵn sàng
document.addEventListener("DOMContentLoaded", function () {
  try {
    initTopCweFromInsights();
  } catch (err) {
    console.error("[VSP][TOP_CWE] DOMContentLoaded hook error:", err);
  }
});
