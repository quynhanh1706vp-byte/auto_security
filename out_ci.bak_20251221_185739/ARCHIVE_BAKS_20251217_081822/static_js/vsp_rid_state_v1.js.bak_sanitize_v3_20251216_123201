/* VSP_PICKLATEST_SHIM_V1: define pickLatest if missing (avoid ReferenceError) */
if (typeof pickLatest !== "function") {
  // pick latest item by ts/created_at or by lexical run_id fallback
  var pickLatest = function(items){
    try{
      if (!Array.isArray(items) || !items.length) return null;
      const score = (it) => {
        const t = it && (it.ts || it.created_at || it.created || it.time || it.started_at);
        const n = (t && Date.parse(t)) ? Date.parse(t) : NaN;
        if (!Number.isNaN(n)) return n;
        const rid = String(it.run_id || it.rid || it.id || "");
        // lexical fallback (works for VSP_CI_YYYYmmdd_HHMMSS-ish)
        return rid ? rid.split("").reduce((a,c)=>a + c.charCodeAt(0), 0) : 0;
      };
      let best = items[0], bestS = score(best);
      for (const it of items){
        const s = score(it);
        if (s > bestS){ bestS = s; best = it; }
      }
      return best;
    }catch(_e){
      return items[0] || null;
    }
  };
}

/* VSP_RID_STATE_FS_FALLBACK_V1: fallback RID from /api/vsp/latest_rid_v1 when runs_index/dashboard returns null */
async function __vspPickLatestRidFallback() {
  try {
    const r = await fetch("/api/vsp/latest_rid_v1");
    const j = await r.json();
    return (j && j.ok && j.run_id) ? j.run_id : null;
  } catch(e) {
    console.warn("[RID_FALLBACK] err", e);
    return null;
  }
}

/* VSP_RID_STATE_V2: global RID state (localStorage + auto pick latest + export capture bind) */
(function(){
  const KEY = "VSP_CURRENT_RID";
  const RID_RE = /(RUN_)?VSP_CI_\d{8}_\d{6}/;

  function normRid(rid){
    if(!rid) return "";
    rid = String(rid).trim();
    rid = rid.replace(/^RUN_/, "");
    if(!RID_RE.test(rid)) return "";
    return rid;
  }

  function get(){ return normRid(localStorage.getItem(KEY) || ""); }
  function set(rid){
    rid = normRid(rid);
    if(!rid) return false;
    localStorage.setItem(KEY, rid);
    window.dispatchEvent(new CustomEvent("vsp:rid-changed", { detail: { rid } }));
    return true;
  }
  function clear(){
    localStorage.removeItem(KEY);
    window.dispatchEvent(new CustomEvent("vsp:rid-changed", { detail: { rid: "" } }));
  }

  async function pickLatest(){
    try{
      const url = "/api/vsp/runs_index_v3_fs_resolved?limit=1&hide_empty=0&filter=1";
      const r = await fetch(url, { cache:"no-store" });
      if(!r.ok) return "";
      const j = await r.json();
      const ridRaw = (j && j.items && j.items[0] && j($1)) ? j($1) : "";
      const rid = normRid(String(ridRaw));
      if(rid) set(rid);
      return rid;
    }catch(e){
      console.warn("[VSP_RID_STATE_V2] pickLatest failed", e);
      return "";
    }
  }

  function updateHeader(){
    const rid = get();
    const el = document.getElementById("vsp-rid-label");
    if(el) el.textContent = rid ? ("RID: " + rid) : "RID: (none)";
  }

  async function ensure(){
    updateHeader();
    const cur = get();
    if(cur) return cur;
    const rid = await pickLatest();
    updateHeader();
    return rid;
  }

  function bindExportCapture(btnId, fmt){
    const b = document.getElementById(btnId);
    if(!b) return;
    if(b.dataset && b.dataset.vspExportBound === "1") return;
    if(b.dataset) b.dataset.vspExportBound = "1";

    b.addEventListener("click", async (e)=>{
      // CAPTURE: block old bubble listeners (your current go(fmt) handler)
      try{
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
      }catch(_){}

      const rid = await ensure();
      if(!rid) {
        console.warn("[VSP_RID_STATE_V2] no RID; cannot export");
        return;
      }
      const ridPath = "RUN_" + rid;
      window.location.href = `/api/vsp/run_export_v3/${ridPath}?fmt=${encodeURIComponent(fmt)}`;
    }, true); // <-- capture
  }

  function wireExports(){
    // your UI uses btn-export-*
    bindExportCapture("btn-export-html", "html");
    bindExportCapture("btn-export-zip",  "zip");
    bindExportCapture("btn-export-pdf",  "pdf");
    // backward compat if any old ids exist
    bindExportCapture("export-html", "html");
    bindExportCapture("export-zip",  "zip");
    bindExportCapture("export-pdf",  "pdf");
  }

  window.VSP_RID_STATE_V2 = { get, set, clear, ensure, pickLatest, updateHeader };

  window.addEventListener("vsp:rid-changed", updateHeader);
  document.addEventListener("DOMContentLoaded", async ()=>{
    wireExports();
    await ensure();
  });

  /* VSP_RIDSTATE_COMMERCIAL_SHIM_V1_BEGIN */
  // commercial safety: always define override hook + expose minimal state
  try {
    window.VSP_RID_PICKLATEST_OVERRIDE_V1 = window.VSP_RID_PICKLATEST_OVERRIDE_V1 || function(items) {
      try {
        if (typeof pickLatest === 'function') return pickLatest(items);
      } catch(e) {}
      return (items && items[0]) ? items[0] : null;
    };
    window.VSP_RID_STATE_V1 = window.VSP_RID_STATE_V1 || {};
    window.VSP_RID_STATE_V1.st = st;
  } catch(e) {}
  /* VSP_RIDSTATE_COMMERCIAL_SHIM_V1_END */

})();

VSP_RID_PICKLATEST_OVERRIDE_V1

/* VSP_RID_PICKLATEST_OVERRIDE_V1: never crash, always resolve RID via API */
(function(){
  'use strict';


  var st = (window.__vspRidState || (window.__vspRidState = {}));
// VSP_RID_STATE_CRASHFIX_V3B: safe globals + no $1 + robust pickLatest fallback
var VSP_RID_PICKLATEST_OVERRIDE_V1 = (typeof window !== "undefined" && window.VSP_RID_PICKLATEST_OVERRIDE_V1) ? window.VSP_RID_PICKLATEST_OVERRIDE_V1 : null;

function vspNormRidV3b(x){
  if(!x) return "";
  try{
    let t = String(x).trim();
    t = t.replace(/^RID:\s*/i, "");
    t = t.replace(/^RUN_/i, "");
    return t.trim();
  }catch(e){ return ""; }
}


  function _setLS(rid){
    try{
      if(!rid) return;
      localStorage.setItem("vsp_rid_selected_v2", String(rid));
      localStorage.setItem("vsp_rid_selected", String(rid));
    }catch(e){}
  }

  async function _fetchJson(url){
    const r = await fetch(url, {headers:{'Accept':'application/json'}});
    return await r.json();
  }

  async function pickLatestSafe(){
    // 1) latest_rid_v1 (FS fallback)
    try{
      const j = await _fetchJson("/api/vsp/latest_rid_v1");
      const rid = j && (j.run_id || j.rid || j.id);
      if(rid){ _setLS(rid); return rid; }
    }catch(e){}

    // 2) runs_index_v3_fs_resolved
    try{
      const j = await _fetchJson("/api/vsp/runs_index_v3_fs_resolved?limit=1&hide_empty=0&filter=0");
      const rid = j && j.items && j.items[0] && j.items[0].run_id;
      if(rid){ _setLS(rid); return rid; }
    }catch(e){}

    return null;
  }

  // patch common globals (best-effort)
  try{
    if(window.VSP_RID_STATE_V2 && typeof window.VSP_RID_STATE_V2.pickLatest === "function"){
      window.VSP_RID_STATE_V2.pickLatest = pickLatestSafe;
    }
  }catch(e){}
  try{
    if(window.VSP_RID_STATE && typeof window.VSP_RID_STATE.pickLatest === "function"){
      window.VSP_RID_STATE.pickLatest = pickLatestSafe;
    }
  }catch(e){}

  // also expose for debugging
  window.__VSP_PICK_LATEST_SAFE = pickLatestSafe;

  console.log("[RID_OVERRIDE_V1] installed");
})();


(function(){
  'use strict';
  async function pickLatestSafe(){
    try{
      if (typeof VSP_RID_PICKLATEST_OVERRIDE_V1!=="undefined" && VSP_RID_PICKLATEST_OVERRIDE_V1){
        const rid = vspNormRidV3b(VSP_RID_PICKLATEST_OVERRIDE_V1);
        if(rid) return rid;
      }
    }catch(e){}

    try{
      const r = await fetch("/api/vsp/latest_rid_v1", {cache:"no-store"});
      const j = await r.json();
      const rid = vspNormRidV3b(j && (j.run_id || j.rid || j.id));
      if(rid) return rid;
    }catch(e){}

    try{
      const rid = vspNormRidV3b(localStorage.getItem("vsp_rid_selected_v2") || localStorage.getItem("vsp_rid_selected") || "");
      if(rid) return rid;
    }catch(e){}

    return "";
  }

  async function ensureRidSafe(){
    const rid = await pickLatestSafe();
    if(!rid){
      console.warn("[VSP_RID_STATE_V3B] no rid resolved");
      return;
    }
    try{ localStorage.setItem("vsp_rid_selected_v2", rid); }catch(e){}
    console.info("[VSP_RID_STATE_V3B] resolved rid=", rid);
  }

  if(document.readyState === "loading") document.addEventListener("DOMContentLoaded", ensureRidSafe);
  else ensureRidSafe();
})();

