// VSP_DASHBOARD_CHARTS_FULL_V5
//  - Donut severity: dùng model dashboard_v3 (đang OK).
//  - Trend over time: /api/vsp/runs_index_v3?limit=30.
//  - Critical & High by tool: aggregate từ /api/vsp/datasource_v2.
//  - Top CWE exposure: aggregate từ /api/vsp/datasource_v2.
//  - Top risk findings (CRIT/HIGH): list từ /api/vsp/datasource_v2.
//  - Top noisy paths (MED/LOW/INFO/TRACE): list từ /api/vsp/datasource_v2.

(function () {
  const LOG = "[VSP][CHARTS]";
  const API_DASHBOARD = "/api/vsp/dashboard_v3";
  const API_RUNS      = "/api/vsp/runs_index_v3?limit=30";
  const API_DS        = "/api/vsp/datasource_v2?limit=5000";

  const SEVERITY_ORDER = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"];
  const SEVERITY_COLORS = {
    CRITICAL: "#ef4444",
    HIGH: "#f97316",
    MEDIUM: "#eab308",
    LOW: "#22c55e",
    INFO: "#0ea5e9",
    TRACE: "#64748b",
  };
  const SEV_WEIGHT = {
    CRITICAL: 5,
    HIGH: 4,
    MEDIUM: 3,
    LOW: 2,
    INFO: 1,
    TRACE: 0,
  };

  // ---------- DOM helpers ----------

  function findCardByTitle(titleText) {
    const tab = document.querySelector("#vsp-tab-dashboard");
    if (!tab) return null;
    const all = Array.from(tab.querySelectorAll("*"));
    let titleEl = null;
    for (const el of all) {
      const text = (el.textContent || "").trim().toUpperCase();
      if (text === titleText.toUpperCase()) {
        titleEl = el;
        break;
      }
    }
    if (!titleEl) return null;
    let card = titleEl.closest(".vsp-chart-card");
    if (!card) card = titleEl.closest("div");
    return card || null;
  }

  function ensureChartCanvas(titleText, canvasId) {
    const card = findCardByTitle(titleText);
    if (!card) {
      console.warn(LOG, "Không tìm thấy card cho", titleText);
      return null;
    }

    let wrapper = card.querySelector(".vsp-chart-canvas-wrapper");
    if (!wrapper) {
      const body = card.querySelector(".vsp-chart-card-body") || card;
      wrapper = document.createElement("div");
      wrapper.className = "vsp-chart-canvas-wrapper";
      body.appendChild(wrapper);
    }

    let canvas = wrapper.querySelector("canvas#" + canvasId);
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = canvasId;
      wrapper.innerHTML = "";
      wrapper.appendChild(canvas);
    }
    return canvas;
  }

  // ---------- Fetch helpers ----------

  async function fetchDashboardModel() {
    const res = await fetch(API_DASHBOARD);
    const model = await res.json();
    console.log(LOG, "dashboard_v3:", model);
    return model;
  }

  async function fetchRunsIndex() {
    try {
      const res = await fetch(API_RUNS);
      const data = await res.json();
      console.log(LOG, "runs_index_v3:", data);
      return data.items || [];
    } catch (e) {
      console.warn(LOG, "Lỗi fetch runs_index_v3:", e);
      return [];
    }
  }

  async function fetchDatasourceItems() {
    try {
      const res = await fetch(API_DS);
      const data = await res.json();
      console.log(LOG, "datasource_v2:", data);
      return data.items || [];
    } catch (e) {
      console.warn(LOG, "Lỗi fetch datasource_v2:", e);
      return [];
    }
  }

  // ---------- Aggregators ----------

  function extractSeverityBucketsFromDashboard(model) {
    const buckets = {};
    SEVERITY_ORDER.forEach((s) => (buckets[s] = 0));

    const byTool =
      model.by_tool ||
      model.summary_by_tool ||
      (model.summary_all && model.summary_all.by_tool) ||
      {};

    function addSeverityFromObject(obj) {
      if (!obj || typeof obj !== "object") return;
      for (const [k, vRaw] of Object.entries(obj)) {
        const key = k.toUpperCase();
        let sev = null;
        if (key.includes("CRIT")) sev = "CRITICAL";
        else if (key.includes("HIGH")) sev = "HIGH";
        else if (key.includes("MED")) sev = "MEDIUM";
        else if (key.includes("LOW")) sev = "LOW";
        else if (key.includes("INFO")) sev = "INFO";
        else if (key.includes("TRACE")) sev = "TRACE";
        if (!sev) continue;
        const v = Number(vRaw || 0);
        if (!Number.isFinite(v)) continue;
        buckets[sev] += v;
      }
    }

    Object.values(byTool).forEach(addSeverityFromObject);

    let sum = Object.values(buckets).reduce((a, b) => a + b, 0);
    if (sum === 0) {
      addSeverityFromObject(model.by_severity || {});
      addSeverityFromObject(
        model.summary_all && model.summary_all.by_severity
          ? model.summary_all.by_severity
          : {}
      );
      sum = Object.values(buckets).reduce((a, b) => a + b, 0);
    }

    if (sum === 0) {
      buckets.CRITICAL = Number(model.crit || 0);
      buckets.HIGH = Number(model.high || 0);
      buckets.MEDIUM = Number(model.med || model.medium || 0);
      buckets.LOW = Number(model.low || 0);
      buckets.INFO = Number(model.info || 0);
      buckets.TRACE = Number(model.trace || 0);
    }

    console.log(LOG, "Severity buckets (final):", buckets);
    return buckets;
  }

  function buildTrendFromRuns(runs) {
    const series = [];
    const arr = Array.isArray(runs) ? runs.slice() : [];
    // Giả sử API trả newest-first -> reverse để vẽ trái->phải
    arr.reverse();

    for (const item of arr) {
      if (!item || typeof item !== "object") continue;
      const label =
        item.label ||
        item.started_at ||
        item.start_time ||
        item.date ||
        item.run_id ||
        "";

      let total =
        item.total_findings ??
        item.total ??
        item.count ??
        item.findings_total ??
        0;

      const sevAgg = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0, TRACE: 0 };
      for (const [k, vRaw] of Object.entries(item)) {
        const key = k.toUpperCase();
        let sev = null;
        if (key.includes("CRIT")) sev = "CRITICAL";
        else if (key.includes("HIGH")) sev = "HIGH";
        else if (key.includes("MED")) sev = "MEDIUM";
        else if (key.includes("LOW")) sev = "LOW";
        else if (key.includes("INFO")) sev = "INFO";
        else if (key.includes("TRACE")) sev = "TRACE";
        if (!sev) continue;
        const v = Number(vRaw || 0);
        if (!Number.isFinite(v)) continue;
        sevAgg[sev] += v;
      }
      const fromSev = Object.values(sevAgg).reduce((a, b) => a + b, 0);
      if ((!total || total === 0) && fromSev > 0) {
        total = fromSev;
      }
      let highCrit =
        item.crit_high ||
        item.critical_high ||
        item.high_crit ||
        sevAgg.CRITICAL + sevAgg.HIGH;

      series.push({
        label: String(label),
        total: Number(total || 0),
        highCrit: Number(highCrit || 0),
      });
    }
    console.log(LOG, "Trend from runs (final):", series);
    return series;
  }

  function buildByToolFromItems(items) {
    const byTool = {};
    for (const f of items) {
      const tool = (f.tool || "unknown").toString();
      const sev = (f.severity || "INFO").toString().toUpperCase();
      if (!byTool[tool]) {
        byTool[tool] = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0, TRACE: 0 };
      }
      if (SEVERITY_ORDER.includes(sev)) {
        byTool[tool][sev] += 1;
      } else {
        byTool[tool].INFO += 1;
      }
    }
    const tmp = [];
    for (const [tool, agg] of Object.entries(byTool)) {
      const critHigh = (agg.CRITICAL || 0) + (agg.HIGH || 0);
      if (critHigh > 0) tmp.push([tool, critHigh]);
    }
    tmp.sort((a, b) => b[1] - a[1]);
    const top = tmp.slice(0, 6);
    const labels = top.map(([tool]) => tool);
    const values = top.map(([, v]) => v);
    console.log(LOG, "Critical+High by tool from items:", { labels, values });
    return { labels, values };
  }

  function buildTopCweFromItems(items) {
    const byCwe = {};
    for (const f of items) {
      const cwe = (f.cwe || f.CWE || "").toString().trim();
      if (!cwe) continue;
      byCwe[cwe] = (byCwe[cwe] || 0) + 1;
    }
    const tmp = Object.entries(byCwe).sort((a, b) => b[1] - a[1]).slice(0, 8);
    const list = tmp.map(([cwe, total]) => ({ cwe, total }));
    console.log(LOG, "Top CWE from items:", list);
    return list;
  }

  function normalizeSeverity(val) {
    if (!val) return { label: "INFO", weight: SEV_WEIGHT.INFO };
    const s = val.toString().toUpperCase();
    for (const k of SEVERITY_ORDER) {
      if (s.includes(k)) {
        return { label: k, weight: SEV_WEIGHT[k] };
      }
    }
    return { label: "INFO", weight: SEV_WEIGHT.INFO };
  }

  function buildTopRiskFromItems(items) {
    const map = {};
    for (const f of items) {
      const { label, weight } = normalizeSeverity(f.severity);
      if (weight < SEV_WEIGHT.HIGH) continue; // chỉ CRIT/HIGH
      const tool = (f.tool || "unknown").toString();
      const cwe = (f.cwe || "").toString();
      const rule = (f.rule || "").toString();
      const path =
        f.path ||
        (f.location && (f.location.path || f.location.file)) ||
        f.file ||
        "";

      const key = [label, tool, cwe, rule, path].join("|");
      if (!map[key]) {
        map[key] = {
          severity: label,
          tool,
          cwe,
          rule,
          path,
          count: 0,
        };
      }
      map[key].count += 1;
    }
    const list = Object.values(map);
    list.sort((a, b) => {
      const wDiff = SEV_WEIGHT[b.severity] - SEV_WEIGHT[a.severity];
      if (wDiff !== 0) return wDiff;
      if (b.count !== a.count) return b.count - a.count;
      return (a.path || "").localeCompare(b.path || "");
    });
    const top = list.slice(0, 5);
    console.log(LOG, "Top risk findings:", top);
    return top;
  }

  function buildTopNoiseFromItems(items) {
    const map = {};
    for (const f of items) {
      const { label, weight } = normalizeSeverity(f.severity);
      if (weight >= SEV_WEIGHT.HIGH) continue; // loại CRIT/HIGH
      const path =
        f.path ||
        (f.location && (f.location.path || f.location.file)) ||
        f.file ||
        "";
      if (!path) continue;
      if (!map[path]) {
        map[path] = {
          path,
          total: 0,
          sevCounts: { MEDIUM: 0, LOW: 0, INFO: 0, TRACE: 0 },
        };
      }
      map[path].total += 1;
      if (["MEDIUM", "LOW", "INFO", "TRACE"].includes(label)) {
        map[path].sevCounts[label] += 1;
      }
    }
    const list = Object.values(map);
    list.sort((a, b) => b.total - a.total);
    const top = list.slice(0, 5).map((item) => {
      const s = item.sevCounts;
      const parts = [];
      if (s.MEDIUM) parts.push(`MED:${s.MEDIUM}`);
      if (s.LOW) parts.push(`LOW:${s.LOW}`);
      if (s.INFO) parts.push(`INFO:${s.INFO}`);
      if (s.TRACE) parts.push(`TRACE:${s.TRACE}`);
      const noiseLevel = parts.join(" · ") || "INFO/TRACE";
      return {
        path: item.path,
        total: item.total,
        noiseLevel,
      };
    });
    console.log(LOG, "Top noisy paths:", top);
    return top;
  }

  // ---------- Render chart ----------

  function renderSeverityDonut(ctx, buckets) {
    const labels = [];
    const data = [];
    const bg = [];
    for (const sev of SEVERITY_ORDER) {
      labels.push(sev);
      data.push(buckets[sev] || 0);
      bg.push(SEVERITY_COLORS[sev] || "#6b7280");
    }
    new Chart(ctx, {
      type: "doughnut",
      data: { labels, datasets: [{ data, backgroundColor: bg }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: "60%",
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: "#e5e7eb", font: { size: 10 } },
          },
          tooltip: {
            callbacks: {
              label: (info) => {
                const v = info.parsed;
                const total = data.reduce((a, b) => a + b, 0) || 1;
                const pct = ((v * 100) / total).toFixed(1);
                return `${info.label}: ${v} (${pct}%)`;
              },
            },
          },
        },
      },
    });
  }

  function renderTrendLine(ctx, series) {
    const parent = ctx.canvas.parentElement || ctx.canvas;
    if (!series.length) {
      parent.innerHTML =
        '<div class="vsp-preview-note"><strong>Preview.</strong> Chưa có dữ liệu lịch sử đủ để vẽ trend.</div>';
      console.log(LOG, "Trend: no series.");
      return;
    }
    const sum = series.reduce((a, s) => a + (s.total || 0) + (s.highCrit || 0), 0);
    if (!sum) {
      parent.innerHTML =
        '<div class="vsp-preview-note"><strong>Preview.</strong> Hiện tại tất cả total/high-risk đều bằng 0 – biểu đồ trend sẽ bật khi có findings.</div>';
      console.log(LOG, "Trend: all zeros.");
      return;
    }
    const labels = series.map((s) => s.label);
    const totals = series.map((s) => s.total);
    const highs = series.map((s) => s.highCrit);
    new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          { label: "Total findings", data: totals, borderWidth: 2, tension: 0.3 },
          { label: "Critical + High", data: highs, borderWidth: 2, tension: 0.3 },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: "#e5e7eb", font: { size: 10 } },
          },
          tooltip: { mode: "index", intersect: false },
        },
        scales: {
          x: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { display: false },
          },
          y: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { color: "rgba(148,163,184,0.25)" },
          },
        },
      },
    });
  }

  function renderCritHighByToolBar(ctx, data) {
    const parent = ctx.canvas.parentElement || ctx.canvas;
    const labels = data.labels || [];
    const values = data.values || [];
    const sum = values.reduce((a, b) => a + b, 0);
    if (!labels.length || !sum) {
      parent.innerHTML =
        '<div class="vsp-preview-note">Chưa có phân bố CRITICAL/HIGH theo tool (datasource_v2 không trả CRIT/HIGH nào).</div>';
      console.log(LOG, "By-tool: no data.");
      return;
    }
    new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [{ label: "Critical + High", data: values }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { mode: "nearest", intersect: true },
        },
        scales: {
          x: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { display: false },
          },
          y: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { color: "rgba(148,163,184,0.25)" },
          },
        },
      },
    });
  }

  function renderTopCweBar(ctx, list) {
    const parent = ctx.canvas.parentElement || ctx.canvas;
    if (!list.length) {
      parent.innerHTML =
        '<div class="vsp-preview-note">Chưa tìm thấy CWE trong findings_unified. Khi có field CWE, biểu đồ này sẽ hiển thị CWE hay gặp nhất.</div>';
      console.log(LOG, "Top CWE: no data.");
      return;
    }
    const labels = list.map((x) => x.cwe);
    const values = list.map((x) => x.total || 0);
    new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [{ label: "Findings", data: values }],
      },
      options: {
        indexAxis: "y",
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { mode: "nearest", intersect: true },
        },
        scales: {
          x: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { color: "rgba(148,163,184,0.25)" },
          },
          y: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { display: false },
          },
        },
      },
    });
  }

  // ---------- Render lists (Top risk / Top noisy) ----------

  function fillTopRiskTable(list) {
    const card = findCardByTitle("TOP RISK FINDINGS");
    if (!card) {
      console.warn(LOG, "Không tìm thấy card TOP RISK FINDINGS.");
      return;
    }
    let tbody = card.querySelector("tbody");
    if (!tbody) {
      const table = card.querySelector("table") || document.createElement("table");
      if (!table.parentElement) card.appendChild(table);
      tbody = document.createElement("tbody");
      table.appendChild(tbody);
    }
    tbody.innerHTML = "";
    if (!list.length) {
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 4;
      td.textContent =
        "Không có findings CRITICAL/HIGH trong unified data – danh sách này sẽ bật khi có high-risk findings.";
      td.style.fontSize = "11px";
      td.style.color = "#9ca3af";
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }
    list.forEach((item) => {
      const tr = document.createElement("tr");
      tr.innerHTML =
        `<td>${item.severity}</td>` +
        `<td>${item.tool || "-"}</td>` +
        `<td>${item.path || "-"}</td>` +
        `<td>${item.rule || item.cwe || "-"}</td>`;
      tbody.appendChild(tr);
    });
  }

  function fillTopNoiseTable(list) {
    const card = findCardByTitle("TOP NOISY PATHS");
    if (!card) {
      console.warn(LOG, "Không tìm thấy card TOP NOISY PATHS.");
      return;
    }
    let tbody = card.querySelector("tbody");
    if (!tbody) {
      const table = card.querySelector("table") || document.createElement("table");
      if (!table.parentElement) card.appendChild(table);
      tbody = document.createElement("tbody");
      table.appendChild(tbody);
    }
    tbody.innerHTML = "";
    if (!list.length) {
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 3;
      td.textContent =
        "Không có findings MED/LOW/INFO/TRACE đủ để hiển thị noisy paths.";
      td.style.fontSize = "11px";
      td.style.color = "#9ca3af";
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }
    list.forEach((item) => {
      const tr = document.createElement("tr");
      tr.innerHTML =
        `<td>${item.path}</td>` +
        `<td>${item.total}</td>` +
        `<td>${item.noiseLevel}</td>`;
      tbody.appendChild(tr);
    });
  }

  // ---------- Init ----------

  async function initCharts() {
    if (typeof Chart === "undefined") {
      console.warn(LOG, "Chart.js chưa load.");
      return;
    }
    try {
      const [dashboardModel, runs, items] = await Promise.all([
        fetchDashboardModel(),
        fetchRunsIndex(),
        fetchDatasourceItems(),
      ]);

      // Donut từ dashboard_v3 (đang chuẩn)
      const buckets = extractSeverityBucketsFromDashboard(dashboardModel);

      // Trend từ runs_index_v3
      const trendSeries = buildTrendFromRuns(runs);

      // By tool + Top CWE từ datasource_v2
      const byToolData = buildByToolFromItems(items);
      const topCweList = buildTopCweFromItems(items);

      // Top risk + noisy paths từ datasource_v2
      const topRisk = buildTopRiskFromItems(items);
      const topNoise = buildTopNoiseFromItems(items);

      const cvsSeverity = ensureChartCanvas(
        "SEVERITY DISTRIBUTION (6 LEVELS)",
        "vsp-chart-severity"
      );
      if (cvsSeverity) {
        renderSeverityDonut(cvsSeverity.getContext("2d"), buckets);
      }

      const cvsTrend = ensureChartCanvas("TREND OVER TIME", "vsp-chart-trend");
      if (cvsTrend) {
        renderTrendLine(cvsTrend.getContext("2d"), trendSeries);
      }

      const cvsTool = ensureChartCanvas(
        "CRITICAL & HIGH BY TOOL",
        "vsp-chart-bytool"
      );
      if (cvsTool) {
        renderCritHighByToolBar(cvsTool.getContext("2d"), byToolData);
      }

      const cvsCwe = ensureChartCanvas("TOP CWE EXPOSURE", "vsp-chart-topcwe");
      if (cvsCwe) {
        renderTopCweBar(cvsCwe.getContext("2d"), topCweList);
      }

      fillTopRiskTable(topRisk);
      fillTopNoiseTable(topNoise);
    } catch (e) {
      console.warn(LOG, "Init charts error:", e);
    }
  }

  function start() {
    let tries = 0;
    const maxTries = 30;
    const timer = setInterval(() => {
      const tab = document.querySelector("#vsp-tab-dashboard");
      if (tab && typeof Chart !== "undefined") {
        clearInterval(timer);
        initCharts();
      } else if (++tries >= maxTries) {
        clearInterval(timer);
        console.warn(LOG, "Give up sau", tries, "lần – không thấy tab hoặc Chart.js.");
      }
    }, 400);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", start);
  } else {
    start();
  }
})();
