// VSP_DASHBOARD_CHARTS_FULL_V4
// 4 chart chính Dashboard:
//  - Severity donut (đang OK)
//  - Trend over time
//  - Critical & High by tool
//  - Top CWE (preview – nếu không có data thì bỏ qua)

(function () {
  const LOG = "[VSP][CHARTS]";
  const API_URL = "/api/vsp/dashboard_v3";

  const SEVERITY_ORDER = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"];
  const SEVERITY_COLORS = {
    CRITICAL: "#ef4444",
    HIGH: "#f97316",
    MEDIUM: "#eab308",
    LOW: "#22c55e",
    INFO: "#0ea5e9",
    TRACE: "#64748b",
  };

  function ensureChartCanvas(titleText, canvasId) {
    const tab = document.querySelector("#vsp-tab-dashboard");
    if (!tab) {
      console.warn(LOG, "Không tìm thấy #vsp-tab-dashboard.");
      return null;
    }
    const all = Array.from(tab.querySelectorAll("*"));
    let titleEl = null;
    for (const el of all) {
      const text = (el.textContent || "").trim().toUpperCase();
      if (text === titleText.toUpperCase()) {
        titleEl = el;
        break;
      }
    }
    if (!titleEl) {
      console.warn(LOG, "Không tìm thấy card title:", titleText);
      return null;
    }

    let card = titleEl.closest(".vsp-chart-card");
    if (!card) card = titleEl.closest("div");
    if (!card) {
      console.warn(LOG, "Không tìm thấy card container cho:", titleText);
      return null;
    }

    let wrapper = card.querySelector(".vsp-chart-canvas-wrapper");
    if (!wrapper) {
      const body = card.querySelector(".vsp-chart-card-body") || card;
      wrapper = document.createElement("div");
      wrapper.className = "vsp-chart-canvas-wrapper";
      body.appendChild(wrapper);
    }

    let canvas = wrapper.querySelector("canvas#" + canvasId);
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = canvasId;
      wrapper.innerHTML = "";
      wrapper.appendChild(canvas);
    }
    return canvas;
  }

  async function fetchDashboardModel() {
    console.log(LOG, "Loading charts data from", API_URL, "...");
    const res = await fetch(API_URL);
    const model = await res.json();
    console.log(LOG, "Model raw:", model);
    return model;
  }

  // ========= AGGREGATOR HELPERS =========

  function addSeverityFromObject(target, obj) {
    if (!obj || typeof obj !== "object") return;
    for (const [k, vRaw] of Object.entries(obj)) {
      const key = k.toUpperCase();
      let sev = null;
      if (key.includes("CRIT")) sev = "CRITICAL";
      else if (key.includes("HIGH")) sev = "HIGH";
      else if (key.includes("MED") || key.includes("MEDIUM")) sev = "MEDIUM";
      else if (key.includes("LOW")) sev = "LOW";
      else if (key.includes("INFO")) sev = "INFO";
      else if (key.includes("TRACE")) sev = "TRACE";

      if (!sev) continue;
      const v = Number(vRaw || 0);
      if (!Number.isFinite(v)) continue;
      target[sev] = (target[sev] || 0) + v;
    }
  }

  function extractSeverityBuckets(model) {
    const buckets = {};
    for (const s of SEVERITY_ORDER) buckets[s] = 0;

    const byTool =
      model.by_tool || model.summary_by_tool || model.summary_all?.by_tool || {};
    for (const obj of Object.values(byTool)) {
      addSeverityFromObject(buckets, obj);
    }

    let sum = Object.values(buckets).reduce((a, b) => a + b, 0);
    if (sum === 0) {
      addSeverityFromObject(buckets, model.by_severity || {});
      addSeverityFromObject(buckets, model.summary_by_severity || {});
      addSeverityFromObject(
        buckets,
        model.summary_all && model.summary_all.by_severity
          ? model.summary_all.by_severity
          : {}
      );
    }

    if (sum === 0) {
      buckets.CRITICAL = Number(model.crit || 0);
      buckets.HIGH = Number(model.high || 0);
      buckets.MEDIUM = Number(model.med || model.medium || 0);
      buckets.LOW = Number(model.low || 0);
      buckets.INFO = Number(model.info || 0);
      buckets.TRACE = Number(model.trace || 0);
    }

    console.log(LOG, "Severity buckets (final):", buckets);
    return buckets;
  }

  function extractTrendSeries(model) {
    const raw =
      model.trend ||
      model.trend_series ||
      model.runs_recent ||
      model.recent_runs ||
      [];

    const series = [];
    for (const item of raw) {
      if (!item || typeof item !== "object") continue;

      const label =
        item.label ||
        item.date ||
        item.started_at ||
        item.start_time ||
        item.run_id ||
        "";

      const sevAgg = {};
      for (const s of SEVERITY_ORDER) sevAgg[s] = 0;
      addSeverityFromObject(sevAgg, item);
      const totalFromSev = Object.values(sevAgg).reduce((a, b) => a + b, 0);

      let total =
        item.total_findings ??
        item.total ??
        item.count ??
        item.findings_total ??
        0;
      if ((!total || total === 0) && totalFromSev > 0) {
        total = totalFromSev;
      }

      let highCrit =
        item.crit_high ??
        item.critical_high ??
        item.high_crit ??
        0;
      if ((!highCrit || highCrit === 0) && totalFromSev > 0) {
        highCrit = sevAgg.CRITICAL + sevAgg.HIGH;
      }

      series.push({
        label: String(label),
        total: Number(total || 0),
        highCrit: Number(highCrit || 0),
      });
    }

    console.log(LOG, "Trend series (final):", series);
    return series;
  }

  function extractCritHighByTool(model) {
    let labels = [];
    let values = [];

    let ch = model.critical_high_by_tool || model.by_tool_critical_high || {};
    if (ch.labels && ch.values) {
      labels = ch.labels.map(String);
      values = ch.values.map((v) => Number(v || 0));
    } else {
      for (const [tool, v] of Object.entries(ch)) {
        labels.push(tool);
        values.push(Number(v || 0));
      }
    }

    let sum = values.reduce((a, b) => a + b, 0);

    if (!labels.length || sum === 0) {
      const byTool =
        model.by_tool ||
        model.summary_by_tool ||
        (model.summary_all && model.summary_all.by_tool) ||
        {};
      const tmp = [];
      for (const [tool, obj] of Object.entries(byTool)) {
        const agg = {};
        for (const s of SEVERITY_ORDER) agg[s] = 0;
        addSeverityFromObject(agg, obj);
        const critHigh = agg.CRITICAL + agg.HIGH;
        if (critHigh > 0) tmp.push([tool, critHigh]);
      }
      tmp.sort((a, b) => b[1] - a[1]);
      const top = tmp.slice(0, 6);
      labels = top.map(([tool]) => tool);
      values = top.map(([, v]) => v);
    }

    console.log(LOG, "Critical+High by tool (final):", { labels, values });
    return { labels, values };
  }

  function extractTopCwe(model) {
    const arr = model.top_cwe || model.topCwe || [];
    const list = [];
    for (const item of arr) {
      if (typeof item === "string") {
        list.push({ cwe: item, total: null });
      } else if (item && typeof item === "object") {
        list.push({
          cwe: item.cwe || item.id || item.code || "-",
          total: Number(
            item.count ?? item.total ?? item.findings ?? item.value ?? 0
          ),
        });
      }
    }
    console.log(LOG, "Top CWE (parsed):", list);
    return list;
  }

  // ========= RENDER =========

  function renderSeverityDonut(ctx, buckets) {
    const labels = [];
    const data = [];
    const bg = [];
    for (const sev of SEVERITY_ORDER) {
      labels.push(sev);
      data.push(buckets[sev] || 0);
      bg.push(SEVERITY_COLORS[sev] || "#6b7280");
    }
    new Chart(ctx, {
      type: "doughnut",
      data: { labels, datasets: [{ data, backgroundColor: bg }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: "60%",
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: "#e5e7eb", font: { size: 10 } },
          },
          tooltip: {
            callbacks: {
              label: (info) => {
                const v = info.parsed;
                const total = data.reduce((a, b) => a + b, 0) || 1;
                const pct = ((v * 100) / total).toFixed(1);
                return `${info.label}: ${v} (${pct}%)`;
              },
            },
          },
        },
      },
    });
  }

  function renderTrendLine(ctx, series) {
    const parent = ctx.canvas.parentElement || ctx.canvas;
    if (!series.length) {
      parent.innerHTML =
        '<div class="vsp-preview-note"><strong>Preview.</strong> Chưa có dữ liệu lịch sử đủ để vẽ trend. Hãy chạy thêm vài lần scan để biểu đồ này bật lên.</div>';
      console.log(LOG, "Trend: no series, show preview text.");
      return;
    }
    const sum = series.reduce((a, s) => a + (s.total || 0) + (s.highCrit || 0), 0);
    if (!sum) {
      parent.innerHTML =
        '<div class="vsp-preview-note"><strong>Preview.</strong> Hiện tại tất cả total/high-risk đều bằng 0 – biểu đồ trend sẽ bật khi có findings.</div>';
      console.log(LOG, "Trend: all zeros, show preview text.");
      return;
    }

    const labels = series.map((s) => s.label);
    const totals = series.map((s) => s.total);
    const highs  = series.map((s) => s.highCrit);

    new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Total findings",
            data: totals,
            borderWidth: 2,
            tension: 0.3,
          },
          {
            label: "Critical + High",
            data: highs,
            borderWidth: 2,
            tension: 0.3,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: "#e5e7eb", font: { size: 10 } },
          },
          tooltip: { mode: "index", intersect: false },
        },
        scales: {
          x: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { display: false },
          },
          y: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { color: "rgba(148,163,184,0.25)" },
          },
        },
      },
    });
  }

  function renderCritHighByToolBar(ctx, data) {
    const parent = ctx.canvas.parentElement || ctx.canvas;
    const labels = data.labels || [];
    const values = data.values || [];
    const sum = values.reduce((a, b) => a + b, 0);

    if (!labels.length || !sum) {
      parent.innerHTML =
        '<div class="vsp-preview-note"><strong>Preview.</strong> Chưa có phân bố CRITICAL/HIGH theo tool. Khi có findings CRIT/HIGH, biểu đồ này sẽ hiển thị tool nào rủi ro nhất.</div>';
      console.log(LOG, "By-tool: no data, show preview text.");
      return;
    }

    new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            label: "Critical + High",
            data: values,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { mode: "nearest", intersect: true },
        },
        scales: {
          x: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { display: false },
          },
          y: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { color: "rgba(148,163,184,0.25)" },
          },
        },
      },
    });
  }

  function renderTopCweBar(ctx, list) {
    if (!list.length) {
      console.warn(LOG, "Top CWE: no data – để nguyên placeholder.");
      return;
    }
    const labels = list.map((x) => x.cwe);
    const values = list.map((x) => x.total ?? 0);

    new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            label: "Findings",
            data: values,
          },
        ],
      },
      options: {
        indexAxis: "y",
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { mode: "nearest", intersect: true },
        },
        scales: {
          x: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { color: "rgba(148,163,184,0.25)" },
          },
          y: {
            ticks: { color: "#9ca3af", font: { size: 10 } },
            grid: { display: false },
          },
        },
      },
    });
  }

  async function initCharts() {
    if (typeof Chart === "undefined") {
      console.warn(LOG, "Chart.js chưa được load (window.Chart undefined).");
      return;
    }

    try {
      const model = await fetchDashboardModel();

      const buckets = extractSeverityBuckets(model);
      const trend   = extractTrendSeries(model);
      const byTool  = extractCritHighByTool(model);
      const topCwe  = extractTopCwe(model);

      const cvsSeverity = ensureChartCanvas("SEVERITY DISTRIBUTION (6 LEVELS)", "vsp-chart-severity");
      if (cvsSeverity) {
        renderSeverityDonut(cvsSeverity.getContext("2d"), buckets);
      }

      const cvsTrend = ensureChartCanvas("TREND OVER TIME", "vsp-chart-trend");
      if (cvsTrend) {
        renderTrendLine(cvsTrend.getContext("2d"), trend);
      }

      const cvsTool = ensureChartCanvas("CRITICAL & HIGH BY TOOL", "vsp-chart-bytool");
      if (cvsTool) {
        renderCritHighByToolBar(cvsTool.getContext("2d"), byTool);
      }

      const cvsCwe = ensureChartCanvas("TOP CWE EXPOSURE", "vsp-chart-topcwe");
      if (cvsCwe) {
        renderTopCweBar(cvsCwe.getContext("2d"), topCwe);
      }
    } catch (e) {
      console.warn(LOG, "Init charts error:", e);
    }
  }

  function start() {
    let tries = 0;
    const maxTries = 30;
    const timer = setInterval(() => {
      const tab = document.querySelector("#vsp-tab-dashboard");
      if (tab && typeof Chart !== "undefined") {
        clearInterval(timer);
        initCharts();
      } else if (++tries >= maxTries) {
        clearInterval(timer);
        console.warn(LOG, "Give up sau", tries, "lần – không thấy tab hoặc Chart.js.");
      }
    }, 400);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", start);
  } else {
    start();
  }
})();
