"use strict";

console.log("[VSP][CHARTS] vsp_dashboard_charts_v1.js loaded.");

(function () {
  if (typeof Chart === "undefined") {
    console.error("[VSP][CHARTS][ERR] Chart.js not found on window.Chart");
    return;
  }

  const DASHBOARD_API = "/api/vsp/dashboard_v3";

  const SEVERITY_LEVELS = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"];
  const SEVERITY_LABELS = {
    CRITICAL: "Critical",
    HIGH: "High",
    MEDIUM: "Medium",
    LOW: "Low",
    INFO: "Info",
    TRACE: "Trace",
  };
  const SEVERITY_COLORS = {
    CRITICAL: "#ff4d4f",
    HIGH: "#fa8c16",
    MEDIUM: "#faad14",
    LOW: "#52c41a",
    INFO: "#40a9ff",
    TRACE: "#bfbfbf",
  };

  function safeGet(obj, path, fallback) {
    try {
      return path.split(".").reduce((acc, key) => (acc && acc[key] != null ? acc[key] : undefined), obj) ?? fallback;
    } catch (e) {
      return fallback;
    }
  }

  function extractSevCount(entry) {
    if (typeof entry === "number") return entry;
    if (entry && typeof entry === "object") {
      if (typeof entry.open === "number") return entry.open;
      if (typeof entry.count === "number") return entry.count;
      if (typeof entry.total === "number") return entry.total;
    }
    return 0;
  }

  // ========= TÌM CARD & TẠO CANVAS THEO TIÊU ĐỀ ==========

  function findElementByText(substring) {
    const needle = (substring || "").toLowerCase();
    if (!needle) return null;

    const all = document.querySelectorAll("h1,h2,h3,h4,h5,h6,div,span");
    for (const el of all) {
      const txt = (el.textContent || "").trim().toLowerCase();
      if (!txt) continue;
      if (txt.length > 200) continue;
      if (txt.includes(needle)) return el;
    }
    return null;
  }

  function ensureCanvasForCard(titleSubstring, canvasId, minHeight) {
    const header = findElementByText(titleSubstring);
    if (!header) {
      console.warn("[VSP][CHARTS] Không tìm thấy card cho title:", titleSubstring);
      return null;
    }

    let card =
      header.closest(".vsp-card, .vsp-dashboard-card, .vsp-grid-item") ||
      header.closest("section, article") ||
      header.parentElement;

    if (!card) {
      console.warn("[VSP][CHARTS] Không xác định được container cho title:", titleSubstring);
      return null;
    }

    // body chính chứa chart
    let body =
      card.querySelector(".vsp-card-body, .vsp-chart-body, .vsp-chart-wrapper") ||
      card.querySelector(".vsp-card-content") ||
      card;

    // DỌN placeholder dotted nếu có
    const placeholders = card.querySelectorAll(
      ".vsp-chart-placeholder, .vsp-chart-placeholder-inner, .vsp-chart-border, .vsp-chart-dotted"
    );
    placeholders.forEach((el) => {
      el.style.display = "none";
    });

    body.classList.remove("vsp-chart-empty");
    body.classList.add("vsp-chart-has-data");
    body.style.backgroundImage = "none";
    body.style.borderStyle = "none";
    body.style.position = "relative";
    card.style.borderStyle = "none";

    let canvas =
      body.querySelector("canvas#" + canvasId) ||
      body.querySelector('canvas[data-vsp-chart="' + canvasId + '"]');

    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = canvasId;
      canvas.dataset.vspChart = canvasId;
      body.appendChild(canvas);
    }

    const h = minHeight || 220;
    canvas.height = h;
    canvas.style.height = h + "px";
    canvas.style.width = "100%";
    canvas.style.display = "block";
    body.style.minHeight = h + "px";
    body.style.display = "block";

    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.warn("[VSP][CHARTS] getContext(2d) failed for", canvasId);
      return null;
    }
    return ctx;
  }

  // ========= SEVERITY DONUT ==========

  function deriveSeverityBuckets(model) {
    const buckets = {};
    const src1 = safeGet(model, "summary_by_severity", null);
    const src2 = safeGet(model, "by_severity", null);
    const src3 = safeGet(model, "summary_all.by_severity", null);

    const src = src1 || src2 || src3 || {};

    SEVERITY_LEVELS.forEach((sev) => {
      const entry = src[sev] ?? 0;
      buckets[sev] = extractSevCount(entry);
    });

    return buckets;
  }

  function renderSeverityDonut(model) {
    const ctx = ensureCanvasForCard("Severity distribution", "vsp-chart-severity-donut", 220);
    if (!ctx) return null;

    const buckets = deriveSeverityBuckets(model);
    const data = SEVERITY_LEVELS.map((sev) => buckets[sev] || 0);

    console.log("[VSP][CHARTS] Severity buckets:", buckets);

    return new Chart(ctx, {
      type: "doughnut",
      data: {
        labels: SEVERITY_LEVELS.map((sev) => SEVERITY_LABELS[sev]),
        datasets: [
          {
            data,
            backgroundColor: SEVERITY_LEVELS.map((sev) => SEVERITY_COLORS[sev]),
            borderWidth: 0,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "bottom",
            labels: {
              usePointStyle: true,
            },
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                const label = context.label || "";
                const value = context.raw || 0;
                return `${label}: ${value}`;
              },
            },
          },
        },
        cutout: "60%",
      },
    });
  }

  // ========= CRITICAL + HIGH BY TOOL ==========

  function deriveCritHighByTool(model) {
    const byTool =
      safeGet(model, "by_tool", null) ||
      safeGet(model, "summary_by_tool", null) ||
      {};

    const labels = [];
    const values = [];

    Object.keys(byTool).forEach((tool) => {
      const t = byTool[tool] || {};
      const bySev = t.by_severity || t.severity || {};

      const crit = extractSevCount(bySev["CRITICAL"]);
      const high = extractSevCount(bySev["HIGH"]);
      const total = crit + high;

      if (total > 0) {
        labels.push(tool);
        values.push(total);
      }
    });

    return { labels, values };
  }

  function renderCriticalHighByTool(model) {
    const ctx = ensureCanvasForCard(
      "Critical & High by tool",
      "vsp-chart-critical-high-by-tool",
      220
    );
    if (!ctx) return null;

    const { labels, values } = deriveCritHighByTool(model);

    console.log("[VSP][CHARTS] Critical+High by tool:", { labels, values });

    if (!labels.length) {
      console.warn("[VSP][CHARTS] No Critical/High data by tool to render.");
      return null;
    }

    return new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            label: "Critical + High findings",
            data: values,
            borderWidth: 1,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              autoSkip: false,
              maxRotation: 45,
              minRotation: 0,
            },
          },
          y: {
            beginAtZero: true,
          },
        },
        plugins: {
          legend: {
            display: false,
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                const value = context.raw || 0;
                return `Critical+High: ${value}`;
              },
            },
          },
        },
      },
    });
  }

  // ========= TOP CWE (BAR NGANG) ==========

  function deriveTopCwe(model, limit) {
    const list = safeGet(model, "top_cwe", []) || [];
    let arr = [];

    if (Array.isArray(list)) {
      arr = list
        .map((item) => {
          if (!item) return null;
          const id = item.id || item.cwe || item.name;
          const value = extractSevCount(item);
          return id ? { id, value } : null;
        })
        .filter(Boolean);
    } else if (list && typeof list === "object") {
      arr = Object.keys(list).map((k) => {
        const v = list[k] || {};
        return { id: k, value: extractSevCount(v) };
      });
    }

    arr.sort((a, b) => b.value - a.value);
    return arr.slice(0, limit);
  }

  function renderTopCwe(model) {
    const ctx = ensureCanvasForCard("Top CWE exposure", "vsp-chart-top-cwe", 220);
    if (!ctx) return null;

    const top = deriveTopCwe(model, 8);
    console.log("[VSP][CHARTS] Top CWE:", top);

    if (!top.length) {
      console.warn("[VSP][CHARTS] No Top CWE data to render.");
      return null;
    }

    const labels = top.map((x) => x.id);
    const values = top.map((x) => x.value);

    return new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            data: values,
            borderWidth: 1,
          },
        ],
      },
      options: {
        indexAxis: "y",
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false,
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                const value = context.raw || 0;
                return `Findings: ${value}`;
              },
            },
          },
        },
        scales: {
          x: {
            beginAtZero: true,
          },
        },
      },
    });
  }

  // ========= TREND OVER TIME (LINE) ==========

  function deriveTrend(model, limit) {
    const runs = safeGet(model, "runs_recent", []) || [];
    if (!Array.isArray(runs) || !runs.length) return [];

    const slice = runs.slice(-limit);
    return slice.map((r, idx) => {
      const label =
        r.label ||
        r.short_id ||
        r.run_id ||
        `#${runs.length - slice.length + idx + 1}`;

      const total =
        (typeof r.total_findings === "number" && r.total_findings) ||
        safeGet(r, "summary_all.total", 0);

      const sevMap =
        safeGet(r, "by_severity", null) ||
        safeGet(r, "summary_by_severity", null) ||
        {};

      const crit = extractSevCount(sevMap["CRITICAL"]);
      const high = extractSevCount(sevMap["HIGH"]);
      const critHigh = crit + high;

      return { label, total, critHigh };
    });
  }

  function renderTrend(model) {
    const ctx = ensureCanvasForCard("Trend over time", "vsp-chart-trend", 260);
    if (!ctx) return null;

    const series = deriveTrend(model, 20);
    console.log("[VSP][CHARTS] Trend series:", series);

    if (!series.length) {
      console.warn("[VSP][CHARTS] No trend data to render.");
      return null;
    }

    const labels = series.map((p) => p.label);
    const totals = series.map((p) => p.total);
    const critHigh = series.map((p) => p.critHigh);

    return new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Total findings",
            data: totals,
            borderWidth: 2,
            tension: 0.25,
          },
          {
            label: "Critical + High",
            data: critHigh,
            borderWidth: 2,
            tension: 0.25,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "bottom",
          },
        },
        scales: {
          x: {
            ticks: {
              autoSkip: true,
              maxRotation: 45,
              minRotation: 0,
            },
          },
          y: {
            beginAtZero: true,
          },
        },
      },
    });
  }

  // ========= INIT ==========

  async function initCharts() {
    try {
      console.log("[VSP][CHARTS] Loading charts data from", DASHBOARD_API, "...");
      const resp = await fetch(DASHBOARD_API);
      if (!resp.ok) {
        console.error("[VSP][CHARTS][ERR] Failed to fetch dashboard_v3:", resp.status, resp.statusText);
        return;
      }
      const data = await resp.json();
      console.log("[VSP][CHARTS] Render charts với model", data);

      const severityChart = renderSeverityDonut(data);
      const critHighChart = renderCriticalHighByTool(data);
      const trendChart = renderTrend(data);
      const topCweChart = renderTopCwe(data);

      window.vspCharts = {
        severityChart,
        critHighChart,
        trendChart,
        topCweChart,
      };
    } catch (err) {
      console.error("[VSP][CHARTS][ERR] Unexpected error while loading charts:", err);
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initCharts);
  } else {
    initCharts();
  }
})();
