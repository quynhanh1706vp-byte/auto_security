from __future__ import annotations

from flask import Blueprint, jsonify, request
CORE_BASE = "http://localhost:8961"
from pathlib import Path
import json
from typing import Any, Dict, List, Optional

bp_v3 = Blueprint("vsp_api_core_v3", __name__)

# ROOT = /home/test/Data/SECURITY_BUNDLE
ROOT = Path(__file__).resolve().parent.parent
OUT_DIR = ROOT / "out"


def _iter_summary_files():
    """
    Duyệt tất cả summary_unified.json của các RUN_VSP_FULL_EXT_*.
    """
    if not OUT_DIR.exists():
        return []
    return sorted(
        OUT_DIR.glob("RUN_VSP_FULL_EXT_*/report/summary_unified.json"),
        key=lambda p: p.stat().st_mtime,
    )


def _get_latest_run_id() -> Optional[str]:
    """
    Lấy run mới nhất dựa trên mtime của summary_unified.json.
    """
    summaries = _iter_summary_files()
    if not summaries:
        return None
    latest = summaries[-1]
    # .../out/RUN_VSP_FULL_EXT_xxx/report/summary_unified.json
    return latest.parent.parent.name


def _load_json(path: Path) -> Any:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def _load_summary(run_id: str) -> Dict[str, Any]:
    summary_path = OUT_DIR / run_id / "report" / "summary_unified.json"
    if not summary_path.is_file():
        return {}
    data = _load_json(summary_path)
    # Chuẩn hóa total_findings
    if "total_findings" not in data:
        if "total" in data and isinstance(data["total"], int):
            data["total_findings"] = data["total"]
        elif "by_severity" in data and isinstance(data["by_severity"], dict):
            try:
                data["total_findings"] = int(sum(data["by_severity"].values()))
            except Exception:
                data["total_findings"] = 0
        else:
            data["total_findings"] = 0
    return data


def _load_findings(run_id: str) -> List[Dict[str, Any]]:
    findings_path = OUT_DIR / run_id / "report" / "findings_unified.json"
    if not findings_path.is_file():
        return []
    raw = _load_json(findings_path)
    if isinstance(raw, list):
        return raw
    if isinstance(raw, dict):
        # Một số tool unify kiểu {"items": [...]} hoặc {"findings": [...]}
        for key in ("items", "findings", "results"):
            if key in raw and isinstance(raw[key], list):
                return raw[key]
    return []


def _pick_top_key(counts: Dict[str, Any]) -> Optional[str]:
    if not isinstance(counts, dict) or not counts:
        return None
    try:
        return max(counts.items(), key=lambda kv: kv[1])[0]
    except Exception:
        return None


@bp_v3.route("/api/vsp/dashboard_v3", methods=["GET"])
def api_vsp_dashboard_v3():
    """
    Dashboard V3:
      - KPI cho run mới nhất (TOTAL, severity, tool, score, top_*).
      - trend: 10 run gần nhất (cũ → mới) cho line chart.
      - last_runs: 10 run mới nhất (mới → cũ) cho bảng history.
    """
    from flask import jsonify
    from pathlib import Path
    from collections import Counter
    from datetime import datetime
    import json

    root = Path(__file__).resolve().parents[1]   # /home/test/Data/SECURITY_BUNDLE
    out_dir = root / "out"

    def _load_summary(run_dir: Path):
        if not run_dir:
            return None
        for p in [
            run_dir / "report" / "summary_unified.json",
            run_dir / "summary_unified.json",
        ]:
            if p.is_file():
                try:
                    return json.loads(p.read_text(encoding="utf-8"))
                except Exception:
                    pass
        return None

    def _load_findings(run_dir: Path):
        if not run_dir:
            return []
        candidates = [
            run_dir / "report" / "findings_unified.json",
            run_dir / "findings_unified.json",
        ]
        for p in candidates:
            if p.is_file():
                try:
                    data = json.loads(p.read_text(encoding="utf-8"))
                except Exception:
                    continue
                if isinstance(data, list):
                    return data
                if isinstance(data, dict) and isinstance(data.get("items"), list):
                    return data["items"]
        return []

    # ===== Lấy danh sách run =====
    if not out_dir.is_dir():
        return jsonify({
            "ok": True,
            "run_id": None,
            "total_findings": 0,
            "by_severity": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0, "TRACE": 0},
            "by_tool": {},
            "security_score": 0,
            "top_risky_tool": None,
            "top_cwe": None,
            "top_module": None,
            "trend": [],
            "last_runs": [],
        })

    runs = [d for d in out_dir.iterdir() if d.is_dir() and d.name.startswith("RUN_VSP_FULL_EXT_")]
    if not runs:
        return jsonify({
            "ok": True,
            "run_id": None,
            "total_findings": 0,
            "by_severity": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0, "TRACE": 0},
            "by_tool": {},
            "security_score": 0,
            "top_risky_tool": None,
            "top_cwe": None,
            "top_module": None,
            "trend": [],
            "last_runs": [],
        })

    # sort theo timestamp trong tên (…_YYYYmmdd_HHMMSS); fallback mtime → cũ → mới
    from datetime import datetime

    def _run_ts_from_name(p: Path):
        name = p.name
        parts = name.split("_")
        if len(parts) >= 3:
            date_part = parts[-2]
            time_part = parts[-1]
            if date_part.isdigit() and time_part.isdigit():
                try:
                    return datetime.strptime(date_part + time_part, "%Y%m%d%H%M%S")
                except Exception:
                    pass
        # fallback: mtime
        return datetime.fromtimestamp(p.stat().st_mtime)

    runs_sorted = sorted(runs, key=_run_ts_from_name)
    latest_run = runs_sorted[-1]

    summary = _load_summary(latest_run) or {}
    findings_latest = _load_findings(latest_run)

    # KPI chính
    total = summary.get("total_findings") or summary.get("total") or len(findings_latest)
    by_sev = summary.get("by_severity") or summary.get("severity") or {}
    by_tool = summary.get("by_tool") or {}

    # nếu thiếu by_severity hoặc by_tool thì tự tính từ findings
    if (not by_sev or not isinstance(by_sev, dict)) and findings_latest:
        cnt = Counter()
        for it in findings_latest:
            sev = (it.get("severity_effective") or it.get("severity") or "INFO").upper()
            cnt[sev] += 1
        by_sev = dict(cnt)

    if (not by_tool or not isinstance(by_tool, dict)) and findings_latest:
        cnt = Counter()
        for it in findings_latest:
            tool = it.get("tool") or it.get("scanner") or "UNKNOWN"
            cnt[tool] += 1
        by_tool = dict(cnt)

    # đảm bảo đủ 6 bucket (0 nếu thiếu)
    for key in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]:
        by_sev.setdefault(key, 0)

    security_score = summary.get("security_score", 0)
    top_risky_tool = summary.get("top_risky_tool")
    top_cwe_single = summary.get("top_cwe") or summary.get("top_CWE")
    top_module = summary.get("top_module")

    # ===== trend + last_runs =====
    runs_info = []
    for rd in runs_sorted:
        s = _load_summary(rd) or {}
        t = s.get("total_findings") or s.get("total") or 0
        ts = s.get("ts") or s.get("timestamp")

        if not ts:
            parts = rd.name.split("_")
            if len(parts) >= 3:
                date_part = parts[-2]
                time_part = parts[-1]
                try:
                    dt = datetime.strptime(date_part + time_part, "%Y%m%d%H%M%S")
                    ts = dt.isoformat()
                except Exception:
                    ts = None

        runs_info.append({
            "run_id": rd.name,
            "total_findings": t,
            "ts": ts,
        })

    # last_runs: 10 run mới nhất (mới → cũ)
    last_runs = list(reversed(runs_info))[:10]

    # trend: 10 run gần nhất (cũ → mới)
    trend_src = list(reversed(last_runs))
    trend = [
        {
            "index": idx + 1,
            "run_id": r["run_id"],
            "total_findings": r["total_findings"],
            "label": f"Run {idx+1}",
        }
        for idx, r in enumerate(trend_src)
    ]

    resp = {
        "ok": True,
        "run_id": latest_run.name,
        "total_findings": total,
        "by_severity": by_sev,
        "by_tool": by_tool,
        "security_score": security_score,
        "top_risky_tool": top_risky_tool,
        "top_cwe": top_cwe_single,
        "top_module": top_module,
        "trend": trend,
        "last_runs": last_runs,
    }
    return jsonify(resp)

@bp_v3.route("/api/vsp/runs_index_v3", methods=["GET"])
def runs_index_v3():
    from flask import jsonify
    from pathlib import Path
    import json

    cur = Path(__file__).resolve()
    ROOT = None
    for p in cur.parents:
        if (p / "out").is_dir():
            ROOT = p
            break
    if ROOT is None:
        ROOT = cur.parents[1]
    out_dir = ROOT / "out"
    runs = sorted(out_dir.glob("RUN_VSP_FULL_EXT_*"), reverse=True)

    items = []
    for r in runs:
        summary_path = r / "report" / "summary_unified.json"
        if not summary_path.is_file():
            continue
        try:
            s = json.loads(summary_path.read_text(encoding="utf-8"))
        except Exception:
            continue

        items.append({
            "run_id": s.get("run_id") or r.name,
            "total_findings": s.get("total_findings", 0),
            "sbom_total": s.get("sbom_total", 0),
            "by_tool": s.get("by_tool", {}),
            "by_severity": s.get("by_severity", {}),
            "security_score": s.get("security_score", 0),
            "top_cwe": s.get("top_cwe"),
        })

    return jsonify(items)

@bp_v3.route("/api/vsp/datasource_v2", methods=["GET"])
def datasource_v2():
    from flask import request, jsonify
    from pathlib import Path
    import json

    cur = Path(__file__).resolve()
    ROOT = None
    for p in cur.parents:
        if (p / "out").is_dir():
            ROOT = p
            break
    if ROOT is None:
        ROOT = cur.parents[1]
    out_dir = ROOT / "out"

    run_dir = request.args.get("run_dir", "").strip()
    limit = request.args.get("limit", "").strip()
    offset = request.args.get("offset", "").strip()

    try:
        limit_val = int(limit) if limit else None
    except ValueError:
        limit_val = None
    try:
        offset_val = int(offset) if offset else 0
    except ValueError:
        offset_val = 0

    if run_dir:
        run_path = Path(run_dir)
    else:
        runs = sorted(out_dir.glob("RUN_VSP_FULL_EXT_*"), reverse=True)
        if not runs:
            return jsonify(ok=False, error="No runs found")
        run_path = runs[0]

    findings_path = run_path / "report" / "findings_unified.json"
    if not findings_path.is_file():
        return jsonify(ok=False, error=f"findings_unified.json not found for {run_path}")

    try:
        data = json.loads(findings_path.read_text(encoding="utf-8"))
    except Exception as e:
        return jsonify(ok=False, error=f"Parse error: {e}")

    # Hỗ trợ cả dạng list và dạng { "items": [...] }
    if isinstance(data, list):
        items = data
    elif isinstance(data, dict):
        items = data.get("items") or []
    else:
        items = []

    total = len(items)
    start = offset_val if offset_val >= 0 else 0
    end = start + limit_val if (limit_val is not None and limit_val > 0) else total
    sliced = items[start:end]

    return jsonify(
        ok=True,
        items=sliced,
        count=total,
        limit=limit_val,
        offset=offset_val,
        run_dir=str(run_path),
    )

@bp_v3.route("/api/vsp/datasource", methods=["GET"])
def api_vsp_datasource_legacy():
    """
    Legacy datasource cho các call:
    - /api/vsp/datasource?mode=dashboard
    - /api/vsp/datasource?severity=CRITICAL&limit=1
    """
    # Dùng chung logic với datasource_v2
    return api_vsp_datasource_v2()


@bp_v3.route("/api/vsp/trend_v1", methods=["GET"])
def api_vsp_trend_v1():
    """
    Trend theo từng run: run_id, total, ts/label.
    """
    points: List[Dict[str, Any]] = []
    for summary_path in _iter_summary_files():
        run_id = summary_path.parent.parent.name
        summary = _load_json(summary_path)
        by_severity = summary.get("by_severity") or {}
        total_findings = summary.get("total_findings")
        if not isinstance(total_findings, int):
            try:
                total_findings = int(sum(by_severity.values()))
            except Exception:
                total_findings = 0

        ts = summary.get("ts") or None
        label = summary.get("label") or run_id

        points.append(
            {
                "run_id": run_id,
                "total": total_findings,
                "ts": ts,
                "label": label,
            }
        )

    # Sort theo ts nếu có, không thì sort theo run_id
    def _key(p: Dict[str, Any]):
        return (p.get("ts") or "", p.get("run_id") or "")

    points = sorted(points, key=_key)
    return jsonify({"ok": True, "points": points}), 200

@bp_v3.route("/api/vsp/top_cwe_v1")
def proxy_top_cwe_v1():
    """
    Proxy Insights Top CWE từ core 8961 ra UI 8910.
    """
    import requests
    from flask import jsonify, request, current_app

    try:
        resp = requests.get(
            f"{CORE_BASE}/api/vsp/insights/top_cwe_v1",
            params=request.args,
            timeout=15,
        )
        return (resp.content, resp.status_code, resp.headers.items())
    except Exception as e:
        current_app.logger.warning("[VSP][PROXY] top_cwe_v1 error: %s", e)
        return jsonify({"ok": False, "error": "proxy_failed"}), 502

# ======================= VSP_OVERRIDES_BE_V1 =======================
# API: GET /api/vsp/overrides/list
# Mục tiêu: trả về danh sách rule overrides để UI Rule Overrides tab hiển thị.

@bp_v3.route("/api/vsp/overrides/list", methods=["GET"])
def api_vsp_overrides_list():
    """Stub overrides list - phase 1.
    Trả dữ liệu mẫu, sau này có thể thay bằng load từ file JSON hoặc DB.

    JSON schema (tham khảo):
      {
        "ok": true,
        "profile": "EXT+",
        "total_overrides": 2,
        "items": [ ... ]
      }
    """
    sample = {
        "ok": True,
        "profile": "EXT+",
        "total_overrides": 2,
        "items": [
            {
                "id": "GITLEAKS_GENERIC_SECRET",
                "tool": "gitleaks",
                "current_severity": "HIGH",
                "override_severity": "LOW",
                "scope": "path:^tests/",
                "description": "Giảm mức cho test data",
                "active": True,
                "affected_count": 23,
            },
            {
                "id": "SEMGREP_PYTHON_SQL",
                "tool": "semgrep",
                "current_severity": "MEDIUM",
                "override_severity": "CRITICAL",
                "scope": None,
                "description": "Tăng mức cho SQL injection patterns",
                "active": True,
                "affected_count": 5,
            },
        ],
    }
    return jsonify(sample)

