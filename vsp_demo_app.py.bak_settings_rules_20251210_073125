from api.vsp_run_export_api_v3 import bp_run_export_v3
#!/usr/bin/env python
import os
import subprocess
from pathlib import Path

from flask import (
    Flask,
    render_template,
    request,
    jsonify,
    Response,
)
import requests

# === Config chung ===
ROOT = Path(__file__).resolve().parents[1]  # /home/test/Data/SECURITY_BUNDLE
CORE_BASE = "http://localhost:8961"         # Core API (dashboard_v3, runs_index_v3, datasource_v2)

app = Flask(
    __name__,
    static_folder="static",
    template_folder="templates",
)


# === Helper proxy sang core 8961 ===
def proxy_get(path: str) -> Response:
    """
    Proxy GET từ 8910 -> 8961, giữ nguyên query string.
    """
    core_url = CORE_BASE + path
    try:
        resp = requests.get(core_url, params=request.args, timeout=60)
    except Exception as e:
        return jsonify(ok=False, error=f"Proxy error to core {core_url}: {e}"), 502

    headers = {}
    ct = resp.headers.get("Content-Type")
    if ct:
        headers["Content-Type"] = ct
    return Response(resp.content, status=resp.status_code, headers=headers)


# === Routes UI chính ===

@app.route("/")
def index():
    # Trang VSP 5 tab (index.html đã là layout mới)
    return render_template("index.html")


@app.route("/security_bundle")
def security_bundle():
    # Giữ route cũ nếu có chỗ nào gọi
    return render_template("index.html")


# === Proxy API: dashboard_v3, runs_index_v3, datasource_v2 ===

@app.route("/api/vsp/dashboard_v3", methods=["GET"])
def api_vsp_dashboard_v3():
    return proxy_get("/api/vsp/dashboard_v3")


@app.route("/api/vsp/runs_index_v3", methods=["GET"])
def api_vsp_runs_index_v3():
    return proxy_get("/api/vsp/runs_index_v3")


@app.route("/api/vsp/datasource_v2", methods=["GET"])
def api_vsp_datasource_v2():
    # Proxy đúng sang core, giữ nguyên run_dir, limit, filters,...
    return proxy_get("/api/vsp/datasource_v2")


# === RUN FULL SCAN EXT+ – gọi bin/vsp_selfcheck_full.sh ===

@app.route("/api/vsp/run_full_scan", methods=["POST", "OPTIONS"])
def api_vsp_run_full_scan():
    """
    Nhận JSON:
      {
        "profile": "EXT" | "FAST" | "AGGR" | "FULL" | ...,
        "source_root": "/home/test/Data/khach6",
        "target_url": "https://demo.demasterpro.com"
      }

    Gọi: bin/vsp_selfcheck_full.sh <profile> <source_root> <target_url>
    cwd = /home/test/Data/SECURITY_BUNDLE
    """
    if request.method == "OPTIONS":
        # Đơn giản trả 200 cho preflight nếu có
        return ("", 200)

    data = request.get_json(silent=True) or {}

    profile = data.get("profile") or "FULL_EXT"
    source_root = data.get("source_root") or data.get("src_path") or str(ROOT / "khach6")
    target_url = data.get("target_url") or data.get("url") or "https://demo.demasterpro.com"

    script = ROOT / "bin" / "vsp_selfcheck_full.sh"

    if not script.is_file():
        return jsonify(
            ok=False,
            error=f"Script không tồn tại: {script}",
        ), 500

    # Đảm bảo script có quyền execute
    try:
        os.chmod(str(script), 0o755)
    except Exception:
        pass

    try:
        proc = subprocess.Popen(
            [str(script), profile, source_root, target_url],
            cwd=str(ROOT),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except Exception as e:
        return jsonify(ok=False, error=f"Lỗi chạy {script}: {e}"), 500

    return jsonify(
        ok=True,
        pid=proc.pid,
        profile=profile,
        source_root=source_root,
        target_url=target_url,
    )


# === Healthcheck đơn giản (tuỳ chọn) ===
@app.route("/health")
def health():
    return jsonify(ok=True, app="vsp_demo_app", core=CORE_BASE)


# VSP_RUN_EXPORT_DIRECT_V1_BEGIN
from flask import send_file, request, jsonify, render_template
import io, json, zipfile, subprocess, shutil
from pathlib import Path

@app.route("/api/vsp/run_export_v3", methods=["GET"])
def vsp_run_export_v3():
    """
    Direct export HTML/PDF/ZIP cho 1 RUN_...
    - fmt=html -> RUN_..._vsp_report.html
    - fmt=pdf  -> RUN_..._vsp_report.pdf (cần wkhtmltopdf)
    - fmt=zip  -> RUN_..._vsp_full_bundle.zip (nguyên thư mục out/RUN_...)
    """
    run_id = request.args.get("run_id")
    fmt = (request.args.get("fmt") or "html").lower()

    if not run_id:
        return jsonify(ok=False, error="Missing run_id"), 400

    # ROOT = thư mục SECURITY_BUNDLE, out chứa RUN_VSP_FULL_EXT_*
    root = Path(__file__).resolve().parents[1] / "out"
    run_dir = root / run_id

    if not run_dir.is_dir():
        return jsonify(ok=False, error=f"Run directory not found: {run_dir}"), 404

    summary_path = run_dir / "report" / "summary_unified.json"
    if not summary_path.is_file():
        return jsonify(ok=False, error="report/summary_unified.json not found"), 500

    # Đọc summary 1 lần
    with summary_path.open("r", encoding="utf-8") as f:
        summary = json.load(f)

    if fmt == "html":
        html = render_template(
            "vsp_run_report_cio_v3.html",
            run_id=run_id,
            summary=summary,
        )
        return app.response_class(
            html,
            mimetype="text/html",
            headers={
                "Content-Disposition": f"attachment; filename={run_id}_vsp_report.html"
            },
        )

    if fmt == "pdf":
        # Yêu cầu wkhtmltopdf
        if shutil.which("wkhtmltopdf") is None:
            return jsonify(ok=False, error="wkhtmltopdf not installed"), 500

        html = render_template(
            "vsp_run_report_cio_v3.html",
            run_id=run_id,
            summary=summary,
        )
        pdf_bytes = subprocess.check_output(
            ["wkhtmltopdf", "-", "-"],
            input=html.encode("utf-8"),
        )
        return send_file(
            io.BytesIO(pdf_bytes),
            mimetype="application/pdf",
            as_attachment=True,
            download_name=f"{run_id}_vsp_report.pdf",
        )

    if fmt == "zip":
        buf = io.BytesIO()
        # Zip nguyên thư mục RUN_... (giữ luôn tên RUN_... ở root trong zip)
        with zipfile.ZipFile(buf, "w", compression=zipfile.ZIP_DEFLATED) as z:
            for path in run_dir.rglob("*"):
                if path.is_file():
                    # entry path: RUN_.../path/to/file
                    arcname = path.relative_to(run_dir.parent)
                    z.write(path, arcname)
        buf.seek(0)
        return send_file(
            buf,
            mimetype="application/zip",
            as_attachment=True,
            download_name=f"{run_id}_vsp_full_bundle.zip",
        )

    return jsonify(ok=False, error=f"Unsupported fmt={fmt}"), 400
# VSP_RUN_EXPORT_DIRECT_V1_END
if __name__ == "__main__":
    print("[VSP_RUN_FULL_SCAN_V3] Registered /api/vsp/run_full_scan trên app vsp_demo_app")
    app.run(host="0.0.0.0", port=8910, debug=True)


# === VSP_RUN_EXPORT_V3 auto patch ===
app.register_blueprint(bp_run_export_v3)

# === VSP_RUN_EXPORT_DIRECT_V1 ===
from flask import request, send_file, render_template, make_response, jsonify

@app.route("/api/vsp/run_export_v3", methods=["GET"])
def vsp_run_export_v3_direct():
    """
    Direct export HTML/PDF/ZIP cho 1 run – chạy trực tiếp trên UI gateway (8910).
    """
    from pathlib import Path
    import json, io, zipfile, subprocess, shutil

    ROOT = Path(__file__).resolve().parents[1]   # /home/test/Data/SECURITY_BUNDLE
    OUT_DIR = ROOT / "out"

    run_id = (request.args.get("run_id") or "").strip()
    fmt = (request.args.get("fmt") or "html").lower()

    if not run_id:
        return jsonify(ok=False, error="Missing run_id"), 400

    run_dir = OUT_DIR / run_id
    if not run_dir.is_dir():
        return jsonify(ok=False, error=f"Run dir not found: {run_dir}"), 404

    report_dir = run_dir / "report"
    summary_path = report_dir / "summary_unified.json"

    if summary_path.is_file():
        try:
            summary = json.loads(summary_path.read_text(encoding="utf-8"))
        except Exception:
            summary = {}
    else:
        summary = {}

    summary.setdefault("run_id", run_id)
    summary.setdefault("total_findings", 0)
    summary.setdefault("security_score", None)
    summary.setdefault("by_severity", {})
    summary.setdefault("by_tool", {})

    # HTML luôn generate trước
    html = render_template("vsp_run_report_cio_v3.html",
                           run_id=run_id,
                           summary=summary)

    # 1) HTML
    if fmt == "html":
        resp = make_response(html)
        resp.headers["Content-Type"] = "text/html; charset=utf-8"
        filename = f"{run_id}_vsp_report.html"
        if request.args.get("inline") == "1":
            # hiển thị trực tiếp
            pass
        else:
            resp.headers["Content-Disposition"] = f'attachment; filename="{filename}"'
        return resp

    # 2) PDF – dùng wkhtmltopdf nếu có
    if fmt == "pdf":
        if not shutil.which("wkhtmltopdf"):
            return jsonify(ok=False,
                           error="wkhtmltopdf not installed on server – cannot build PDF"), 500
        try:
            proc = subprocess.run(
                ["wkhtmltopdf", "-q", "-", "-"],
                input=html.encode("utf-8"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=False,
            )
            if proc.returncode != 0:
                return jsonify(
                    ok=False,
                    error="wkhtmltopdf failed",
                    stderr=proc.stderr.decode("utf-8", errors="ignore"),
                ), 500

            pdf_bytes = proc.stdout
            buf = io.BytesIO(pdf_bytes)
            buf.seek(0)
            return send_file(
                buf,
                mimetype="application/pdf",
                as_attachment=True,
                download_name=f"{run_id}_vsp_report.pdf",
            )
        except Exception as ex:
            return jsonify(ok=False, error=f"PDF export error: {ex}"), 500

    # 3) ZIP – bundle full run dir (evidence)
    if fmt == "zip":
        mem = io.BytesIO()
        with zipfile.ZipFile(mem, "w", compression=zipfile.ZIP_DEFLATED) as zf:
            for pth in run_dir.rglob("*"):
                if pth.is_file():
                    arc = pth.relative_to(run_dir)
                    zf.write(pth, arcname=str(arc))
        mem.seek(0)
        return send_file(
            mem,
            mimetype="application/zip",
            as_attachment=True,
            download_name=f"{run_id}_vsp_full_bundle.zip",
        )

    return jsonify(ok=False, error=f"Unsupported fmt: {fmt}"), 400


