from flask import Blueprint, request, jsonify, send_file
import os
import io
import zipfile
import json
import glob
import shutil
import tempfile
import subprocess
from datetime import datetime, timezone

bp_run_export_v3 = Blueprint("bp_run_export_v3", __name__)


@bp_run_export_v3.route("/api/vsp/run_export_v3", methods=["GET"])
def vsp_run_export_v3():
    """
    Direct export HTML/ZIP/PDF/CSV cho 1 run - chạy trên UI gateway (8910).
    """
    run_id = (request.args.get("run_id") or "").strip()
    fmt = (request.args.get("fmt") or "html").strip().lower()

    if not run_id:
        return jsonify({"ok": False, "error": "Missing run_id"}), 400

    # Thư mục out gốc: ưu tiên env VSP_OUT_ROOT, fallback ../out cạnh ui/
    base_out = os.environ.get("VSP_OUT_ROOT")
    if not base_out:
        base_out = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "out"))

    run_dir = os.path.join(base_out, run_id)
    if not os.path.isdir(run_dir):
        return jsonify({"ok": False, "error": f"Run dir not found: {run_dir}"}), 404

    report_dir = os.path.join(run_dir, "report")

    # HTML export
    if fmt == "html":
        candidates = [
            os.path.join(report_dir, "vsp_run_report_cio_v3.html"),
            os.path.join(report_dir, "vsp_run_report_cio_v2.html"),
            os.path.join(report_dir, "vsp_run_report_cio.html"),
            os.path.join(report_dir, "run_report.html"),
        ]
        for path in candidates:
            if os.path.isfile(path):
                return send_file(
                    path,
                    mimetype="text/html",
                    as_attachment=False,
                    download_name=os.path.basename(path),
                )

        # fallback – render summary_unified.json thành HTML đơn giản
        summary_path = os.path.join(report_dir, "summary_unified.json")
        summary = {}
        if os.path.isfile(summary_path):
            try:
                with open(summary_path, "r", encoding="utf-8") as f:
                    summary = json.load(f)
            except Exception:
                summary = {}

        body = json.dumps(
            summary or {"note": "No summary_unified.json found"},
            indent=2,
            ensure_ascii=False,
        )

        html = (
            "<html><head><meta charset='utf-8'>"
            f"<title>VSP run {run_id}</title></head><body>"
            f"<h1>VSP run {run_id}</h1>"
            f"<pre>{body}</pre>"
            "</body></html>"
        )

        return html

    # CSV export
    if fmt == "csv":
        csv_path = os.path.join(report_dir, "findings_unified.csv")
        if os.path.isfile(csv_path):
            return send_file(
                csv_path,
                mimetype="text/csv",
                as_attachment=True,
                download_name=f"{run_id}_findings.csv",
            )
        return jsonify({"ok": False, "error": "findings_unified.csv not found"}), 404

    # ZIP export
    if fmt == "zip":
        if not os.path.isdir(report_dir):
            return jsonify({"ok": False, "error": "report dir not found"}), 404

        mem = io.BytesIO()
        with zipfile.ZipFile(mem, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
            for root, _dirs, files in os.walk(report_dir):
                for fn in files:
                    full = os.path.join(root, fn)
                    rel = os.path.relpath(full, run_dir)
                    zf.write(full, rel)

        mem.seek(0)
        return send_file(
            mem,
            mimetype="application/zip",
            as_attachment=True,
            download_name=f"{run_id}_report.zip",
        )

    # PDF export (nếu có sẵn file PDF trong report/)
    if fmt == "pdf":
        if os.path.isdir(report_dir):
            for name in os.listdir(report_dir):
                if name.lower().endswith(".pdf"):
                    path = os.path.join(report_dir, name)
                    return send_file(
                        path,
                        mimetype="application/pdf",
                        as_attachment=True,
                        download_name=name,
                    )
        return jsonify({"ok": False, "error": "PDF report not found"}), 404

    return jsonify({"ok": False, "error": f"Unsupported fmt={fmt}"}), 400


### [COMMERCIAL] EXPORT_V3_COMMERCIAL_V2 ###
def _vsp_export_resolve_run_dir_best_effort(rid_norm: str):
    cands = []
    cands += glob.glob(f"/home/test/Data/SECURITY-*/out_ci/{rid_norm}")
    cands += glob.glob(f"/home/test/Data/*/out_ci/{rid_norm}")
    for x in cands:
        try:
            if os.path.isdir(x):
                return x
        except Exception:
            pass
    return None

def _vsp_export_try_pdf_wkhtmltopdf(url: str, timeout_sec: int = 180):
    exe = shutil.which("wkhtmltopdf")
    if not exe:
        return None, "wkhtmltopdf_missing"
    tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".pdf", delete=False)
    tmp.close()
    cmd = [exe, "--quiet", url, tmp.name]
    try:
        subprocess.run(cmd, timeout=timeout_sec, check=True)
        if os.path.isfile(tmp.name) and os.path.getsize(tmp.name) > 0:
            return tmp.name, None
        return None, "wkhtmltopdf_empty_output"
    except Exception as e:
        return None, f"wkhtmltopdf_failed:{type(e).__name__}"

# --- monkey patch: wrap original handler if it exists ---
try:
    _orig_run_export_v3 = run_export_v3  # type: ignore[name-defined]
except Exception:
    _orig_run_export_v3 = None

if _orig_run_export_v3:
    def run_export_v3(rid, *args, **kwargs):

        # [COMMERCIAL] on-demand export (fix HTML_NOT_FOUND/ZIP_NOT_FOUND and enable PDF via wkhtmltopdf)
        try:
            fmt = (request.args.get("fmt") or "html").lower()
            rid_norm = rid.replace("RUN_","") if isinstance(rid,str) else str(rid)
            run_dir = _resolve_run_dir_best_effort(rid_norm)
            if run_dir and os.path.isdir(run_dir):
                report_dir, csv_path, json_path = _ensure_report_files(run_dir)
                html_file = _build_export_html(report_dir, csv_path, json_path, rid_norm)
                if fmt == "html":
                    resp = send_file(html_file, mimetype="text/html", as_attachment=True, download_name=f"{rid_norm}.html")
                    resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
                    resp.headers["X-VSP-EXPORT-MODE"] = "ONDEMAND_V2"
                    return resp
                if fmt == "zip":
                    z = _zip_dir(report_dir)
                    resp = send_file(z, mimetype="application/zip", as_attachment=True, download_name=f"{rid_norm}.zip")
                    resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
                    resp.headers["X-VSP-EXPORT-MODE"] = "ONDEMAND_V2"
                    return resp
                if fmt == "pdf":
                    pdf_path, err = _pdf_wkhtmltopdf(html_file, timeout_sec=180)
                    if pdf_path:
                        resp = send_file(pdf_path, mimetype="application/pdf", as_attachment=True, download_name=f"{rid_norm}.pdf")
                        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
                        resp.headers["X-VSP-EXPORT-MODE"] = "ONDEMAND_V2"
                        return resp
                    resp = jsonify({"ok": False, "error": "pdf_export_failed", "detail": err, "run_dir": run_dir})
                    resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
                    return resp, 500
        except Exception as e:
            # do not silently fallback to stub (pdf_not_enabled)
            detail = f"{type(e).__name__}:{e}"
            resp = jsonify({"ok": False, "error": "export_ondemand_exception", "detail": detail})
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
            resp.headers["X-VSP-EXPORT-MODE"] = "ONDEMAND_V2_EXCEPTION"
            return resp, 500
        # do not silently fallback to stub (pdf_not_enabled)
        resp = jsonify({"ok": False, "error": "export_ondemand_exception", "detail": f"{type(e).__name__}:{e}"})
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        resp.headers["X-VSP-EXPORT-MODE"] = "ONDEMAND_V2_EXCEPTION"
        return resp, 500

  # noqa: F811
        # keep original behavior but fix run_dir resolver + implement pdf
        fmt = (request.args.get("fmt") or "html").lower()
        rid_norm = rid.replace("RUN_", "") if isinstance(rid, str) else str(rid)

        # PDF: implement with wkhtmltopdf from html URL
        if fmt == "pdf":
            base = request.url_root.rstrip("/")
            html_url = f"{base}/api/vsp/run_export_v3/{rid}?fmt=html"
            pdf_path, err = _vsp_export_try_pdf_wkhtmltopdf(html_url, timeout_sec=180)
            if pdf_path:
                resp = send_file(pdf_path, mimetype="application/pdf", as_attachment=True,
                                 download_name=f"{rid_norm}.pdf")
                resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
                return resp
            resp = jsonify({"ok": False, "error": "pdf_export_failed", "detail": err})
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
            return resp, 500

        # For html/zip: ensure resolver can find correct run_dir via RID
        # (Original handler typically uses run_dir; we pass through, but we also set a global hint if it reads it)
        cand = _vsp_export_resolve_run_dir_best_effort(rid_norm)
        if cand:
            # set env-style hint for downstream if handler uses it
            os.environ["VSP_EXPORT_RUN_DIR_HINT"] = cand

        return _orig_run_export_v3(rid, *args, **kwargs)


### [COMMERCIAL] EXPORT_V3_OVERRIDE_V3 ###
# ---- Commercial override: robust run_dir resolve + wkhtmltopdf PDF ----
def _vsp_export_resolve_run_dir_best_effort(rid_norm: str):
    cands = []
    cands += glob.glob(f"/home/test/Data/SECURITY-*/out_ci/{rid_norm}")
    cands += glob.glob(f"/home/test/Data/*/out_ci/{rid_norm}")
    for x in cands:
        try:
            if os.path.isdir(x):
                return x
        except Exception:
            pass
    return None

def _vsp_export_pick_report_paths(run_dir: str):
    # prefer RUN_DIR/report/*
    rd = os.path.join(run_dir, "report")
    csv1 = os.path.join(rd, "findings_unified.csv")
    json1 = os.path.join(rd, "findings_unified.json")
    # fallback RUN_DIR/*
    csv2 = os.path.join(run_dir, "findings_unified.csv")
    json2 = os.path.join(run_dir, "findings_unified.json")
    return {
        "report_dir": rd,
        "csv": csv1 if os.path.isfile(csv1) else (csv2 if os.path.isfile(csv2) else None),
        "json": json1 if os.path.isfile(json1) else (json2 if os.path.isfile(json2) else None),
    }

def _vsp_export_pdf_wkhtmltopdf_from_html_url(html_url: str, timeout_sec: int = 180):
    exe = shutil.which("wkhtmltopdf")
    if not exe:
        return None, "wkhtmltopdf_missing"
    tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".pdf", delete=False)
    tmp.close()
    try:
        subprocess.run([exe, "--quiet", html_url, tmp.name], timeout=timeout_sec, check=True)
        if os.path.isfile(tmp.name) and os.path.getsize(tmp.name) > 0:
            return tmp.name, None
        return None, "wkhtmltopdf_empty_output"
    except Exception as e:
        return None, f"wkhtmltopdf_failed:{type(e).__name__}"

# IMPORTANT: override same URL rule
@bp_run_export_v3.route("/api/vsp/run_export_v3/<rid>")
def run_export_v3_override_v3(rid):  # noqa: F811
    fmt = (request.args.get("fmt") or "html").lower()
    rid_norm = rid.replace("RUN_", "") if isinstance(rid, str) else str(rid)

    run_dir = None
    # Try existing resolver if present
    try:
        # some versions have get_run_dir_for_rid / resolve_* etc.
        for name in ("get_run_dir_for_rid", "resolve_run_dir_for_rid", "vsp_resolve_run_dir_for_rid"):
            fn = globals().get(name)
            if callable(fn):
                run_dir = fn(rid)
                break
    except Exception:
        run_dir = None

    if (not run_dir) or (not os.path.isdir(str(run_dir))):
        run_dir = _vsp_export_resolve_run_dir_best_effort(rid_norm)

    if not run_dir or not os.path.isdir(run_dir):
        resp = jsonify({"ok": False, "error": "run_dir_not_found", "rid": rid, "rid_norm": rid_norm})
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp, 404

    paths = _vsp_export_pick_report_paths(run_dir)

    if fmt in ("zip", "html"):
        # require at least CSV or JSON
        if not paths["csv"] and not paths["json"]:
            resp = jsonify({
                "ok": False,
                "error": "report_files_missing",
                "need_any_of": ["report/findings_unified.csv", "report/findings_unified.json", "findings_unified.json"],
                "run_dir": run_dir,
                "report_dir": paths["report_dir"],
                "have": {
                    "csv": bool(paths["csv"]),
                    "json": bool(paths["json"]),
                }
            })
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
            return resp, 404

    if fmt == "html":
        # simplest: return the CSV as downloadable HTML-ish fallback if template missing
        # (your existing system likely has better HTML; we keep fallback to avoid 404)
        # if original exporter exists, prefer it:
        orig = globals().get("run_export_v3")
        if callable(orig) and orig is not run_export_v3_override_v3:
            try:
                return orig(rid)
            except Exception:
                pass
        # fallback: serve json
        if paths["json"]:
            resp = send_file(paths["json"], mimetype="application/json", as_attachment=True, download_name=f"{rid_norm}.json")
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            return resp
        resp = send_file(paths["csv"], mimetype="text/csv", as_attachment=True, download_name=f"{rid_norm}.csv")
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        return resp

    if fmt == "zip":
        # prefer original zip if exists
        orig = globals().get("run_export_v3")
        if callable(orig) and orig is not run_export_v3_override_v3:
            try:
                return orig(rid)
            except Exception:
                pass
        # fallback zip: package report_dir
        tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".zip", delete=False)
        tmp.close()
        import zipfile
        zf = zipfile.ZipFile(tmp.name, "w", compression=zipfile.ZIP_DEFLATED)
        base = paths["report_dir"] if os.path.isdir(paths["report_dir"]) else run_dir
        for root, _, files in os.walk(base):
            for fn in files:
                ap = os.path.join(root, fn)
                rel = os.path.relpath(ap, base)
                zf.write(ap, arcname=rel)
        zf.close()
        resp = send_file(tmp.name, mimetype="application/zip", as_attachment=True, download_name=f"{rid_norm}.zip")
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        return resp

    if fmt == "pdf":
        base = request.url_root.rstrip("/")
        # Render from HTML endpoint (which now at least returns something)
        html_url = f"{base}/api/vsp/run_export_v3/{rid}?fmt=html"
        pdf_path, err = _vsp_export_pdf_wkhtmltopdf_from_html_url(html_url, timeout_sec=180)
        if pdf_path:
            resp = send_file(pdf_path, mimetype="application/pdf", as_attachment=True, download_name=f"{rid_norm}.pdf")
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            return resp
        resp = jsonify({"ok": False, "error": "pdf_export_failed", "detail": err, "html_url": html_url})
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp, 500

    resp = jsonify({"ok": False, "error": "fmt_not_supported", "fmt": fmt})
    resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
    return resp, 400


### [COMMERCIAL] EXPORT_V3_ONDEMAND_V2 ###
def _nowz():
    return datetime.now(timezone.utc).isoformat(timespec="microseconds").replace("+00:00","Z")

def _resolve_run_dir_best_effort(rid_norm: str):
    cands = []
    cands += glob.glob(f"/home/test/Data/SECURITY-*/out_ci/{rid_norm}")
    cands += glob.glob(f"/home/test/Data/*/out_ci/{rid_norm}")
    for x in cands:
        try:
            if os.path.isdir(x):
                return x
        except Exception:
            pass
    return None

def _ensure_report_files(run_dir: str):
    report_dir = os.path.join(run_dir, "report")
    os.makedirs(report_dir, exist_ok=True)
    csv_path = os.path.join(report_dir, "findings_unified.csv")
    json_path = os.path.join(report_dir, "findings_unified.json")
    # if only root findings exists, copy into report/
    root_json = os.path.join(run_dir, "findings_unified.json")
    if (not os.path.isfile(json_path)) and os.path.isfile(root_json):
        try: shutil.copy2(root_json, json_path)
        except Exception: pass
    return report_dir, csv_path, json_path

def _build_export_html(report_dir: str, csv_path: str, json_path: str, rid_norm: str):
    html_path = os.path.join(report_dir, "export_v3.html")
    if os.path.isfile(html_path) and os.path.getsize(html_path) > 0:
        return html_path

    total = 0
    sev_counts, tool_counts = {}, {}
    if os.path.isfile(json_path):
        try:
            data = json.load(open(json_path, "r", encoding="utf-8"))
            items = data.get("items") or []
            total = len(items)
            for it in items:
                sev = (it.get("severity_norm") or it.get("severity") or "INFO").upper()
                tool = (it.get("tool") or "UNKNOWN").upper()
                sev_counts[sev] = sev_counts.get(sev, 0) + 1
                tool_counts[tool] = tool_counts.get(tool, 0) + 1
        except Exception:
            pass

    def rows(d):
        if not d: return "<tr><td colspan='2'>(none)</td></tr>"
        return "\n".join([f"<tr><td>{k}</td><td>{v}</td></tr>" for k,v in sorted(d.items(), key=lambda kv:(-kv[1],kv[0]))])

    html = f"""<!doctype html><html><head><meta charset='utf-8'/>
    <title>VSP Export {rid_norm}</title>
    <style>body{{font-family:Arial;padding:24px}} table{{border-collapse:collapse;width:100%}}
    td,th{{border:1px solid #eee;padding:6px 8px}}</style></head>
    <body>
    <h2>VSP Export v3 - {rid_norm}</h2>
    <p>Generated at: {_nowz()}</p>
    <p><b>Total findings:</b> {total}</p>
    <h3>By severity</h3><table><tr><th>Severity</th><th>Count</th></tr>{rows(sev_counts)}</table>
    <h3>By tool</h3><table><tr><th>Tool</th><th>Count</th></tr>{rows(tool_counts)}</table>
    <p style='margin-top:18px;color:#777'>Commercial on-demand export fallback.</p>
    </body></html>"""
    with open(html_path, "w", encoding="utf-8") as f:
        f.write(html)
    return html_path

def _zip_dir(src_dir: str):
    tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".zip", delete=False)
    tmp.close()
    with zipfile.ZipFile(tmp.name, "w", compression=zipfile.ZIP_DEFLATED) as z:
        for root, _, files in os.walk(src_dir):
            for fn in files:
                ap = os.path.join(root, fn)
                rel = os.path.relpath(ap, src_dir)
                z.write(ap, arcname=rel)
    return tmp.name

def _pdf_wkhtmltopdf(html_file: str, timeout_sec: int = 180):
    exe = shutil.which("wkhtmltopdf")
    if not exe:
        return None, "wkhtmltopdf_missing"
    tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".pdf", delete=False)
    tmp.close()
    try:
        subprocess.run([exe, "--quiet", html_file, tmp.name], timeout=timeout_sec, check=True)
        if os.path.isfile(tmp.name) and os.path.getsize(tmp.name) > 0:
            return tmp.name, None
        return None, "wkhtmltopdf_empty_output"
    except Exception as e:
        return None, f"wkhtmltopdf_failed:{type(e).__name__}"


# [COMMERCIAL] EXPORT_ONDEMAND_DEPS_V1
import os, json
import glob, shutil, tempfile, subprocess, zipfile
