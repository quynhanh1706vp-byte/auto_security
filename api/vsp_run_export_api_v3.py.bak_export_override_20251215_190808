from flask import Blueprint, request, jsonify, send_file
import os
import io
import zipfile
import json
import glob
import shutil
import tempfile
import subprocess

bp_run_export_v3 = Blueprint("bp_run_export_v3", __name__)


@bp_run_export_v3.route("/api/vsp/run_export_v3", methods=["GET"])
def vsp_run_export_v3():
    """
    Direct export HTML/ZIP/PDF/CSV cho 1 run - chạy trên UI gateway (8910).
    """
    run_id = (request.args.get("run_id") or "").strip()
    fmt = (request.args.get("fmt") or "html").strip().lower()

    if not run_id:
        return jsonify({"ok": False, "error": "Missing run_id"}), 400

    # Thư mục out gốc: ưu tiên env VSP_OUT_ROOT, fallback ../out cạnh ui/
    base_out = os.environ.get("VSP_OUT_ROOT")
    if not base_out:
        base_out = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "out"))

    run_dir = os.path.join(base_out, run_id)
    if not os.path.isdir(run_dir):
        return jsonify({"ok": False, "error": f"Run dir not found: {run_dir}"}), 404

    report_dir = os.path.join(run_dir, "report")

    # HTML export
    if fmt == "html":
        candidates = [
            os.path.join(report_dir, "vsp_run_report_cio_v3.html"),
            os.path.join(report_dir, "vsp_run_report_cio_v2.html"),
            os.path.join(report_dir, "vsp_run_report_cio.html"),
            os.path.join(report_dir, "run_report.html"),
        ]
        for path in candidates:
            if os.path.isfile(path):
                return send_file(
                    path,
                    mimetype="text/html",
                    as_attachment=False,
                    download_name=os.path.basename(path),
                )

        # fallback – render summary_unified.json thành HTML đơn giản
        summary_path = os.path.join(report_dir, "summary_unified.json")
        summary = {}
        if os.path.isfile(summary_path):
            try:
                with open(summary_path, "r", encoding="utf-8") as f:
                    summary = json.load(f)
            except Exception:
                summary = {}

        body = json.dumps(
            summary or {"note": "No summary_unified.json found"},
            indent=2,
            ensure_ascii=False,
        )

        html = (
            "<html><head><meta charset='utf-8'>"
            f"<title>VSP run {run_id}</title></head><body>"
            f"<h1>VSP run {run_id}</h1>"
            f"<pre>{body}</pre>"
            "</body></html>"
        )

        return html

    # CSV export
    if fmt == "csv":
        csv_path = os.path.join(report_dir, "findings_unified.csv")
        if os.path.isfile(csv_path):
            return send_file(
                csv_path,
                mimetype="text/csv",
                as_attachment=True,
                download_name=f"{run_id}_findings.csv",
            )
        return jsonify({"ok": False, "error": "findings_unified.csv not found"}), 404

    # ZIP export
    if fmt == "zip":
        if not os.path.isdir(report_dir):
            return jsonify({"ok": False, "error": "report dir not found"}), 404

        mem = io.BytesIO()
        with zipfile.ZipFile(mem, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
            for root, _dirs, files in os.walk(report_dir):
                for fn in files:
                    full = os.path.join(root, fn)
                    rel = os.path.relpath(full, run_dir)
                    zf.write(full, rel)

        mem.seek(0)
        return send_file(
            mem,
            mimetype="application/zip",
            as_attachment=True,
            download_name=f"{run_id}_report.zip",
        )

    # PDF export (nếu có sẵn file PDF trong report/)
    if fmt == "pdf":
        if os.path.isdir(report_dir):
            for name in os.listdir(report_dir):
                if name.lower().endswith(".pdf"):
                    path = os.path.join(report_dir, name)
                    return send_file(
                        path,
                        mimetype="application/pdf",
                        as_attachment=True,
                        download_name=name,
                    )
        return jsonify({"ok": False, "error": "PDF report not found"}), 404

    return jsonify({"ok": False, "error": f"Unsupported fmt={fmt}"}), 400


### [COMMERCIAL] EXPORT_V3_COMMERCIAL_V2 ###
def _vsp_export_resolve_run_dir_best_effort(rid_norm: str):
    cands = []
    cands += glob.glob(f"/home/test/Data/SECURITY-*/out_ci/{rid_norm}")
    cands += glob.glob(f"/home/test/Data/*/out_ci/{rid_norm}")
    for x in cands:
        try:
            if os.path.isdir(x):
                return x
        except Exception:
            pass
    return None

def _vsp_export_try_pdf_wkhtmltopdf(url: str, timeout_sec: int = 180):
    exe = shutil.which("wkhtmltopdf")
    if not exe:
        return None, "wkhtmltopdf_missing"
    tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".pdf", delete=False)
    tmp.close()
    cmd = [exe, "--quiet", url, tmp.name]
    try:
        subprocess.run(cmd, timeout=timeout_sec, check=True)
        if os.path.isfile(tmp.name) and os.path.getsize(tmp.name) > 0:
            return tmp.name, None
        return None, "wkhtmltopdf_empty_output"
    except Exception as e:
        return None, f"wkhtmltopdf_failed:{type(e).__name__}"

# --- monkey patch: wrap original handler if it exists ---
try:
    _orig_run_export_v3 = run_export_v3  # type: ignore[name-defined]
except Exception:
    _orig_run_export_v3 = None

if _orig_run_export_v3:
    def run_export_v3(rid, *args, **kwargs):  # noqa: F811
        # keep original behavior but fix run_dir resolver + implement pdf
        fmt = (request.args.get("fmt") or "html").lower()
        rid_norm = rid.replace("RUN_", "") if isinstance(rid, str) else str(rid)

        # PDF: implement with wkhtmltopdf from html URL
        if fmt == "pdf":
            base = request.url_root.rstrip("/")
            html_url = f"{base}/api/vsp/run_export_v3/{rid}?fmt=html"
            pdf_path, err = _vsp_export_try_pdf_wkhtmltopdf(html_url, timeout_sec=180)
            if pdf_path:
                resp = send_file(pdf_path, mimetype="application/pdf", as_attachment=True,
                                 download_name=f"{rid_norm}.pdf")
                resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
                return resp
            resp = jsonify({"ok": False, "error": "pdf_export_failed", "detail": err})
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
            return resp, 500

        # For html/zip: ensure resolver can find correct run_dir via RID
        # (Original handler typically uses run_dir; we pass through, but we also set a global hint if it reads it)
        cand = _vsp_export_resolve_run_dir_best_effort(rid_norm)
        if cand:
            # set env-style hint for downstream if handler uses it
            os.environ["VSP_EXPORT_RUN_DIR_HINT"] = cand

        return _orig_run_export_v3(rid, *args, **kwargs)

