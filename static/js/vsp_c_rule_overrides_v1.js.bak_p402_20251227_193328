/* VSP_RULE_OVERRIDES_REWRITE_P401 - clean & stable (no observer) */
(function(){
  "use strict";
  const log = (...a)=>console.log("[ovr:p401]", ...a);
  const warn = (...a)=>console.warn("[ovr:p401]", ...a);

  function el(tag, attrs, html){
    const e = document.createElement(tag);
    if (attrs) for (const [k,v] of Object.entries(attrs)) {
      if (k === "class") e.className = v;
      else if (k === "style") e.setAttribute("style", v);
      else e.setAttribute(k, v);
    }
    if (html !== undefined) e.innerHTML = html;
    return e;
  }

  function cssOnce(){
    if (document.getElementById("vsp_ovr_css_p401")) return;
    const css = `
      .ovr-p401{ padding:16px; }
      .ovr-h1{ font-size:18px; margin:0 0 12px 0; }
      .ovr-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
      .ovr-card{ border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.18); border-radius:14px; padding:12px; min-height:120px; }
      .ovr-card h2{ font-size:13px; margin:0 0 10px 0; opacity:.9; }
      .ovr-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:0 0 10px 0; }
      .ovr-btn{ cursor:pointer; border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.06); color:#eaeaea; padding:6px 10px; border-radius:10px; font-size:12px; }
      .ovr-btn:hover{ background:rgba(255,255,255,.10); }
      .ovr-badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; border:1px solid rgba(255,255,255,.15); }
      .ok{ background:rgba(0,255,0,.08); }
      .bad{ background:rgba(255,0,0,.08); }
      textarea.ovr-ta{ width:100%; min-height:240px; resize:vertical; border-radius:12px; padding:10px; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.25); color:#eaeaea; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; line-height:1.4; }
      .ovr-msg{ margin-top:8px; font-size:12px; opacity:.8; }
      @media (max-width: 1100px){ .ovr-grid{ grid-template-columns:1fr; } }
    `;
    document.head.appendChild(el("style",{id:"vsp_ovr_css_p401"},css));
  }

  function findMount(){
    return document.querySelector("#vsp_tab_content")
      || document.querySelector("#content")
      || document.querySelector("main")
      || document.body;
  }

  async function ensureViewerLoaded(){
    if (window.VSP && window.VSP.jsonViewer) return true;
    return await new Promise((resolve)=>{
      const s = document.createElement("script");
      s.src = "/static/js/vsp_json_viewer_v1.js?v=" + Date.now();
      s.onload = ()=>resolve(true);
      s.onerror = ()=>resolve(false);
      document.head.appendChild(s);
    });
  }

  async function fetchJson(url, opts){
    const ms = (opts && opts.timeoutMs) ? opts.timeoutMs : 4500;
    const method = (opts && opts.method) ? opts.method : "GET";
    const body = (opts && opts.body) ? opts.body : null;

    const ctl = new AbortController();
    const t = setTimeout(()=>ctl.abort(), ms);
    const t0 = performance.now();
    try{
      const r = await fetch(url, {
        method,
        cache:"no-store",
        credentials:"same-origin",
        headers: body ? { "Content-Type":"application/json" } : undefined,
        body: body ? JSON.stringify(body) : undefined,
        signal: ctl.signal
      });
      const text = await r.text();
      let data = null;
      try{ data = JSON.parse(text); }catch(_){}
      return { ok:r.ok, status:r.status, ms:(performance.now()-t0), text, data };
    }finally{ clearTimeout(t); }
  }

  async function detectEndpoint(){
    // optional override: window.VSP_OVR_ENDPOINT="/api/vsp/rule_overrides_v1"
    const fixed = (window.VSP_OVR_ENDPOINT || "").trim();
    if (fixed) return fixed;

    const cands = [
      "/api/vsp/rule_overrides_v1",
      "/api/vsp/overrides_v1",
      "/api/vsp/rule_overrides",
      "/api/vsp/overrides",
    ];

    for (const u of cands){
      const r = await fetchJson(u, { timeoutMs: 3500 });
      if (r.ok && r.data !== null) return u;
    }
    return cands[0]; // default
  }

  function badge(ok){
    return `<span class="ovr-badge ${ok ? "ok":"bad"}">${ok ? "OK":"ERR"}</span>`;
  }

  async function main(){
    cssOnce();
    const mount = findMount();

    const root = el("div",{class:"ovr-p401"});
    root.appendChild(el("div",{class:"ovr-h1"}, "Rule Overrides • P401 rewrite"));

    const grid = el("div",{class:"ovr-grid"});
    const cardLeft = el("div",{class:"ovr-card"});
    const cardRight = el("div",{class:"ovr-card"});

    cardLeft.appendChild(el("h2",null,"Live view (stable JSON)"));
    const jsonBox = el("div");
    cardLeft.appendChild(jsonBox);

    cardRight.appendChild(el("h2",null,"Editor (validate + save if backend supports POST)"));
    const row = el("div",{class:"ovr-row"});
    const btnReload = el("button",{class:"ovr-btn",type:"button"},"Reload");
    const btnValidate = el("button",{class:"ovr-btn",type:"button"},"Validate JSON");
    const btnSave = el("button",{class:"ovr-btn",type:"button"},"Save");
    const epSpan = el("span",{class:"ovr-msg"},"");
    row.appendChild(btnReload); row.appendChild(btnValidate); row.appendChild(btnSave); row.appendChild(epSpan);

    const ta = el("textarea",{class:"ovr-ta",spellcheck:"false"});
    const msg = el("div",{class:"ovr-msg"},"");

    cardRight.appendChild(row);
    cardRight.appendChild(ta);
    cardRight.appendChild(msg);

    grid.appendChild(cardLeft);
    grid.appendChild(cardRight);
    root.appendChild(grid);

    mount.innerHTML = "";
    mount.appendChild(root);

    const viewerOk = await ensureViewerLoaded();
    const endpoint = await detectEndpoint();
    epSpan.innerHTML = `endpoint: <code>${endpoint}</code>`;

    async function reload(){
      msg.textContent = "Loading…";
      const r = await fetchJson(endpoint, { timeoutMs: 4500 });
      msg.innerHTML = `${badge(r.ok)} status=${r.status} • ${Math.round(r.ms)}ms`;
      const payload = (r.data !== null) ? r.data : { error:"non-json response", status:r.status, text:(r.text||"").slice(0,1600) };

      // populate editor with pretty JSON
      try{ ta.value = JSON.stringify(payload, null, 2); }catch(_){ ta.value = String(r.text||""); }

      if (viewerOk && window.VSP && window.VSP.jsonViewer){
        window.VSP.jsonViewer.render(jsonBox, { endpoint, payload }, { title:"RuleOverrides", maxDepth: 8 });
      } else {
        warn("jsonViewer missing; fallback <pre>");
        jsonBox.innerHTML = `<pre style="white-space:pre-wrap;word-break:break-word;opacity:.9">${(r.text||"").slice(0,3000)}</pre>`;
      }
    }

    btnReload.addEventListener("click", reload);

    btnValidate.addEventListener("click", ()=>{
      try{
        JSON.parse(ta.value);
        msg.innerHTML = `${badge(true)} JSON valid`;
      }catch(e){
        msg.innerHTML = `${badge(false)} JSON invalid: ${String(e && e.message ? e.message : e)}`;
      }
    });

    btnSave.addEventListener("click", async ()=>{
      let obj;
      try{
        obj = JSON.parse(ta.value);
      }catch(e){
        msg.innerHTML = `${badge(false)} Cannot save: JSON invalid`;
        return;
      }
      msg.textContent = "Saving…";
      const r = await fetchJson(endpoint, { method:"POST", body: obj, timeoutMs: 7000 });
      msg.innerHTML = `${badge(r.ok)} POST status=${r.status} • ${Math.round(r.ms)}ms • ${(r.data && (r.data.message||r.data.status)) ? (r.data.message||r.data.status) : ""}`;
      // refresh view after save if ok
      if (r.ok) await reload();
    });

    await reload();
    log("rendered");
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", main);
  else main();
})();
