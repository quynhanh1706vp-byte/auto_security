/* VSP_P118C_FIX_TOPFINDINGS_DOM_TARGET_V1
 * Keeps P117 behavior but fixes Top Findings DOM targeting robustly.
 */
(() => {
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  function qparam(name){
    try { return new URLSearchParams(location.search).get(name); } catch(e){ return null; }
  }
  function setText(id, v){
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = (v === null || v === undefined) ? "" : String(v);
  }
  function escapeHtml(s){
    s = String(s || "");
    return s.replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function isValidRid(r){
    if (!r) return false;
    r = String(r).trim();
    if (!r) return false;
    const up = r.toUpperCase();
    if (/FILL_REAL_DATA|\.JS|\.CSS|TABS_P1_V1/.test(up)) return false;
    if (/^(VSP_CI_\d{8}_\d{6})$/.test(r)) return true;
    if (/^(RUN_)/.test(r) && /\d/.test(r) && r.length > 12) return true;
    if (/^(RUN_VSP_)/.test(r) && /\d/.test(r)) return true;
    if (!/^(VSP_|RUN_)/.test(r)) return false;
    if (!/\d/.test(r)) return false;
    if (!/^[A-Za-z0-9_:-]+$/.test(r)) return false;
    return true;
  }

  async function fetchJson(url){
    const r = await fetch(url, { credentials: "same-origin" });
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t); }catch(e){}
    return { ok:r.ok, status:r.status, json:j, text:t };
  }

  async function resolveRid(){
    let rid = qparam("rid");
    if (rid !== null) rid = (rid || "").trim();
    if (isValidRid(rid)) return rid;

    if (rid !== null && rid && !isValidRid(rid)) {
      try {
        const u = new URL(location.href);
        u.searchParams.delete("rid");
        location.replace(u.toString());
        return null;
      } catch(e){}
    }

    const runs = await fetchJson(`/api/ui/runs_v3?limit=1&include_ci=1`);
    const latest = (runs?.json?.items?.[0]?.rid || "").trim();
    if (isValidRid(latest)) return latest;

    try {
      const last = (localStorage.getItem("vsp_rid") || "").trim();
      if (isValidRid(last)) return last;
      if (last && !isValidRid(last)) localStorage.removeItem("vsp_rid");
    } catch(e){}
    return "";
  }

  function getFileLike(it){
    if (!it) return "";
    const loc = it.location;
    if (typeof loc === "string" && loc) return loc;
    if (loc && typeof loc === "object") {
      return loc.path || loc.file || loc.url || loc.uri || "";
    }
    const comp = it.component || "";
    const ver = it.version ? `@${it.version}` : "";
    return (comp || "") + ver;
  }

  function normalizeFinding(it){
    return {
      severity: String(it?.severity || it?.sev || it?.level || "").toUpperCase(),
      title: String(it?.title || it?.message || it?.id || ""),
      tool: String(it?.tool || it?.engine || it?.source || ""),
      file: String(getFileLike(it) || "")
    };
  }

  // Find the "Top Findings" card area robustly
  function findCardByTitle(title){
    const want = String(title).trim();
    const nodes = $$("*");
    for (const n of nodes){
      if (n.children && n.children.length === 0) {
        const txt = (n.textContent || "").trim();
        if (txt === want) {
          // climb to a reasonable container
          return n.closest("section,article,div") || n.parentElement;
        }
      }
    }
    // fallback: partial match
    for (const n of nodes){
      const txt = (n.textContent || "").trim();
      if (txt === want) return n.closest("section,article,div") || n.parentElement;
    }
    return null;
  }

  function renderTopFindings(items){
    const card = findCardByTitle("Top Findings");
    if (!card) return;

    const rows = (Array.isArray(items) ? items : [])
      .map(normalizeFinding)
      .filter(r => r && (r.title || r.severity || r.tool || r.file))
      .slice(0, 20);

    // Case A: real <table>
    const table = card.querySelector("table");
    if (table) {
      let body = table.querySelector("tbody");
      if (!body) {
        body = document.createElement("tbody");
        table.appendChild(body);
      }
      body.innerHTML = "";
      if (!rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4" style="opacity:.75;padding:10px">No findings</td>`;
        body.appendChild(tr);
        return;
      }
      for (const r of rows){
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td style="padding:8px 10px;opacity:.9;white-space:nowrap">${escapeHtml(r.severity || "-")}</td>
          <td style="padding:8px 10px;opacity:.95">${escapeHtml(r.title)}</td>
          <td style="padding:8px 10px;opacity:.85;white-space:nowrap">${escapeHtml(r.tool)}</td>
          <td style="padding:8px 10px;opacity:.75">${escapeHtml(r.file)}</td>
        `;
        body.appendChild(tr);
      }
      return;
    }

    // Case B: div-grid / placeholder text exists
    const all = $$("*", card);
    const ph = all.find(el => /No\s+TopCWE\s+data|No\s+findings|Loading/i.test(el.textContent || ""));
    const host = (ph && (ph.closest("div") || ph.parentElement)) || card;

    // Build a lightweight grid block (won't break existing header row)
    const box = document.createElement("div");
    box.style.marginTop = "8px";
    box.innerHTML = rows.length ? rows.map(r => `
      <div style="display:grid;grid-template-columns:120px 1fr 140px 1fr;gap:10px;padding:6px 2px;border-top:1px solid rgba(255,255,255,.06)">
        <div style="opacity:.9;white-space:nowrap">${escapeHtml(r.severity || "-")}</div>
        <div style="opacity:.95">${escapeHtml(r.title)}</div>
        <div style="opacity:.85;white-space:nowrap">${escapeHtml(r.tool)}</div>
        <div style="opacity:.75">${escapeHtml(r.file)}</div>
      </div>
    `).join("") : `<div style="opacity:.75;padding:10px">No findings</div>`;

    // replace placeholder node if found, else append
    if (ph && ph.parentElement) {
      ph.parentElement.innerHTML = "";
      ph.parentElement.appendChild(box);
    } else {
      host.appendChild(box);
    }
  }

  function renderTrendMini(points){
    const host = document.getElementById("trend-mini");
    if (!host) return;

    let series = [];
    if (Array.isArray(points)) {
      for (const p of points) {
        const y =
          (typeof p.total === "number" ? p.total :
          typeof p.count === "number" ? p.count :
          typeof p.value === "number" ? p.value :
          typeof p.y === "number" ? p.y : null);
        if (y === null) continue;
        const xLabel = (p.label ?? p.x ?? p.ts ?? p.time ?? "");
        series.push({ xLabel, y });
      }
    }
    if (series.length < 2){
      host.innerHTML = `<div style="opacity:.75;font-size:12px">No trend data</div>`;
      return;
    }

    const W = 520, H = 90, P = 10;
    const ys = series.map(s => s.y);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const span = (maxY - minY) || 1;
    const xAt = (i) => P + (i * (W - P*2) / (series.length - 1));
    const yAt = (y) => (H - P) - ((y - minY) * (H - P*2) / span);

    let d = "";
    for (let i=0;i<series.length;i++){
      const x = xAt(i), y = yAt(series[i].y);
      d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
    }
    const last = series[series.length-1];
    const first = series[0];

    host.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <div style="font-size:12px;opacity:.85">Trend (last=${last.y})</div>
        <div style="font-size:11px;opacity:.7">${String(first.xLabel).slice(0,16)} → ${String(last.xLabel).slice(0,16)}</div>
      </div>
      <svg viewBox="0 0 ${W} ${H}" width="100%" height="${H}" style="border:1px solid rgba(255,255,255,.06);border-radius:10px">
        <path d="${d}" fill="none" stroke="rgba(80,180,255,.95)" stroke-width="2"/>
        <circle cx="${xAt(series.length-1)}" cy="${yAt(last.y)}" r="3.5" fill="rgba(255,255,255,.95)"/>
      </svg>
    `;
  }

  async function main(){
    const rid = await resolveRid();
    if (rid === null) return;

    if (isValidRid(rid)) {
      try { localStorage.setItem("vsp_rid", rid); } catch(e){}
      try { window.VSP_RID = rid; } catch(e){}
    }

    // ensure URL has rid
    try {
      const u = new URL(location.href);
      const cur = (u.searchParams.get("rid") || "").trim();
      if (!cur && isValidRid(rid)) {
        u.searchParams.set("rid", rid);
        location.replace(u.toString());
        return;
      }
    } catch(e){}

    setText("p-rid", rid || "(no rid)");
    setText("k-status", "Loading…");
    setText("k-time", new Date().toLocaleString());

    const br = document.getElementById("b-refresh");
    if (br && !br.dataset.p118c){
      br.dataset.p118c="1";
      br.addEventListener("click", () => {
        const u = new URL(location.href);
        u.searchParams.set("nocache","1");
        location.href = u.toString();
      });
    }

    const qs = rid ? `?rid=${encodeURIComponent(rid)}` : "";
    const [kpis, top, trend] = await Promise.all([
      fetchJson(`/api/vsp/dashboard_kpis_v4${qs}`),
      fetchJson(`/api/vsp/top_findings_v2?limit=20${rid ? `&rid=${encodeURIComponent(rid)}` : ""}`),
      fetchJson(`/api/vsp/trend_v1${qs}`),
    ]);

    if (kpis.ok && kpis.json){
      const j = kpis.json;
      setText("k-total", j.total ?? j.kpi_total ?? j.summary?.total ?? "");
      setText("k-from", j.from ?? j.label ?? j.ts ?? "");
    }

    if (top.ok && top.json){
      const items = top.json.items ?? top.json.rows ?? top.json.data ?? [];
      renderTopFindings(Array.isArray(items) ? items : []);
      setText("k-toplen", top.json.total ?? (Array.isArray(items)?items.length:"") );
      setText("k-topmeta", top.status);
    } else {
      renderTopFindings([]);
      setText("k-topmeta", `top ${top.status}`);
    }

    if (trend.ok && trend.json){
      const pts = trend.json.points ?? trend.json.items ?? trend.json.data ?? [];
      renderTrendMini(Array.isArray(pts) ? pts : []);
      setText("k-trend", Array.isArray(pts) ? pts.length : "");
      setText("k-trendmeta", trend.status);
    } else {
      renderTrendMini([]);
      setText("k-trendmeta", `trend ${trend.status}`);
    }

    setText("k-status", (kpis.ok && top.ok && trend.ok) ? "OK" : "DEGRADED");
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", main);
  } else {
    main();
  }
})();
