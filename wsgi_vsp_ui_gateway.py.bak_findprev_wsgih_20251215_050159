import importlib

m = importlib.import_module("vsp_demo_app")

if hasattr(m, "app"):
    application = m.app
elif hasattr(m, "create_app"):
    application = m.create_app()
else:
    raise RuntimeError("vsp_demo_app has no 'app' or 'create_app'")



# === VSP_GATEWAY_EXPORT_V3_IN_WSGI_V1 ===
def _vsp_install_export_v3_on_app(_app):
    # Install export route on the REAL gateway Flask app (application/app)
    try:
        from flask import request, jsonify, send_file, Response
    except Exception:
        return
    from pathlib import Path
    import glob, mimetypes

    if _app is None or not hasattr(_app, "route"):
        return
    if getattr(_app, "_vsp_export_v3_installed", False):
        return
    setattr(_app, "_vsp_export_v3_installed", True)

    def _vsp_norm_rid_to_ci_key(rid: str) -> str:
        s = (rid or "").strip()
        if s.startswith("RUN_"):
            s = s[len("RUN_"):]
        return s

    def _vsp_resolve_ci_run_dir(rid: str):
        key = _vsp_norm_rid_to_ci_key(rid)
        bases = [
            "/home/test/Data/SECURITY-10-10-v4/out_ci",
            "/home/test/Data/SECURITY_BUNDLE/out",
            "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        ]
        for b in bases:
            d = Path(b) / key
            if d.is_dir():
                return d
        # glob fallback
        pats = [f"**/{key}", f"**/RUN_{key}", f"**/{key}*"]
        for b in bases:
            bp = Path(b)
            if not bp.exists():
                continue
            for pat in pats:
                for m in bp.glob(pat):
                    if m.is_dir():
                        return m
        return None

    def _vsp_export_candidates(ci_run_dir, fmt: str):
        d = Path(ci_run_dir)
        html = [
            d / "reports" / "vsp_run_report_cio_v3.html",
            d / "reports" / "report.html",
            d / "reports" / "index.html",
            d / "vsp_run_report_cio_v3.html",
            d / "report.html",
        ]
        pdf = [
            d / "reports" / "report.pdf",
            d / "reports" / "vsp_run_report_cio_v3.pdf",
            d / "report.pdf",
        ]
        zips = [
            d / "reports" / "report.zip",
            d / "reports.zip",
            d / "report.zip",
        ]
        if fmt == "html":
            cands = html + [Path(x) for x in glob.glob(str(d / "reports" / "*.html"))]
        elif fmt == "pdf":
            cands = pdf + [Path(x) for x in glob.glob(str(d / "reports" / "*.pdf"))]
        else:
            cands = zips + [Path(x) for x in glob.glob(str(d / "reports" / "*.zip"))]

        out = []
        for f in cands:
            try:
                if f.is_file() and f.stat().st_size > 0:
                    out.append(f)
            except Exception:
                pass
        # de-dupe
        seen = set(); uniq = []
        for f in out:
            k = str(f)
            if k not in seen:
                uniq.append(f); seen.add(k)
        return uniq

    @_app.route("/api/vsp/run_export_v3/<rid>", methods=["GET","HEAD"])
    def api_vsp_run_export_v3(rid):
        fmt = (request.args.get("fmt", "html") or "html").lower().strip()
        if fmt not in ("html","pdf","zip"):
            return jsonify(ok=False, error="bad_fmt", fmt=fmt), 400

        ci_dir = _vsp_resolve_ci_run_dir(rid)
        if not ci_dir:
            return jsonify(ok=False, error="run_not_found", rid=rid), 404

        cands = _vsp_export_candidates(ci_dir, fmt)
        if not cands:
            # IMPORTANT: differentiate from missing-route
            return jsonify(ok=False, error="export_file_not_found", rid=rid, fmt=fmt, ci_run_dir=str(ci_dir)), 404

        f = cands[0]
        
        ctype = mimetypes.guess_type(str(f))[0] or "application/octet-stream"

        # meta mode for quick debugging
        if request.args.get("meta","0") == "1":
            return jsonify(ok=True, rid=rid, rel=rel, abs=str(f), ctype=ctype, size=int(f.stat().st_size)), 200

        if request.method == "HEAD":
            resp = Response(status=200)
            resp.headers["Content-Type"] = ctype
            resp.headers["X-VSP-ARTOPEN"] = "ok"
            try:
                resp.headers["Content-Length"] = str(f.stat().st_size)
            except Exception:
                pass
            return resp

        # Read file and respond with explicit mimetype (resists gateway header overrides better than send_file)
        data = f.read_bytes()
        resp = Response(data, status=200, mimetype=ctype)
        resp.headers["X-VSP-ARTOPEN"] = "ok"
        resp.headers["X-Content-Type-Options"] = "nosniff"
        return resp

# Install onto the live app
try:
    _APP = globals().get("application") or globals().get("app")
    _vsp_install_export_v3_on_app(_APP)
except Exception:
    pass
# === /VSP_GATEWAY_EXPORT_V3_IN_WSGI_V1 ===




# === VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_FILL8_BYTOOL_V1 ===
def _vsp_statusv2_fill8_bytool(obj: dict) -> dict:
    """
    Ensure run_gate_summary.by_tool includes 8 commercial tools keys.
    If missing, set verdict=NOT_RUN and total=0 (do NOT override existing).
    """
    want = ["SEMGREP","TRIVY","KICS","GITLEAKS","CODEQL","BANDIT","SYFT","GRYPE"]
    try:
        rgs = obj.get("run_gate_summary") or {}
        by_tool = rgs.get("by_tool") or {}
        if not isinstance(by_tool, dict):
            by_tool = {}
        changed = False
        for k in want:
            if k not in by_tool:
                by_tool[k] = {"tool": k, "verdict": "NOT_RUN", "total": 0}
                changed = True
            else:
                # normalize shape a bit (keep existing verdict/total)
                v = by_tool.get(k) or {}
                if isinstance(v, dict):
                    if "tool" not in v:
                        v["tool"] = k
                        changed = True
                    by_tool[k] = v
        if changed:
            rgs["by_tool"] = by_tool
            obj["run_gate_summary"] = rgs
    except Exception:
        pass
    return obj

def _vsp_try_fill8_on_json_bytes(b: bytes) -> bytes:
    import json
    try:
        obj = json.loads(b.decode("utf-8", errors="ignore"))
        if isinstance(obj, dict) and obj.get("ok") is True:
            obj2 = _vsp_statusv2_fill8_bytool(obj)
            return json.dumps(obj2, ensure_ascii=False).encode("utf-8")
    except Exception:
        return b
    return b

# Hook into existing bytes postprocess chain if present; otherwise wrap WSGI app at the end.
try:
    # If there is a global postprocess dispatcher, extend it
    if "_VSP_STATUSV2_BYTES_POSTPROCESSORS" in globals() and isinstance(globals().get("_VSP_STATUSV2_BYTES_POSTPROCESSORS"), list):
        globals()["_VSP_STATUSV2_BYTES_POSTPROCESSORS"].append(_vsp_try_fill8_on_json_bytes)
    else:
        globals()["_VSP_STATUSV2_BYTES_POSTPROCESSORS"] = [_vsp_try_fill8_on_json_bytes]
except Exception:
    pass
# === /VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_FILL8_BYTOOL_V1 ===




# === VSP_WSGI_STATUSV2_FILL8_MW_V1 ===
def _vsp_statusv2_fill8_obj(obj: dict) -> dict:
    want = ["SEMGREP","TRIVY","KICS","GITLEAKS","CODEQL","BANDIT","SYFT","GRYPE"]
    try:
        rgs = obj.get("run_gate_summary") or {}
        by_tool = rgs.get("by_tool") or {}
        if not isinstance(by_tool, dict):
            by_tool = {}
        for k in want:
            if k not in by_tool:
                by_tool[k] = {"tool": k, "verdict": "NOT_RUN", "total": 0}
            else:
                v = by_tool.get(k)
                if isinstance(v, dict) and "tool" not in v:
                    v["tool"] = k
                    by_tool[k] = v
        rgs["by_tool"] = by_tool
        obj["run_gate_summary"] = rgs
    except Exception:
        pass
    return obj

def _vsp_statusv2_fill8_bytes(body_bytes: bytes) -> bytes:
    import json
    try:
        obj = json.loads(body_bytes.decode("utf-8", errors="ignore"))
        if isinstance(obj, dict) and obj.get("ok") is True and isinstance(obj.get("run_gate_summary"), dict):
            obj = _vsp_statusv2_fill8_obj(obj)
            return json.dumps(obj, ensure_ascii=False).encode("utf-8")
    except Exception:
        return body_bytes
    return body_bytes

def _vsp_wsgi_wrap_statusv2_fill8(app):
    if getattr(app, "_vsp_wrapped_statusv2_fill8", False):
        return app
    setattr(app, "_vsp_wrapped_statusv2_fill8", True)

    def _wrapped(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_status_v2/"):
            return app(environ, start_response)

        # capture status/headers
        captured = {"status": None, "headers": None, "exc": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            # delay calling real start_response until we potentially rewrite body
            return None

        iterable = app(environ, _sr)

        # buffer body (status_v2 JSON is small)
        chunks = []
        try:
            for c in iterable:
                if c:
                    chunks.append(c)
        finally:
            try:
                close = getattr(iterable, "close", None)
                if close:
                    close()
            except Exception:
                pass

        body = b"".join(chunks)
        # Only rewrite when JSON-ish
        hdrs = captured["headers"] or []
        ct = ""
        for k, v in hdrs:
            if str(k).lower() == "content-type":
                ct = str(v).lower()
                break

        if ("application/json" in ct) or (body.lstrip().startswith(b"{")):
            body2 = _vsp_statusv2_fill8_bytes(body)
        else:
            body2 = body

        # fix Content-Length
        new_hdrs = []
        for k, v in hdrs:
            if str(k).lower() == "content-length":
                continue
            new_hdrs.append((k, v))
        new_hdrs.append(("Content-Length", str(len(body2))))

        start_response(captured["status"] or "200 OK", new_hdrs, captured["exc"])
        return [body2]

    return _wrapped

try:
    _APP = globals().get("application") or globals().get("app")
    if _APP is not None:
        globals()["application"] = _vsp_wsgi_wrap_statusv2_fill8(_APP)
except Exception:
    pass
# === /VSP_WSGI_STATUSV2_FILL8_MW_V1 ===




# === VSP_GATEWAY_ARTIFACT_OPEN_V1 ===
def _vsp_install_artifact_open_v1(_app):
    try:
        from flask import request, jsonify, send_file
    except Exception:
        return
    from pathlib import Path
    import mimetypes

    if _app is None or not hasattr(_app, "route"):
        return
    if getattr(_app, "_vsp_artifact_open_v1_installed", False):
        return
    setattr(_app, "_vsp_artifact_open_v1_installed", True)

    # reuse resolver from export_v3 if present
    _resolve = globals().get("_vsp_resolve_ci_run_dir", None)
    if _resolve is None:
        def _resolve(rid: str):
            key = (rid or "").strip()
            if key.startswith("RUN_"):
                key = key[len("RUN_"):]
            bases = [
                "/home/test/Data/SECURITY-10-10-v4/out_ci",
                "/home/test/Data/SECURITY_BUNDLE/out",
                "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
            ]
            for b in bases:
                d = Path(b) / key
                if d.is_dir():
                    return d
            return None

    # simple whitelist for rel paths (only allow inside run dir, deny parent traversal)
    def _safe_join(run_dir: Path, rel: str):
        rel = (rel or "").lstrip("/").strip()
        if not rel:
            return None
        if ".." in rel.split("/"):
            return None
        # allow only certain top-level folders/files
        allow_prefixes = ("reports/", "findings_", "summary_", "gitleaks/", "semgrep/", "trivy/", "kics/", "codeql/", "bandit/", "syft/", "grype/", "artifacts/")
        if not (rel.startswith(allow_prefixes) or rel in ("runner.log","SUMMARY.txt")):
            return None
        f = (run_dir / rel).resolve()
        if run_dir.resolve() not in f.parents and f != run_dir.resolve():
            return None
        return f

    @_app.route("/api/vsp/run_artifact_open_v1/<rid>", methods=["GET","HEAD"])
    def api_vsp_run_artifact_open_v1(rid):
        from flask import Response
        rel = request.args.get("rel","")
        run_dir = _resolve(rid)
        if not run_dir:
            return jsonify(ok=False, error="run_not_found", rid=rid), 404

        f = _safe_join(Path(run_dir), rel)
        if not f:
            return jsonify(ok=False, error="bad_rel", rel=rel), 400
        if not f.is_file():
            return jsonify(ok=False, error="file_not_found", rel=rel), 404

        ctype = mimetypes.guess_type(str(f))[0] or "application/octet-stream"
        if request.method == "HEAD":
            resp = Response(status=200)
            resp.headers["Content-Type"] = ctype
            try:
                resp.headers["Content-Length"] = str(f.stat().st_size)
            except Exception:
                pass
            return resp

        # inline for html/json/txt; attachment for others
        as_attach = not (ctype.startswith("text/") or ctype.endswith("json") or "html" in ctype)
        return send_file(str(f), mimetype=ctype, as_attachment=as_attach, download_name=f.name)
# === /VSP_GATEWAY_ARTIFACT_OPEN_V1 ===

try:
    _APP = globals().get("application") or globals().get("app")
    _vsp_install_artifact_open_v1(_APP)
except Exception:
    pass


# === VSP_GATEWAY_ARTIFACT_OPEN_V2_FIXCT ===



# === VSP_GATEWAY_FINDINGS_PREVIEW_V1 ===
def _vsp_install_findings_preview_v1(_app):
    try:
        from flask import request, jsonify
    except Exception:
        return
    import json, csv
    from pathlib import Path

    if _app is None or not hasattr(_app, "route"):
        return
    if getattr(_app, "_vsp_findings_preview_v1_installed", False):
        return
    setattr(_app, "_vsp_findings_preview_v1_installed", True)

    _resolve = globals().get("_vsp_resolve_ci_run_dir", None)
    if _resolve is None:
        def _resolve(rid: str):
            key = (rid or "").strip()
            if key.startswith("RUN_"):
                key = key[len("RUN_"):]
            bases = [
                "/home/test/Data/SECURITY-10-10-v4/out_ci",
                "/home/test/Data/SECURITY_BUNDLE/out",
                "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
            ]
            for b in bases:
                d = Path(b) / key
                if d.is_dir():
                    return d
            return None

    def _norm(x):
        return (x or "").strip()

    def _pick_fields(rec: dict):
        # normalize common fields across tools
        return {
            "severity": rec.get("severity") or rec.get("sev") or rec.get("level") or "",
            "tool": rec.get("tool") or rec.get("source") or "",
            "rule_id": rec.get("rule_id") or rec.get("check_id") or rec.get("id") or "",
            "title": rec.get("title") or rec.get("message") or rec.get("name") or "",
            "file": rec.get("file") or rec.get("path") or rec.get("filename") or "",
            "line": rec.get("line") or rec.get("start_line") or rec.get("startLine") or "",
            "cwe": rec.get("cwe") or rec.get("cwe_id") or "",
        }

    def _load_json_findings(fp: Path):
        obj = json.loads(fp.read_text(encoding="utf-8", errors="ignore"))
        if isinstance(obj, dict):
            # common: {"findings":[...]} or {"items":[...]}
            for k in ("findings","items","results","data"):
                if k in obj and isinstance(obj[k], list):
                    return obj[k]
            # or already normalized dict -> wrap
            return [obj]
        if isinstance(obj, list):
            return obj
        return []

    def _load_csv_findings(fp: Path):
        rows = []
        with fp.open("r", encoding="utf-8", errors="ignore", newline="") as f:
            r = csv.DictReader(f)
            for row in r:
                rows.append(row)
        return rows

    def _match(rec: dict, sevs:set, tools:set, search:str):
        s = search.lower().strip() if search else ""
        if sevs:
            sev = str(rec.get("severity","")).upper()
            if sev not in sevs:
                return False
        if tools:
            tool = str(rec.get("tool","")).upper()
            if tool not in tools:
                return False
        if s:
            hay = " ".join([
                str(rec.get("title","")),
                str(rec.get("rule_id","")),
                str(rec.get("file","")),
                str(rec.get("cwe","")),
                str(rec.get("tool","")),
                str(rec.get("severity","")),
            ]).lower()
            if s not in hay:
                return False
        return True

    @_app.route("/api/vsp/run_findings_preview_v1/<rid>", methods=["GET"])
    def api_vsp_run_findings_preview_v1(rid):
        limit = int(request.args.get("limit","200") or "200")
        limit = max(1, min(limit, 2000))
        page = int(request.args.get("page","1") or "1")
        page = max(1, page)

        sevs_q = _norm(request.args.get("sev",""))
        tools_q = _norm(request.args.get("tool",""))
        search = _norm(request.args.get("search",""))

        sevs = set([x.strip().upper() for x in sevs_q.split(",") if x.strip()]) if sevs_q else set()
        tools = set([x.strip().upper() for x in tools_q.split(",") if x.strip()]) if tools_q else set()

        run_dir = _resolve(rid)
        if not run_dir:
            return jsonify(ok=False, error="run_not_found", rid=rid), 404

        run_dir = Path(run_dir)
        cand = [
            run_dir / "findings_unified.json",
            run_dir / "reports" / "findings_unified.json",
            run_dir / "findings_unified.csv",
            run_dir / "reports" / "findings_unified.csv",
        ]
        fp = next((x for x in cand if x.is_file() and x.stat().st_size>0), None)
        if not fp:
            return jsonify(ok=False, error="findings_file_not_found", rid=rid, run_dir=str(run_dir)), 404

        try:
            if fp.suffix.lower() == ".json":
                raw = _load_json_findings(fp)
            else:
                raw = _load_csv_findings(fp)
        except Exception as e:
            return jsonify(ok=False, error="findings_parse_error", detail=str(e), file=str(fp)), 500

        # normalize + filter
        normed = []
        for r in raw:
            if not isinstance(r, dict):
                continue
            rec = _pick_fields(r)
            if _match(rec, sevs, tools, search):
                normed.append(rec)

        total = len(normed)
        start = (page-1)*limit
        end = start + limit
        items = normed[start:end]

        # helpful facets
        sev_counts = {}
        tool_counts = {}
        for rec in normed[:5000]:
            sv = str(rec.get("severity","")).upper() or "UNKNOWN"
            tl = str(rec.get("tool","")).upper() or "UNKNOWN"
            sev_counts[sv] = sev_counts.get(sv, 0) + 1
            tool_counts[tl] = tool_counts.get(tl, 0) + 1

        return jsonify(
            ok=True,
            rid=rid,
            run_dir=str(run_dir),
            file=str(fp),
            page=page,
            limit=limit,
            total=total,
            items=items,
            facets={"severity": sev_counts, "tool": tool_counts},
        )
# === /VSP_GATEWAY_FINDINGS_PREVIEW_V1 ===

try:
    _APP = globals().get("application") or globals().get("app")
    _vsp_install_findings_preview_v1(_APP)
except Exception:
    pass




# === VSP_WSGI_FINDINGS_PREVIEW_SCHEMA_GUARD_V1 ===
def _vsp_findings_preview_guard_bytes(body_bytes: bytes) -> bytes:
    import json
    try:
        obj = json.loads(body_bytes.decode("utf-8", errors="ignore"))
        if not isinstance(obj, dict):
            return body_bytes

        # If endpoint returns missing-file -> degrade gracefully (commercial)
        if obj.get("ok") is False and obj.get("error") in ("findings_file_not_found",):
            rid = obj.get("rid")
            run_dir = obj.get("run_dir") or obj.get("run_dir_guess") or obj.get("run_dir_resolved") or obj.get("run_dir_path")
            fixed = {
                "ok": True,
                "has_findings": False,
                "warning": obj.get("error"),
                "rid": rid,
                "run_dir": run_dir,
                "file": None,
                "page": int(obj.get("page", 1) or 1),
                "limit": int(obj.get("limit", 200) or 200),
                "total": 0,
                "items": [],
                "facets": {"severity": {}, "tool": {}},
            }
            return json.dumps(fixed, ensure_ascii=False).encode("utf-8")

        return body_bytes
    except Exception:
        return body_bytes

def _vsp_wsgi_wrap_findings_preview_schema(app):
    if getattr(app, "_vsp_wrapped_findprev_guard", False):
        return app
    setattr(app, "_vsp_wrapped_findprev_guard", True)

    def _wrapped(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_findings_preview_v1/"):
            return app(environ, start_response)

        captured = {"status": None, "headers": None, "exc": None}
        def _sr(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers) if headers else []
            captured["exc"] = exc_info
            return None

        iterable = app(environ, _sr)

        chunks = []
        try:
            for c in iterable:
                if c:
                    chunks.append(c)
        finally:
            try:
                close = getattr(iterable, "close", None)
                if close:
                    close()
            except Exception:
                pass

        body = b"".join(chunks)
        body2 = _vsp_findings_preview_guard_bytes(body)

        hdrs = captured["headers"] or []
        new_hdrs = []
        for k, v in hdrs:
            if str(k).lower() == "content-length":
                continue
            new_hdrs.append((k, v))
        new_hdrs.append(("Content-Length", str(len(body2))))
        start_response(captured["status"] or "200 OK", new_hdrs, captured["exc"])
        return [body2]

    return _wrapped

try:
    _APP = globals().get("application") or globals().get("app")
    if _APP is not None:
        globals()["application"] = _vsp_wsgi_wrap_findings_preview_schema(_APP)
except Exception:
    pass
# === /VSP_WSGI_FINDINGS_PREVIEW_SCHEMA_GUARD_V1 ===

