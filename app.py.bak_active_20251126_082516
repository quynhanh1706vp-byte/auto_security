from __future__ import annotations
import json
import os
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime

from flask import Flask, render_template, send_file, abort, request

BASE_DIR = Path(__file__).resolve().parent.parent  # .../SECURITY_BUNDLE
OUT_DIR = BASE_DIR / "out"
UI_DIR = BASE_DIR / "ui"
TOOL_CONFIG_PATH = UI_DIR / "tool_config.json"
DASHBOARD_STATE_PATH = UI_DIR / "dashboard_state.json"

app = Flask(__name__)

# === Helpers cho Runs & Reports ===
def _sb_scan_runs(max_items: int = 50):
    """Scan thư mục out/ để lấy danh sách RUN_* + *_RUN_* mới nhất.

    Trả về list[dict] với các field:
      - run_id
      - total, c, h, m, l
      - report_html (link tới PM-style report nếu có)
    """
    import os, json
    from pathlib import Path

    ROOT = Path(__file__).resolve().parent.parent
    out_dir = ROOT / "out"
    if not out_dir.exists():
        return []

    def norm_int(x):
        try:
            return int(x)
        except Exception:
            return 0

    runs = []
    for d in sorted(out_dir.iterdir(), key=lambda p: p.stat().st_mtime, reverse=True):
        if not d.is_dir():
            continue
        name = d.name
        if "RUN" not in name:
            continue

        report_dir = d / "report"
        summary_path = report_dir / "summary_unified.json"
        total = c = h = m = l = 0
        if summary_path.exists():
            try:
                js = json.loads(summary_path.read_text(encoding="utf-8"))
                total = norm_int(js.get("total_findings") or js.get("TOTAL_FINDINGS") or 0)
                sev = js.get("severity_counts") or js.get("SEVERITY_COUNTS") or {}
                c = norm_int(sev.get("CRITICAL") or sev.get("Critical") or 0)
                h = norm_int(sev.get("HIGH") or 0)
                m = norm_int(sev.get("MEDIUM") or 0)
                l = norm_int(sev.get("LOW") or 0)
            except Exception:
                pass

        report_html = None
        pm = report_dir / "security_resilient.html"
        if pm.exists():
            report_html = f"/pm_report/{name}/html"

        runs.append({
            "run_id": name,
            "total": total,
            "c": c,
            "h": h,
            "m": m,
            "l": l,
            "report_html": report_html,
        })
        if len(runs) >= max_items:
            break
    return runs

# @app.route("/runs")  # disabled duplicate /runs route
def runs_page():
    """Trang Runs & Reports – bảng history các RUN trong out/."""
    runs = _sb_scan_runs()
    return render_template("runs.html", active_page="runs", runs=runs)


def get_run_dirs() -> List[Path]:
    if not OUT_DIR.is_dir():
        return []
    dirs = [p for p in OUT_DIR.iterdir() if p.is_dir() and p.name.startswith("RUN_")]
    dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return dirs


def load_summary_for_run(run_dir: Path) -> Dict[str, Any]:
    summary_candidates = [
        run_dir / "summary_unified.json",
        run_dir / "summary.json",
        run_dir / "SUMMARY.json",
        run_dir / "SUMMARY.txt",
        run_dir / "summary" / "summary_unified.json",
        run_dir / "summary" / "summary.json",
        run_dir / "summary" / "SUMMARY.json",
        run_dir / "summary" / "SUMMARY.txt",
    ]

    for p in summary_candidates:
        if p.is_file():
            try:
                if p.suffix.lower() == ".txt":
                    return {
                        "source": str(p.relative_to(run_dir)),
                        "raw_text": p.read_text(encoding="utf-8", errors="ignore"),
                    }
                data = json.loads(p.read_text(encoding="utf-8"))
                if isinstance(data, dict):
                    data.setdefault("source", str(p.relative_to(run_dir)))
                return data
            except Exception as e:
                return {
                    "error": f"Error reading {p.name}: {e}",
                    "source": str(p.relative_to(run_dir)),
                }

    findings_candidates = [
        run_dir / "findings_unified.json",
        run_dir / "findings.json",
        run_dir / "summary" / "findings_unified.json",
        run_dir / "summary" / "findings.json",
    ]

    for p in findings_candidates:
        if not p.is_file():
            continue
        try:
            raw = json.loads(p.read_text(encoding="utf-8"))
            if isinstance(raw, dict) and "findings" in raw:
                items = raw["findings"]
            else:
                items = raw

            sev_counts: Dict[str, int] = {}
            tool_counts: Dict[str, int] = {}

            if isinstance(items, list):
                for f in items:
                    if not isinstance(f, dict):
                        continue
                    sev = (
                        str(
                            f.get("severity")
                            or f.get("level")
                            or f.get("severity_label")
                            or ""
                        )
                        .upper()
                        .strip()
                    )
                    if sev:
                        sev_counts[sev] = sev_counts.get(sev, 0) + 1

                    tool = (
                        f.get("tool")
                        or f.get("source")
                        or f.get("engine")
                        or f.get("scanner")
                    )
                    if tool:
                        tool = str(tool)
                        tool_counts[tool] = tool_counts.get(tool, 0) + 1

            total = sum(sev_counts.values()) if sev_counts else None

            return {
                "source": str(p.relative_to(run_dir)),
                "total_findings": total,
                "by_severity": sev_counts,
                "by_tool": tool_counts,
                "note": "Summary auto-built from findings file because no explicit summary_* file was found.",
            }
        except Exception as e:
            return {
                "error": f"Error building summary from {p.name}: {e}",
                "source": str(p.relative_to(run_dir)),
            }

    return {}


def extract_severity(summary: Dict[str, Any]) -> Dict[str, int]:
    if not isinstance(summary, dict):
        return {}
    for key in ("by_severity", "severity_count", "severity"):
        val = summary.get(key)
        if isinstance(val, dict):
            return {
                str(k): int(v)
                for k, v in val.items()
                if isinstance(v, (int, float))
            }
    return {}


def extract_tools(summary: Dict[str, Any]) -> Dict[str, int]:
    if not isinstance(summary, dict):
        return {}
    for key in ("by_tool", "tool_count", "tools"):
        val = summary.get(key)
        if isinstance(val, dict):
            return {
                str(k): int(v)
                for k, v in val.items()
                if isinstance(v, (int, float))
            }
    return {}


def extract_total(summary: Dict[str, Any]) -> Optional[int]:
    if not isinstance(summary, dict):
        return None
    for key in ("total_findings", "total", "count", "total_issues"):
        v = summary.get(key)
        if isinstance(v, (int, float)):
            return int(v)
    sev = extract_severity(summary)
    if sev:
        return sum(sev.values())
    return None


def load_tool_config() -> Any:
    if TOOL_CONFIG_PATH.is_file():
        try:
            return json.loads(TOOL_CONFIG_PATH.read_text(encoding="utf-8"))
        except Exception as e:
            return {"error": f"Error reading tool_config.json: {e}"}
    return {"info": "tool_config.json not found in ui/."}


def load_dashboard_state() -> Dict[str, Any]:
    if DASHBOARD_STATE_PATH.is_file():
        try:
            return json.loads(DASHBOARD_STATE_PATH.read_text(encoding="utf-8"))
        except Exception:
            return {}
    return {}


def save_dashboard_state(state: Dict[str, Any]) -> None:
    try:
        DASHBOARD_STATE_PATH.write_text(
            json.dumps(state, ensure_ascii=False, indent=2),
            encoding="utf-8",
        )
    except Exception:
        pass


def get_latest_run_with_summary() -> (Optional[Path], Dict[str, Any]):
    for rd in get_run_dirs():
        s = load_summary_for_run(rd)
        if s:  # có gì đó (summary/findings) thì dùng
            return rd, s
    return None, {}


@app.route("/")
def index():
    # Dashboard main: latest RUN_* summary_unified.json + findings.json
    import json
    from pathlib import Path

    root = Path(__file__).resolve().parent.parent  # /home/test/Data/SECURITY_BUNDLE
    out_dir = root / "out"

    run_dirs = sorted(
        [p for p in out_dir.glob("RUN_*") if p.is_dir() and not p.name.startswith("RUN_DEMO_")],
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )

    summary = {
        "run_id": None,
        "src": "",
        "total": 0,
        "critical": 0,
        "high": 0,
        "medium": 0,
        "low": 0,
        "info": 0,
        "tools": [],
        "critical_pct": 0,
        "high_pct": 0,
        "medium_pct": 0,
        "low_pct": 0,
        "info_pct": 0,
    }

    trend = []
    top_risks = []

    def parse_summary(path, run_name):
        try:
            raw = json.loads(path.read_text(encoding="utf-8"))
        except Exception as e:
            print(f"[ERR][INDEX] cannot read {path}: {e}")
            return None

        total = (
            raw.get("total_findings")
            or raw.get("TOTAL_FINDINGS")
            or raw.get("total")
            or raw.get("total_findings_all")
            or 0
        )

        sev_raw = (
            raw.get("severity_counts")
            or raw.get("SEVERITY_COUNTS")
            or raw.get("by_severity")
            or raw.get("severity")
            or {}
        )
        sev = {str(k).upper(): int(v) for k, v in sev_raw.items()}

        return {
            "run_id": run_name,
            "src": raw.get("src") or raw.get("SRC") or "",
            "total": int(total),
            "critical": sev.get("CRITICAL", 0),
            "high": sev.get("HIGH", 0),
            "medium": sev.get("MEDIUM", 0),
            "low": sev.get("LOW", 0),
            "info": sev.get("INFO", 0),
        }

    if run_dirs:
        # latest run
        run_dir = run_dirs[0]
        report_dir = run_dir / "report"
        summary_path = report_dir / "summary_unified.json"
        findings_path = report_dir / "findings.json"

        parsed = parse_summary(summary_path, run_dir.name)
        if parsed:
            summary.update(parsed)

        # percentages for severity bar chart
        max_bucket = max(
            summary["critical"],
            summary["high"],
            summary["medium"],
            summary["low"],
            summary["info"],
            1,
        )
        if max_bucket > 0:
            summary["critical_pct"] = int(summary["critical"] * 100 / max_bucket)
            summary["high_pct"] = int(summary["high"] * 100 / max_bucket)
            summary["medium_pct"] = int(summary["medium"] * 100 / max_bucket)
            summary["low_pct"] = int(summary["low"] * 100 / max_bucket)
            summary["info_pct"] = int(summary["info"] * 100 / max_bucket)

        # per-tool counts
        try:
            raw2 = json.loads(summary_path.read_text(encoding="utf-8"))
        except Exception:
            raw2 = {}
        tools_raw = raw2.get("by_tool") or raw2.get("BY_TOOL") or raw2.get("tools") or {}
        tools = []
        for name, counts in tools_raw.items():
            if isinstance(counts, dict):
                count_val = int(counts.get("count", 0))
            else:
                try:
                    count_val = int(counts)
                except Exception:
                    count_val = 0
            tools.append({"name": name, "count": count_val})
        summary["tools"] = tools

        # Trend – last runs (up to 6)
        for rd in run_dirs[:6]:
            sp = rd / "report" / "summary_unified.json"
            if not sp.is_file():
                continue
            parsed_trend = parse_summary(sp, rd.name)
            if parsed_trend:
                trend.append(parsed_trend)

        # Top risk findings from findings.json
        try:
            raw_findings = json.loads(findings_path.read_text(encoding="utf-8"))
            if isinstance(raw_findings, dict) and "items" in raw_findings:
                items = raw_findings.get("items") or []
            elif isinstance(raw_findings, list):
                items = raw_findings
            else:
                items = []
        except Exception as e:
            print(f"[WARN][INDEX] cannot read findings from {findings_path}: {e}")
            items = []

        def pick(d, keys, default=""):
            for k in keys:
                if k in d and d[k]:
                    return d[k]
            return default

        severity_order = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1, "INFO": 0}

        for it in items:
            if not isinstance(it, dict):
                continue
            sev_raw_item = str(pick(it, ["severity_norm", "SEVERITY", "severity"], "INFO")).upper()
            sev_rank = severity_order.get(sev_raw_item, 0)
            rule_id = pick(it, ["rule_id", "id", "check_id", "rule", "type"], "")
            tool = pick(it, ["tool", "source", "scanner"], "")
            msg = pick(it, ["message_short", "message", "msg", "description", "detail"], "")
            path_val = pick(it, ["file", "path", "target", "location"], "")
            line_val = pick(it, ["line", "line_number", "start_line"], "")

            top_risks.append(
                {
                    "severity": sev_raw_item,
                    "severity_rank": sev_rank,
                    "rule_id": rule_id,
                    "tool": tool,
                    "msg": msg,
                    "path": path_val,
                    "line": line_val,
                }
            )

        top_risks.sort(key=lambda x: (x["severity_rank"], x["rule_id"]), reverse=True)
        top_risks = top_risks[:10]

    print(
        f"[INFO][INDEX] RUN={summary['run_id']}, total={summary['total']}, "
        f"C={summary['critical']}, H={summary['high']}, "
        f"M={summary['medium']}, L={summary['low']}"
    )

    return render_template("index.html", active_page="dashboard", summary=summary, trend=trend, top_risks=top_risks)



@app.route("/run/<run_id>")
def run_detail(run_id: str):
    run_dir = OUT_DIR / run_id
    if not run_dir.is_dir():
        abort(404, description=f"Run directory not found: {run_id}")

    summary = load_summary_for_run(run_dir)
    sev = extract_severity(summary)
    tools = extract_tools(summary)
    total = extract_total(summary)

    reports = []
    report_dir = run_dir / "report"
    if report_dir.is_dir():
        for fname, label in [
            ("security_resilient.html", "Security Resilient"),
            ("pm_style_report.html", "PM-style (HTML)"),
            ("pm_style_report_print.html", "PM-style (Print/PDF)"),
            ("simple_report.html", "Checkmarx-style (simple_report)"),
        ]:
            p = report_dir / fname
            if p.is_file():
                reports.append({"name": fname, "label": label})

    return render_template(
        "run_detail.html",
        run_id=run_id,
        summary=summary,
        sev=sev,
        tools=tools,
        total=total,
        reports=reports,
    )


@app.route("/report/<run_id>/<report_name>")
def serve_report(run_id: str, report_name: str):
    run_dir = OUT_DIR / run_id
    report_dir = run_dir / "report"
    file_path = report_dir / report_name

    if not report_dir.is_dir() or not file_path.is_file():
        abort(404, description=f"Report not found: {run_id}/{report_name}")

    return send_file(file_path)



@app.route("/settings", methods=["GET"])
def settings():
    """
    SECURITY_BUNDLE – Settings page.
    Hiển thị bảng BY TOOL / CONFIG từ static/last_tool_config.json.
    """
    import os, json
    from flask import render_template

    root = os.path.dirname(os.path.abspath(__file__))
    cfg_path = os.path.join(root, "static", "last_tool_config.json")

    cfg_data = []
    if os.path.exists(cfg_path):
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                cfg_data = json.load(f)
        except Exception:
            # Nếu lỗi parse thì vẫn trả trang, JS phía client sẽ fetch API riêng
            cfg_data = []

    return render_template(
        "settings.html",
        cfg_path=cfg_path,
        cfg_data=cfg_data,
    )
def _load_last_summary_and_findings():
    """Load last summary_unified.json + findings.json.

    Ưu tiên:
    - ui/static/last_summary_unified.json
    - ui/static/last_findings.json
    Nếu không có thì tìm RUN_* mới nhất trong out/ có đủ 2 file.
    """
    summary_path = STATIC_DIR / "last_summary_unified.json"
    findings_path = STATIC_DIR / "last_findings.json"

    run_dir = None
    run_id = None

    if not summary_path.exists() or not findings_path.exists():
        candidates = []
        if OUT_DIR.exists():
            for d in OUT_DIR.iterdir():
                if not d.is_dir():
                    continue
                name = d.name
                if not name.startswith("RUN_"):
                    continue
                s = d / "report" / "summary_unified.json"
                f = d / "report" / "findings.json"
                if s.exists() and f.exists():
                    candidates.append((d.stat().st_mtime, d, s, f))
        if not candidates:
            return None
        candidates.sort(reverse=True)
        _, run_dir, summary_path, findings_path = candidates[0]
        run_id = run_dir.name

    with summary_path.open(encoding="utf-8") as fh:
        summary = json.load(fh)
    with findings_path.open(encoding="utf-8") as fh:
        findings = json.load(fh)

    if not run_id:
        run_id = summary.get("run_id") or summary.get("run") or "UNKNOWN"

    return {
        "run_id": run_id,
        "run_dir": str(run_dir) if run_dir else None,
        "summary_path": str(summary_path),
        "findings_path": str(findings_path),
        "summary": summary,
        "findings": findings,
    }
# ======= END HELPERS V2 =======


@app.route("/settings", methods=["GET", "POST"])
def settings_latest():
    """
    Settings – phiên bản override cuối cùng.
    Đọc /ui/tool_config.json và đổ vào bảng BY TOOL / CONFIG.
    Hỗ trợ:
    - [ {...}, {...} ]
    - { "tools": [ {...}, {...} ] }
    - {..},{..},{..} (nhiều object không bọc [])
    """
    from pathlib import Path as _Path
    import json as _json

    cfg_path = _Path("/home/test/Data/SECURITY_BUNDLE/ui/tool_config.json")
    print(f"[INFO][SETTINGS_LATEST] cfg_path={cfg_path} exists={cfg_path.exists()}")

    tools = []
    raw_text = ""
    if cfg_path.exists():
        try:
            raw_text = cfg_path.read_text(encoding="utf-8")
            print(f"[INFO][SETTINGS_LATEST] len(raw_text)={len(raw_text)}")
        except Exception as e:
            print(f"[ERR][SETTINGS_LATEST] read_text failed: {e}")
    else:
        print("[WARN][SETTINGS_LATEST] tool_config.json not found")

    parsed = None
    txt = raw_text.strip()

    if txt:
        # 1) Thử JSON chuẩn
        try:
            parsed = _json.loads(txt)
            print("[INFO][SETTINGS_LATEST] json.loads OK (chuẩn).")
        except Exception as e1:
            print(f"[WARN][SETTINGS_LATEST] json.loads failed: {e1}")
            # 2) Thử coi toàn bộ file là list các object, không bọc []
            #    => cắt theo block { ... } bằng counter depth
            chunks = []
            cur = ""
            depth = 0
            for ch in txt:
                cur += ch
                if ch == '{':
                    depth += 1
                elif ch == '}':
                    depth -= 1
                    if depth == 0 and cur.strip():
                        chunks.append(cur)
                        cur = ""
            items = []
            for c in chunks:
                s = c.strip()
                if s.endswith(','):
                    s = s[:-1]
                try:
                    items.append(_json.loads(s))
                except Exception as e2:
                    print(f"[ERR][SETTINGS_LATEST] parse chunk failed: {e2}")
            if items:
                parsed = items
                print(f"[INFO][SETTINGS_LATEST] parsed {len(items)} tool objects từ chunks.")

    if isinstance(parsed, dict) and isinstance(parsed.get("tools"), list):
        tools = parsed["tools"]
    elif isinstance(parsed, list):
        tools = parsed

    print(f"[INFO][SETTINGS_LATEST] rows={len(tools)}")

    # Luôn truyền nguyên văn cho RAW JSON (DEBUG)
    raw_str = raw_text

    # Chưa xử lý POST, chỉ đọc.
    if request.method == "POST":
        pass

    return render_template(
        "settings.html",
        cfg_path=str(cfg_path),
        cfg_rows=tools,
        table_rows=tools,
        rows=tools,
        cfg_raw=raw_str,
    )


# EXTRA_SETTINGS_LATEST_REMOVED @app.route("/settings_latest", methods=["GET", "POST"])
def settings_latest():
    """
    Settings LATEST – đọc /ui/tool_config.json và render bảng.
    Hỗ trợ:
    - [ {...}, {...} ]
    - { "tools": [ {...}, {...} ] }
    - {..},{..},{..} (nhiều object không bọc [])
    """
    from pathlib import Path as _Path
    import json as _json

    cfg_path = _Path("/home/test/Data/SECURITY_BUNDLE/ui/tool_config.json")
    print(f"[INFO][SETTINGS_LATEST] cfg_path={cfg_path} exists={cfg_path.exists()}")

    tools = []
    raw_text = ""
    if cfg_path.exists():
        try:
            raw_text = cfg_path.read_text(encoding="utf-8")
            print(f"[INFO][SETTINGS_LATEST] len(raw_text)={len(raw_text)}")
        except Exception as e:
            print(f"[ERR][SETTINGS_LATEST] read_text failed: {e}")
    else:
        print("[WARN][SETTINGS_LATEST] tool_config.json not found")

    parsed = None
    txt = raw_text.strip()

    if txt:
        # 1) Thử JSON chuẩn
        try:
            parsed = _json.loads(txt)
            print("[INFO][SETTINGS_LATEST] json.loads OK (chuẩn).")
        except Exception as e1:
            print(f"[WARN][SETTINGS_LATEST] json.loads failed: {e1}")
            # 2) Tự tách thành các block { ... } theo depth
            chunks = []
            cur = ""
            depth = 0
            for ch in txt:
                cur += ch
                if ch == '{':
                    depth += 1
                elif ch == '}':
                    depth -= 1
                    if depth == 0 and cur.strip():
                        chunks.append(cur)
                        cur = ""
            items = []
            for c in chunks:
                s = c.strip()
                if s.endswith(','):
                    s = s[:-1]
                try:
                    items.append(_json.loads(s))
                except Exception as e2:
                    print(f"[ERR][SETTINGS_LATEST] parse chunk failed: {e2}")
            if items:
                parsed = items
                print(f"[INFO][SETTINGS_LATEST] parsed {len(items)} tool objects từ chunks.")

    if isinstance(parsed, dict) and isinstance(parsed.get("tools"), list):
        tools = parsed["tools"]
    elif isinstance(parsed, list):
        tools = parsed

    print(f"[INFO][SETTINGS_LATEST] rows={len(tools)}")

    raw_str = raw_text  # show nguyên văn

    if request.method == "POST":
        # Chưa xử lý Save, chỉ đọc
        pass

    return render_template(
        "settings.html",
        cfg_path=str(cfg_path),
        cfg_rows=tools,
        table_rows=tools,
        rows=tools,
        cfg_raw=raw_str,
    )





@app.route("/api/tool_rules_v2_v2", methods=["GET"])
def api_tool_rules_v2_v2_sb():
    """
    Trả về danh sách tool rules cho tab Settings/Data Source.
    Đọc trực tiếp static/last_tool_config.json.
    """
    import os, json
    from flask import jsonify

    root = os.path.dirname(os.path.abspath(__file__))
    cfg_path = os.path.join(root, "static", "last_tool_config.json")

    if not os.path.exists(cfg_path):
        return jsonify({
            "status": "error",
            "error": "last_tool_config.json not found",
            "path": cfg_path,
        }), 404

    try:
        with open(cfg_path, "r", encoding="utf-8") as f:
            cfg = json.load(f)
    except Exception as e:
        return jsonify({
            "status": "error",
            "error": f"Cannot parse last_tool_config.json: {e}",
            "path": cfg_path,
        }), 500

    # Nếu file là list thì bọc vào field tools, cho UI dễ dùng
    if isinstance(cfg, list):
        payload = {"status": "ok", "tools": cfg}
    else:
        payload = {"status": "ok", "data": cfg}

    return jsonify(payload)
### SB_FORCE_MAIN_RUN_UI_V1




@app.route("/tool_rules", methods=["GET"])
def tool_rules_redirect():
    from flask import render_template
    return render_template("tool_rules.html", active_page="tool_rules")


@app.route("/datasource", methods=["GET"])
def datasource_page():
    from flask import render_template
    # Trang Data Source: chỉ hiển thị phần JSON / summary (Tool rules đang bị ẩn bằng active_page != 'tool_rules')
    return render_template("datasource.html")



# === Tool rules API (reset clean) ===
@app.route("/api/tool_rules", methods=["GET", "POST"])
def api_tool_rules():
    from pathlib import Path as _Path
    import json
    from flask import request, jsonify

    rules_path = _Path(__file__).resolve().parent.parent / "tool_rules.json"

    if request.method == "GET":
        # GET luôn trả 200, kể cả khi có lỗi -> tránh HTTP 500
        try:
            if rules_path.exists():
                raw = rules_path.read_text(encoding="utf-8")
                data = json.loads(raw) if raw.strip() else []
            else:
                data = []
        except Exception as e:
            # Lỗi đọc / parse: trả list rỗng + thông tin lỗi, nhưng HTTP 200
            return jsonify({
                "ok": False,
                "error": "load_failed: " + str(e),
                "path": str(rules_path),
                "rules": []
            }), 200

        if not isinstance(data, list):
            data = []

        return jsonify({
            "ok": True,
            "path": str(rules_path),
            "rules": data
        }), 200

    # POST: lưu rules
    payload = request.get_json(silent=True) or {}
    rules = payload.get("rules", [])
    if not isinstance(rules, list):
        return jsonify({
            "ok": False,
            "error": "rules must be a list"
        }), 400

    try:
        rules_path.write_text(
            json.dumps(rules, indent=2, ensure_ascii=False),
            encoding="utf-8",
        )
    except Exception as e:
        return jsonify({
            "ok": False,
            "error": "save_failed: " + str(e),
            "path": str(rules_path)
        }), 200

    return jsonify({
        "ok": True,
        "path": str(rules_path),
        "saved": len(rules)
    }), 200

if __name__ == "__main__":
    print("[INFO] SECURITY_BUNDLE UI starting on 0.0.0.0:8905 (SB_FORCE_MAIN_RUN_UI_V1)")
    # Debug = True để auto-reload khi sửa template/static
    app.run(host="0.0.0.0", port=8905, debug=True)


# Alias API: tool_rules_v2_v2 – tái sử dụng logic của api_tool_rules_v2
@app.route("/api/tool_rules_v2_v2", methods=["GET"])
def api_tool_rules_v2_v2():
    try:
        return api_tool_rules_v2()
    except Exception as e:
        from flask import jsonify
        return jsonify({"status": "error", "error": f"alias v2_v2 failed: {e}"}), 500
