

#!/usr/bin/env python3
from __future__ import annotations
from pathlib import Path
VSPPath = Path

import json

ROOT = Path(__file__).resolve().parents[1]


import subprocess

from typing import Any, Dict, List, Optional

from flask import Flask, jsonify, render_template, request

HERE = Path(__file__).resolve().parent
ROOT = HERE.parent
OUT_DIR = ROOT / "out"
BIN_DIR = ROOT / "bin"

app = Flask(
    __name__,
    template_folder=str(HERE / "my_flask_app" / "templates"),
    static_folder=str(HERE / "my_flask_app" / "static"),
)

# ---------- helpers ----------

def _load_json_safe(path: Path) -> Optional[Any]:
    try:
        if not path.is_file():
            return None
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:  # noqa: BLE001
        print(f"[VSP] Lỗi đọc JSON {path}: {e}")
        return None


def _discover_run_dirs(limit: int = 50) -> List[Path]:
    runs: List[Path] = []
    if not OUT_DIR.is_dir():
        return runs

    candidates: List[Path] = []
    candidates.extend(sorted(OUT_DIR.glob("RUN_VSP_FULL_EXT_*")))
    candidates.extend(sorted(OUT_DIR.glob("RUN_*")))

    for p in candidates:
        if p.is_dir():
            runs.append(p)

    if limit and len(runs) > limit:
        runs = runs[-limit:]
    return runs


def _get_latest_run() -> Optional[Path]:
    candidates = _discover_run_dirs(limit=50)
    for run_dir in reversed(candidates):
        summary = run_dir / "report" / "summary_unified.json"
        data = _load_json_safe(summary)
        if isinstance(data, dict) and "total_findings" in data:
            return run_dir
    return None


def _build_severity(summary: Dict[str, Any]) -> Dict[str, int]:
    raw = summary.get("by_severity") or summary.get("severity") or {}
    sev_full: Dict[str, int] = {}
    for key in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]:
        sev_full[key] = int(raw.get(key, 0))
    return sev_full


def _build_by_tool_crit_high(summary: Dict[str, Any]) -> List[Dict[str, Any]]:
    result: List[Dict[str, Any]] = []

    by_tool_total = summary.get("by_tool") or {}
    if not isinstance(by_tool_total, dict):
        by_tool_total = {}

    by_tool_sev = summary.get("by_tool_severity") or {}
    if not isinstance(by_tool_sev, dict):
        by_tool_sev = {}

    tools = sorted(by_tool_total.keys())
    for t in tools:
        sev = by_tool_sev.get(t) or {}
        crit = int(sev.get("CRITICAL", 0))
        high = int(sev.get("HIGH", 0))
        total = int(by_tool_total.get(t, 0))
        if crit == 0 and high == 0 and total > 0:
            high = total
        result.append(
            {
                "tool": t,
                "critical": crit,
                "high": high,
                "total": total,
            }
        )

    result.sort(key=lambda r: (r["critical"] + r["high"]), reverse=True)
    return result


def _build_top_cwe(summary: Dict[str, Any]) -> List[Dict[str, Any]]:
    rows = summary.get("top_cwe") or summary.get("by_cwe") or []
    if not isinstance(rows, list):
        return []
    result: List[Dict[str, Any]] = []
    for r in rows:
        if not isinstance(r, dict):
            continue
        cwe = r.get("cwe") or r.get("id") or "N/A"
        count = int(r.get("count") or r.get("total") or 0)
        result.append({"cwe": cwe, "count": count})
    return result


def _build_top_dirs(summary: Dict[str, Any]) -> List[Dict[str, Any]]:
    rows = summary.get("top_dirs") or summary.get("by_dir") or []
    if not isinstance(rows, list):
        return []
    result: List[Dict[str, Any]] = []
    for r in rows:
        if not isinstance(r, dict):
            continue
        path = r.get("path") or r.get("dir") or "N/A"
        count = int(r.get("count") or r.get("total") or 0)
        result.append({"path": path, "count": count})
    return result


def _compute_security_score(sev: Dict[str, int]) -> int:
    """
    Tính điểm 0–100 rất đơn giản:
      - CRITICAL * 5
      - HIGH     * 2
      - MEDIUM   * 1
    Score = 100 - penalty (clamp 0–100)
    """
    crit = int(sev.get("CRITICAL", 0))
    high = int(sev.get("HIGH", 0))
    med = int(sev.get("MEDIUM", 0))
    penalty = crit * 5 + high * 2 + med * 1
    score = 100 - penalty
    if score < 0:
        score = 0
    if score > 100:
        score = 100
    return int(score)


# ---------- UI route ----------

def get_latest_vsp_run():
    """
    Tìm RUN_VSP_FULL_EXT_* mới nhất dựa trên timestamp trong tên thư mục
    (YYYYmmdd_HHMMSS). Hỗ trợ cả tên có hoặc không có 'DEMO'.
    Trả về (run_id, data_summary). Nếu không có thì (None, {}).
    """
    out_dir = ROOT / "out"
    candidates = list(out_dir.glob("RUN_VSP_FULL_EXT_*"))
    if not candidates:
        return None, {}

    def extract_ts(path_obj: Path):
        """
        Lấy timestamp dạng int YYYYmmddHHMMSS từ tên thư mục.
        Ví dụ:
        - RUN_VSP_FULL_EXT_20251202_121212
        - RUN_VSP_FULL_EXT_DEMO_20251201_160000
        """
        name = path_obj.name
        parts = name.split("_")
        ts_int = None

        for i in range(len(parts) - 2, -1, -1):
            if (
                len(parts[i]) == 8
                and parts[i].isdigit()
                and i + 1 < len(parts)
                and len(parts[i + 1]) == 6
                and parts[i + 1].isdigit()
            ):
                try:
                    ts_int = int(parts[i] + parts[i + 1])  # YYYYmmddHHMMSS
                except ValueError:
                    ts_int = None
                break

        if ts_int is not None:
            return (0, ts_int)

        # Fallback: dùng mtime nếu không parse được
        return (1, int(path_obj.stat().st_mtime))

    # Sort theo timestamp, bất kể DEMO hay không
    sorted_runs = sorted(candidates, key=extract_ts)
    run_dir = sorted_runs[-1]

    summary_path = run_dir / "report" / "summary_unified.json"
    if not summary_path.exists():
        return run_dir.name, {}

    try:
        with summary_path.open("r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception:
        data = {}

    return run_dir.name, data



@app.route("/")
@app.route("/security_bundle")
def security_bundle_index():
    return render_template("index.html")


# ---------- health ----------

@app.route("/api/vsp/health", methods=["GET"])
def api_vsp_health():
    return jsonify(
        {
            "ok": True,
            "status": "ok",
            "message": "VSP backend is alive.",
            "root": str(ROOT),
        }
    )


# ---------- RUN ----------

@app.route("/api/vsp/run", methods=["POST"])
def api_vsp_run():
    body = request.get_json(silent=True) or {}
    src_path = body.get("src_path") or "/home/test/Data/khach6"

    script = BIN_DIR / "run_vsp_full_ext.sh"
    if not script.is_file():
        return (
            jsonify(
                {
                    "ok": False,
                    "status": "error",
                    "message": f"Không tìm thấy script {script}",
                }
            ),
            500,
        )

    proc = subprocess.run(  # noqa: S603
        [str(script), src_path],
        cwd=str(ROOT),
        capture_output=True,
        text=True,
    )

    if proc.returncode != 0:
        return (
            jsonify(
                {
                    "ok": False,
                    "status": "error",
                    "message": "run_vsp_full_ext.sh failed",
                    "rc": proc.returncode,
                    "stderr": proc.stderr[-4000:],
                }
            ),
            500,
        )

    run_dir = _get_latest_run()
    if not run_dir:
        return (
            jsonify(
                {
                    "ok": False,
                    "status": "error",
                    "message": "Không tìm thấy RUN_VSP_FULL_EXT_* với summary_unified.json",
                }
            ),
            500,
        )

    summary_path = run_dir / "report" / "summary_unified.json"
    summary = _load_json_safe(summary_path) or {}

    return jsonify(
        {
            "ok": True,
            "status": "ok",
            "run_id": run_dir.name,
            "run_dir": str(run_dir),
            "summary": summary,
        }
    )


# ---------- Dashboard ----------


@app.route("/api/vsp/dashboard", methods=["GET"])
def api_vsp_dashboard():
    """
    Dashboard V1 (FE đang dùng) nhưng đọc data mới:
    - Chọn RUN_VSP_FULL_EXT_* mới nhất theo mtime
    - Đọc summary_unified.json -> severity, by_tool, ... 
    - Trả về cùng shape cũ: severity, total_findings, by_tool, run_id, profile, target
    """


    root = Path("/home/test/Data/SECURITY_BUNDLE")
    out_dir = root / "out"

    runs = sorted(out_dir.glob("RUN_VSP_FULL_EXT_*"), key=lambda p: p.stat().st_mtime, reverse=True)

    chosen_run = None
    summary = None

    for rd in runs:
        sp = rd / "report" / "summary_unified.json"
        if not sp.is_file():
            continue
        try:
            sdata = json.loads(sp.read_text(encoding="utf-8"))
        except Exception:
            continue
        chosen_run = rd
        summary = sdata
        break

    if not chosen_run or summary is None:
        # Trả về khung rỗng cho FE
        return jsonify({
            "run_id": None,
            "total_findings": 0,
            "severity": {
                "CRITICAL": 0,
                "HIGH": 0,
                "MEDIUM": 0,
                "LOW": 0,
                "INFO": 0,
                "TRACE": 0,
            },
            "by_tool": {},
            "profile": None,
            "target": None,
        })

    by_sev = summary.get("by_severity", {}) or {}
    severity = {
        "CRITICAL": int(by_sev.get("CRITICAL", 0) or 0),
        "HIGH": int(by_sev.get("HIGH", 0) or 0),
        "MEDIUM": int(by_sev.get("MEDIUM", 0) or 0),
        "LOW": int(by_sev.get("LOW", 0) or 0),
        "INFO": int(by_sev.get("INFO", 0) or 0),
        "TRACE": int(by_sev.get("TRACE", 0) or 0),
    }

    total_findings = int(summary.get("total_findings", 0) or 0)
    by_tool = summary.get("by_tool", {}) or {}

    payload = {
        "run_id": chosen_run.name,
        "total_findings": total_findings,
        "severity": severity,
        "by_tool": by_tool,
        "profile": summary.get("profile"),
        "target": summary.get("target"),
    }

    # Nếu unify đã tính thêm các KPI nâng cao thì cho luôn ra payload
    for key in ("security_score", "top_cwe", "top_dirs", "top_modules", "top_risky_tool"):
        if key in summary:
            payload[key] = summary[key]

    return jsonify(payload)

@app.route("/api/vsp/datasource", methods=["GET"])
def api_vsp_datasource():
    """
    mode=dashboard: trả summary cho chart / widget (đã normalize field + KPI).
    default: danh sách findings, đã normalize field cho UI.
    """
    run_dir = _get_latest_run()
    if not run_dir:
        mode = request.args.get("mode") or "detail"
        if mode == "dashboard":
            return jsonify({"ok": True, "run_id": None, "summary": {}})
        return jsonify({"ok": True, "run_id": None, "total": 0, "items": []})

    summary_path = run_dir / "report" / "summary_unified.json"
    findings_path = run_dir / "report" / "findings_unified.json"

    mode = request.args.get("mode") or "detail"

    if mode == "dashboard":
        summary_raw = _load_json_safe(summary_path) or {}
        if not isinstance(summary_raw, dict):
            summary_raw = {}

        # clone + thêm field UI + KPI
        summary = dict(summary_raw)
        sev = _build_severity(summary_raw)
        by_tool_ch = _build_by_tool_crit_high(summary_raw)
        by_cwe = _build_top_cwe(summary_raw)
        by_dir = _build_top_dirs(summary_raw)

        summary["severity"] = sev
        summary["by_tool_crit_high"] = by_tool_ch
        summary["by_cwe_ui"] = by_cwe
        summary["by_dir_ui"] = by_dir

        summary["security_score"] = _compute_security_score(sev)
        summary["top_risky_tool"] = by_tool_ch[0]["tool"] if by_tool_ch else "-"
        summary["top_cwe"] = by_cwe[0]["cwe"] if by_cwe else "-"
        summary["top_module"] = by_dir[0]["path"] if by_dir else "-"

        return jsonify(
            {
                "ok": True,
                "run_id": run_dir.name,
                "summary": summary,
            }
        )

    # --- detail mode ---
    raw_items = _load_json_safe(findings_path) or []
    if not isinstance(raw_items, list):
        raw_items = []

    severity = request.args.get("severity")
    tool = request.args.get("tool")
    search = request.args.get("search")

    def _match(it: Dict[str, Any]) -> bool:
        if severity and str(it.get("severity", "")).upper() != severity.upper():
            return False
        if tool and str(it.get("tool", "")).lower() != tool.lower():
            return False
        if search:
            s = search.lower()
            text = (
                str(it.get("rule_id", ""))
                + " "
                + str(it.get("message", ""))
                + " "
                + str(it.get("file", ""))
                + " "
                + str(it.get("cwe", ""))
                + " "
                + str(it.get("cve", ""))
            ).lower()
            if s not in text:
                return False
        return True

    filtered: List[Dict[str, Any]] = []
    for it in raw_items:
        if not isinstance(it, dict):
            continue
        if _match(it):
            norm: Dict[str, Any] = dict(it)
            sev2 = str(it.get("severity", "")).upper()
            norm["severity"] = sev2
            norm["sev"] = sev2
            norm["tool"] = it.get("tool", "")
            norm["rule"] = it.get("rule_id", "")
            norm["file"] = it.get("file", "")
            norm["line"] = it.get("line", 0)
            norm["message"] = it.get("message", "")
            norm["cwe"] = it.get("cwe", "")
            norm["cve"] = it.get("cve", "")
            filtered.append(norm)

    limit = request.args.get("limit", type=int) or 1000
    if limit > 5000:
        limit = 5000

    return jsonify(
        {
            "ok": True,
            "run_id": run_dir.name,
            "total": len(filtered),
            "items": filtered[:limit],
        }
    )


# ---------- Settings ----------

@app.route("/api/vsp/settings", methods=["GET"])
def api_vsp_settings():
    run_dir = _get_latest_run()
    summary: Dict[str, Any] = {}
    if run_dir:
        summary_path = run_dir / "report" / "summary_unified.json"
        s = _load_json_safe(summary_path)
        if isinstance(s, dict):
            summary = s

    by_tool_total = summary.get("by_tool", {}) if isinstance(summary, dict) else {}
    if not isinstance(by_tool_total, dict):
        by_tool_total = {}

    TOOL_META = {
        "bandit": ("Bandit", "Python SAST"),
        "codeql": ("CodeQL", "CodeQL"),
        "gitleaks": ("Gitleaks", "Secrets"),
        "grype": ("Grype", "Vuln DB"),
        "kics": ("KICS", "IaC"),
        "semgrep": ("Semgrep", "SAST"),
        "syft": ("Syft", "SBOM"),
        "trivy_fs": ("Trivy FS", "FS scan"),
    }

    tools_list: List[Dict[str, Any]] = []
    for key in ["gitleaks", "semgrep", "kics", "codeql", "bandit", "trivy_fs", "syft", "grype"]:
        label, ttype = TOOL_META.get(key, (key, ""))  # type: ignore[misc]
        enabled = bool(by_tool_total.get(key, 0))
        tools_list.append(
            {
                "key": key,
                "name": label,
                "type": ttype,
                "enabled": enabled,
            }
        )

    resp = {
        "ok": True,
        "profile": "EXT",
        "src_path": "/home/test/Data/khach6",
        "last_run_id": run_dir.name if run_dir else None,
        "tools": tools_list,
    }
    return jsonify(resp)


# ---------- Runs ----------

@app.route("/api/vsp/runs", methods=["GET"])
def api_vsp_runs():
    runs = _discover_run_dirs(limit=100)
    result: List[Dict[str, Any]] = []

    for run_dir in reversed(runs):
        summary_path = run_dir / "report" / "summary_unified.json"
        summary = _load_json_safe(summary_path)
        if not isinstance(summary, dict):
            summary = {}
        total = int(summary.get("total_findings", 0))
        tool_counts = summary.get("by_tool") or {}
        if not isinstance(tool_counts, dict):
            tool_counts = {}
        tools_enabled = sorted([k for k, v in tool_counts.items() if v])

        result.append(
            {
                "run_id": run_dir.name,
                "total_findings": total,
                "tools_enabled": tools_enabled,
            }
        )

    return jsonify({"ok": True, "runs": result})


@app.route("/api/vsp/runs_index", methods=["GET"])
def api_vsp_runs_index():
    return api_vsp_runs()


# ---------- main ----------




# === VSP DASHBOARD LIVE V2 – CLEAN IMPLEMENTATION (v4) ===
from pathlib import Path as _VSPPath
from flask import jsonify as _vsp_jsonify

try:
    VSPPath  # type: ignore[name-defined]
except NameError:  # pragma: no cover
    VSPPath = _VSPPath  # fallback nếu chưa có alias

VSP_ROOT = VSPPath("/home/test/Data/SECURITY_BUNDLE")

def _vsp_get_latest_full_ext_run():
    """Tìm RUN_VSP_FULL_EXT_* mới nhất, fallback last_vsp_run.txt nếu cần."""
    out_dir = VSP_ROOT / "out"
    run_dir = None

    try:
        candidates = sorted(out_dir.glob("RUN_VSP_FULL_EXT_*"))
    except Exception:
        candidates = []

    if candidates:
        run_dir = candidates[-1]
    else:
        last = VSP_ROOT / "out" / "last_vsp_run.txt"
        if last.exists():
            p = last.read_text(encoding="utf-8").strip()
            if p:
                run_dir = VSPPath(p)

    if not run_dir:
        return None, {}

    summary_path = run_dir / "report" / "summary_unified.json"
    if not summary_path.exists():
        return run_dir.name, {}

    import json
    try:
        data = json.loads(summary_path.read_text(encoding="utf-8"))
    except Exception:
        data = {}

    return run_dir.name, data


@app.route("/api/vsp/dashboard_v2")
def api_vsp_dashboard_v2():
    """API cho DASHBOARD v2 – trả về summary unify FULL EXT mới nhất."""
    run_id, data = _vsp_get_latest_full_ext_run()
    if not data:
        return _vsp_jsonify({
            "ok": False,
            "error": "No VSP FULL EXT run found.",
        }), 404

    summary = data.get("summary") or {}
    by_sev = summary.get("by_severity") or data.get("by_severity") or {}
    by_tool = summary.get("by_tool") or data.get("by_tool") or {}

    total = data.get("total_findings")
    if total is None and by_sev:
        try:
            total = int(sum(int(by_sev.get(k, 0)) for k in by_sev))
        except Exception:
            total = None

    summary["by_severity"] = by_sev
    summary["by_tool"] = by_tool

    payload = {
        "ok": True,
        "run_id": run_id,
        "total_findings": total,
        "summary": summary,
    }
    return _vsp_jsonify(payload)


@app.route("/api/vsp/dashboard_tables")
def api_vsp_dashboard_tables():
    """API cho các bảng dưới Dashboard (Top Files / CWE / Modules)."""
    run_id, data = _vsp_get_latest_full_ext_run()
    if not data:
        return _vsp_jsonify({
            "ok": False,
            "error": "No VSP FULL EXT run found.",
        }), 404

    summary = data.get("summary") or {}

    resp = {
        "ok": True,
        "run_id": run_id,
        "top_files": summary.get("top_files") or [],
        "top_dirs": summary.get("top_dirs") or [],
        "top_cwe": summary.get("top_cwe") or data.get("top_cwe"),
        "top_cwe_list": summary.get("top_cwe_list") or [],
        "top_modules": summary.get("top_modules") or [],
    }
    return _vsp_jsonify(resp)
# === END VSP DASHBOARD LIVE V2 (v4) ===


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8910)

