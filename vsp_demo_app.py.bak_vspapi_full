from __future__ import annotations
import json
import subprocess
import datetime
from pathlib import Path
from typing import Dict, Any, List

from flask import Flask, render_template, jsonify, request

ROOT = Path("/home/test/Data/SECURITY_BUNDLE").resolve()
OUT_ROOT = ROOT / "out"

app = Flask(__name__, template_folder="templates", static_folder="static")


def find_run_dirs() -> List[Path]:
    if not OUT_ROOT.exists():
        return []
    runs = [p for p in OUT_ROOT.iterdir() if p.is_dir() and p.name.startswith("RUN_")]
    runs.sort(key=lambda p: p.name, reverse=True)
    return runs


def get_latest_run_dir() -> Path | None:
    runs = find_run_dirs()
    return runs[0] if runs else None


def load_summary(run_dir: Path) -> Dict[str, Any]:
    summary_path = run_dir / "report" / "summary_unified.json"
    if not summary_path.exists():
        return {}
    try:
        return json.loads(summary_path.read_text(encoding="utf-8"))
    except Exception as e:
        print("[ERR] load_summary:", e)
        return {}


@app.route("/")
def vsp_dashboard():
    return render_template("vsp_dashboard_2025.html")








@app.route("/api/vsp/dashboard", methods=["GET"])
def api_vsp_dashboard():
    import json
    from pathlib import Path

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"

    # Tìm summary_unified.json mới nhất dưới out/RUN_*/report/
    candidates = []
    for p in out_dir.glob("RUN_*/report/summary_unified.json"):
        try:
            mtime = p.stat().st_mtime
        except OSError:
            continue
        candidates.append((mtime, p))

    candidates.sort(reverse=True)
    summary_data = None
    run_id = None
    summary_path = None
    if candidates:
        mtime, latest_path = candidates[0]
        run_id = latest_path.parent.parent.name
        summary_path = latest_path
        try:
            summary_data = json.loads(latest_path.read_text(encoding="utf-8"))
        except Exception:
            summary_data = None

    sev_keys = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]
    sev = {k: 0 for k in sev_keys}
    total_findings = 0
    top_tool = None
    top_cwe = None
    top_module = None
    per_tool = {}
    cwe_counts = {}
    module_counts = {}

    known_tools = [
        "gitleaks",
        "semgrep",
        "bandit",
        "trivy",
        "trivy_fs",
        "grype",
        "kics",
        "codeql",
        "syft",
    ]

    def _extract_count(v):
        if isinstance(v, dict):
            for key in ("count", "total", "value", "n"):
                if key in v:
                    try:
                        return int(v[key] or 0)
                    except Exception:
                        return 0
            return 0
        try:
            return int(v or 0)
        except Exception:
            return 0

    def _find_severity_dict(obj):
        # Đệ quy tìm dict có nhiều key thuộc sev_keys
        if isinstance(obj, dict):
            keys = obj.keys()
            match = sum(1 for k in sev_keys if k in keys)
            if match >= 3:
                return obj
            for v in obj.values():
                found = _find_severity_dict(v)
                if found is not None:
                    return found
        elif isinstance(obj, (list, tuple)):
            for it in obj:
                found = _find_severity_dict(it)
                if found is not None:
                    return found
        return None

    def _find_tool_dict(obj):
        # Đệ quy tìm dict có key giống tên tool (gitleaks, semgrep,...)
        if isinstance(obj, dict):
            keys = list(obj.keys())
            score = 0
            for k in keys:
                lk = str(k).lower()
                if lk in known_tools:
                    score += 1
            if score >= 2:  # có >=2 tool là coi như đúng
                return obj
            for v in obj.values():
                found = _find_tool_dict(v)
                if found is not None:
                    return found
        elif isinstance(obj, (list, tuple)):
            for it in obj:
                found = _find_tool_dict(it)
                if found is not None:
                    return found
        return None

    def _looks_like_cwe(key: str) -> bool:
        k = str(key).upper()
        return k.startswith("CWE-")

    def _find_cwe_dict(obj):
        # Đệ quy tìm dict mà phần lớn key có dạng CWE-xxx
        if isinstance(obj, dict):
            keys = list(obj.keys())
            if keys:
                hits = sum(1 for k in keys if _looks_like_cwe(k))
                if hits >= 3:
                    return obj
            for v in obj.values():
                found = _find_cwe_dict(v)
                if found is not None:
                    return found
        elif isinstance(obj, (list, tuple)):
            for it in obj:
                found = _find_cwe_dict(it)
                if found is not None:
                    return found
        return None

    if isinstance(summary_data, dict):
        # 1) Lấy severity
        raw_sev = _find_severity_dict(summary_data)
        if isinstance(raw_sev, dict):
            for k in sev_keys:
                if k in raw_sev:
                    sev[k] = _extract_count(raw_sev.get(k))

        if all(v == 0 for v in sev.values()):
            direct = (
                summary_data.get("severity")
                or summary_data.get("severity_buckets")
                or summary_data.get("severity_breakdown")
            )
            if isinstance(direct, dict):
                for k in sev_keys:
                    if k in direct:
                        sev[k] = _extract_count(direct.get(k))

        if all(v == 0 for v in sev.values()):
            for k in sev_keys:
                if k in summary_data:
                    sev[k] = _extract_count(summary_data.get(k))

        # 2) Tổng findings
        total_findings = summary_data.get("total_findings")
        if total_findings is None or total_findings == 0:
            total_findings = sum(sev.values())
        try:
            total_findings = int(total_findings or 0)
        except Exception:
            total_findings = sum(sev.values())

        # 3) By tool
        per_tool = summary_data.get("by_tool") or summary_data.get("tool_counts") or {}
        if not isinstance(per_tool, dict) or not per_tool:
            auto_tool = _find_tool_dict(summary_data)
            if isinstance(auto_tool, dict):
                per_tool = {str(k): _extract_count(v) for k, v in auto_tool.items()}
        if not isinstance(per_tool, dict):
            per_tool = {}

        if per_tool:
            try:
                top_tool = max(per_tool.items(), key=lambda kv: kv[1])[0]
            except Exception:
                top_tool = None

        # 4) CWE counts (từ summary nếu có)
        cwe_counts = summary_data.get("cwe_counts") or {}
        if not isinstance(cwe_counts, dict) or not cwe_counts:
            auto_cwe = _find_cwe_dict(summary_data)
            if isinstance(auto_cwe, dict):
                cwe_counts = {str(k): _extract_count(v) for k, v in auto_cwe.items()}
        if not isinstance(cwe_counts, dict):
            cwe_counts = {}

        # 5) module_counts (nếu có rõ ràng)
        module_counts = summary_data.get("module_counts") or {}
        if not isinstance(module_counts, dict):
            module_counts = {}
        if module_counts:
            try:
                top_module = max(module_counts.items(), key=lambda kv: kv[1])[0]
            except Exception:
                top_module = None

    # Nếu vẫn chưa có CWE => đọc findings_unified.json của run mới nhất
    if (not cwe_counts) and run_id is not None:
        findings_path = out_dir / run_id / "report" / "findings_unified.json"
        if findings_path.is_file():
            try:
                data = json.loads(findings_path.read_text(encoding="utf-8"))
                tmp = {}
                if isinstance(data, list):
                    for item in data:
                        if not isinstance(item, dict):
                            continue
                        cwe = (
                            item.get("cwe")
                            or item.get("CWE")
                            or item.get("cwe_id")
                        )
                        if not cwe:
                            continue
                        if isinstance(cwe, str):
                            raw = cwe.replace(";", ",")
                            parts = [p.strip() for p in raw.split(",") if p.strip()]
                        elif isinstance(cwe, (list, tuple)):
                            parts = [str(p).strip() for p in cwe if str(p).strip()]
                        else:
                            continue
                        for p in parts:
                            tmp[p] = tmp.get(p, 0) + 1
                cwe_counts = tmp
                if cwe_counts:
                    try:
                        top_cwe = max(cwe_counts.items(), key=lambda kv: kv[1])[0]
                    except Exception:
                        top_cwe = None
            except Exception as e:
                print("[WARN] Không đọc được findings_unified.json để thống kê CWE:", e)

    crit = sev["CRITICAL"]
    high = sev["HIGH"]
    penalty = crit * 8 + high * 3
    posture_score = 100 - penalty
    if posture_score < 0:
        posture_score = 0
    if posture_score > 100:
        posture_score = 100

    return jsonify(
        posture_score=posture_score,
        run_id=run_id,
        severity=sev,
        top_cwe=top_cwe,
        top_module=top_module,
        top_tool=top_tool,
        total_findings=total_findings,
        by_tool=per_tool,
        cwe_counts=cwe_counts,
        module_counts=module_counts,
    )


@app.route("/api/vsp/runs_index")
def api_vsp_runs_index():
    """Trả list RUN cho tab Runs & Reports (sau này dùng)."""
    runs = []
    for d in find_run_dirs():
        summary = load_summary(d)
        sev = summary.get("severity_buckets", {}) or summary.get("severity", {})
        runs.append({
            "run_id": d.name,
            "total_findings": int(summary.get("total_findings", 0) or 0),
            "profile": summary.get("profile", "EXT"),
            "src_path": summary.get("src_path", "-"),
            "url": summary.get("url", "-"),
            "severity": {
                "CRIT": int(sev.get("CRITICAL", 0) or 0),
                "HIGH": int(sev.get("HIGH", 0) or 0),
                "MED": int(sev.get("MEDIUM", 0) or 0),
                "LOW": int(sev.get("LOW", 0) or 0),
                "INFO": int(sev.get("INFO", 0) or 0),
                "TRACE": int(sev.get("TRACE", 0) or 0),
            },
        })
    return jsonify({"runs": runs})


@app.route("/api/vsp/run_full_ext", methods=["POST"])
def api_vsp_run_full_ext():
    """
    Nhập SRC trên UI -> gọi run_all_tools_v2.sh -> unify -> trả run_id.
    Chạy đồng bộ cho bản đầu (run xong mới trả JSON).
    """
    payload = request.get_json(silent=True) or {}
    src_path = payload.get("src_path")
    if not src_path:
        return jsonify({"ok": False, "error": "Missing src_path"}), 400

    src = Path(src_path).expanduser().resolve()
    if not src.exists():
        return jsonify({"ok": False, "error": f"SRC không tồn tại: {src}"}), 400

    ts = datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    run_id = f"RUN_VSP_FULL_EXT_{ts}"
    out_dir = OUT_ROOT / run_id
    out_dir.mkdir(parents=True, exist_ok=True)

    import os
    env = dict(os.environ)
    env["SRC"] = str(src)
    env["OUT_DIR"] = str(out_dir)

    try:
        # 1) Chạy full 8 tool
        subprocess.run(
            ["bash", "bin/run_all_tools_v2.sh", str(src), str(out_dir), "EXT"],
            cwd=str(ROOT),
            env=env,
            check=True,
        )
        # 2) Unify
        subprocess.run(
            ["python3", "bin/unify_findings_all_tools.py", str(out_dir)],
            cwd=str(ROOT),
            env=env,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        return jsonify({
            "ok": False,
            "error": f"run_all_tools_v2 hoặc unify bị lỗi (rc={e.returncode})",
            "run_id": run_id,
        }), 500

    return jsonify({"ok": True, "run_id": run_id})


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8910, debug=False)
