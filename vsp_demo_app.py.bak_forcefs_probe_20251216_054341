import shutil
import zipfile

# === VSP_MIN_IMPORTS_COMMERCIAL_V1 ===
# Hardened minimal imports to avoid NameError chain after patches
import os, sys, json, time, re, subprocess


# ---- commercial findings resolver ----  # VSP_FINDINGS_RESOLVE_V1
def vsp_resolve_findings_file(run_dir: str):
    import os
    cands = [
        "findings_unified_current.json",
        "findings_unified_commercial_v2.json",
        "findings_unified_commercial.json",
        "findings_unified.json",
    ]
    for name in cands:
        fp = os.path.join(run_dir, name)
        if os.path.isfile(fp) and os.path.getsize(fp) > 0:
            return fp
    return None
# ---- end resolver ----


# === VSP_EXPORT_PDF_RESOLVE_RUN_DIR_FROM_STATUSV2_V2 ===
def _vsp_resolve_ci_run_dir_from_status_v2_v2(rid: str):
    """Commercial: resolve run_dir using same contract as UI (run_status_v2)."""
    try:
        # local call: avoid requests dependency by importing urllib
        import json as _json
        from urllib.request import urlopen as _urlopen
        u = "http://127.0.0.1:8910/api/vsp/run_status_v2/" + str(rid)
        with _urlopen(u, timeout=2) as r:
            data = r.read().decode("utf-8", "ignore")
        d = _json.loads(data)
        ci = d.get("ci_run_dir") or d.get("ci") or ""
        if ci and isinstance(ci, str):
            return ci
    except Exception:
        return None
    return None

from pathlib import Path

class _VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_GITLEAKS_V1:
    """Outermost WSGI wrapper: mutate JSON bytes for /api/vsp/run_status_v2/* so fields can't be overwritten later."""
    # === VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_GITLEAKS_V1 ===
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if "/api/vsp/run_status_v2/" not in path:
            return self.app(environ, start_response)

        captured = {"status": None, "headers": None, "exc": None, "body_via_write": []}

        def _start_response_cap(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers or [])
            captured["exc"] = exc_info
            def _write(data):
                try:
                    if data:
                        captured["body_via_write"].append(data)
                except Exception:
                    pass
            return _write

        it = self.app(environ, _start_response_cap)

        chunks = []
        try:
            if captured["body_via_write"]:
                chunks.extend(captured["body_via_write"])
            if it is not None:
                for c in it:
                    if c:
                        chunks.append(c)
        finally:
            try:
                close = getattr(it, "close", None)
                if callable(close):
                    close()
            except Exception:
                pass

        body = b"".join(chunks)
        status = captured["status"] or "200 OK"
        headers = captured["headers"] or []

        ct = ""
        for k, v in headers:
            if str(k).lower() == "content-type":
                ct = str(v)
                break

        if ("application/json" not in ct.lower()) or (not body):
            start_response(status, headers, captured["exc"])
            return [body]

        try:
            import json
            from pathlib import Path as _P

            payload = json.loads(body.decode("utf-8", errors="ignore"))
            if isinstance(payload, dict):
                if payload.get("overall_verdict", None) is None:
                    payload["overall_verdict"] = ""

                payload.setdefault("has_gitleaks", False)
                payload.setdefault("gitleaks_verdict", "")
                payload.setdefault("gitleaks_total", 0)
                payload.setdefault("gitleaks_counts", {})

                ci = payload.get("ci_run_dir") or payload.get("ci_dir") or payload.get("ci") or ""
                ci = str(ci).strip()
                if ci:
                    def _readj(fp):
                        try:
                            if fp and fp.exists():
                                return json.loads(fp.read_text(encoding="utf-8", errors="ignore") or "{}")
                        except Exception:
                            return None
                        return None

                    base = _P(ci)

                    gsum = _readj(base / "gitleaks" / "gitleaks_summary.json") or _readj(base / "gitleaks_summary.json")
                    if not isinstance(gsum, dict):
                        try:
                            for fp in base.rglob("gitleaks_summary.json"):
                                gsum = _readj(fp)
                                if isinstance(gsum, dict):
                                    break
                        except Exception:
                            gsum = None

                    if isinstance(gsum, dict):
                        payload["has_gitleaks"] = True
                        payload["gitleaks_verdict"] = str(gsum.get("verdict") or "")
                        try:
                            payload["gitleaks_total"] = int(gsum.get("total") or 0)
                        except Exception:
                            payload["gitleaks_total"] = 0
                        cc = gsum.get("counts")
                        payload["gitleaks_counts"] = cc if isinstance(cc, dict) else {}

                    gate = _readj(base / "run_gate_summary.json")
                    if isinstance(gate, dict):
                        payload["overall_verdict"] = str(gate.get("overall") or payload.get("overall_verdict") or "")

                new_body = json.dumps(payload, ensure_ascii=False).encode("utf-8")

                new_headers = []
                for k, v in headers:
                    if str(k).lower() == "content-length":
                        continue
                    new_headers.append((k, v))
                new_headers.append(("Content-Length", str(len(new_body))))

                start_response(status, new_headers, captured["exc"])
                return [new_body]
        except Exception:
            pass

        start_response(status, headers, captured["exc"])
        return [body]


# === VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V31 ===
def _vsp_read_kics_summary(ci_run_dir: str):
    try:
        from pathlib import Path as _P
        fp = _P(ci_run_dir) / "kics" / "kics_summary.json"
        if not fp.exists():
            return None
        import json as _json
        obj = _json.loads(fp.read_text(encoding="utf-8", errors="ignore") or "{}")
        return obj if isinstance(obj, dict) else None
    except Exception:
        return None
# === END VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V31 ===

try:
    from flask import Flask, Blueprint, request, jsonify, Response, abort, send_file
except Exception:
    # allow import-time failure to surface clearly
    Flask = Blueprint = request = jsonify = Response = abort = send_file = None
# === END VSP_MIN_IMPORTS_COMMERCIAL_V1 ===

# === VSP_DEFINE__PATH_ALIAS_V1 ===
try:
    _Path
except Exception:
    _Path = Path
# === END VSP_DEFINE__PATH_ALIAS_V1 ===
UIREQ_STATE_DIR = Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1")  # VSP_UIREQ_CANON_DIR_V1
from collections import defaultdict
import functools
import re
from api.vsp_run_export_api_v3 import bp_run_export_v3
from api.vsp_settings_rules_v1 import bp_settings_rules

# === VSP_RESTORE_MISSING_BLUEPRINTS_V1 ===
try:
    from flask import Blueprint as _VSP_Blueprint
except Exception:
    _VSP_Blueprint = None

if _VSP_Blueprint is not None:
    vsp_runs_fs_bp = _VSP_Blueprint("vsp_runs_fs_bp", __name__)
# === END VSP_RESTORE_MISSING_BLUEPRINTS_V1 ===


# === VSP_KICS_TAIL_HELPERS_V2 ===
import json as _vsp_json
from pathlib import Path as _vsp_Path

def _vsp_safe_tail_text(_p, max_bytes=8192, max_lines=120):

    # === VSP_RUN_EXPORT_V3_PDF_EARLY_RETURN_V1 ===
    try:
        _fmt = (request.args.get("fmt","") or "").lower()
    except Exception:
        _fmt = ""
    if _fmt == "pdf":
        # Resolve run_dir robustly from rid
        try:
            rid_in = rid
        except Exception:
            rid_in = request.view_args.get("rid","") if hasattr(request, "view_args") else ""
        rid_norm = str(rid_in or "")
        # Normalize RUN_VSP_CI_... -> VSP_CI_...
        if rid_norm.startswith("RUN_"):
            rid_norm2 = rid_norm[len("RUN_"):]
        else:
            rid_norm2 = rid_norm

        # Candidate run dirs (keep your current base)
        bases = [
            "/home/test/Data/SECURITY-10-10-v4/out_ci",
            "/home/test/Data/SECURITY-10-10-v4/out_ci/",
        ]
        cands = []
        for b in bases:
            cands.append(os.path.join(b, rid_norm2))
            cands.append(os.path.join(b, rid_norm))
            # also allow VSP_CI_ prefix if missing
            if "VSP_CI_" not in rid_norm2 and rid_norm2:
                cands.append(os.path.join(b, "VSP_CI_" + rid_norm2))

        run_dir = None
        for c in cands:
            try:
                if os.path.isdir(c):
                    run_dir = c
                    break
            except Exception:
                pass

        # If your existing code already computed run_dir earlier, prefer it
        if "run_dir" in locals() and isinstance(locals().get("run_dir"), str) and os.path.isdir(locals().get("run_dir")):
            run_dir = locals().get("run_dir")

        files = []
        if run_dir:
            globs = [
                os.path.join(run_dir, "report*.pdf"),
                os.path.join(run_dir, "reports", "report*.pdf"),
                os.path.join(run_dir, "*.pdf"),
                os.path.join(run_dir, "reports", "*.pdf"),
            ]
            for g in globs:
                try:
                    files += glob.glob(g)
                except Exception:
                    pass

        files = [f for f in files if isinstance(f, str) and os.path.isfile(f)]
        if files:
            try:
                pick = max(files, key=lambda x: os.path.getmtime(x))
            except Exception:
                pick = files[-1]
            rsp = send_file(pick, mimetype="application/pdf", as_attachment=True, download_name=os.path.basename(pick))
            rsp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            return rsp

        # Not found => commercial: 200 + available=0 (NOT 404)
        rsp = jsonify({
            "ok": True,
            "fmt": "pdf",
            "available": 0,
            "rid": rid_norm,
            "rid_norm": rid_norm2,
            "run_dir": run_dir,
            "reason": "pdf_not_found",
        })
        rsp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return rsp
    try:
        _p = _vsp_Path(_p)
        if not _p.exists():
            return ""
        b = _p.read_bytes()
    except Exception:
        return ""
    if max_bytes and len(b) > max_bytes:
        b = b[-max_bytes:]
    try:
        s = b.decode("utf-8", errors="replace")
    except Exception:
        s = str(b)
    lines = s.splitlines()
    if max_lines and len(lines) > max_lines:
        lines = lines[-max_lines:]
    return "\n".join(lines).strip()
def _vsp_kics_tail_from_ci(ci_run_dir):
    """
    Commercial guarantee:
      - If KICS log exists => return tail
      - Else try degraded_tools.json for KICS (rc/reason)
      - Else try runner.log tail for KICS rc=127 / command not found / No such file / timeout
      - Else if CI dir hints KICS stage => return explicit NO_KICS_LOG/NO_EVIDENCE message (NOT empty)
      - Else return "" (non-KICS runs)
    """
    if not ci_run_dir:
        return ""
    try:
        base = _vsp_Path(str(ci_run_dir))
    except Exception:
        return ""

    # 1) kics.log
    klog = base / "kics" / "kics.log"
    if klog.exists():
        return _vsp_safe_tail_text(klog)

    # 2) degraded_tools.json (either list or {"degraded_tools":[...]})
    for dj in (base / "degraded_tools.json",):
        if dj.exists():
            try:
                raw = dj.read_text(encoding="utf-8", errors="ignore").strip() or "[]"
                data = _vsp_json.loads(raw)
                items = data.get("degraded_tools", []) if isinstance(data, dict) else data
                for it in (items or []):
                    tool = str((it or {}).get("tool","")).upper()
                    if tool == "KICS":
                        rc = (it or {}).get("rc")
                        reason = (it or {}).get("reason") or (it or {}).get("msg") or "degraded"
                        return "MISSING_TOOL: KICS (rc=%s) reason=%s" % (rc, reason)
            except Exception:
                pass

    # 3) runner.log fallback (best effort)
    rlog = base / "runner.log"
    if rlog.exists():
        tail = _vsp_safe_tail_text(rlog, max_bytes=16384, max_lines=200)
        up = tail.upper()
        # detect KICS-related failures
        if "KICS" in up:
            # common missing/rc patterns
            if ("RC=127" in up) or ("COMMAND NOT FOUND" in up) or ("NO SUCH FILE" in up) or ("NOT FOUND" in up):
                # include last few lines containing KICS / rc=127 / not found
                lines = tail.splitlines()
                keep = []
                for ln in lines[-200:]:
                    u = ln.upper()
                    if ("KICS" in u) or ("RC=127" in u) or ("COMMAND NOT FOUND" in u) or ("NO SUCH FILE" in u) or ("NOT FOUND" in u):
                        keep.append(ln)
                msg = "\n".join(keep[-30:]).strip() or tail
                return "MISSING_TOOL: KICS (from runner.log)\n" + msg

            if ("TIMEOUT" in up) or ("RC=124" in up):
                return "TIMEOUT: KICS (from runner.log)\n" + tail

            # KICS mentioned but no explicit error: still give useful context
            return "NO_KICS_LOG: %s\n(from runner.log)\n%s" % (klog, tail)

    # 4) heuristic: CI dir hints KICS stage (kics folder exists or stage marker exists somewhere)
    if (base / "kics").exists():
        return "NO_KICS_LOG: %s" % (klog,)

    # runner.log missing, kics dir missing: cannot assert it's KICS stage
    return ""

def _runsfs_safe_load_json(path):
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            return json.load(f)
    except Exception:
        return None

def _runsfs_sum_totals(totals):
    if not isinstance(totals, dict):
        return 0
    s = 0
    for k,v in totals.items():
        try:
            s += int(v)
        except Exception:
            pass
    return s

def _runsfs_pick_runs(out_root, limit=50, hide_empty=False):
    items = []
    try:
        for name in os.listdir(out_root):
            if not name.startswith("RUN_"):
                continue
            run_dir = os.path.join(out_root, name)
            if not os.path.isdir(run_dir):
                continue
            rpt = os.path.join(run_dir, "report")
            summary = os.path.join(rpt, "summary_unified.json")
            st = os.stat(run_dir)
            created_at = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(st.st_mtime))
            meta = _runsfs_safe_load_json(os.path.join(run_dir, "ci_source_meta.json")) or {}
            s = _runsfs_safe_load_json(summary) or {}
            bysev = (s.get("summary_by_severity") or s.get("by_severity") or {})
            items.append({
                "run_id": name,
                "created_at": created_at,
                "profile": (meta.get("profile") or s.get("profile") or ""),
                "target": (meta.get("target") or s.get("target") or ""),
                "totals": bysev if isinstance(bysev, dict) else {},
                "total_findings": _runsfs_sum_totals(bysev if isinstance(bysev, dict) else {}),
                "has_findings": 1 if _runsfs_sum_totals(bysev if isinstance(bysev, dict) else {}) > 0 else 0,
            })
    except Exception:
        pass
    if hide_empty:
        items = [it for it in items if int(it.get('has_findings',0)) == 1]
    # prefer has_findings then by time
    items.sort(key=lambda x: (int(x.get('has_findings',0)), x.get('created_at','')), reverse=True)
    # prefer has_findings sorting
    return items[:max(1, int(limit))]

@vsp_runs_fs_bp.get("/api/vsp/runs_index_v3_fs")
def vsp_runs_index_v3_fs():
    limit = request.args.get("limit", "40")
    try:
        limit_i = max(1, min(500, int(limit)))
    except Exception:
        limit_i = 40
    bundle_root = _Path(__file__).resolve().parents[1]  # .../SECURITY_BUNDLE
    bundle_root = _Path(os.environ.get('VSP_BUNDLE_ROOT', str(bundle_root))).resolve()
    out_dir = bundle_root / "out"
    hide_empty = request.args.get('hide_empty','0') in ('1','true','yes')
    items = _runsfs_pick_runs(str(out_dir), limit_i, hide_empty=hide_empty)
    kpi = {"total_runs": len(items), "last_n": min(20, len(items))}
    # === VSP_COMMERCIAL_RUNSFS_SORT_V1 (CI-first + newest-first) ===
    try:
        # 1) newest-first (ISO string compare works for YYYY-mm-ddTHH:MM:SS)
        items.sort(key=lambda r: (str(r.get('created_at','')), str(r.get('run_id',''))), reverse=True)
        # 2) CI-first (stable sort)
        items.sort(key=lambda r: (0 if str(r.get('run_id','')).startswith('RUN_VSP_CI_') else 1))
    except Exception:
        pass
    # === END VSP_COMMERCIAL_RUNSFS_SORT_V1 ===

    return jsonify({"ok": True, "source": "fs", "items": items, "kpi": kpi})
# === END RUNS_INDEX_FS_V1 ===

import requests

# === Config chung ===
from pathlib import Path  # VSP_FORCE_PATH_SYMBOL_V3
ROOT = Path(__file__).resolve().parents[1]  # /home/test/Data/SECURITY_BUNDLE
CORE_BASE = "http://localhost:8961"         # Core API (dashboard_v3, runs_index_v3, datasource_v2)

from flask import Flask  # VSP_FORCE_FLASK_SYMBOL_V1

app = Flask(
    __name__,
    static_folder="static",
    template_folder="templates",
)


# === VSP_RUN_STATUS_V2_WINLAST_V6 ===
# Commercial harden: /api/vsp/run_status_v2/<rid> never 404, inject stage + degraded + KICS summary.
import json, re
def _vsp__sanitize_stage_name_v2(s: str) -> str:
    if not s:
        return ""
    s = str(s)
    s = s.replace("\r\n", "\n").replace("\r", "\n")
    # keep first line only
    s = s.split("\n", 1)[0].strip()
    # remove trailing markers
    if "=====" in s:
        s = s.split("=====", 1)[0].strip()
    # remove possible prefix like "===== [3/8]"
    s = re.sub(r"^=+\s*\[\s*\d+\s*/\s*\d+\s*\]\s*", "", s).strip()
    s = re.sub(r"\s*=+\s*$", "", s).strip()
    return s


from pathlib import Path
from flask import jsonify
_STAGE_RE_V2 = re.compile(r"=+\s*\[\s*(\d+)\s*/\s*(\d+)\s*\]\s*([^\n=]+?)\s*=+", re.IGNORECASE)

def _vsp__tail_text_v2(pp: Path, max_bytes: int = 20000) -> str:
    try:
        if not pp.exists() or not pp.is_file():
            return ""
        bs = pp.read_bytes()
        if len(bs) > max_bytes:
            bs = bs[-max_bytes:]
        return bs.decode("utf-8", errors="ignore")
    except Exception:
        return ""

def _vsp__resolve_ci_run_dir_v2(rid: str):
    fn = globals().get("_vsp_guess_ci_run_dir_from_rid_v33")
    if callable(fn):
        try:
            d = fn(rid)
            if d and Path(d).exists():
                return str(Path(d))
        except Exception:
            pass

    rid_norm = str(rid).strip()
    rid_norm = rid_norm.replace("RUN_", "").replace("VSP_UIREQ_", "VSP_CI_")
    m = re.search(r"(VSP_CI_\d{8}_\d{6})", rid_norm)
    if m:
        cand = Path("/home/test/Data/SECURITY-10-10-v4/out_ci") / m.group(1)
        if cand.exists():
            return str(cand)
    return None

def _vsp__inject_stage_progress_v2(ci_dir: str, payload: dict):
    payload.setdefault("stage_name", "")
    payload.setdefault("stage_index", 0)
    payload.setdefault("stage_total", 0)
    payload.setdefault("progress_pct", 0)
    if not ci_dir:
        return
    tail = _vsp__tail_text_v2(Path(ci_dir) / "runner.log")
    if not tail:
        return

    # Normalize CRLF/CR to LF
    tail = tail.replace("\r\n", "\n").replace("\r", "\n")

    last = None
    for line in tail.split("\n"):
        # example line: "===== [3/8] KICS (EXT) ====="
        if "=====" in line and "]" in line and "[" in line:
            if re.search(r"\[\s*\d+\s*/\s*\d+\s*\]", line):
                last = line

    if not last:
        return

    mm = re.search(r"\[\s*(\d+)\s*/\s*(\d+)\s*\]", last)
    if not mm:
        return

    si = int(mm.group(1) or 0)
    st = int(mm.group(2) or 0)

    after = last.split("]", 1)[1] if "]" in last else ""
    name = after.split("=====", 1)[0].strip()

    payload["stage_name"] = name
    payload["stage_index"] = si
    payload["stage_total"] = st
    payload["progress_pct"] = int((si / st) * 100) if st > 0 else 0

def _vsp__inject_degraded_tools_v2(ci_dir: str, payload: dict):
    payload.setdefault("degraded_tools", [])
    if not ci_dir:
        return
    dj = _vsp__read_json_if_exists_v2(Path(ci_dir) / "degraded_tools.json")
    if isinstance(dj, list):
        payload["degraded_tools"] = dj

def _vsp__inject_kics_summary_v2(ci_dir: str, payload: dict):
    # === VSP_PAYLOAD_DEFAULT_GITLEAKS_V1 ===
    payload.setdefault("has_gitleaks", False)
    payload.setdefault("gitleaks_verdict", "")
    payload.setdefault("gitleaks_total", 0)
    payload.setdefault("gitleaks_counts", {})
    payload.setdefault("kics_verdict", "")
    payload.setdefault("kics_total", 0)
    payload.setdefault("kics_counts", {})
    if not ci_dir:
        return
    ksum = _vsp__read_json_if_exists_v2(Path(ci_dir) / "kics" / "kics_summary.json")
    if isinstance(ksum, dict):
        payload["kics_verdict"] = str(ksum.get("verdict") or "")
        payload["kics_total"] = int(ksum.get("total") or 0)
        cnt = ksum.get("counts") or {}
        payload["kics_counts"] = cnt if isinstance(cnt, dict) else {}

def api_vsp_run_status_v2_winlast_v6(rid):
    payload = {
        "ok": True,
        "rid": str(rid),
        "ci_run_dir": None,
        "stage_name": "",
        "stage_index": 0,
        "stage_total": 0,
        "progress_pct": 0,
        "kics_verdict": "",
        "kics_total": 0,
        "kics_counts": {},
        "degraded_tools": [],
    }

    ci_dir = _vsp__resolve_ci_run_dir_v2(str(rid))
    payload["ci_run_dir"] = ci_dir
    if not ci_dir:
        payload["ok"] = False
        payload["error"] = "CI_RUN_DIR_NOT_FOUND"

        # === VSP_STATUS_V2_CALLS_FIX_NO_CI_RUN_DIR_V1 ===
        try:
            _ci = None
            # prefer response field (most stable)
            if isinstance(resp, dict):
                _ci = resp.get("ci_run_dir") or resp.get("ci_dir") or resp.get("run_dir")
            # fallback: local vars if present
            try:
                _ci = _ci or ci_run_dir
            except Exception:
                pass
            try:
                _ci = _ci or ci_dir
            except Exception:
                pass
            _vsp_inject_tool_summary(resp, _ci, "semgrep", "semgrep_summary.json")
            _vsp_inject_tool_summary(resp, _ci, "trivy",   "trivy_summary.json")
            _vsp_inject_run_gate(resp, _ci)
        except Exception:
            pass

# === VSP_STATUS_ALWAYS8_TOOLS_V1 ===
    # Force commercial invariant: always present 8 tool lanes in status payload (NOT_RUN if missing)
    try:
        _CANON_TOOLS = ["SEMGREP","GITLEAKS","TRIVY","CODEQL","KICS","GRYPE","SYFT","BANDIT"]
        _ZERO_COUNTS = {"CRITICAL":0,"HIGH":0,"MEDIUM":0,"LOW":0,"INFO":0,"TRACE":0}

        # payload variable name may differ; attempt common ones
        _payload = None
        for _nm in ["payload","rsp","out","data","ret","result"]:
            if _nm in locals() and isinstance(locals().get(_nm), dict):
                _payload = locals()[_nm]
                break
        if _payload is None:
            # fallback: try the argument passed into jsonify(...) if it is a dict var
            pass

        if isinstance(_payload, dict):
            tools = _payload.get("tools") or _payload.get("by_tool") or _payload.get("tool_status") or {}
            if isinstance(tools, dict):
                for t in _CANON_TOOLS:
                    if t not in tools:
                        tools[t] = {
                            "tool": t,
                            "status": "NOT_RUN",
                            "verdict": "NOT_RUN",
                            "total": 0,
                            "counts": dict(_ZERO_COUNTS),
                            "reason": "missing_tool_output"
                        }
                # normalize container key
                _payload["tools"] = tools

            # Optional: keep a stable ordered list for UI
            _payload["tools_order"] = _CANON_TOOLS
    except Exception as _e:
        try:
            _payload = locals().get("payload")
            if isinstance(_payload, dict):
                _payload.setdefault("warnings", []).append("always8_tools_patch_failed")
        except Exception:
            pass


        return jsonify(payload), 200

    _vsp__inject_stage_progress_v2(ci_dir, payload)
    _vsp__inject_degraded_tools_v2(ci_dir, payload)
    _vsp__inject_kics_summary_v2(ci_dir, payload)
    payload["stage_name"] = _vsp__sanitize_stage_name_v2(payload.get("stage_name",""))
    return jsonify(payload), 200
def _vsp__register_run_status_v2_winlast_v6(flask_app):
    if flask_app is None:
        return
    try:
        flask_app.add_url_rule(
            "/api/vsp/run_status_v2/<rid>",
            endpoint="api_vsp_run_status_v2_winlast_v6",
            view_func=api_vsp_run_status_v2_winlast_v6,
            methods=["GET"],
        )
    except Exception as e:
        msg = str(e)
        if "already exists" in msg or "existing endpoint function" in msg:
            return
# === END VSP_RUN_STATUS_V2_WINLAST_V6 ===

_vsp__register_run_status_v2_winlast_v6(app)
# === VSP_AFTER_REQUEST_KICS_TAIL_V2_SAFE ===
def _vsp__kics_tail_from_ci(ci_run_dir: str, max_bytes: int = 65536) -> str:
    try:
        import os
        from pathlib import Path
        NL = chr(10)
        klog = os.path.join(ci_run_dir, "kics", "kics.log")
        if not os.path.exists(klog):
            return ""
        rawb = Path(klog).read_bytes()
        if len(rawb) > max_bytes:
            rawb = rawb[-max_bytes:]
        raw = rawb.decode("utf-8", errors="ignore").replace(chr(13), NL)
        # keep last non-empty lines (avoid spinner noise)
        lines2 = [x for x in raw.splitlines() if x.strip()]
        tail = NL.join(lines2[-60:])
        # pick latest HB/rc marker
        hb = ""
        for ln in reversed(lines2):
            if ("[KICS_V" in ln and "][HB]" in ln) or ("[KICS_V" in ln and "rc=" in ln) or ("[DEGRADED]" in ln):
                hb = ln.strip()
                break
        if hb and hb not in tail:
            tail = hb + NL + tail
        return tail[-4096:]
    except Exception:
        return ""

def _vsp__load_ci_dir_from_state(req_id: str) -> str:
    try:
        import json
        from pathlib import Path
        base = Path(__file__).resolve().parent
        cands = [
            base / "out_ci" / "uireq_v1" / (req_id + ".json"),
            base / "ui" / "out_ci" / "uireq_v1" / (req_id + ".json"),
            base / "out_ci" / "ui_req_state" / (req_id + ".json"),
            base / "ui" / "out_ci" / "ui_req_state" / (req_id + ".json"),
        ]
        for fp in cands:
            if fp.exists():
                txt = fp.read_text(encoding="utf-8", errors="ignore") or ""
                j = json.loads(txt) if txt.strip() else {}
                # === VSP_PREEMPT_STATUSV2_POSTPROCESS_HOOK_V1 ===
                try:
                    j = _vsp_preempt_statusv2_postprocess_v1(j)
                except Exception:
                    pass
                ci = str(j.get("ci_run_dir") or "")
                if ci:
                    return ci
        return ""
    except Exception:
        return ""

def _vsp__after_request_kics_tail(resp):
    try:
        import json
        from flask import request
        if not request.path.startswith("/api/vsp/run_status_v1/"):
            return resp
        # only patch JSON responses
        if (getattr(resp, "mimetype", "") or "") != "application/json":
            return resp
        rid = request.path.rsplit("/", 1)[-1]
        data = resp.get_data(as_text=True) or ""
        obj = json.loads(data) if data.strip() else {}
        stage = str(obj.get("stage_name") or "").lower()
        ci = str(obj.get("ci_run_dir") or "")
        if not ci:
            ci = _vsp__load_ci_dir_from_state(rid)
        if ci and ("kics" in stage):
            kt = _vsp__kics_tail_from_ci(ci)
            if kt:
                obj["kics_tail"] = kt
                resp.set_data(json.dumps(obj, ensure_ascii=False))
                resp.headers["Content-Length"] = str(len(resp.get_data()))
        return resp
    except Exception:
        return resp

try:
    app.after_request(_vsp__after_request_kics_tail)
except Exception:
    pass
# === END VSP_AFTER_REQUEST_KICS_TAIL_V2_SAFE ===
# === VSP_RUN_API_FORCE_REGISTER_V2_AST (do not edit) ===
def _vsp__load_runapi_bp__v2():
    try:
        # normal import (package-style)
        from run_api.vsp_run_api_v1 import bp_vsp_run_api_v1
        return bp_vsp_run_api_v1
    except Exception as e1:
        try:
            # fallback: load by file path (works even if run_api isn't a package)
            import importlib.util
            from pathlib import Path as _Path
            mod_path = _Path(__file__).resolve().parent / "run_api" / "vsp_run_api_v1.py"
            spec = importlib.util.spec_from_file_location("vsp_run_api_v1_dyn_v2", str(mod_path))
            mod = importlib.util.module_from_spec(spec)
            assert spec and spec.loader
            spec.loader.exec_module(mod)
            return getattr(mod, "bp_vsp_run_api_v1", None)
        except Exception as e2:
            print("[VSP_RUN_API] WARN load failed:", repr(e1), repr(e2))
            return None

try:
    _bp = _vsp__load_runapi_bp__v2()
    if _bp is not None:
        _bps = getattr(app, "blueprints", None) or {}
        if getattr(_bp, "name", None) in _bps:
            print("[VSP_RUN_API] already registered:", _bp.name)
        else:
            app.register_blueprint(_bp)
            print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
    else:
        print("[VSP_RUN_API] WARN: bp_vsp_run_api_v1 is None")
except Exception as e:
    print("[VSP_RUN_API] WARN: cannot register run_api blueprint:", repr(e))
# === END VSP_RUN_API_FORCE_REGISTER_V2_AST ===
# === RUNS_INDEX_FS_REGISTER_V1 ===
try:
    app.register_blueprint(vsp_runs_fs_bp)
except Exception as _e:
    pass
# === END RUNS_INDEX_FS_REGISTER_V1 ===

# === Helper proxy sang core 8961 ===
from flask import Response  # VSP_FORCE_RESPONSE_SYMBOL_V1
def proxy_get(path: str) -> Response:
    """
    Proxy GET từ 8910 -> 8961, giữ nguyên query string.
    """
    core_url = CORE_BASE + path
    try:
        resp = requests.get(core_url, params=request.args, timeout=60)
    except Exception as e:
        return jsonify(ok=False, error=f"Proxy error to core {core_url}: {e}"), 502

    headers = {}
    ct = resp.headers.get("Content-Type")
    if ct:
        headers["Content-Type"] = ct
    return Response(resp.content, status=resp.status_code, headers=headers)


# === Routes UI chính ===
@app.route("/")
def index():
    # Trang VSP 5 tab (index.html đã là layout mới)
    return render_template('vsp_dashboard_2025.html')


@app.route("/security_bundle")
def security_bundle():
    # Giữ route cũ nếu có chỗ nào gọi
    return render_template('vsp_dashboard_2025.html')


# === Proxy API: dashboard_v3, runs_index_v3, datasource_v2 ===



    try:
        root = pathlib.Path(__file__).resolve().parents[1]
        out_dir = root / "out"
        if not out_dir.is_dir():
            return jsonify(ok=False, error="no_out_dir"), 404

        ci_runs = sorted(
            [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_VSP_CI_")]
        )
        if not ci_runs:
            return jsonify(ok=False, error="no_ci_runs"), 404

        latest = ci_runs[-1]
        snap_path = latest / "report" / "ci_snapshot.json"
        flag_path = latest / "report" / "ci_flag_has_findings.env"

        snap_data = {}
        if snap_path.is_file():
            try:
                snap_data = json.loads(snap_path.read_text(encoding="utf-8"))
            except Exception as e:
                app.logger.error("[CI_SNAPSHOT_API] Lỗi đọc %s: %s", snap_path, e)

        has_flag = None
        if flag_path.is_file():
            try:
                for line in flag_path.read_text(encoding="utf-8").splitlines():
                    line = line.strip()
                    if line.startswith("has_findings="):
                        v = line.split("=", 1)[1].strip()
                        has_flag = (v == "1")
                        break
            except Exception as e:
                app.logger.error("[CI_SNAPSHOT_API] Lỗi đọc %s: %s", flag_path, e)

        # Ưu tiên has_findings từ snapshot, fallback sang flag
        has_findings = snap_data.get("has_findings", has_flag)

        resp = {
            "ok": True,
            "run_id": snap_data.get("run_id", latest.name),
            "ci_run_dir": latest.name,
            "source": snap_data.get("source", "CI"),
            "has_findings": bool(has_findings) if has_findings is not None else None,
            "total_findings": snap_data.get("total_findings"),
            "by_severity": snap_data.get("by_severity", {}),
            "top_tools": snap_data.get("top_tools", []),
            "top_cwe": snap_data.get("top_cwe", []),
            "generated_at": snap_data.get("generated_at"),
            "raw": snap_data,
        }
        return jsonify(resp)
    except Exception as e:
        app.logger.exception("[CI_SNAPSHOT_API] Exception: %s", e)
        return jsonify(ok=False, error="exception", detail=str(e)), 500




    ci_runs = sorted(
        [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_VSP_CI_")]
    )
    if not ci_runs:
        return jsonify(ok=False, error="no_ci_runs"), 404

    latest = ci_runs[-1]
    snap_path = latest / "report" / "ci_snapshot.json"
    flag_path = latest / "report" / "ci_flag_has_findings.env"

    if not snap_path.is_file():
        return jsonify(ok=False, error="no_ci_snapshot", run_dir=latest.name), 404

    try:
        snap_data = json.loads(snap_path.read_text(encoding="utf-8"))
    except Exception as e:
        app.logger.exception("[CI_SNAPSHOT_API_V2] Lỗi parse %s: %s", snap_path, e)
        return jsonify(ok=False, error="invalid_snapshot_json", run_dir=latest.name), 500

    has_flag = None
    if flag_path.is_file():
        try:
            for line in flag_path.read_text(encoding="utf-8").splitlines():
                line = line.strip()
                if line.startswith("has_findings="):
                    v = line.split("=", 1)[1].strip()
                    has_flag = (v == "1")
                    break
        except Exception as e:
            app.logger.error("[CI_SNAPSHOT_API_V2] Lỗi đọc %s: %s", flag_path, e)

    has_findings = snap_data.get("has_findings", has_flag)

    resp = {
        "ok": True,
        "run_id": snap_data.get("run_id", latest.name),
        "ci_run_dir": latest.name,
        "source": snap_data.get("source", "CI"),
        "has_findings": bool(has_findings) if has_findings is not None else None,
        "total_findings": snap_data.get("total_findings"),
        "by_severity": snap_data.get("by_severity", {}),
        "top_tools": snap_data.get("top_tools", []),
        "top_cwe": snap_data.get("top_cwe", []),
        "generated_at": snap_data.get("generated_at"),
    }
    return jsonify(resp)


@app.route("/api/vsp/ci_snapshot_latest", methods=["GET"])
def vsp_ci_snapshot_latest():
    """
    Trả về snapshot CI mới nhất:
    - Chọn RUN_VSP_CI_* mới nhất trong out/
    - Đọc report/ci_snapshot.json + ci_flag_has_findings.env
    """
    import json
    import pathlib

    root = pathlib.Path(__file__).resolve().parents[1]
    out_dir = root / "out"

    if not out_dir.is_dir():
        return jsonify(ok=False, error="no_out_dir"), 404

    ci_runs = sorted(
        [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_VSP_CI_")]
    )
    if not ci_runs:
        return jsonify(ok=False, error="no_ci_runs"), 404

    latest = ci_runs[-1]
    snap_path = latest / "report" / "ci_snapshot.json"
    flag_path = latest / "report" / "ci_flag_has_findings.env"

    if not snap_path.is_file():
        return jsonify(ok=False, error="no_ci_snapshot", run_dir=latest.name), 404

    try:
        snap_data = json.loads(snap_path.read_text(encoding="utf-8"))
    except Exception as e:
        app.logger.exception("[CI_SNAPSHOT_API_V2] Lỗi parse %s: %s", snap_path, e)
        return jsonify(ok=False, error="invalid_snapshot_json", run_dir=latest.name), 500

    has_flag = None
    if flag_path.is_file():
        try:
            for line in flag_path.read_text(encoding="utf-8").splitlines():
                line = line.strip()
                if line.startswith("has_findings="):
                    v = line.split("=", 1)[1].strip()
                    has_flag = (v == "1")
                    break
        except Exception as e:
            app.logger.error("[CI_SNAPSHOT_API_V2] Lỗi đọc %s: %s", flag_path, e)

    has_findings = snap_data.get("has_findings", has_flag)

    resp = {
        "ok": True,
        "run_id": snap_data.get("run_id", latest.name),
        "ci_run_dir": latest.name,
        "source": snap_data.get("source", "CI"),
        "has_findings": bool(has_findings) if has_findings is not None else None,
        "total_findings": snap_data.get("total_findings"),
        "by_severity": snap_data.get("by_severity", {}),
        "top_tools": snap_data.get("top_tools", []),
        "top_cwe": snap_data.get("top_cwe", []),
        "generated_at": snap_data.get("generated_at"),
    }
    return jsonify(resp)


@app.route("/api/vsp/dashboard_delta_latest", methods=["GET"])
def vsp_dashboard_delta_latest():
    """
    Lightweight API: so sánh run mới nhất với run liền trước
    dựa trên out/summary_by_run.json.
    """
    import os, json, datetime as _dt

    root = os.path.dirname(os.path.dirname(__file__))
    summary_path = os.path.join(root, "out", "summary_by_run.json")

    if not os.path.exists(summary_path):
        return jsonify({"ok": False, "error": "summary_by_run.json not found"}), 404

    try:
        with open(summary_path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        return jsonify({"ok": False, "error": "failed to load summary_by_run.json: %s" % e}), 500

    # Chuẩn hoá list run
    if isinstance(data, dict):
        items = list(data.get("runs") or data.get("items") or data.values())
    else:
        items = list(data or [])

    if not items:
        return jsonify({"ok": False, "error": "no runs in summary_by_run.json"}), 200

    def extract_ts(item):
        meta = item.get("meta") or {}
        for key in ("started_at", "created_at", "generated_at"):
            v = meta.get(key) or item.get(key)
            if isinstance(v, str):
                try:
                    return _dt.datetime.fromisoformat(v.replace("Z", ""))
                except Exception:
                    pass
        # Fallback: dùng run_id như timestamp thô
        rid = str(item.get("run_id") or "")
        try:
            return _dt.datetime.strptime(rid[-15:], "%Y%m%d_%H%M%S")
        except Exception:
            return _dt.datetime.min

    def is_full_ext(item):
        profile = (item.get("profile") or item.get("mode") or "").upper()
        rid = (item.get("run_id") or "").upper()
        return ("FULL_EXT" in profile) or ("FULL_EXT" in rid)

    full_ext = [it for it in items if is_full_ext(it)]
    source_items = full_ext if len(full_ext) >= 2 else items

    source_items = [it for it in source_items if isinstance(it, dict)]
    if len(source_items) < 2:
        return jsonify({"ok": False, "error": "not enough runs for delta"}), 200

    source_items.sort(
        key=lambda it: (extract_ts(it), str(it.get("run_id") or "")),
        reverse=True,
    )

    current, previous = source_items[0], source_items[1]

    def pick_num(it, keys, default=0):
        for k in keys:
            v = it.get(k)
            if isinstance(v, (int, float)):
                return v
        summary_all = it.get("summary_all") or {}
        for k in keys:
            v = summary_all.get(k)
            if isinstance(v, (int, float)):
                return v
        return default

    cur_total = pick_num(current, ["total_findings", "findings_total"])
    prev_total = pick_num(previous, ["total_findings", "findings_total"])

    cur_score = pick_num(current, ["security_posture_score", "security_score", "score"])
    prev_score = pick_num(previous, ["security_posture_score", "security_score", "score"])

    delta_total = None if (cur_total is None or prev_total is None) else cur_total - prev_total
    delta_score = None if (cur_score is None or prev_score is None) else cur_score - prev_score

    resp = {
        "ok": True,
        "current": {
            "run_id": current.get("run_id"),
            "total_findings": cur_total,
            "security_posture_score": cur_score,
        },
        "previous": {
            "run_id": previous.get("run_id"),
            "total_findings": prev_total,
            "security_posture_score": prev_score,
        },
        "delta": {
            "total_findings": delta_total,
            "security_posture_score": delta_score,
        },
    }
    return jsonify(resp)
@app.route("/api/vsp/dashboard_v3", methods=["GET"])
def api_vsp_dashboard_v3():

    # [VSP_UI_DASHBOARD_V3_LATEST_JSON_PATCH] Ưu tiên đọc file out/vsp_dashboard_v3_latest.json nếu tồn tại
    try:
        import json, pathlib
        from flask import jsonify
        ui_root = pathlib.Path(__file__).resolve().parent
        root = ui_root.parent  # /home/test/Data/SECURITY_BUNDLE
        latest_path = root / "out" / "vsp_dashboard_v3_latest.json"
        if latest_path.is_file():
            model = json.loads(latest_path.read_text(encoding="utf-8"))
            return jsonify(model)
    except Exception as e:  # noqa: E722
        try:
            from flask import current_app
            current_app.logger.warning("VSP_UI_DASHBOARD_V3_LATEST_JSON_PATCH failed: %r", e)
        except Exception:
            print("VSP_UI_DASHBOARD_V3_LATEST_JSON_PATCH failed:", repr(e))
    return proxy_get("/api/vsp/dashboard_v3")






@app.route("/api/vsp/runs_index_v3")
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    - KPI + trend: cố gắng lấy từ out/summary_by_run.json (nếu có).
    - Danh sách runs (items): *không phụ thuộc* vào summary_by_run.json,
      mà tự quét out/RUN_*/report/findings_unified.json.
    """
    import json
    import datetime
    from pathlib import Path
    from flask import request, jsonify

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    kpi = {}
    trend = []

    # (1) Đọc KPI + trend (nếu có)
    if summary_path.exists():
        try:
            with summary_path.open("r", encoding="utf-8") as f:
                summary = json.load(f)
            if isinstance(summary, dict):
                kpi = summary.get("kpi") or {}
                trend = summary.get("trend_crit_high") or summary.get("trend") or []
        except Exception:
            pass

    # (2) Build items bằng cách duyệt RUN_* + findings_unified.json
    items = []

    run_dirs = [
        p for p in out_dir.iterdir()
        if p.is_dir() and p.name.startswith("RUN_")
    ]
    run_dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)

    for run_dir in run_dirs:
        run_id = run_dir.name
        report_dir = run_dir / "report"
        findings_file = report_dir / "findings_unified.json"
        summary_file = report_dir / "summary_unified.json"

        if not findings_file.exists() and not summary_file.exists():
            continue

        total_findings = None
        run_type = "UNKNOWN"
        source = "FULL_EXT"
        score = None
        started_at = None

        # (2a) Ưu tiên lấy total_findings từ findings_unified.json
        if findings_file.exists():
            try:
                with findings_file.open("r", encoding="utf-8") as f:
                    fd = json.load(f)
                if isinstance(fd, dict):
                    if isinstance(fd.get("items"), list):
                        items_list = fd["items"]
                        total_findings = int(fd.get("total", len(items_list)))
                    elif isinstance(fd.get("findings"), list):
                        items_list = fd["findings"]
                        total_findings = len(items_list)
                elif isinstance(fd, list):
                    total_findings = len(fd)
            except Exception:
                pass

        # (2b) Nếu vẫn chưa có total_findings, fallback sang summary_unified.json
        if total_findings is None and summary_file.exists():
            try:
                with summary_file.open("r", encoding="utf-8") as f:
                    s = json.load(f)
            except Exception:
                s = None

            if isinstance(s, dict):
                total_findings = (
                    s.get("summary_all", {}).get("total_findings")
                    if isinstance(s.get("summary_all"), dict)
                    else None
                )
                if total_findings is None:
                    total_findings = s.get("total_findings")

                if total_findings is None:
                    sev = None
                    if "summary_all" in s and isinstance(s["summary_all"], dict):
                        sev = s["summary_all"].get("by_severity")
                    if sev is None:
                        sev = s.get("by_severity")
                    if isinstance(sev, dict):
                        try:
                            total_findings = int(sum(int(v) for v in sev.values()))
                        except Exception:
                            total_findings = None

                run_profile = s.get("run_profile") if isinstance(s.get("run_profile"), dict) else {}
                run_type = run_profile.get("type") or run_profile.get("run_type") or run_type
                source = run_profile.get("source") or run_profile.get("source_type") or source
                score = s.get("security_posture_score")
                if score is None and isinstance(s.get("summary_all"), dict):
                    score = s["summary_all"].get("security_posture_score")
                started_at = run_profile.get("started_at") or run_profile.get("started") or started_at

        # (2c) Nếu vẫn không có total_findings thì bỏ run này
        if total_findings is None:
            continue

        # (2d) Nếu chưa có started_at thì lấy mtime thư mục
        if not started_at:
            try:
                dt = datetime.datetime.fromtimestamp(run_dir.stat().st_mtime)
                started_at = dt.isoformat(timespec="seconds")
            except Exception:
                started_at = ""

        item = {
            "run_id": run_id,
            "run_type": run_type,
            "source": source,
            "total_findings": int(total_findings),
            "security_posture_score": score if isinstance(score, (int, float)) else None,
            "started_at": started_at,
        }
        items.append(item)

    # (3) Áp dụng limit
    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50
    items_slice = items[:limit]

    # (4) Nếu chưa có KPI thì tự build
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = total_findings_sum / float(last_n) if last_n > 0 else 0.0
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    Ưu tiên:
    1) Đọc KPI + trend từ out/summary_by_run.json (nếu có).
    2) Tự quét thư mục out/RUN_* để build danh sách items (list run)
       nên không phụ thuộc schema summary_by_run.json nữa.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify
    import os
    import datetime

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    kpi = {}
    trend = []

    # (1) Đọc KPI + trend (nếu có)
    if summary_path.exists():
        try:
            with summary_path.open("r", encoding="utf-8") as f:
                summary = json.load(f)
            if isinstance(summary, dict):
                kpi = summary.get("kpi") or {}
                trend = summary.get("trend_crit_high") or summary.get("trend") or []
        except Exception:
            pass

    # (2) Quét thư mục RUN_* để build items
    items = []

    # Duyệt tất cả thư mục RUN_* trong out/
    run_dirs = [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_")]
    # Sắp xếp theo thời gian sửa đổi mới nhất (mới -> cũ)
    run_dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)

    for run_dir in run_dirs:
        run_id = run_dir.name
        report_dir = run_dir / "report"
        summary_file = report_dir / "summary_unified.json"
        if not summary_file.exists():
            continue

        try:
            with summary_file.open("r", encoding="utf-8") as f:
                s = json.load(f)
        except Exception:
            continue

        # Lấy total_findings
        total_findings = None
        # Ưu tiên các kiểu phổ biến
        if isinstance(s, dict):
            # Kiểu summary_all.total_findings
            total_findings = (
                s.get("summary_all", {}).get("total_findings")
                if isinstance(s.get("summary_all"), dict)
                else None
            )
            # Kiểu top-level total_findings
            if total_findings is None:
                total_findings = s.get("total_findings")

            # Nếu vẫn None, thử tính từ by_severity
            if total_findings is None:
                sev = None
                if "summary_all" in s and isinstance(s["summary_all"], dict):
                    sev = s["summary_all"].get("by_severity")
                if sev is None:
                    sev = s.get("by_severity")
                if isinstance(sev, dict):
                    try:
                        total_findings = int(sum(int(v) for v in sev.values()))
                    except Exception:
                        total_findings = None

            # Run type / source
            run_profile = s.get("run_profile") if isinstance(s.get("run_profile"), dict) else {}
            run_type = run_profile.get("type") or run_profile.get("run_type") or "UNKNOWN"
            source = run_profile.get("source") or run_profile.get("source_type") or "FULL_EXT"

            # Score nếu có
            score = s.get("security_posture_score")
            if score is None and isinstance(s.get("summary_all"), dict):
                score = s["summary_all"].get("security_posture_score")

            # Time nếu có
            started_at = run_profile.get("started_at") or run_profile.get("started") or None
        else:
            run_type = "UNKNOWN"
            source = "FULL_EXT"
            score = None
            started_at = None

        # Nếu vẫn chưa có total_findings, bỏ qua run này
        if total_findings is None:
            continue

        # Nếu không có started_at thì lấy mtime thư mục
        if not started_at:
            try:
                dt = datetime.datetime.fromtimestamp(run_dir.stat().st_mtime)
                started_at = dt.isoformat(timespec="seconds")
            except Exception:
                started_at = ""

        item = {
            "run_id": run_id,
            "run_type": run_type,
            "source": source,
            "total_findings": int(total_findings),
            "security_posture_score": score if isinstance(score, (int, float)) else None,
            "started_at": started_at,
        }
        items.append(item)

    # (3) Áp dụng limit
    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50
    items_slice = items[:limit]

    # (4) Nếu chưa có KPI thì tự build
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = total_findings_sum / float(last_n) if last_n > 0 else 0.0
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    Đọc summary_by_run.json trong SECURITY_BUNDLE/out và
    expose items + kpi + trend_crit_high cho UI.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    try:
        with summary_path.open("r", encoding="utf-8") as f:
            summary = json.load(f)
    except FileNotFoundError:
        return jsonify({"ok": False, "error": f"Missing {summary_path}"}), 500

    # Chuẩn hóa items theo nhiều kiểu schema khác nhau
    if isinstance(summary, dict):
        raw_items = (
            summary.get("items")
            or summary.get("by_run")
            or summary.get("runs")
            or summary.get("data")
        )
        if isinstance(raw_items, list):
            items = raw_items
        else:
            items = []
        kpi = summary.get("kpi") or {}
        trend = summary.get("trend_crit_high") or summary.get("trend") or []
    else:
        items = summary if isinstance(summary, list) else []
        kpi = {}
        trend = []

    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50

    items_slice = items[:limit]

    # Nếu summary_by_run.json chưa có kpi ⇒ tự tính KPI cơ bản
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = total_findings_sum / float(last_n) if last_n > 0 else 0.0
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    Đọc summary_by_run.json trong SECURITY_BUNDLE/out và
    expose items + kpi + trend_crit_high cho UI.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    try:
        with summary_path.open("r", encoding="utf-8") as f:
            summary = json.load(f)
    except FileNotFoundError:
        return jsonify({"ok": False, "error": f"Missing {summary_path}"}), 500

    if isinstance(summary, dict):
        items = summary.get("items") or []
        kpi = summary.get("kpi") or {}
        trend = summary.get("trend_crit_high") or []
    else:
        items = summary
        kpi = {}
        trend = []

    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50

    items_slice = items[:limit]

    # Nếu summary_by_run.json chưa có kpi ⇒ tự tính KPI cơ bản
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = (
                total_findings_sum / float(last_n) if last_n > 0 else 0.0
            )
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    return proxy_get("/api/vsp/runs_index_v3")



@app.route("/api/vsp/datasource_v2")
def api_vsp_datasource_v2():
    """
    Local implementation cho Data Source tab (VSP 2025 UI demo).

    Thay vì proxy sang core, route này đọc trực tiếp
    findings_unified.json của latest FULL_EXT run trong
    SECURITY_BUNDLE/out.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify

    # SECURITY_BUNDLE root = parent của thư mục ui/
    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"

    dash_path = out_dir / "vsp_dashboard_v3_latest.json"
    try:
        with dash_path.open("r", encoding="utf-8") as f:
            dash = json.load(f)
    except FileNotFoundError:
        return jsonify({"ok": False, "error": f"Missing {dash_path}"}), 500

    latest_run = dash.get("latest_run_id")
    if not latest_run:
        return jsonify(
            {"ok": False, "error": "No latest_run_id in vsp_dashboard_v3_latest.json"}
        ), 500

    findings_path = out_dir / latest_run / "report" / "findings_unified.json"
    try:
        with findings_path.open("r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        return jsonify(
            {
                "ok": False,
                "error": f"Missing findings_unified.json for run {latest_run}",
            }
        ), 500

    # data có thể là list hoặc {items: [...], total: N}
    if isinstance(data, dict) and "items" in data:
        items = data.get("items") or []
        total = int(data.get("total", len(items)))
    else:
        items = data
        total = len(items)

    try:
        limit = int(request.args.get("limit", 100))
    except Exception:
        limit = 100

    items_slice = items[:limit]

    return jsonify(
        {
            "ok": True,
            "run_id": latest_run,
            "total": total,
            "limit": limit,
            "items": items_slice,
        }
    )
def api_vsp_datasource_v2():
    # Proxy đúng sang core, giữ nguyên run_dir, limit, filters,...
    return proxy_get("/api/vsp/datasource_v2")


# === RUN FULL SCAN EXT+ – gọi bin/vsp_selfcheck_full.sh ===

@app.route("/api/vsp/run_full_scan", methods=["POST", "OPTIONS"])
def api_vsp_run_full_scan():
    """
    Nhận JSON:
      {
        "profile": "EXT" | "FAST" | "AGGR" | "FULL" | ...,
        "source_root": "/home/test/Data/khach6",
        "target_url": "https://demo.demasterpro.com"
      }

    Gọi: bin/vsp_selfcheck_full.sh <profile> <source_root> <target_url>
    cwd = /home/test/Data/SECURITY_BUNDLE
    """
    if request.method == "OPTIONS":
        # Đơn giản trả 200 cho preflight nếu có
        return ("", 200)

    data = request.get_json(silent=True) or {}

    profile = data.get("profile") or "FULL_EXT"
    source_root = data.get("source_root") or data.get("src_path") or str(ROOT / "khach6")
    target_url = data.get("target_url") or data.get("url") or "https://demo.demasterpro.com"

    script = ROOT / "bin" / "vsp_selfcheck_full.sh"

    if not script.is_file():
        return jsonify(
            ok=False,
            error=f"Script không tồn tại: {script}",
        ), 500

    # Đảm bảo script có quyền execute
    try:
        os.chmod(str(script), 0o755)
    except Exception:
        pass

    try:
        proc = subprocess.Popen(
            [str(script), profile, source_root, target_url],
            cwd=str(ROOT),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except Exception as e:
        return jsonify(ok=False, error=f"Lỗi chạy {script}: {e}"), 500

    return jsonify(
        ok=True,
        pid=proc.pid,
        profile=profile,
        source_root=source_root,
        target_url=target_url,
    )


# === Healthcheck đơn giản (tuỳ chọn) ===
@app.route("/health")
def health():
    return jsonify(ok=True, app="vsp_demo_app", core=CORE_BASE)


# VSP_RUN_EXPORT_DIRECT_V1_BEGIN
from flask import send_file, request, jsonify, render_template
import io, json, zipfile, subprocess, shutil
from pathlib import Path

@app.route("/api/vsp/settings_v1", methods=["GET", "POST"])

def _settings_file_path():
    import os
    # Cho phép override bằng env nếu cần
    path = os.environ.get("VSP_SETTINGS_FILE")
    if path:
        return path
    return os.path.join(os.path.dirname(__file__), "config", "settings_v1.json")


def _load_settings_from_file():
    import json, os
    path = _settings_file_path()
    if not os.path.isfile(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        # Nếu file hỏng thì trả rỗng để UI còn tự fill mặc định
        return {}


def _save_settings_to_file(data):
    import json, os
    path = _settings_file_path()
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

@app.route("/api/vsp/settings_ui_v1", methods=["GET", "POST"])
def vsp_settings_ui_v1():
    """
    Settings API cho UI:
    - GET  -> trả JSON {ok: true, settings: {...}}
    - POST -> nhận {settings: {...}} hoặc object raw, lưu file rồi trả lại JSON.
    """
    from flask import request, jsonify

    if request.method == "GET":
        settings = _load_settings_from_file()
        return jsonify({"ok": True, "settings": settings})

    payload = request.get_json(silent=True) or {}
    # Nếu payload dạng {settings: {...}} thì lấy bên trong, còn không thì dùng cả object
    if isinstance(payload, dict) and "settings" in payload and isinstance(payload["settings"], dict):
        settings = payload["settings"]
    else:
        settings = payload

    _save_settings_to_file(settings)
    return jsonify({"ok": True, "settings": settings})


def vsp_settings_v1():
    """GET/POST settings trực tiếp trên gateway 8910 (lưu file JSON)."""
    if request.method == "GET":
        settings = _load_settings_from_file()
        return jsonify(ok=True, settings=settings)

    payload = request.get_json(silent=True) or {}
    try:
        _SETTINGS_FILE.parent.mkdir(parents=True, exist_ok=True)
        _SETTINGS_FILE.write_text(json.dumps(payload, indent=2), encoding="utf-8")
    except Exception as e:
        return jsonify(ok=False, error=str(e)), 500
    return jsonify(ok=True)




    """
    UI-only wrapper cho file config/rule_overrides_v1.json.
    Dùng riêng cho tab Rules trên VSP_UI 2025.
    """
    import os, json, flask

    cfg_dir = os.path.join(os.path.dirname(__file__), "config")
    cfg_path = os.path.join(cfg_dir, "rule_overrides_v1.json")

    # POST: lưu overrides từ UI
    if flask.request.method == "POST":
        try:
            body = flask.request.get_json(force=True, silent=False)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc)), 400

        # Hỗ trợ các format:
        # - { "items": [...] }
        # - { "overrides": [...] }
        # - [ ... ]
        data = body
        if isinstance(body, dict):
            if "items" in body:
                data = body["items"]
            elif "overrides" in body:
                data = body["overrides"]

        os.makedirs(cfg_dir, exist_ok=True)
        with open(cfg_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        return flask.jsonify(ok=True)

    # GET: đọc file, nếu chưa có thì trả [] để UI render bảng trống
    if os.path.exists(cfg_path):
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc), items=[], overrides=[], raw=None), 200
    else:
        raw = []

    # Chuẩn hóa: luôn có items + overrides
    if isinstance(raw, dict):
        items = raw.get("items") or raw.get("overrides") or raw
    else:
        items = raw

    return flask.jsonify(ok=True, items=items, overrides=items, raw=raw)
@app.route("/api/vsp/rule_overrides_ui_v1", methods=["GET", "POST", "OPTIONS"])
def vsp_rule_overrides_ui_v1():
    """
    UI-only wrapper cho file config/rule_overrides_v1.json.
    Dùng riêng cho tab Rules trên VSP_UI 2025.
    """
    import os, json, flask

    cfg_dir = os.path.join(os.path.dirname(__file__), "config")
    cfg_path = os.path.join(cfg_dir, "rule_overrides_v1.json")

    # POST: lưu overrides từ UI
    if flask.request.method == "POST":
        try:
            body = flask.request.get_json(force=True, silent=False)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc)), 400

        # Hỗ trợ các format:
        # - { "items": [...] }
        # - { "overrides": [...] }
        # - [ ... ]
        data = body
        if isinstance(body, dict):
            if "items" in body:
                data = body["items"]
            elif "overrides" in body:
                data = body["overrides"]

        os.makedirs(cfg_dir, exist_ok=True)
        with open(cfg_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        return flask.jsonify(ok=True)

    # GET: đọc file, nếu chưa có thì trả [] để UI render bảng trống
    if os.path.exists(cfg_path):
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc), items=[], overrides=[], raw=None), 200
    else:
        raw = []

    # Chuẩn hóa: luôn có items + overrides
    if isinstance(raw, dict):
        items = raw.get("items") or raw.get("overrides") or raw
    else:
        items = raw

    return flask.jsonify(ok=True, items=items, overrides=items, raw=raw)

@app.route("/api/vsp/run_export_v3", methods=["GET"])
def vsp_run_export_v3():
    """
    Direct export HTML/ZIP/PDF/CSV cho 1 run - chạy trên UI gateway (8910).
    """
    from flask import request, jsonify, send_file
    import os, io, zipfile, json

    run_id = (request.args.get("run_id") or "").strip()
    fmt = (request.args.get("fmt") or "html").strip().lower()

    if not run_id:
        return jsonify({"ok": False, "error": "Missing run_id"}), 400

    # Thư mục out gốc: ưu tiên env VSP_OUT_ROOT, fallback ../out cạnh ui/
    base_out = os.environ.get("VSP_OUT_ROOT")
    if not base_out:
        base_out = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "out"))

    run_dir = os.path.join(base_out, run_id)
    if not os.path.isdir(run_dir):
        return jsonify({"ok": False, "error": f"Run dir not found: {run_dir}"}), 404

    report_dir = os.path.join(run_dir, "report")

    # HTML export
    if fmt == "html":
        candidates = [
            os.path.join(report_dir, "vsp_run_report_cio_v3.html"),
            os.path.join(report_dir, "vsp_run_report_cio_v2.html"),
            os.path.join(report_dir, "vsp_run_report_cio.html"),
            os.path.join(report_dir, "run_report.html"),
        ]
        for path in candidates:
            if os.path.isfile(path):
                return send_file(
                    path,
                    mimetype="text/html",
                    as_attachment=False,
                    download_name=os.path.basename(path),
                )

        # fallback – render summary_unified.json thành HTML đơn giản
        summary_path = os.path.join(report_dir, "summary_unified.json")
        summary = {}
        if os.path.isfile(summary_path):
            try:
                with open(summary_path, "r", encoding="utf-8") as f:
                    summary = json.load(f)
            except Exception:
                summary = {}

        body = json.dumps(
            summary or {"note": "No summary_unified.json found"},
            indent=2,
            ensure_ascii=False,
        )

        html = (
            "<html><head><meta charset='utf-8'>"
            "<title>VSP run {run_id}</title></head><body>"
            "<h1>VSP run {run_id}</h1>"
            "<pre>{body}</pre>"
            "</body></html>"
        ).format(run_id=run_id, body=body)

        return html

    # CSV export
    if fmt == "csv":
        csv_path = os.path.join(report_dir, "findings_unified.csv")
        if os.path.isfile(csv_path):
            return send_file(
                csv_path,
                mimetype="text/csv",
                as_attachment=True,
                download_name=f"{run_id}_findings.csv",
            )
        return jsonify({"ok": False, "error": "findings_unified.csv not found"}), 404

    # ZIP export
    if fmt == "zip":
        if not os.path.isdir(report_dir):
            return jsonify({"ok": False, "error": "report dir not found"}), 404

        mem = io.BytesIO()
        with zipfile.ZipFile(mem, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
            for root, dirs, files in os.walk(report_dir):
                for fn in files:
                    full = os.path.join(root, fn)
                    rel = os.path.relpath(full, run_dir)
                    zf.write(full, rel)

        mem.seek(0)
        return send_file(
            mem,
            mimetype="application/zip",
            as_attachment=True,
            download_name=f"{run_id}_report.zip",
        )

    # PDF export (nếu có sẵn file PDF trong report/)
    if fmt == "pdf":
        if os.path.isdir(report_dir):
            for name in os.listdir(report_dir):
                if name.lower().endswith(".pdf"):
                    path = os.path.join(report_dir, name)
                    return send_file(
                        path,
                        mimetype="application/pdf",
                        as_attachment=True,
                        download_name=name,
                    )
        return jsonify({"ok": False, "error": "PDF report not found"}), 404

    return jsonify({"ok": False, "error": f"Unsupported fmt={fmt}"}), 400



@app.route("/api/vsp/run_fullscan_v1", methods=["POST"])
def vsp_run_fullscan_v1():
    """
    Nhận source_root / target_url / profile / mode từ UI,
    gọi shell wrapper vsp_run_fullscan_from_api_v1.sh chạy background.
    """
    import subprocess
    from pathlib import Path
    from flask import request, jsonify

    payload = request.get_json(force=True) or {}
    source_root = payload.get("source_root") or ""
    target_url = payload.get("target_url") or ""
    profile = payload.get("profile") or "FULL_EXT"
    mode = payload.get("mode") or "EXT_ONLY"

    wrapper = Path(__file__).resolve().parent.parent / "bin" / "vsp_run_fullscan_from_api_v1.sh"

    proc = subprocess.Popen(
        [str(wrapper), profile, mode, source_root, target_url],
        cwd=str(wrapper.parent.parent),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )

    app.logger.info("[VSP_RUN_FULLSCAN_API] payload=%s pid=%s", payload, proc.pid)

    return jsonify({
        "ok": True,
        "pid": proc.pid,
        "profile": profile,
        "mode": mode,
    })



@app.route("/api/vsp/rule_overrides_v1", methods=["GET", "POST"], endpoint="vsp_rule_overrides_v1_api_ui")
def vsp_rule_overrides_v1_api():
    """Simple file-based storage cho rule_overrides_v1.

    File lưu tại: ../config/rule_overrides_v1.json (tính từ thư mục ui/).
    """
    root = _VSP_Path2(__file__).resolve().parent.parent  # .../SECURITY_BUNDLE
    cfg_dir = root / "config"
    cfg_dir.mkdir(exist_ok=True)
    cfg_file = cfg_dir / "rule_overrides_v1.json"

    if request.method == "GET":
        if cfg_file.exists():
            try:
                data = _vsp_json2.loads(cfg_file.read_text(encoding="utf-8"))
            except Exception as exc:  # pragma: no cover
                app.logger.warning("Invalid rule_overrides_v1.json: %s", exc)
                data = []
        else:
            data = []
        return jsonify(data)

    payload = request.get_json(force=True, silent=True)
    if payload is None:
        payload = []

    to_save = payload
    try:
        cfg_file.write_text(
            _vsp_json2.dumps(to_save, indent=2, ensure_ascii=False),
            encoding="utf-8",
        )
    except Exception as exc:  # pragma: no cover
        app.logger.error("Cannot write rule_overrides_v1.json: %s", exc)
        return jsonify({"ok": False, "error": str(exc)}), 500

    return jsonify(to_save)

# === VSP Rule Overrides UI API stub V1 ===
from pathlib import Path as _VSP_Path_UI
import json as _vsp_json_ui



@app.route("/api/vsp/rule_overrides_ui_v1", methods=["GET", "POST"])
def vsp_rule_overrides_ui_v1_force():
    app.logger.info("[VSP_RULES_UI] stub handler active (vsp_rule_overrides_ui_v1_force)")
    root = _VSP_Path_UI2(__file__).resolve().parent.parent  # .../SECURITY_BUNDLE
    cfg_dir = root / "config"
    cfg_dir.mkdir(exist_ok=True)
    cfg_file = cfg_dir / "rule_overrides_v1.json"

    if request.method == "GET":
        if cfg_file.exists():
            try:
                data = _vsp_json_ui2.loads(cfg_file.read_text(encoding="utf-8"))
            except Exception as exc:  # pragma: no cover
                app.logger.warning("Invalid rule_overrides_v1.json: %s", exc)
                data = []
        else:
            data = []
        return jsonify(data)

    payload = request.get_json(force=True, silent=True)
    if payload is None:
        payload = []

    to_save = payload
    try:
        cfg_file.write_text(
            _vsp_json_ui2.dumps(to_save, indent=2, ensure_ascii=False),
            encoding="utf-8",
        )
    except Exception as exc:  # pragma: no cover
        app.logger.error("Cannot write rule_overrides_v1.json: %s", exc)
        return jsonify({"ok": False, "error": str(exc)}), 500

    return jsonify(to_save)




    """
    UI-only wrapper cho file config/rule_overrides_v1.json.
    Dùng riêng cho tab Rules trên VSP_UI 2025.
    """
    import os, json, flask

    cfg_dir = os.path.join(os.path.dirname(__file__), "config")
    cfg_path = os.path.join(cfg_dir, "rule_overrides_v1.json")

    # POST: lưu overrides từ UI
    if flask.request.method == "POST":
        try:
            body = flask.request.get_json(force=True, silent=False)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc)), 400

        # Hỗ trợ vài format:
        # - { "items": [...] }
        # - { "overrides": [...] }
        # - [ ... ]
        data = body
        if isinstance(body, dict):
            if "items" in body:
                data = body["items"]
            elif "overrides" in body:
                data = body["overrides"]

        os.makedirs(cfg_dir, exist_ok=True)
        with open(cfg_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        return flask.jsonify(ok=True)

    # GET: đọc file, nếu chưa có thì trả [] để UI render bảng trống
    if os.path.exists(cfg_path):
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc), items=[], overrides=[], raw=None), 200
    else:
        raw = []

    # Chuẩn hóa: luôn có items + overrides
    if isinstance(raw, dict):
        items = raw.get("items") or raw.get("overrides") or raw
    else:
        items = raw

    return flask.jsonify(ok=True, items=items, overrides=items, raw=raw)


@app.route("/api/vsp/dashboard_extras_v1")
def vsp_dashboard_extras_v1():
    """Extras cho Dashboard: top findings, noisy paths, CVE, by_tool – stub V1.

    V1 chỉ wrap lại /api/vsp/dashboard_v3 nếu có, để UI có data tối thiểu.
    Sau này có thể mở rộng để đọc trực tiếp findings_unified.json.
    """
    from flask import jsonify

    base = {}
    try:
        # Gọi lại dashboard_v3 để lấy latest_run_id, by_tool...
        with app.test_client() as c:
            r = c.get("/api/vsp/dashboard_v3")
            if r.is_json:
                base = r.get_json() or {}
    except Exception as e:
        base = {"error": str(e)}

    by_tool = (
        base.get("by_tool")
        or base.get("summary_by_tool")
        or {}
    )

    payload = {
        "ok": True,
        "latest_run_id": base.get("latest_run_id"),
        # Các field này V1 có thể rỗng, UI sẽ hiển thị 'No data'
        "top_risky": base.get("top_risky") or [],
        "top_noisy_paths": base.get("top_noisy_paths") or [],
        "top_cves": base.get("top_cves") or [],
        "by_tool_severity": by_tool,
    }
    return jsonify(payload)


@app.route("/api/vsp/datasource_export_v1")
def vsp_datasource_export_v1():
    """Export findings_unified cho Data Source – V1: JSON + CSV.

    - Nếu có run_dir trong query thì dùng run_dir đó.
    - Nếu không, dùng latest_run_id từ /api/vsp/dashboard_v3.
    """

    from flask import request, jsonify, send_file
    import json
    import csv
    import tempfile

    ui_root = Path(__file__).resolve().parent
    bundle_root = ui_root.parent
    out_root = bundle_root / "out"

    fmt = (request.args.get("fmt") or "json").strip().lower()
    run_dir_arg = (request.args.get("run_dir") or "").strip()

    run_dir = None

    if run_dir_arg:
        run_dir = Path(run_dir_arg)
    else:
        # Lấy latest_run_id từ dashboard_v3
        try:
            with app.test_client() as c:
                r = c.get("/api/vsp/dashboard_v3")
                if r.is_json:
                    data = r.get_json() or {}
                else:
                    data = {}
            latest_run_id = data.get("latest_run_id")
            if latest_run_id:
                run_dir = out_root / latest_run_id
        except Exception as e:
            return jsonify(ok=False, error=f"Không lấy được latest_run_id: {e}"), 500

    if run_dir is None:
        return jsonify(ok=False, error="Không xác định được run_dir"), 400

    if not run_dir.is_dir():
        return jsonify(ok=False, error=f"Run dir not found: {run_dir}"), 404

    report_dir = run_dir / "report"
    findings_path = report_dir / "findings_unified.json"

    if not findings_path.is_file():
        return jsonify(ok=False, error=f"Không tìm thấy findings_unified.json trong {report_dir}"), 404

    if fmt == "json":
        # Trả thẳng file JSON
        return send_file(
            findings_path,
            mimetype="application/json",
            as_attachment=True,
            download_name=f"{run_dir.name}_findings_unified.json",
        )

    if fmt == "csv":
        # Convert JSON -> CSV với các cột chuẩn
        try:
            items = json.loads(findings_path.read_text(encoding="utf-8"))
        except Exception as e:
            return jsonify(ok=False, error=f"Không đọc được JSON: {e}"), 500

        if not isinstance(items, list):
            return jsonify(ok=False, error="findings_unified.json không phải là list"), 500

        # Giữ schema giống Data Source ext columns
        fieldnames = [
            "severity",
            "tool",
            "rule",
            "path",
            "line",
            "message",
            "run",
            "cwe",
            "cve",
            "component",
            "tags",
            "fix",
        ]

        def norm_sev(s):
            if not s:
                return ""
            up = str(s).upper()
            known = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]
            return up if up in known else str(s)

        def extract_line(item):
            if "line" in item and item["line"] is not None:
                return item["line"]
            if "line_number" in item and item["line_number"] is not None:
                return item["line_number"]
            loc = item.get("location") or {}
            if isinstance(loc, dict) and "line" in loc:
                return loc["line"]
            return ""

        def extract_rule(item):
            for k in ["rule_id", "rule", "check_id", "check", "rule_name", "id"]:
                if k in item and item[k]:
                    return item[k]
            return ""

        def extract_msg(item):
            for k in ["message", "msg", "description", "title"]:
                if k in item and item[k]:
                    return item[k]
            return ""

        def extract_run(item):
            for k in ["run_id", "run", "run_ref"]:
                if k in item and item[k]:
                    return item[k]
            return ""

        def extract_cwe(item):
            if item.get("cwe"):
                return item["cwe"]
            if item.get("cwe_id"):
                return item["cwe_id"]
            if isinstance(item.get("cwe_list"), list) and item["cwe_list"]:
                return ",".join(map(str, item["cwe_list"]))
            return ""

        def extract_cve(item):
            if item.get("cve"):
                return item["cve"]
            for k in ["cve_list", "cves"]:
                v = item.get(k)
                if isinstance(v, list) and v:
                    return ",".join(map(str, v))
            return ""

        def extract_component(item):
            for k in ["component", "module", "package", "image"]:
                if item.get(k):
                    return item[k]
            return ""

        def extract_tags(item):
            tags = item.get("tags") or item.get("labels")
            if not tags:
                return ""
            if isinstance(tags, list):
                return ",".join(map(str, tags))
            return str(tags)

        def extract_fix(item):
            for k in ["fix", "remediation", "recommendation"]:
                if item.get(k):
                    return item[k]
            return ""

        tmp = tempfile.NamedTemporaryFile(mode="w+", suffix=".csv", delete=False, encoding="utf-8", newline="")
        tmp_path = Path(tmp.name)

        writer = csv.DictWriter(tmp, fieldnames=fieldnames)
        writer.writeheader()

        for it in items:
            if not isinstance(it, dict):
                continue
            row = {
                "severity": norm_sev(it.get("severity") or it.get("level")),
                "tool": it.get("tool") or it.get("source") or it.get("scanner") or "",
                "rule": extract_rule(it),
                "path": it.get("path") or it.get("file") or it.get("location") or "",
                "line": extract_line(it),
                "message": extract_msg(it),
                "run": extract_run(it),
                "cwe": extract_cwe(it),
                "cve": extract_cve(it),
                "component": extract_component(it),
                "tags": extract_tags(it),
                "fix": extract_fix(it),
            }
            writer.writerow(row)

        tmp.flush()
        tmp.close()

        return send_file(
            tmp_path,
            mimetype="text/csv",
            as_attachment=True,
            download_name=f"{run_dir.name}_findings_unified.csv",
        )

    return jsonify(ok=False, error=f"Unsupported fmt={fmt} (chỉ hỗ trợ json|csv trong V1)"), 400

@app.route("/api/vsp/dashboard_v3", methods=["GET"])
def vsp_dashboard_v3():
    """
    Dashboard V3:
      - Chọn run theo:
        + Pin trong vsp_dashboard_pin_v1.json, hoặc
        + FULL_EXT mới nhất có summary_unified.json
      - Trả total_findings + by_severity + by_tool
    """
    import json
    from flask import request, jsonify

    run_id = request.args.get("run_id") or pick_dashboard_run()

    if not run_id:
        return jsonify({
            "ok": False,
            "error": "No FULL_EXT run with summary_unified.json found",
            "latest_run_id": None,
        }), 500

    summary_file = (OUT_DIR / run_id / "report" / "summary_unified.json")

    if not summary_file.is_file():
        return jsonify({
            "ok": False,
            "error": f"summary_unified.json not found for {run_id}",
            "latest_run_id": run_id,
        }), 500

    summary = json.loads(summary_file.read_text(encoding="utf-8"))

    data = {
        "ok": True,
        "latest_run_id": run_id,
        "total_findings": sum(
            s.get("count", 0) for s in summary.get("summary_by_severity", {}).values()
        ),
        "by_severity": summary["summary_by_severity"],
        "by_tool": summary.get("by_tool", {}),
    }
    return jsonify(data)




# ==== VSP_METRICS_AFTER_REQUEST_V1 ====
# Inject KPI cho /api/vsp/dashboard_v3 và /api/vsp/runs_index_v3
# Không phá code cũ – chỉ chỉnh JSON response sau khi route xử lý xong.

from flask import request
import json as _vsp_json
import pathlib as _vsp_pathlib

SEVERITY_BUCKETS = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]

_VSP_ROOT = _vsp_pathlib.Path(__file__).resolve().parents[1]


def _vsp_build_severity_cards(by_sev):
    """Chuẩn hoá by_severity thành đầy đủ 6 bucket."""
    cards = {sev: 0 for sev in SEVERITY_BUCKETS}
    if not isinstance(by_sev, dict):
        return cards
    for sev, v in by_sev.items():
        if sev not in cards:
            continue
        if isinstance(v, dict):
            n = v.get("count") or v.get("total") or 0
        else:
            n = v
        try:
            cards[sev] = int(n)
        except Exception:
            pass
    return cards


def _vsp_security_score_simple(cards):
    """Score 0–100, càng nhiều CRIT/HIGH thì trừ điểm mạnh."""
    crit = cards.get("CRITICAL", 0)
    high = cards.get("HIGH", 0)
    med = cards.get("MEDIUM", 0)
    low = cards.get("LOW", 0)

    # model đơn giản: mỗi CRIT trừ 8, HIGH trừ 4, MED trừ 2, LOW trừ 1
    penalty = crit * 8 + high * 4 + med * 2 + low * 1
    score = 100 - penalty
    if score < 0:
        score = 0
    if score > 100:
        score = 100
    return int(score)


@app.after_request
def vsp_metrics_after_request_v1(resp):
    """Bơm thêm KPI vào dashboard_v3 & runs_index_v3."""
    try:
        path = request.path
    except Exception:
        return resp

    # Chỉ xử lý JSON của namespace /api/vsp/
    if not getattr(resp, "is_json", False):
        return resp
    if not (isinstance(path, str) and path.startswith("/api/vsp/")):
        return resp

    try:
        data = resp.get_json(silent=True)
    except Exception:
        return resp

    changed = False

    # ===== 1) DASHBOARD V3 KPI =====
    if path == "/api/vsp/dashboard_v3" and isinstance(data, dict):
        by_sev = data.get("by_severity") or {}
        cards = _vsp_build_severity_cards(by_sev)

        if not data.get("severity_cards"):
            data["severity_cards"] = cards
            changed = True

        if "security_posture_score" not in data or data.get("security_posture_score") is None:
            data["security_posture_score"] = _vsp_security_score_simple(cards)
            changed = True

        # Alias cho field top_* nếu backend chỉ có top_cwe, top_module
        if "top_risky_tool" not in data:
            data["top_risky_tool"] = data.get("top_risky_tool") or data.get("top_tool")
        if "top_impacted_cwe" not in data:
            data["top_impacted_cwe"] = data.get("top_impacted_cwe") or data.get("top_cwe")
        if "top_vulnerable_module" not in data:
            data["top_vulnerable_module"] = data.get("top_vulnerable_module") or data.get("top_module")
        changed = True

    # ===== 2) RUNS_INDEX V3 KPI (dùng summary_by_run.json) =====
    if path == "/api/vsp/runs_index_v3" and isinstance(data, dict):
        summary_path = _VSP_ROOT / "out" / "summary_by_run.json"
        s = {}
        try:
            if summary_path.is_file():
                s = _vsp_json.loads(summary_path.read_text(encoding="utf-8"))
        except Exception as e:
            print(f"[VSP_METRICS] Lỗi đọc {summary_path}: {e}")

        kpi = s.get("kpi")
        trend = s.get("trend_crit_high")

        if "kpi" not in data and kpi is not None:
            data["kpi"] = kpi
            changed = True
        if "trend_crit_high" not in data and trend is not None:
            data["trend_crit_high"] = trend
            changed = True

    if not changed:
        return resp

    # Ghi lại body JSON mới
    try:
        new_body = _vsp_json.dumps(data, ensure_ascii=False)
        resp.set_data(new_body)
        resp.mimetype = "application/json"
        resp.headers["Content-Type"] = "application/json; charset=utf-8"
        resp.headers["Content-Length"] = str(len(new_body.encode("utf-8")))
    except Exception as e:
        print(f"[VSP_METRICS] Lỗi set_data: {e}")
    return resp

# ==== END VSP_METRICS_AFTER_REQUEST_V1 ====



# ========== VSP_METRICS_TOP_V1 START ==========
import json
import logging
from collections import Counter
from pathlib import Path
from flask import request

logger = logging.getLogger(__name__)

_VSP_RISKY_SEVERITIES_TOP = {"CRITICAL", "HIGH"}

def _vsp_root_dir_from_ui_top():
    try:
        return Path(__file__).resolve().parent.parent
    except Exception:
        return Path(".")

def _vsp_find_report_dir_top(latest_run_id):
    try:
        root = _vsp_root_dir_from_ui_top()
        report_dir = root / "out" / latest_run_id / "report"
        if report_dir.is_dir():
            return report_dir
    except Exception as exc:
        logger.warning("[VSP_METRICS_TOP] Cannot resolve report dir for %s: %s", latest_run_id, exc)
    return None

def _vsp_load_findings_top(report_dir):
    f = report_dir / "findings_unified.json"
    if not f.exists():
        logger.info("[VSP_METRICS_TOP] %s không tồn tại – bỏ qua top_*", f)
        return []

    try:
        data = json.loads(f.read_text(encoding="utf-8"))
    except Exception as exc:
        logger.warning("[VSP_METRICS_TOP] Lỗi đọc %s: %s", f, exc)
        return []

    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        if isinstance(data.get("findings"), list):
            return data["findings"]
        if isinstance(data.get("items"), list):
            return data["items"]
    return []

def _vsp_extract_cwe_top(f):
    # 1) Field trực tiếp
    for key in ("cwe_id", "cwe", "cwe_code", "cweid"):
        val = f.get(key)
        if isinstance(val, str) and val.strip():
            return val.strip()
        if isinstance(val, list) and val:
            first = val[0]
            if isinstance(first, str) and first.strip():
                return first.strip()
            if isinstance(first, dict):
                for kk in ("id", "code", "name"):
                    v2 = first.get(kk)
                    if isinstance(v2, str) and v2.strip():
                        return v2.strip()

    # 2) Danh sách cwes / cwe_ids
    for key in ("cwes", "cwe_ids"):
        val = f.get(key)
        if isinstance(val, list) and val:
            first = val[0]
            if isinstance(first, str) and first.strip():
                return first.strip()
            if isinstance(first, dict):
                for kk in ("id", "code", "name"):
                    v2 = first.get(kk)
                    if isinstance(v2, str) and v2.strip():
                        return v2.strip()

    # 3) Bên trong extra / metadata
    for key in ("extra", "metadata", "details"):
        sub = f.get(key)
        if isinstance(sub, dict):
            for kk in ("cwe_id", "cwe", "cwe_code", "cweid"):
                val = sub.get(kk)
                if isinstance(val, str) and val.strip():
                    return val.strip()
                if isinstance(val, list) and val:
                    first = val[0]
                    if isinstance(first, str) and first.strip():
                        return first.strip()
                    if isinstance(first, dict):
                        for k2 in ("id", "code", "name"):
                            v2 = first.get(k2)
                            if isinstance(v2, str) and v2.strip():
                                return v2.strip()

    # 4) Tìm trong tags/labels có "CWE-"
    for key in ("tags", "labels", "categories"):
        val = f.get(key)
        if isinstance(val, list):
            for item in val:
                if isinstance(item, str) and "CWE-" in item.upper():
                    return item.strip()

    return None

def _vsp_extract_module_top(f):
    # 1) Các key phổ biến cho module/dependency
    for key in (
        "dependency",
        "package",
        "package_name",
        "module",
        "component",
        "image",
        "image_name",
        "target",
        "resource",
        "resource_name",
        "artifact",
    ):
        val = f.get(key)
        if isinstance(val, str) and val.strip():
            return val.strip()

    # 2) Một số tool gói trong extra/metadata
    for key in ("extra", "metadata", "details"):
        sub = f.get(key)
        if isinstance(sub, dict):
            for kk in (
                "dependency",
                "package",
                "package_name",
                "module",
                "component",
                "image",
                "image_name",
                "target",
                "resource",
                "resource_name",
                "artifact",
            ):
                val = sub.get(kk)
                if isinstance(val, str) and val.strip():
                    return val.strip()

    # 3) Fallback: dùng đường dẫn file như "module"
    for key in ("file", "filepath", "path", "location"):
        val = f.get(key)
        if isinstance(val, str) and val.strip():
            return val.strip()

    return None

def _vsp_accumulate_top_metrics(findings, risky_only):
    by_tool = Counter()
    by_cwe = Counter()
    by_module = Counter()

    for item in findings:
        if not isinstance(item, dict):
            continue
        sev = str(item.get("severity", "")).upper()
        if risky_only and sev not in _VSP_RISKY_SEVERITIES_TOP:
            continue

        # Tool / engine
        tool = (
            item.get("tool")
            or item.get("source")
            or item.get("scanner")
            or item.get("engine")
            or item.get("engine_id")
            or item.get("provider")
        )
        if isinstance(tool, str) and tool.strip():
            by_tool[tool.strip()] += 1

        cwe = _vsp_extract_cwe_top(item)
        if cwe:
            by_cwe[cwe] += 1

        module = _vsp_extract_module_top(item)
        if module:
            by_module[module] += 1

    return by_tool, by_cwe, by_module

def _vsp_compute_top_metrics_top(latest_run_id):
    report_dir = _vsp_find_report_dir_top(latest_run_id)
    if not report_dir:
        return {}

    findings = _vsp_load_findings_top(report_dir)
    if not findings:
        return {}

    # Pass 1: chỉ CRITICAL/HIGH
    by_tool, by_cwe, by_module = _vsp_accumulate_top_metrics(findings, risky_only=True)

    # Nếu CWE/module không có thì fallback dùng tất cả severity
    if not by_cwe or not by_module:
        by_tool_all, by_cwe_all, by_module_all = _vsp_accumulate_top_metrics(findings, risky_only=False)
        if not by_tool and by_tool_all:
            by_tool = by_tool_all
        if not by_cwe and by_cwe_all:
            by_cwe = by_cwe_all
        if not by_module and by_module_all:
            by_module = by_module_all

    result = {}

    if by_tool:
        tool, n = by_tool.most_common(1)[0]
        result["top_risky_tool"] = {
            "id": tool,
            "label": tool,
            "crit_high": int(n),
        }

    if by_cwe:
        cwe, n = by_cwe.most_common(1)[0]
        result["top_impacted_cwe"] = {
            "id": cwe,
            "label": cwe,
            "count": int(n),
        }

    if by_module:
        module, n = by_module.most_common(1)[0]
        result["top_vulnerable_module"] = {
            "id": module,
            "label": module,
            "count": int(n),
        }

    return result

@app.after_request
def vsp_metrics_after_request_top_v1(response):
    # Hậu xử lý riêng cho Dashboard V3 để bơm top_* nếu thiếu.
    try:
        path = request.path
    except RuntimeError:
        return response

    if path != "/api/vsp/dashboard_v3":
        return response

    mimetype = response.mimetype or ""
    if not mimetype.startswith("application/json"):
        return response

    try:
        data = json.loads(response.get_data(as_text=True) or "{}")
    except Exception:
        logger.warning("[VSP_METRICS_TOP] Không parse được JSON từ %s", path)
        return response

    latest_run_id = data.get("latest_run_id")
    if not isinstance(latest_run_id, str) or not latest_run_id:
        return response

    top = _vsp_compute_top_metrics_top(latest_run_id)
    if not top:
        return response

    for key in ("top_risky_tool", "top_impacted_cwe", "top_vulnerable_module"):
        if key in top and not data.get(key):
            data[key] = top[key]

    new_body = json.dumps(data, ensure_ascii=False).encode("utf-8")
    response.set_data(new_body)
    response.headers["Content-Length"] = str(len(new_body))
    return response

# ========== VSP_METRICS_TOP_V1 END ==========
# == VSP_TABS_ROUTER_INJECT_ANY_V1 ==
@app.after_request
def vsp_tabs_router_inject_any(response):
    """Inject router JS vào TẤT CẢ response text/html.
    Không phụ thuộc id vsp-dashboard-main nữa.
    """
    try:
        ctype = response.headers.get("Content-Type", "")
        if "text/html" not in ctype.lower():
            return response

        body = response.get_data(as_text=True)

        # Nếu đã có script rồi thì thôi
        if "vsp_tabs_hash_router_v1.js" in body:
            return response

        if "</body>" not in body:
            return response

        body = body.replace(
            "</body>",
            '  <script src="/static/js/vsp_tabs_hash_router_v1.js" defer></script>\n</body>'
        )
        response.set_data(body)
    except Exception as e:
        print("[VSP_TABS_ROUTER_INJECT_ANY][ERR]", e)
    return response



# === VSP UI WHOAMI DEBUG V2 + API RUN CI TRIGGER ===
@app.route("/__vsp_ui_whoami", methods=["GET"])
def vsp_ui_whoami():
    """
    Endpoint debug để kiểm tra app nào đang chạy trên gateway 8910.
    """
    from flask import jsonify
    import os
    return jsonify({
        "ok": True,
        "app": "vsp_demo_app",
        "cwd": os.getcwd(),
        "file": __file__,
    })

@app.route("/api/vsp/run", methods=["POST"])
def api_vsp_run():
    """
    Trigger scan từ UI:
    Body:
    {
      "mode": "local" | "ci",
      "profile": "FULL_EXT",
      "target_type": "path",
      "target": "/path/to/project"
    }
    """
    import subprocess
    from pathlib import Path
    from flask import request, jsonify

    try:
        data = request.get_json(force=True, silent=True) or {}
    except Exception:
        data = {}

    mode = (data.get("mode") or "local").lower()
    profile = data.get("profile") or "FULL_EXT"
    target_type = data.get("target_type") or "path"
    target = data.get("target") or ""

    ci_mode = "LOCAL_UI"
    if mode in ("ci", "gitlab", "jenkins"):
        ci_mode = mode.upper() + "_UI"

    # Hiện tại chỉ hỗ trợ target_type=path
    if target_type != "path":
        return jsonify({
            "ok": False,
            "implemented": True,
            "ci_triggered": False,
            "error": "Only target_type='path' is supported currently"
        }), 400

    # Nếu không truyền, default là project SECURITY-10-10-v4
    if not target:
        target = "/home/test/Data/SECURITY-10-10-v4"

    wrapper = Path(__file__).resolve().parents[1] / "bin" / "vsp_ci_trigger_from_ui_v1.sh"

    if not wrapper.exists():
        return jsonify({
            "ok": False,
            "implemented": False,
            "ci_triggered": False,
            "error": f"Wrapper not found: {wrapper}"
        }), 500

    try:
        proc = subprocess.Popen(
            [str(wrapper), profile, target, ci_mode],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = proc.communicate(timeout=5)
        req_id = (stdout or "").strip() or "UNKNOWN"

        if proc.returncode != 0:
            return jsonify({
                "ok": False,
                "implemented": True,
                "ci_triggered": False,
                "request_id": req_id,
                "error": f"Wrapper exited with code {proc.returncode}",
                "stderr": (stderr or "")[-4000:],
            }), 500

        return jsonify({
            "ok": True,
            "implemented": True,
            "ci_triggered": True,
            "request_id": req_id,
            "profile": profile,
            "target": target,
            "ci_mode": ci_mode,
            "message": "Scan request accepted, CI pipeline running in background."
        })
    except subprocess.TimeoutExpired:
        return jsonify({
            "ok": True,
            "implemented": True,
            "ci_triggered": True,
            "request_id": "TIMEOUT_SPAWN",
            "profile": profile,
            "target": target,
            "ci_mode": ci_mode,
            "message": "Scan request spawned (timeout on wrapper stdout)."
        })
    except Exception as e:
        return jsonify({
            "ok": False,
            "implemented": False,
            "ci_triggered": False,
            "error": str(e),
        }), 500
# === END VSP UI WHOAMI DEBUG V2 + API RUN CI TRIGGER ===



# ============================================================
# VSP UI -> CI: Status endpoint for polling (Run Scan Now UI)
# GET /api/vsp/run_status/<req_id>
# - Reads UI trigger log: SECURITY_BUNDLE/out_ci/ui_triggers/UIREQ_*.log
# - Parses ci_run_id, gate, final rc
# - Returns tail log lines
# ============================================================
def _vsp_tail_lines(p: str, n: int = 80):
    try:
        with open(p, "r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()
        return lines[-n:]
    except Exception as e:
        return [f"[run_status][ERR] cannot read log: {e}"]

def _vsp_parse_status_from_log(lines):
    # defaults
    status = "PENDING"
    final_rc = None
    ci_run_id = None
    gate = None

    # Parse ci_run_id from OUTER banner
    rx_run = re.compile(r"\bRUN_ID\b\s*=\s*(VSP_CI_\d{8}_\d{6})")
    rx_run2 = re.compile(r"\bRUN_ID\b\s*=\s*(VSP_CI_\d{8}_\d{6})")
    rx_outer = re.compile(r"\[VSP_CI_OUTER\].*?\bRUN_ID\b\s*=\s*(VSP_CI_\d{8}_\d{6})")
    rx_pipe_end = re.compile(r"\[VSP_UI_RUN\].*?Pipeline kết thúc với RC=(\-?\d+)")
    rx_gate_final = re.compile(r"\[VSP_CI_GATE\].*?\bFinal RC\b\s*:\s*(\-?\d+)")
    rx_runner_rc = re.compile(r"\[VSP_CI_GATE\].*?Runner kết thúc với RC=(\-?\d+)")
    rx_gate_pass = re.compile(r"\[VSP_CI_GATE\].*?\bGATE PASS\b")
    rx_gate_fail = re.compile(r"\[VSP_CI_GATE\].*?\bGATE FAIL\b")

    saw_start = False
    for ln in lines:
        if "[VSP_UI_RUN]" in ln or "[VSP_CI_OUTER]" in ln or "[VSP_CI_GATE]" in ln:
            saw_start = True

        m = rx_outer.search(ln) or rx_run.search(ln) or rx_run2.search(ln)
        if m and not ci_run_id:
            ci_run_id = m.group(1)

        if rx_gate_pass.search(ln):
            gate = "PASS"
        if rx_gate_fail.search(ln):
            gate = "FAIL"

        m = rx_gate_final.search(ln)
        if m:
            final_rc = int(m.group(1))

        m = rx_pipe_end.search(ln)
        if m:
            final_rc = int(m.group(1))

        # Nếu runner chết sớm mà chưa có Final RC
        if final_rc is None:
            m = rx_runner_rc.search(ln)
            if m:
                final_rc = int(m.group(1))

    if not saw_start:
        status = "PENDING"
    else:
        # Có start
        status = "RUNNING"
        if final_rc is not None:
            status = "DONE" if final_rc == 0 else "FAILED"

    return status, ci_run_id, gate, final_rc

def _vsp_try_read_has_findings(ci_run_id: str):
    # ưu tiên nếu đã sync về VSP core: out/RUN_VSP_CI_x/report/ci_flag_has_findings.env
    if not ci_run_id:
        return None

    vsp_run_id = "RUN_" + ci_run_id.replace("VSP_CI_", "VSP_CI_")
    vsp_flag = Path("/home/test/Data/SECURITY_BUNDLE/out") / vsp_run_id / "report" / "ci_flag_has_findings.env"
    # fallback: có thể có flag trong CI_RUN_DIR/report/ci_flag_has_findings.env (nếu bạn tạo ở outer)
    ci_flag = Path("/home/test/Data/SECURITY-10-10-v4/out_ci") / ci_run_id / "report" / "ci_flag_has_findings.env"

    for fp in [vsp_flag, ci_flag]:
        try:
            if fp.is_file():
                data = fp.read_text(encoding="utf-8", errors="ignore").splitlines()
                for ln in data:
                    ln = ln.strip()
                    if ln.startswith("has_findings="):
                        return int(ln.split("=", 1)[1].strip())
        except Exception:
            continue
    return None

@app.route("/api/vsp/run_status/<req_id>", methods=["GET"])
def api_vsp_run_status(req_id):
    # req_id expected like UIREQ_YYYYmmdd_HHMMSS_pid
    log_dir = Path("/home/test/Data/SECURITY_BUNDLE/out_ci/ui_triggers")
    log_path = log_dir / f"{req_id}.log"

    if not log_path.is_file():
        return jsonify({
            "ok": False,
            "error": f"REQ log not found: {log_path}"
        }), 404

    lines = _vsp_tail_lines(str(log_path), n=90)
    status, ci_run_id, gate, final_rc = _vsp_parse_status_from_log(lines)

    has_findings = _vsp_try_read_has_findings(ci_run_id)
    flag = {}
    if has_findings is not None:
        flag["has_findings"] = has_findings

    # === VSP_API_VSP_RUN_STATUS_INJECT_CI_KICS_V1 ===
    try:
        # ensure payload exists + is dict
        _pl = payload if isinstance(locals().get("payload", None), dict) else None
        if _pl is None:
            _pl = locals().get("obj", None) if isinstance(locals().get("obj", None), dict) else None
        if _pl is not None:
            _rid = (req_id or "").strip()
            _ci = (_pl.get("ci_run_dir") or "").strip()
            if not _ci:
                try:
                    _ci = _vsp_guess_ci_run_dir_from_rid_v33(_rid) or ""
                except Exception:
                    _ci = ""
                if _ci:
                    _pl["ci_run_dir"] = _ci
            if _ci:
                # inject KICS summary (if exists)
                try:
                    import json as _json
                    from pathlib import Path as _Path
                    _ks = _Path(_ci) / "kics" / "kics_summary.json"
                    if _ks.is_file():
                        _ko = _json.loads(_ks.read_text(encoding="utf-8", errors="ignore") or "{}")
                        if isinstance(_ko, dict):
                            _pl["kics_verdict"] = _ko.get("verdict","") or _pl.get("kics_verdict","")
                            try:
                                _pl["kics_total"] = int(_ko.get("total") or 0)
                            except Exception:
                                pass
                            _pl["kics_counts"] = _ko.get("counts") or _pl.get("kics_counts") or {}
                except Exception:
                    pass
    except Exception:
        pass

    return jsonify({
        "ok": True,
        "request_id": req_id,
        "status": status,
        "ci_run_id": ci_run_id,
        "gate": gate,
        "final": final_rc,
        "flag": flag,
        "tail": lines[-60:]  # UI show last 60 lines
    })


# === VSP_JSON_ERRHANDLERS_V4 ===
# Contract: any /api/vsp/* error must still be JSON so jq never dies.
def _vsp_env_int(name, default):
    try:
        import os
        v = os.getenv(name, "")
        if str(v).strip() == "":
            return int(default)
        return int(float(v))
    except Exception:
        return int(default)

def _vsp_api_json_err(code, msg):
    from flask import jsonify
    stall = _vsp_env_int("VSP_UIREQ_STALL_TIMEOUT_SEC", _vsp_env_int("VSP_STALL_TIMEOUT_SEC", 600))
    total = _vsp_env_int("VSP_UIREQ_TOTAL_TIMEOUT_SEC", _vsp_env_int("VSP_TOTAL_TIMEOUT_SEC", 7200))
    if stall < 1: stall = 1
    if total < 1: total = 1
    payload = {
        "ok": False,
        "status": "ERROR",
        "final": True,
        "error": msg,
        "http_code": code,
        "stall_timeout_sec": stall,
        "total_timeout_sec": total,
        "progress_pct": 0,
        "stage_index": 0,
        "stage_total": 0,
        "stage_name": "",
        "stage_sig": "",
    }
    return jsonify(payload), 200

def _vsp_err_404(e):
    try:
        from flask import request
        if request.path.startswith("/api/vsp/"):
            return _vsp_api_json_err(404, "HTTP_404_NOT_FOUND")
    except Exception:
        pass
    return ("Not Found", 404)

def _vsp_err_500(e):
    try:
        from flask import request
        if request.path.startswith("/api/vsp/"):
            return _vsp_api_json_err(500, "HTTP_500_INTERNAL")
    except Exception:
        pass
    return ("Internal Server Error", 500)

app.register_error_handler(404, _vsp_err_404)
app.register_error_handler(500, _vsp_err_500)
# === END VSP_JSON_ERRHANDLERS_V4 ===

# === VSP_RUN_API_FALLBACK_V1 ===
    
import os as _os
if _os.getenv("VSP_DISABLE_RUNAPI_FALLBACK", "0") == "1":
    print("[VSP_RUN_API_FALLBACK] disabled by VSP_DISABLE_RUNAPI_FALLBACK=1")
else:
    # If real run_api blueprint fails to load, we still MUST expose /api/vsp/run_v1 and /api/vsp/run_status_v1/*
    # so UI + jq never breaks. This is the "commercial contract".
    def _vsp_env_int(name, default):
        try:
            import os
            v = os.getenv(name, "")
            if str(v).strip() == "":
                return int(default)
            return int(float(v))
        except Exception:
            return int(default)

    def _vsp_contractize(payload):
        if not isinstance(payload, dict):
            payload = {"ok": False, "status": "ERROR", "final": True, "error": "INVALID_STATUS_PAYLOAD"}
        stall = _vsp_env_int("VSP_UIREQ_STALL_TIMEOUT_SEC", _vsp_env_int("VSP_STALL_TIMEOUT_SEC", 600))
        total = _vsp_env_int("VSP_UIREQ_TOTAL_TIMEOUT_SEC", _vsp_env_int("VSP_TOTAL_TIMEOUT_SEC", 7200))
        if stall < 1: stall = 1
        if total < 1: total = 1
        payload.setdefault("ok", bool(payload.get("ok", False)))
        payload.setdefault("status", payload.get("status") or "UNKNOWN")
        payload.setdefault("final", bool(payload.get("final", False)))
        payload.setdefault("error", payload.get("error") or "")
        payload.setdefault("req_id", payload.get("req_id") or "")
        payload["stall_timeout_sec"] = int(payload.get("stall_timeout_sec") or stall)
        payload["total_timeout_sec"] = int(payload.get("total_timeout_sec") or total)
        payload.setdefault("killed", bool(payload.get("killed", False)))
        payload.setdefault("kill_reason", payload.get("kill_reason") or "")
        payload.setdefault("progress_pct", int(payload.get("progress_pct") or 0))
        payload.setdefault("stage_index", int(payload.get("stage_index") or 0))
        payload.setdefault("stage_total", int(payload.get("stage_total") or 0))
        payload.setdefault("stage_name", payload.get("stage_name") or "")
        payload.setdefault("stage_sig", payload.get("stage_sig") or "")
        payload.setdefault("updated_at", int(__import__("time").time()))
        return payload

    try:
        bp_vsp_run_api_v1  # noqa
    except Exception:
        bp_vsp_run_api_v1 = None

    if bp_vsp_run_api_v1 is None:
        from flask import Blueprint, request, jsonify
        bp_vsp_run_api_v1 = Blueprint("vsp_run_api_v1_fallback", __name__)
        _VSP_FALLBACK_REQ = {}

        @bp_vsp_run_api_v1.route("/api/vsp/run_v1", methods=["POST"])
        def _fallback_run_v1():
            # Keep same behavior: missing body => 400 but still JSON
            body = None
            try:
                body = request.get_json(silent=True)
            except Exception:
                body = None
            if not body:
                return jsonify({"ok": False, "error": "MISSING_BODY"}), 400

            req_id = "REQ_FALLBACK_" + __import__("time").strftime("%Y%m%d_%H%M%S")
            st = _vsp_contractize({
                "ok": True,
                "status": "RUNNING",
                "final": False,
                "error": "",
                "req_id": req_id,
                "progress_pct": 0,
                "stage_index": 0,
                "stage_total": 0,
                "stage_name": "INIT",
                "stage_sig": "0/0|INIT|0",
            })
            _VSP_FALLBACK_REQ[req_id] = st
            return jsonify({"ok": True, "request_id": req_id, "implemented": False, "message": "Fallback run_api active (real bp load failed)."}), 200

        @bp_vsp_run_api_v1.route("/api/vsp/run_status_v1/<req_id>", methods=["GET"])
        def _fallback_run_status_v1(req_id):
            if req_id not in _VSP_FALLBACK_REQ:
                # === VSP_KICS_TAIL_PRE_RETURN_V3_DEBUG ===
                try:
                    import os, json
                    from pathlib import Path
                    NL = chr(10)
                    d = None
                    # try common local dict vars
                    for k in ('_out','out','resp','payload','ret','data','result','st'):
                        v = locals().get(k)
                        if isinstance(v, dict):
                            d = v; break
                    # fallback store (if exists)
                    if d is None:
                        fb = globals().get('_VSP_FALLBACK_REQ')
                        if isinstance(fb, dict):
                            vv = fb.get(req_id)
                            if isinstance(vv, dict): d = vv
                    if isinstance(d, dict):
                        d['_handler'] = '_fallback_run_status_v1'
                        ci = str(d.get('ci_run_dir') or '')
                        # if ci missing, try statefile candidates
                        if not ci:
                            base = Path(__file__).resolve().parent
                            cands = [
                                base / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                                base / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                                base / 'ui' / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                            ]
                            for stp in cands:
                                if stp.exists():
                                    try:
                                        t = stp.read_text(encoding='utf-8', errors='ignore') or ''
                                        j = json.loads(t) if t.strip() else dict()
                                        ci = str(j.get('ci_run_dir') or '')
                                        if ci: break
                                    except Exception:
                                        pass
                        klog = os.path.join(ci, 'kics', 'kics.log')
                        if ci and os.path.exists(klog):
                            rawb = Path(klog).read_bytes()
                            if len(rawb) > 65536: rawb = rawb[-65536:]
                            raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                            hb = ''
                            for ln in reversed(raw.splitlines()):
                                if '][HB]' in ln and '[KICS_V' in ln:
                                    hb = ln.strip(); break
                            ls2 = [x for x in raw.splitlines() if x.strip()]
                            tail = NL.join(ls2[-30:])
                            if hb and (hb not in tail): tail = hb + NL + tail
                            d['kics_tail'] = tail[-4096:]
                        else:
                            d['kics_tail'] = '[kics_tail] ci=' + str(ci) + ' exists=' + str(os.path.exists(klog))
                except Exception:
                    pass
                # === END VSP_KICS_TAIL_PRE_RETURN_V3_DEBUG ===
                return jsonify(_vsp_contractize({
                    "ok": False,
                    "status": "NOT_FOUND",
                    "final": True,
                    "error": "REQ_ID_NOT_FOUND",
                    "req_id": req_id
                })), 200
            # === VSP_STATUS_TAIL_APPEND_KICS_HB_V6_FIXED_SAFE ===
            try:
                import os
                st = _VSP_FALLBACK_REQ.get(req_id) or {}
                _stage = str(st.get('stage_name') or '').lower()
                _ci = str(st.get('ci_run_dir') or '')
                if ('kics' in _stage) and _ci:
                    _klog = os.path.join(_ci, 'kics', 'kics.log')
                    if os.path.exists(_klog):
                        with open(_klog, 'rb') as fh:
                            _rawb = fh.read()
                        if len(_rawb) > 65536:
                            _rawb = _rawb[-65536:]
                        _raw = _rawb.decode('utf-8', errors='ignore').replace('\r','\n')
                        _hb = ''
                        for _ln in reversed(_raw.splitlines()):
                            if '][HB]' in _ln and '[KICS_V' in _ln:
                                _hb = _ln.strip()
                                break
                        _lines = [x for x in _raw.splitlines() if x.strip()]
                        _tail = '\n'.join(_lines[-25:])
                        if _hb and (_hb not in _tail):
                            _tail = _hb + '\n' + _tail
                        st['tail'] = (_tail or '')[-4096:]
                        _VSP_FALLBACK_REQ[req_id] = st
            except Exception:
                pass
            # === END VSP_STATUS_TAIL_APPEND_KICS_HB_V6_FIXED_SAFE ===
            _out = _vsp_contractize(_VSP_FALLBACK_REQ[req_id])
            # === VSP_STATUS_TAIL_OVERRIDE_KICS_V8 ===
            try:
                import os
                from pathlib import Path
                _stage = str(_out.get('stage_name') or '').lower()
                _ci = str(_out.get('ci_run_dir') or '')
                if _ci:
                    _klog = os.path.join(_ci, 'kics', 'kics.log')
                    if os.path.exists(_klog):
                        rawb = Path(_klog).read_bytes()
                        if len(rawb) > 65536:
                            rawb = rawb[-65536:]
                        raw = rawb.decode('utf-8', errors='ignore').replace('\\r','\\n')
                        hb = ''
                        for ln in reversed(raw.splitlines()):
                            if '][HB]' in ln and '[KICS_V' in ln:
                                hb = ln.strip(); break
                        clean = [x for x in raw.splitlines() if x.strip()]
                        ktail = '\\n'.join(clean[-25:])
                        if hb and (hb not in ktail):
                            ktail = hb + '\\n' + ktail
                        _out['kics_tail'] = (ktail or '')[-4096:]
                        # only override main tail when stage is KICS
                        if 'kics' in _stage:
                            _out['tail'] = _out['kics_tail']
            except Exception:
                pass
            # === END VSP_STATUS_TAIL_OVERRIDE_KICS_V8 ===
            # === VSP_STATUS_TAIL_OVERRIDE_KICS_V10_RETURNPATCH ===
            _out = _vsp_contractize(_VSP_FALLBACK_REQ[req_id])
            try:
                import os, json
                from pathlib import Path
                NL = chr(10)
                _stage = str(_out.get('stage_name') or '').lower()
                _ci = str(_out.get('ci_run_dir') or '')
                if not _ci:
                    try:
                        _st = (Path(__file__).resolve().parent / 'out_ci' / 'uireq_v1' / (req_id + '.json'))
                        if _st.exists():
                            txt = _st.read_text(encoding='utf-8', errors='ignore') or ''
                            j = json.loads(txt) if txt.strip() else dict()
                            _ci = str(j.get('ci_run_dir') or '')
                    except Exception:
                        pass
                if _ci:
                    _klog = os.path.join(_ci, 'kics', 'kics.log')
                    if os.path.exists(_klog):
                        rawb = Path(_klog).read_bytes()
                        if len(rawb) > 65536:
                            rawb = rawb[-65536:]
                        raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                        hb = ''
                        for ln in reversed(raw.splitlines()):
                            if '][HB]' in ln and '[KICS_V' in ln:
                                hb = ln.strip()
                                break
                        clean = [x for x in raw.splitlines() if x.strip()]
                        ktail = NL.join(clean[-25:])
                        if hb and (hb not in ktail):
                            ktail = hb + NL + ktail
                        _out['kics_tail'] = (ktail or '')[-4096:]
                        if 'kics' in _stage:
                            _out['tail'] = _out.get('kics_tail','')
            except Exception:
                pass
            # === END VSP_STATUS_TAIL_OVERRIDE_KICS_V10_RETURNPATCH ===
            # === VSP_KICS_TAIL_HOTFIX_V11_LITE2 ===
            try:
                import os, json
                from pathlib import Path
                NL = chr(10)
                # ensure _out exists
                if '_out' not in locals():
                    _out = _vsp_contractize(_VSP_FALLBACK_REQ[req_id])
                _stage = str(_out.get('stage_name') or '').lower()
                _ci = str(_out.get('ci_run_dir') or _out.get('ci_dir') or '')
                if not _ci:
                    base = Path(__file__).resolve().parent
                    cands = [
                        base / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                        base / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                        base / 'ui' / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                        UIREQ_STATE_DIR / (req_id + '.json'),
                        UIREQ_STATE_DIR / (req_id + '.json'),
                    ]
                    for st in cands:
                        try:
                            if st.exists():
                                txt = st.read_text(encoding='utf-8', errors='ignore') or ''
                                j = json.loads(txt) if txt.strip() else dict()
                                _ci = str(j.get('ci_run_dir') or j.get('ci_dir') or '')
                                if _ci:
                                    _out['ci_run_dir'] = _ci
                                    break
                        except Exception:
                            pass
                _klog = ''
                if _ci:
                    _klog = os.path.join(_ci, 'kics', 'kics.log')
                    if not os.path.exists(_klog):
                        try:
                            kd = Path(_ci) / 'kics'
                            if kd.exists():
                                logs = [x for x in kd.glob('*.log') if x.is_file()]
                                logs.sort(key=lambda x: x.stat().st_mtime, reverse=True)
                                if logs:
                                    _klog = str(logs[0])
                        except Exception:
                            pass
                _tail_msg = ''
                if _klog and os.path.exists(_klog):
                    rawb = Path(_klog).read_bytes()
                    if len(rawb) > 65536:
                        rawb = rawb[-65536:]
                    raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                    hb = ''
                    for ln in reversed(raw.splitlines()):
                        if '][HB]' in ln and '[KICS_V' in ln:
                            hb = ln.strip(); break
                    clean = [x for x in raw.splitlines() if x.strip()]
                    ktail = NL.join(clean[-25:])
                    if hb and (hb not in ktail):
                        ktail = hb + NL + ktail
                    _tail_msg = (ktail or '')[-4096:]
                else:
                    # fallback: runner.log
                    if _ci:
                        rlog = os.path.join(_ci, 'runner.log')
                        if os.path.exists(rlog):
                            rawb = Path(rlog).read_bytes()
                            if len(rawb) > 65536:
                                rawb = rawb[-65536:]
                            raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                            clean = [x for x in raw.splitlines() if x.strip()]
                            _tail_msg = ('[KICS_TAIL][fallback runner.log]' + NL + NL.join(clean[-25:]))[-4096:]
                    if not _tail_msg:
                        _tail_msg = '[KICS_TAIL] no kics log yet'
                _out['kics_tail'] = _tail_msg
                if 'kics' in _stage:
                    _out['tail'] = _tail_msg
            except Exception:
                pass
            # === END VSP_KICS_TAIL_HOTFIX_V11_LITE2 ===
            # === VSP_FORCE_KICS_TAIL_V2 ===
            _out = _vsp_contractize(_VSP_FALLBACK_REQ[req_id])
            try:
                import os, json
                from pathlib import Path
                NL = chr(10)
                _ci = str(_out.get('ci_run_dir') or '')
                if not _ci:
                    cands = [
                        (Path(__file__).resolve().parent / 'out_ci' / 'uireq_v1' / (req_id + '.json')),
                        (Path(__file__).resolve().parent / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json')),
                        (Path(__file__).resolve().parent / 'ui' / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json')),
                    ]
                    for _st in cands:
                        if _st.exists():
                            txt = _st.read_text(encoding='utf-8', errors='ignore') or ''
                            j = json.loads(txt) if txt.strip() else {}
                            _ci = str(j.get('ci_run_dir') or '')
                            break
                if _ci:
                    _klog = os.path.join(_ci, 'kics', 'kics.log')
                    if os.path.exists(_klog):
                        rawb = Path(_klog).read_bytes()
                        if len(rawb) > 65536:
                            rawb = rawb[-65536:]
                        raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                        hb = ''
                        for ln in reversed(raw.splitlines()):
                            if '][HB]' in ln and '[KICS_V' in ln:
                                hb = ln.strip(); break
                        lines2 = [x for x in raw.splitlines() if x.strip()]
                        tail = NL.join(lines2[-60:])
                        if hb and hb not in tail:
                            tail = hb + NL + tail
                        _out['kics_tail'] = tail[-4096:]
            except Exception:
                pass
            # === END VSP_FORCE_KICS_TAIL_V2 ===
            # === VSP_FORCE_KICS_TAIL_FINAL_RETURN_V1 ===
            _out = _out
            try:
                import os, json
                from pathlib import Path
                NL = chr(10)
                if isinstance(_out, dict):
                    stage = str(_out.get('stage_name') or '').lower()
                    ci = str(_out.get('ci_run_dir') or '')
                    if ('kics' in stage) and ci:
                        klog = os.path.join(ci, 'kics', 'kics.log')
                        if os.path.exists(klog):
                            rawb = Path(klog).read_bytes()
                            if len(rawb) > 65536:
                                rawb = rawb[-65536:]
                            raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                            hb = ''
                            for ln in reversed(raw.splitlines()):
                                if '][HB]' in ln and '[KICS_V' in ln:
                                    hb = ln.strip(); break
                            lines2 = [x for x in raw.splitlines() if x.strip()]
                            tail = NL.join(lines2[-30:])
                            if hb and (hb not in tail):
                                tail = hb + NL + tail
                            _out['kics_tail'] = tail[-4096:]
            except Exception:
                pass
            # === END VSP_FORCE_KICS_TAIL_FINAL_RETURN_V1 ===
            # === VSP_FORCE_KICS_TAIL_BY_ROUTE_V2 ===
            _out = _out
            try:
                import os
                from pathlib import Path
                NL = chr(10)
                if isinstance(_out, dict):
                    ci = str(_out.get('ci_run_dir') or '')
                    if ci:
                        klog = os.path.join(ci, 'kics', 'kics.log')
                        if os.path.exists(klog):
                            rawb = Path(klog).read_bytes()
                            if len(rawb) > 65536:
                                rawb = rawb[-65536:]
                            raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                            hb = ''
                            for ln in reversed(raw.splitlines()):
                                if '][HB]' in ln and '[KICS_V' in ln:
                                    hb = ln.strip(); break
                            lines2 = [x for x in raw.splitlines() if x.strip()]
                            tail = NL.join(lines2[-30:])
                            if hb and (hb not in tail):
                                tail = hb + NL + tail
                            _out['kics_tail'] = tail[-4096:]
            except Exception:
                pass
            # === END VSP_FORCE_KICS_TAIL_BY_ROUTE_V2 ===
            # === VSP_KICS_TAIL_PRE_RETURN_V3_DEBUG ===
            try:
                import os, json
                from pathlib import Path
                NL = chr(10)
                d = None
                # try common local dict vars
                for k in ('_out','out','resp','payload','ret','data','result','st'):
                    v = locals().get(k)
                    if isinstance(v, dict):
                        d = v; break
                # fallback store (if exists)
                if d is None:
                    fb = globals().get('_VSP_FALLBACK_REQ')
                    if isinstance(fb, dict):
                        vv = fb.get(req_id)
                        if isinstance(vv, dict): d = vv
                if isinstance(d, dict):
                    d['_handler'] = '_fallback_run_status_v1'
                    ci = str(d.get('ci_run_dir') or '')
                    # if ci missing, try statefile candidates
                    if not ci:
                        base = Path(__file__).resolve().parent
                        cands = [
                            base / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                            base / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                            base / 'ui' / 'ui' / 'out_ci' / 'uireq_v1' / (req_id + '.json'),
                        ]
                        for stp in cands:
                            if stp.exists():
                                try:
                                    t = stp.read_text(encoding='utf-8', errors='ignore') or ''
                                    j = json.loads(t) if t.strip() else dict()
                                    ci = str(j.get('ci_run_dir') or '')
                                    if ci: break
                                except Exception:
                                    pass
                    klog = os.path.join(ci, 'kics', 'kics.log')
                    if ci and os.path.exists(klog):
                        rawb = Path(klog).read_bytes()
                        if len(rawb) > 65536: rawb = rawb[-65536:]
                        raw = rawb.decode('utf-8', errors='ignore').replace(chr(13), NL)
                        hb = ''
                        for ln in reversed(raw.splitlines()):
                            if '][HB]' in ln and '[KICS_V' in ln:
                                hb = ln.strip(); break
                        ls2 = [x for x in raw.splitlines() if x.strip()]
                        tail = NL.join(ls2[-30:])
                        if hb and (hb not in tail): tail = hb + NL + tail
                        d['kics_tail'] = tail[-4096:]
                    else:
                        d['kics_tail'] = '[kics_tail] ci=' + str(ci) + ' exists=' + str(os.path.exists(klog))
            except Exception:
                pass
            # === END VSP_KICS_TAIL_PRE_RETURN_V3_DEBUG ===
            # === VSP_UIREQ_PERSIST_AND_RESOLVE_CI_V1 ===
            # Persist UIREQ state under out_ci/uireq_v1 and try resolve ci_run_dir from state (commercial)
            try:
                import os, json, glob, datetime
                rid = req_id if 'req_id' in locals() else (request_id if 'request_id' in locals() else None)
                if not rid:
                    rid = (locals().get("REQ_ID") or locals().get("RID") or None)
                udir = os.path.join(os.path.dirname(__file__), "out_ci", "uireq_v1")
                os.makedirs(udir, exist_ok=True)
                spath = os.path.join(udir, f"{rid}.json") if rid else None
            
                # choose dst dict (prefer resp/out)
                dst = None
                if isinstance(locals().get("resp", None), dict): dst = resp
                if isinstance(locals().get("out", None), dict): dst = out
            
                if isinstance(dst, dict):
                    # normalize empties
                    if dst.get("stage_name") is None: dst["stage_name"] = ""
                    if dst.get("ci_run_dir") is None: dst["ci_run_dir"] = ""
            
                    # resolve ci_run_dir if empty: read previously persisted state or fallback to latest CI dir
                    if (not dst.get("ci_run_dir")) and spath and os.path.isfile(spath):
                        try:
                            j = json.load(open(spath, "r", encoding="utf-8"))
                            dst["ci_run_dir"] = j.get("ci_run_dir") or j.get("ci") or dst.get("ci_run_dir") or ""
                        except Exception:
                            pass
            
                    if (not dst.get("ci_run_dir")):
                        # fallback guess: newest CI dir under /home/test/Data/SECURITY-10-10-v4/out_ci
                        cand = sorted(glob.glob("/home/test/Data/SECURITY-10-10-v4/out_ci/VSP_CI_*"), reverse=True)
                        if cand:
                            dst["ci_run_dir"] = cand[0]
            
                    # persist state every call (so UI has stable mapping)
                    if spath:
                        payload = dict(dst)
                        payload["ts_persist"] = datetime.datetime.utcnow().isoformat() + "Z"
                        try:
                            open(spath, "w", encoding="utf-8").write(json.dumps(payload, ensure_ascii=False, indent=2))
                        except Exception:
                            pass
            except Exception:
                pass

            return jsonify(_out), 200

        try:
            app.register_blueprint(bp_vsp_run_api_v1)
            print("[VSP_RUN_API_FALLBACK] mounted /api/vsp/run_v1 + /api/vsp/run_status_v1/*")
        except Exception as e:
            print("[VSP_RUN_API_FALLBACK] mount failed:", repr(e))
# === END VSP_RUN_API_FALLBACK_V1 ===

# === VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V31 ===
def _vsp_try_inject_kics_into_payload(payload: dict):
    try:
        ci_dir = payload.get("ci_run_dir") or payload.get("ci_run_dir_abs") or payload.get("run_dir") or payload.get("ci_dir") or ""
        ks = _vsp_read_kics_summary(ci_dir) if ci_dir else None
        if isinstance(ks, dict):
            payload["kics_verdict"] = ks.get("verdict","") or ""
            payload["kics_counts"]  = ks.get("counts",{}) if isinstance(ks.get("counts"), dict) else {}
            payload["kics_total"]   = int(ks.get("total",0) or 0)
        else:
            payload.setdefault("kics_verdict","")
            payload.setdefault("kics_counts",{})
            payload.setdefault("kics_total",0)
    except Exception:
        payload.setdefault("kics_verdict","")
        payload.setdefault("kics_counts",{})
        payload.setdefault("kics_total",0)

def vsp_after_request_inject_kics_summary_v31(resp):
    try:
        from flask import request as _req
        path = getattr(_req, "path", "") or ""
        if not (path.startswith("/api/vsp/run_status_v1/") or path.startswith("/api/vsp/run_status_v2/")):
            return resp

        # read JSON body
        raw = resp.get_data(as_text=True) or ""
        s = raw.lstrip()
        if not s:
            return resp
        c0 = s[0]
        if c0 not in ("{", "["):
            return resp

        import json as _json
        payload = _json.loads(s)
        if not isinstance(payload, dict):
            return resp

        _vsp_try_inject_kics_into_payload(payload)

        resp.set_data(_json.dumps(payload, ensure_ascii=False))
        resp.headers["Content-Type"] = "application/json"
        return resp
    except Exception:
        # === VSP_STATUS_GUARD_INJECT_CI_KICS_V10 ===
        try:
            import json as _json
            from pathlib import Path as _Path
            from flask import request as _req
            _resp = resp
            _path = (_req.path or '')
            if _path.startswith('/api/vsp/run_status_v1/') or _path.startswith('/api/vsp/run_status_v2/'):
                _rid = (_path.rsplit('/', 1)[-1] or '').split('?', 1)[0].strip()
                _rid_norm = _rid[4:].strip() if _rid.startswith('RUN_') else _rid
                _obj = None
                try:
                    _obj = _resp.get_json(silent=True)
                except Exception:
                    _obj = None
                if not isinstance(_obj, dict):
                    try:
                        _raw = (_resp.get_data(as_text=True) or '').lstrip()
                        if _raw.startswith('{'):
                            _obj = _json.loads(_raw)
                    except Exception:
                        _obj = None
                if isinstance(_obj, dict):
                    _obj.setdefault('ci_run_dir', None)
                    _obj.setdefault('kics_verdict', '')
                    _obj.setdefault('kics_total', 0)
                    _obj.setdefault('kics_counts', {})
                    _ci = (_obj.get('ci_run_dir') or '').strip()
                    if (not _ci) and _rid_norm:
                        try:
                            _ci = _vsp_guess_ci_run_dir_from_rid_v33(_rid_norm) or ''
                        except Exception:
                            _ci = ''
                        if _ci:
                            _obj['ci_run_dir'] = _ci
                    _ci = (_obj.get('ci_run_dir') or '').strip()
                    if _ci:
                        _ks = _Path(_ci) / 'kics' / 'kics_summary.json'
                        if _ks.is_file():
                            try:
                                _jj = _json.loads(_ks.read_text(encoding='utf-8', errors='ignore') or '{}')
                                if isinstance(_jj, dict):
                                    _obj['kics_verdict'] = str(_jj.get('verdict') or _obj.get('kics_verdict') or '')
                                    try:
                                        _obj['kics_total'] = int(_jj.get('total') or _obj.get('kics_total') or 0)
                                    except Exception:
                                        pass
                                    _cc = _jj.get('counts')
                                    if isinstance(_cc, dict):
                                        _obj['kics_counts'] = _cc
                            except Exception:
                                pass
                    try:
                        _resp.set_data(_json.dumps(_obj, ensure_ascii=False))
                        _resp.mimetype = 'application/json'
                    except Exception:
                        pass
        except Exception:
            pass
        return resp
# === END VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V31 ===


# === VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V31 ===
try:
    app.after_request(vsp_after_request_inject_kics_summary_v31)
except Exception:
    pass
# === END VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V31 ===


# === VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V33 ===
def _vsp_guess_ci_run_dir_from_rid_v33(rid_norm):
    # === VSP_GUESS_CI_RUN_DIR_V33_REWRITE_CLEAN_V4 ===
    """Return absolute CI run dir for a RID (RUN_* / VSP_CI_* / VSP_UIREQ_*).
    - If RID is UIREQ: read persisted state under ui/out_ci/uireq_v1/<RID>.json
    - Else: find */out_ci/<RID> under /home/test/Data with shallow globs
    """
    try:
        import json
        from pathlib import Path
        rn = str(rid_norm or '').strip()
        if not rn:
            return None
        if rn.startswith("RUN_"):
            rn = rn[4:].strip()

        # UIREQ -> read persisted state (if exists)
        if rn.startswith("VSP_UIREQ_"):
            st = Path("/home/test/Data/SECURITY_BUNDLE/ui/ui/out_ci/uireq_v1") / (rn + ".json")
            if st.is_file():
                try:
                    obj = json.loads(st.read_text(encoding="utf-8", errors="ignore") or "{}")
                    if isinstance(obj, dict):
                        ci = (obj.get("ci_run_dir") or obj.get("ci_dir") or obj.get("ci") or "").strip()
                        if ci and Path(ci).is_dir():
                            return str(Path(ci))
                except Exception:
                    pass

        base = Path("/home/test/Data")

        # very fast common hit: /home/test/Data/*/out_ci/<rn>
        try:
            for c in base.glob("*/out_ci/" + rn):
                if c.is_dir():
                    return str(c)
        except Exception:
            pass

        # shallow fallbacks (no ** recursion)
        pats = (
            "*/*/out_ci/" + rn,
            "*/*/*/out_ci/" + rn,
            "*/*/*/*/out_ci/" + rn,
        )
        for pat in pats:
            try:
                for c in base.glob(pat):
                    if c.is_dir():
                        return str(c)
            except Exception:
                continue

        return None
    except Exception:
        return None
def _vsp_try_inject_kics_into_payload_v33(payload: dict, req_path: str):
    try:
        ci_dir = payload.get("ci_run_dir") or payload.get("ci_run_dir_abs") or payload.get("run_dir") or payload.get("ci_dir") or ""
        if not ci_dir:
            rid = payload.get("rid_norm") or payload.get("run_id") or payload.get("request_id") or ""
            if not rid and req_path:
                rid = req_path.rsplit("/", 1)[-1]
            g = _vsp_guess_ci_run_dir_from_rid_v33(rid)
            if g:
                payload["ci_run_dir"] = g
                ci_dir = g

        ks = _vsp_read_kics_summary(ci_dir) if ci_dir else None
        if isinstance(ks, dict):
            payload["kics_verdict"] = ks.get("verdict","") or ""
            payload["kics_counts"]  = ks.get("counts",{}) if isinstance(ks.get("counts"), dict) else {}
            payload["kics_total"]   = int(ks.get("total",0) or 0)
        else:
            payload.setdefault("kics_verdict","")
            payload.setdefault("kics_counts",{})
            payload.setdefault("kics_total",0)
    except Exception:
        payload.setdefault("kics_verdict","")
        payload.setdefault("kics_counts",{})
        payload.setdefault("kics_total",0)

def vsp_after_request_inject_kics_summary_v33(resp):
    try:
        from flask import request as _req
        path = getattr(_req, "path", "") or ""
        if not (path.startswith("/api/vsp/run_status_v1/") or path.startswith("/api/vsp/run_status_v2/")):
            return resp

        import json as _json
        raw = resp.get_data(as_text=True) or ""
        s = raw.lstrip()
        if not s:
            return resp
        c0 = s[0]
        # FIX: correct JSON detection
        if c0 not in ("{","["):
            return resp

        payload = _json.loads(s)
        if not isinstance(payload, dict):
            return resp

        _vsp_try_inject_kics_into_payload_v33(payload, path)

        resp.set_data(_json.dumps(payload, ensure_ascii=False))
        resp.headers["Content-Type"] = "application/json"
        return resp
    except Exception:
        return resp
# === END VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V33 ===


# === VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V33 ===
try:
    app.after_request(vsp_after_request_inject_kics_summary_v33)
except Exception:
    pass
# === END VSP_AFTER_REQUEST_INJECT_KICS_SUMMARY_V33 ===







def _vsp_preempt_statusv2_postprocess_v1(payload):
    """Postprocess run_status_v2 JSON payload inside WSGI preempt to avoid nulls and inject tool summaries."""
    # === VSP_PREEMPT_STATUSV2_POSTPROCESS_HELPER_V1 ===
    try:
        import json
        from pathlib import Path as _P

        if not isinstance(payload, dict):
            return payload

        # never return nulls for commercial contract keys
        if payload.get("overall_verdict", None) is None:
            payload["overall_verdict"] = ""

        payload.setdefault("has_gitleaks", False)
        payload.setdefault("gitleaks_verdict", "")
        payload.setdefault("gitleaks_total", 0)
        payload.setdefault("gitleaks_counts", {})

        ci = payload.get("ci_run_dir") or payload.get("ci_dir") or payload.get("ci") or ""
        ci = str(ci).strip()
        if not ci:
            return payload

        # local helper read json
        def _readj(fp):
            try:
                if fp and fp.exists():
                    return json.loads(fp.read_text(encoding="utf-8", errors="ignore") or "{}")
            except Exception:
                return None
            return None

        # inject gitleaks from CI
        gsum = _readj(_P(ci) / "gitleaks" / "gitleaks_summary.json") or _readj(_P(ci) / "gitleaks_summary.json")
        if isinstance(gsum, dict):
            payload["has_gitleaks"] = True
            payload["gitleaks_verdict"] = str(gsum.get("verdict") or "")
            try:
                payload["gitleaks_total"] = int(gsum.get("total") or 0)
            except Exception:
                payload.setdefault('gitleaks_total', 0)
            cc = gsum.get("counts")
            payload["gitleaks_counts"] = cc if isinstance(cc, dict) else {}

        # if run_gate exists, take overall from it (single source of truth)
        gate = _readj(_P(ci) / "run_gate_summary.json")
        if isinstance(gate, dict):
            payload["overall_verdict"] = str(gate.get("overall") or payload.get("overall_verdict") or "")

        return payload
    except Exception:
        return payload


# === VSP_EXPORT_OVERRIDE_VIEWFUNC_V2 ===
import os, glob

try:
    from flask import request, jsonify, send_file
except Exception:
    # in case imports are structured differently
    pass

def _vsp_norm_rid(rid: str) -> str:
    rid = (rid or "").strip()
    return rid[4:] if rid.startswith("RUN_") else rid

def _vsp_ci_root() -> str:
    return os.environ.get("VSP_CI_OUT_ROOT") or "/home/test/Data/SECURITY-10-10-v4/out_ci"

def _vsp_resolve_ci_dir(rid: str) -> str:
    rn = _vsp_norm_rid(rid)
    base = _vsp_ci_root()
    cand = os.path.join(base, rn)
    if os.path.isdir(cand):
        return cand
    # fallback: try match substring in latest dirs
    gl = sorted(glob.glob(os.path.join(base, "VSP_CI_*")), reverse=True)
    for d in gl:
        if rn in os.path.basename(d):
            return d
    return ""

def _pick_newest(patterns):
    best = ""
    best_m = -1.0
    for pat in patterns:
        for f in glob.glob(pat):
            try:
                m = os.path.getmtime(f)
            except Exception:
                continue
            if m > best_m:
                best_m = m
                best = f
    return best

def _pick_pdf(ci_dir: str) -> str:
    return _pick_newest([
        os.path.join(ci_dir, "reports", "*.pdf"),
        os.path.join(ci_dir, "*.pdf"),
    ])

def _pick_html(ci_dir: str) -> str:
    return _pick_newest([
        os.path.join(ci_dir, "reports", "*.html"),
        os.path.join(ci_dir, "*.html"),
    ])

def _pick_zip(ci_dir: str) -> str:
    return _pick_newest([
        os.path.join(ci_dir, "reports", "*.zip"),
        os.path.join(ci_dir, "*.zip"),
    ])

def _vsp_export_v3_override(rid):
    fmt = (request.args.get("fmt") or "html").lower().strip()
    ci_dir = _vsp_resolve_ci_dir(rid)
    if not ci_dir:
        resp = jsonify({"ok": False, "http_code": 501, "error": "EXPORT_CI_DIR_NOT_FOUND", "rid": rid, "rid_norm": _vsp_norm_rid(rid)})
        resp.status_code = 404
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp

    if fmt == "pdf":
        f = _pick_pdf(ci_dir)
        if f and os.path.isfile(f):
            resp = send_file(f, mimetype="application/pdf", as_attachment=True, download_name=os.path.basename(f))
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            return resp
        resp = jsonify({"ok": False, "http_code": 501, "error": "pdf_not_enabled", "ci_run_dir": ci_dir})
        resp.status_code = 501
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp

    if fmt == "zip":
        f = _pick_zip(ci_dir)
        if f and os.path.isfile(f):
            resp = send_file(f, mimetype="application/zip", as_attachment=True, download_name=os.path.basename(f))
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            return resp
        resp = jsonify({"ok": False, "http_code": 501, "error": "ZIP_NOT_FOUND", "ci_run_dir": ci_dir})
        resp.status_code = 404
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp

    # default html
    f = _pick_html(ci_dir)
    if f and os.path.isfile(f):
        resp = send_file(f, mimetype="text/html", as_attachment=True, download_name=os.path.basename(f))
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        return resp
    resp = jsonify({"ok": False, "http_code": 501, "error": "HTML_NOT_FOUND", "ci_run_dir": ci_dir})
    resp.status_code = 404
    resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
    return resp

# bind override to the *real* endpoint behind /api/vsp/run_export_v3/<rid>
try:
    _ep = None
    for _r in app.url_map.iter_rules():
        if _r.rule == "/api/vsp/run_export_v3/<rid>" and ("GET" in (_r.methods or set())):
            _ep = _r.endpoint
            break
    if _ep and hasattr(app, "view_functions") and _ep in app.view_functions:
        app.view_functions[_ep] = _vsp_export_v3_override
        try:
            print("[VSP_EXPORT_OVERRIDE] bound endpoint=", _ep)
        except Exception:
            pass
    else:
        try:
            print("[VSP_EXPORT_OVERRIDE][WARN] cannot find endpoint for /api/vsp/run_export_v3/<rid>")
        except Exception:
            pass
except Exception as _e:
    try:
        print("[VSP_EXPORT_OVERRIDE][ERR]", str(_e))
    except Exception:
        pass


# === VSP_FINDINGS_PREVIEW_V1_REAL_V1 ===
# Real implementation for UI Data Source (commercial)
import os, json
from pathlib import Path as _Path

def _vsp_norm_rid(rid: str) -> str:
    rid = (rid or "").strip()
    if rid.startswith("RUN_"):
        rid = rid[4:]
    return rid

def _vsp_guess_ci_dir(rid: str) -> str:
    rid = _vsp_norm_rid(rid)
    roots = [
        os.environ.get("VSP_OUT_CI_ROOT", "").strip(),
        "/home/test/Data/SECURITY-10-10-v4/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/out",
    ]
    for r in roots:
        if not r: 
            continue
        cand = _Path(r) / rid
        if cand.is_dir():
            return str(cand)
    # last resort: search (bounded)
    for r in roots:
        if not r: 
            continue
        base = _Path(r)
        if not base.is_dir():
            continue
        try:
            cand = next(base.glob(f"**/{rid}"))
            if cand.is_dir():
                return str(cand)
        except Exception:
            pass
    return ""

def _vsp_load_findings(ci_dir: str) -> tuple[list, str, str]:
    if not ci_dir:
        return [], "", "ci_dir_not_found"
    c = _Path(ci_dir)
    candidates = [
        c / "reports" / "findings_unified.json",
        c / "findings_unified.json",
        c / "reports" / "findings_unified.jsonl",
        c / "findings_unified.jsonl",
    ]
    for fp in candidates:
        if not fp.is_file():
            continue
        try:
            raw = fp.read_text(encoding="utf-8", errors="ignore").strip()
            if not raw:
                return [], str(fp), "empty_file"
            data = json.loads(raw)
            if isinstance(data, list):
                return data, str(fp), ""
            if isinstance(data, dict):
                items = data.get("items") or []
                if isinstance(items, list):
                    return items, str(fp), ""
            return [], str(fp), "unexpected_json_shape"
        except Exception as e:
            return [], str(fp), f"json_parse_error:{type(e).__name__}"
    return [], "", "findings_file_not_found"

def _vsp_match(item: dict, sev: str, tool: str, cwe: str, q: str, show_suppressed: bool) -> bool:
    if not isinstance(item, dict):
        return False
    if not show_suppressed:
        if item.get("suppressed") is True:
            return False
        if str(item.get("status","")).upper() in ("SUPPRESSED","IGNORE","IGNORED"):
            return False
    if sev:
        s = str(item.get("severity","")).upper()
        if s != sev:
            return False
    if tool:
        tl = str(item.get("tool","")).lower()
        if tl != tool.lower():
            return False
    if cwe:
        cw = str(item.get("cwe",""))
        if cw != cwe:
            return False
    if q:
        qq = q.lower()
        hay = " | ".join([
            str(item.get("title","")),
            str(item.get("file","")),
            str(item.get("rule","")),
            str(item.get("tool","")),
            str(item.get("cwe","")),
        ]).lower()
        if qq not in hay:
            return False
    return True

# NOTE: define both PATH + query styles
# === VSP_FINDINGS_PREVIEW_V2_FS_V1 ===
# REAL findings preview (NO DEMO): read findings_unified.json from CI run dir, filter + limit.
from pathlib import Path as _Path
import json as _json
import glob as _glob

# === VSP_FINDINGS_FALLBACK_V2_SAFE ===
def _vsp_guess_run_roots():
    import os
    roots = []
    # env override (colon separated)
    env = os.environ.get("VSP_RUNS_ROOTS","").strip()
    if env:
        for r in env.split(":"):
            r=r.strip()
            if r: roots.append(r)

    # common relative roots
    roots += ["out_ci", "out", "./out_ci", "./out"]

    # common absolute roots (only used if exist)
    roots += [
        "/home/test/Data/SECURITY-10-10-v4/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/out",
        "/home/test/Data/SECURITY_BUNDLE/out_ci",
    ]

    # de-dup keep order
    out=[]
    seen=set()
    for r in roots:
        if r in seen: continue
        seen.add(r)
        out.append(r)
    return out

def _vsp_pick_findings_fp(run_dir: str):
    import os
    if not run_dir:
        return None
    cands = [
        os.path.join(run_dir, "findings_unified.json"),
        os.path.join(run_dir, "reports", "findings_unified.json"),
        os.path.join(run_dir, "artifacts", "findings_unified.json"),
        os.path.join(run_dir, "findings", "findings_unified.json"),
    ]
    for fp in cands:
        try:
            if os.path.isfile(fp) and os.path.getsize(fp) > 2:
                return fp
        except Exception:
            pass
    return None

def _vsp_resolve_run_dir_from_rid(rid: str):
    import os
    if not rid:
        return None
    # if rid is already a dir path
    if os.path.isdir(rid):
        return rid
    # if rid looks like a file path (e.g., .../findings_unified.json)
    if os.path.isfile(rid):
        return os.path.dirname(rid)

    # otherwise try to find a run dir under known roots
    for root in _vsp_guess_run_roots():
        try:
            root_abs = root
            if not os.path.isabs(root_abs):
                root_abs = os.path.abspath(root_abs)
            cand = os.path.join(root_abs, rid)
            if os.path.isdir(cand):
                return cand
        except Exception:
            pass
    return None
# === /VSP_FINDINGS_FALLBACK_V2_SAFE ===


@app.route("/api/vsp/findings_preview_v2/<path:rid>")
def api_vsp_findings_preview_v2_fs(rid):
    try:
        rid_in = (rid or "").strip()
        rid_norm = rid_in
        if rid_norm.startswith("RUN_"):
            rid_norm = rid_norm[4:]
        rid_norm = rid_norm.strip()

        # Best-effort resolve CI dir (fast path) + fallback glob
        bases = [
            "/home/test/Data/SECURITY-10-10-v4/out_ci",
            "/home/test/Data/SECURITY_BUNDLE/out_ci",
            "/home/test/Data/SECURITY_BUNDLE/out",
        ]
        ci_dir = None
        for b in bases:
            cand = _Path(b) / rid_norm
            if cand.is_dir():
                ci_dir = str(cand)
                break

        if not ci_dir and rid_norm:
            hits = _glob.glob(f"/home/test/Data/**/out_ci/{rid_norm}", recursive=True)
            if hits:
                ci_dir = hits[0]

        if not ci_dir:
            return {
                "ok": False,
                "warning": "ci_run_dir_not_found",
                "rid": rid_in,
                "rid_norm": rid_norm,
                "total": 0,
                "items_n": 0,
                "items": [],
                "file": None,
            }

        # Prefer reports/findings_unified.json
        cands = [
            _Path(ci_dir) / "reports" / "findings_unified.json",
            _Path(ci_dir) / "findings_unified.json",
        ]
        fpath = None
        for c in cands:
            try:
                if c.is_file() and c.stat().st_size > 0:
                    fpath = str(c)
                    break
            except Exception:
                pass

        if not fpath:
            return {
                "ok": True,
                "warning": "findings_file_not_found",
                "rid": rid_in,
                "rid_norm": rid_norm,
                "total": 0,
                "items_n": 0,
                "items": [],
                "file": None,
            }

        data = _json.load(open(fpath, "r", encoding="utf-8", errors="ignore"))
        if isinstance(data, dict) and "items" in data:
            items = data.get("items") or []
        elif isinstance(data, list):
            items = data
        else:
            items = []

        def norm_sev(x):
            return str(x or "").upper().strip()

        q = (request.args.get("q") or request.args.get("text") or "").strip().lower()
        sev = norm_sev(request.args.get("sev") or request.args.get("severity") or "")
        tool = (request.args.get("tool") or "").strip().lower()
        cwe = (request.args.get("cwe") or "").strip().upper()

        show_supp = request.args.get("show_suppressed") or request.args.get("suppressed") or ""
        show_supp = str(show_supp).lower() in ("1","true","yes","y","on")

        def is_supp(it):
            if not isinstance(it, dict):
                return False
            if it.get("suppressed") or it.get("is_suppressed"):
                return True
            flags = it.get("flags") or {}
            return bool(flags.get("suppressed"))

        out = []
        for it in items:
            if not isinstance(it, dict):
                continue
            if (not show_supp) and is_supp(it):
                continue
            if sev and norm_sev(it.get("severity")) != sev:
                continue
            if tool and str(it.get("tool") or "").lower() != tool:
                continue
            if cwe and str(it.get("cwe") or "").upper() != cwe:
                continue
            if q:
                blob = " ".join([
                    str(it.get("title","")),
                    str(it.get("file","")),
                    str(it.get("rule","")),
                    str(it.get("cwe","")),
                    str(it.get("tool","")),
                ]).lower()
                if q not in blob:
                    continue
            out.append(it)

        total = len(out)
        try:
            limit = int(request.args.get("limit") or 200)
        except Exception:
            limit = 200
        if limit < 1: limit = 1
        if limit > 2000: limit = 2000

        return {
            "ok": True,
            "rid": rid_in,
            "rid_norm": rid_norm,
            "ci_run_dir": ci_dir,
            "file": fpath,
            "total": total,
            "items_n": min(total, limit),
            "items": out[:limit],
        }
    except Exception as e:
        return {
            "ok": False,
            "warning": "exception",
            "error": str(e),
            "total": 0,
            "items_n": 0,
            "items": [],
            "file": None,
        }
# === /VSP_FINDINGS_PREVIEW_V2_FS_V1 ===


@app.route("/api/vsp/findings_preview_v1/<path:rid>")
@app.route("/api/vsp/findings_preview_v1", defaults={"rid": None})
def api_vsp_findings_preview_v1_real(rid=None):
    try:
        rid = rid or request.args.get("rid") or request.args.get("run_id") or request.args.get("request_id") or ""
        rid = str(rid).strip()
        if not rid:
            return jsonify(ok=False, total=None, items_n=None, warning="missing_rid", file=None, items=None)

        sev = (request.args.get("sev") or request.args.get("severity") or "").strip().upper()
        tool = (request.args.get("tool") or "").strip()
        cwe  = (request.args.get("cwe")  or "").strip()
        q    = (request.args.get("q") or request.args.get("text") or "").strip()
        show_supp = str(request.args.get("show_suppressed","0")).lower() in ("1","true","yes","on")

        try:
            limit = int(request.args.get("limit","200"))
        except Exception:
            limit = 200
        try:
            offset = int(request.args.get("offset","0"))
        except Exception:
            offset = 0
        limit = max(1, min(limit, 2000))
        offset = max(0, offset)

        # prefer ci_run_dir from run_status_v2 if available
        ci_dir = ""
        try:
            st = api_vsp_run_status_v2_winlast_v6(rid)  # may exist in your codebase
            # if Flask Response, ignore; if dict, use
            if isinstance(st, dict):
                ci_dir = st.get("ci_run_dir") or ""
        except Exception:
            pass

        if not ci_dir:
            ci_dir = _vsp_guess_ci_dir(rid)

        items, fp, warn = _vsp_load_findings(ci_dir)
        flt = [it for it in items if _vsp_match(it, sev, tool, cwe, q, show_supp)]
        total = len(flt)
        page = flt[offset:offset+limit]

        return jsonify(ok=True, total=total, items_n=len(page), warning=(warn or None), file=(fp or None), items=page)
    except Exception as e:
        return jsonify(ok=False, total=None, items_n=None, warning=f"exception:{type(e).__name__}", file=None, items=None)




# === VSP_EXPORT_V3_FORCE_FS_V1 ===
@app.route("/api/vsp/run_export_v3/<rid>")
def api_vsp_run_export_v3_force_fs(rid):

    ### [COMMERCIAL] FORCEFS_PROBE_V1 ###
    if (request.args.get("probe") or "") == "1":
        resp = jsonify({"ok": True, "probe": "FORCEFS_PROBE_V1"})
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        resp.headers["X-VSP-EXPORT-MODE"] = "FORCEFS_PROBE_V1"
        return resp

    # ### [COMMERCIAL] FORCE_FS_EXPORT_V1C ### on-demand exporter (html/zip/pdf)
    fmt = (request.args.get("fmt") or "zip").lower()
    rid_norm = rid.replace("RUN_","") if isinstance(rid, str) else str(rid)

    run_dir = _find_run_dir_v1c(rid_norm)
    if not run_dir or (not os.path.isdir(run_dir)):
        resp = jsonify({"ok": False, "error": "run_dir_not_found", "rid_norm": rid_norm})
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        resp.headers["X-VSP-EXPORT-MODE"] = "FORCE_FS_V1C"
        return resp, 404

    report_dir = _ensure_report_v1c(run_dir)
    html_file = os.path.join(report_dir, "export_v3.html")

    if fmt == "html":
        resp = send_file(html_file, mimetype="text/html", as_attachment=True, download_name=f"{rid_norm}.html")
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        resp.headers["X-VSP-EXPORT-MODE"] = "FORCE_FS_V1C"
        return resp

    if fmt == "zip":
        z = _zip_report_v1c(report_dir)
        resp = send_file(z, mimetype="application/zip", as_attachment=True, download_name=f"{rid_norm}.zip")
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        resp.headers["X-VSP-EXPORT-MODE"] = "FORCE_FS_V1C"
        return resp

    if fmt == "pdf":
        pdf_path, err = _pdf_from_html_wk_v1c(html_file, timeout_sec=180)
        if pdf_path:
            resp = send_file(pdf_path, mimetype="application/pdf", as_attachment=True, download_name=f"{rid_norm}.pdf")
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            resp.headers["X-VSP-EXPORT-MODE"] = "FORCE_FS_V1C"
            return resp
        resp = jsonify({"ok": False, "error": "pdf_export_failed", "detail": err})
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        resp.headers["X-VSP-EXPORT-MODE"] = "FORCE_FS_V1C"
        return resp, 500

    resp = jsonify({"ok": False, "error": "bad_fmt", "fmt": fmt, "allowed": ["html","zip","pdf"]})
    resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
    resp.headers["X-VSP-EXPORT-MODE"] = "FORCE_FS_V1C"
    return resp, 400

def _vsp_gate_policy_find_run_dir(rid: str):
    # Reject path traversal
    if not rid or "/" in rid or ".." in rid:
        return None

    roots = []
    env_root = os.environ.get("VSP_OUT_CI_ROOT", "").strip()
    if env_root:
        roots.append(env_root)

    # common defaults in this project
    roots += [
        "/home/test/Data/SECURITY-10-10-v4/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/out",
    ]

    for r in roots:
        try:
            cand = os.path.join(r, rid)
            if os.path.isdir(cand):
                return cand
        except Exception:
            pass
    return None

def _vsp_gate_policy_load(run_dir: str):
    gp_path = os.path.join(run_dir, "gate_policy.json")
    gp = {}
    if os.path.isfile(gp_path):
        try:
            gp = json.load(open(gp_path, "r", encoding="utf-8"))
        except Exception:
            gp = {"_error": "gate_policy_json_parse_failed"}

    # degraded markers
    deg_dir = os.path.join(run_dir, "degraded")
    deg_items = []
    if os.path.isdir(deg_dir):
        try:
            for name in sorted(os.listdir(deg_dir)):
                fp = os.path.join(deg_dir, name)
                if os.path.isfile(fp):
                    deg_items.append(name)
        except Exception:
            pass

    verdict = gp.get("verdict") or gp.get("overall_verdict") or gp.get("status") or "UNKNOWN"
    reasons = gp.get("reasons") or gp.get("reason") or []
    if isinstance(reasons, str):
        reasons = [reasons]

    return {
        "verdict": verdict,
        "reasons": reasons,
        "degraded_n": len(deg_items),
        "degraded_items": deg_items,
        "raw": gp,
    }

@app.route("/api/vsp/gate_policy_v1/<rid>", methods=["GET"])
def api_vsp_gate_policy_v1(rid):
    run_dir = _vsp_gate_policy_find_run_dir(rid)
    if not run_dir:
        return jsonify({"ok": False, "error": "run_dir_not_found", "run_id": rid}), 404
    out = _vsp_gate_policy_load(run_dir)
    out.update({"ok": True, "run_id": rid, "ci_run_dir": run_dir})
    return jsonify(out)


if __name__ == '__main__':
    # VSP UI Gateway – default port 8910, có thể override bằng biến môi trường VSP_UI_PORT
    port = int(os.environ.get('VSP_UI_PORT', '8910'))
    # debug=False cho gần với bản thương mại; muốn xem log chi tiết thì đổi thành True
    app.run(host='0.0.0.0', port=port, debug=False)


# === VSP 2025 – SIMPLE RUN + DAST API STUB V1 ===
@app.route("/api/vsp/rule_overrides_ui_v1", methods=["POST"])
def api_vsp_rule_overrides_save():
    """
    Lưu rule overrides từ UI editor.
    Expect body: { "items": [ {id, tool, pattern, severity, scope, enabled, ...}, ... ] }
    """
    from flask import request, jsonify

    try:
        payload = request.get_json(force=True) or {}
    except Exception:
        return jsonify({"ok": False, "error": "Invalid JSON"}), 400

    items = payload.get("items")
    if not isinstance(items, list):
        return jsonify({"ok": False, "error": "Field 'items' must be list"}), 400

    # validate đơn giản
    for it in items:
        if not isinstance(it, dict):
            return jsonify({"ok": False, "error": "Each item must be object"}), 400
        if "id" not in it or "tool" not in it or "severity" not in it:
            return jsonify({"ok": False, "error": "Each item must have id/tool/severity"}), 400

    data = {"items": items}
    _save_rule_overrides(data)
    return jsonify({"ok": True, "items_count": len(items)})

# === VSP DAST STUB API – có thể nâng cấp sau ===
from flask import request, jsonify

@app.route("/api/vsp/dast/scan", methods=["POST"])
def api_vsp_dast_scan():
    """
    Stub DAST từ UI:
    Body:
    {
      "url": "https://example.com"
    }
    Hiện tại chỉ ghi lịch sử planned, chưa gọi Nessus/ZAP thật.
    """
    from flask import request, jsonify
    from pathlib import Path
    import json
    import datetime

    data = request.get_json(silent=True) or {}
    url = data.get("url") or ""

    root = Path(__file__).resolve().parents[1]
    hist_path = root / "out" / "dast_history.json"
    hist_path.parent.mkdir(parents=True, exist_ok=True)

    try:
        history = json.loads(hist_path.read_text(encoding="utf-8"))
        if not isinstance(history, list):
            history = []
    except Exception:
        history = []

    entry = {
        "url": url,
        "engine": "DAST_STUB_V1",
        "status": "PLANNED",
        "created_at": datetime.datetime.utcnow().isoformat() + "Z",
    }
    history.append(entry)
    hist_path.write_text(json.dumps(history, indent=2), encoding="utf-8")

    return jsonify({
        "ok": True,
        "implemented": False,
        "engine": "DAST_STUB_V1",
        "url": url,
        "status": "PLANNED"
    })
# === END API VSP DAST SCAN (CLEAN V1) ===

# === API VSP DAST HISTORY (CLEAN V1) ===
@app.route("/api/vsp/dast/history", methods=["GET"])
def api_vsp_dast_history():
    """
    Trả lại lịch sử DAST stub (dast_history.json)
    """
    from flask import jsonify
    from pathlib import Path
    import json

    root = Path(__file__).resolve().parents[1]
    hist_path = root / "out" / "dast_history.json"

    try:
        data = json.loads(hist_path.read_text(encoding="utf-8"))
        if not isinstance(data, list):
            data = []
    except Exception:
        data = []

    return jsonify({
        "ok": True,
        "items": data,
    })
# === END API VSP DAST HISTORY (CLEAN V1) ===

# === VSP RULE OVERRIDES SAVE API (CLEAN V1) ===
@app.route("/api/vsp/rule_overrides_save_v1", methods=["POST"])
def vsp_rule_overrides_save_v1():
    """
    Nhận JSON root object (đúng schema rule_overrides_ui_v1)
    Ghi xuống out/vsp_rule_overrides_v1.json (backup bản cũ nếu có).
    """
    from flask import request, jsonify
    from pathlib import Path
    import json

    data = request.get_json(silent=True)
    if not isinstance(data, dict):
        return jsonify({"ok": False, "error": "Root JSON phải là object."}), 400

    root = Path(__file__).resolve().parents[1]
    overrides_path = root / "out" / "vsp_rule_overrides_v1.json"
    overrides_path.parent.mkdir(parents=True, exist_ok=True)

    # Backup cũ
    if overrides_path.exists():
        backup = overrides_path.with_suffix(".json.bak_ui_save")
        try:
            overrides_path.replace(backup)
        except Exception:
            pass

    overrides_path.write_text(
        json.dumps(data, indent=2, ensure_ascii=False),
        encoding="utf-8",
    )

    return jsonify({"ok": True, "path": str(overrides_path)})
# === END VSP RULE OVERRIDES SAVE API (CLEAN V1) ===

# === VSP UI WHOAMI DEBUG V1 ===
def vsp_ui_whoami():
    """
    Endpoint debug để kiểm tra app nào đang chạy trên gateway 8910.
    """
    from flask import jsonify
    import os
    return jsonify({
        "ok": True,
        "app": "vsp_demo_app",
        "cwd": os.getcwd(),
        "file": __file__,
    })
# === END VSP UI WHOAMI DEBUG V1 ===


# === VSP UI WHOAMI DEBUG V1 ===




# === VSP_RUN_API_BLUEPRINT_V1 ===
try:
    from run_api.vsp_run_api_v1 import bp_vsp_run_api_v1
    bp_name = getattr(bp_vsp_run_api_v1, 'name', 'vsp_run_api_v1')
    if bp_name in getattr(app, 'blueprints', {}):
        print(f"[VSP_RUN_API] skip blueprint already registered: {bp_name}")
    else:
        bp_name = getattr(bp_vsp_run_api_v1, 'name', 'vsp_run_api_v1')
        if bp_name in getattr(app, 'blueprints', {}):
            print(f"[VSP_RUN_API] skip blueprint already registered: {bp_name}")
        else:
            app.register_blueprint(bp_vsp_run_api_v1)
            print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
        print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
    print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
except Exception as e:
    print("[VSP_RUN_API] ERR register blueprint:", repr(e))
# === END VSP_RUN_API_BLUEPRINT_V1 ===
# === VSP_RUN_V1_HEALMAP_WRAPPER_V16 ===
# Commercial contract:
# - /healthz must be 200
# - POST /api/vsp/run_v1 must ALWAYS return JSON
# - If underlying run_v1 returns None -> return HTTP 500 JSON (not Flask TypeError)
# - Do NOT do url_map surgery (only heal _rules_by_endpoint rebuild)

try:
    import os as _os
    import json as _json
    import functools as _functools
    from collections import defaultdict as _defaultdict
    from flask import request as _request, jsonify as _jsonify
except Exception:
    _request = None
    _jsonify = None

def _vsp_heal_url_map_v16():
    try:
        um = app.url_map
        rules = list(um.iter_rules())
        new = _defaultdict(list)
        for r in rules:
            new[r.endpoint].append(r)
        um._rules_by_endpoint = new
        print("[VSP_RUNV1_V16] healed url_map._rules_by_endpoint endpoints=", len(new))
        return True
    except Exception as e:
        print("[VSP_RUNV1_V16] heal failed:", repr(e))
        return False

def _vsp_defaults_v16(j: dict) -> dict:
    j = j if isinstance(j, dict) else {}
    j.setdefault("mode", _os.environ.get("VSP_DEFAULT_MODE", "local"))
    j.setdefault("profile", _os.environ.get("VSP_DEFAULT_PROFILE", "FULL_EXT"))
    j.setdefault("target_type", "path")
    j.setdefault("target", _os.environ.get("VSP_DEFAULT_TARGET", "/home/test/Data/SECURITY-10-10-v4"))
    return j

def _vsp_json_v16(obj, status_code=None):
    # If obj has http_code and caller didn't force status_code -> use it
    if status_code is None and isinstance(obj, dict):
        hc = obj.get("http_code")
        if isinstance(hc, int) and 100 <= hc <= 599:
            status_code = hc
    if _jsonify is None:
        return obj
    resp = _jsonify(obj)
    if status_code is not None:
        resp.status_code = int(status_code)
    return resp

def _vsp_fix_status_from_body_v16(resp):
    # === VSP_FIX_STATUS_REWRITE_CLEAN_CI_KICS_V1 ===
    try:
        import json as _json
        from pathlib import Path as _Path

        # Only touch JSON-like responses; if cannot parse -> return as-is.
        obj = None
        try:
            obj = resp.get_json(silent=True)
        except Exception:
            obj = None
        if not isinstance(obj, dict):
            try:
                raw = (resp.get_data(as_text=True) or "")
                raw_s = raw.lstrip()
                if raw_s.startswith("{"):
                    obj = _json.loads(raw)
            except Exception:
                obj = None
        if not isinstance(obj, dict):
            return resp

        # defaults (commercial contract)
        obj.setdefault("ci_run_dir", None)
        obj.setdefault("kics_verdict", "")
        obj.setdefault("kics_total", 0)
        obj.setdefault("kics_counts", {})

        # RID from request.path (v1/v2)
        rid = ""
        try:
            from flask import request as _req
            path = (_req.path or "")
            if path.startswith("/api/vsp/run_status_v2/") or path.startswith("/api/vsp/run_status_v1/"):
                rid = (path.rsplit("/", 1)[-1] or "").split("?", 1)[0].strip()
        except Exception:
            rid = ""

        rid_norm = rid[4:].strip() if rid.startswith("RUN_") else rid

        # Fill ci_run_dir if missing
        if (not (obj.get("ci_run_dir") or "").strip()) and rid_norm:
            try:
                ci = _vsp_guess_ci_run_dir_from_rid_v33(rid_norm)
                if ci:
                    obj["ci_run_dir"] = str(ci)
            except Exception:
                pass

        # Inject KICS summary
        ci_dir = (obj.get("ci_run_dir") or "").strip()
        if ci_dir:
            ks = _Path(ci_dir) / "kics" / "kics_summary.json"
            if ks.is_file():
                try:
                    jj = _json.loads(ks.read_text(encoding="utf-8", errors="ignore") or "{}")
                    if isinstance(jj, dict):
                        obj["kics_verdict"] = str(jj.get("verdict") or obj.get("kics_verdict") or "")
                        try:
                            obj["kics_total"] = int(jj.get("total") or obj.get("kics_total") or 0)
                        except Exception:
                            pass
                        cc = jj.get("counts")
                        if isinstance(cc, dict):
                            obj["kics_counts"] = cc
                except Exception:
                    pass

        # Fix http_code if present
        try:
            hc = obj.get("http_code")
            if isinstance(hc, int) and 400 <= hc <= 599:
                resp.status_code = hc
        except Exception:
            pass

        # Write back JSON to response
        try:
            resp.set_data(_json.dumps(obj, ensure_ascii=False))
            resp.mimetype = "application/json"
        except Exception:
            pass
        return resp
    except Exception:
        return resp
def _vsp_wrap_run_v1_v16():
    if _request is None:
        return 0
    _vsp_heal_url_map_v16()

    rules = [r for r in app.url_map.iter_rules()
             if r.rule == "/api/vsp/run_v1" and "POST" in (r.methods or set())]
    if not rules:
        print("[VSP_RUNV1_V16] no POST /api/vsp/run_v1 rule found")
        return 0

    n = 0
    for r in rules:
        ep = r.endpoint
        orig = app.view_functions.get(ep)
        if not orig:
            continue

        @_functools.wraps(orig)
        def _wrapped(*args, __orig=orig, __ep=ep, **kwargs):
            try:
                j = _request.get_json(silent=True)
                j = j if isinstance(j, dict) else {}
                j = _vsp_defaults_v16(j)

                # Force cached json so downstream sees defaults (Flask uses dict map)
                try:
                    _request._cached_json = {False: j, True: j}
                except Exception:
                    pass

                out = __orig(*args, **kwargs)

                # IMPORTANT: handle None (commercial-safe)
                if out is None:
                    return _vsp_json_v16({
                        "ok": False,
                        "error": "RUN_V1_RETURNED_NONE",
                        "http_code": 500,
                        "message": f"endpoint={__ep} returned None (missing return in vsp_run_api_v1.run_v1)"
                    }, 500)

                # Tuple returns
                if isinstance(out, tuple) and len(out) >= 2:
                    body, code = out[0], out[1]
                    if isinstance(body, (dict, list)):
                        return _vsp_fix_status_from_body_v16(_vsp_json_v16(body, int(code)))
                    return out

                # Dict/list -> JSON
                if isinstance(out, (dict, list)):
                    return _vsp_fix_status_from_body_v16(_vsp_json_v16(out, None))

                # Flask Response -> try fix status if body says http_code
                return _vsp_fix_status_from_body_v16(out)

            except Exception as e:
                return _vsp_json_v16({
                    "ok": False,
                    "error": "HTTP_500_INTERNAL",
                    "http_code": 500,
                    "message": str(e)
                }, 500)

        app.view_functions[ep] = _wrapped
        n += 1
        print("[VSP_RUNV1_V16] wrapped endpoint=", ep, "orig=", getattr(orig, "__name__", "<?>"))
    return n

# healthz contract
try:
    has_hz = any(getattr(r, "rule", None) == "/healthz" for r in app.url_map.iter_rules())
    if not has_hz:
        @app.route("/healthz", methods=["GET"])
        def _healthz_v16():
            return _vsp_json_v16({"ok": True, "service": "vsp-ui-8910"}, 200)
        print("[VSP_RUNV1_V16] installed /healthz")
except Exception as _e:
    print("[VSP_RUNV1_V16] healthz install failed:", repr(_e))

try:
    _n = _vsp_wrap_run_v1_v16()
    print("[VSP_RUNV1_V16] installed wrappers:", _n)
except Exception as _e:
    print("[VSP_RUNV1_V16] install exception:", repr(_e))
# === END VSP_RUN_V1_HEALMAP_WRAPPER_V16 ===


# === VSP_AFTER_REQUEST_INJECT_KICS_TAIL_V2 ===
def _vsp__inject_kics_tail_to_response(resp):
    try:
        from flask import request as _req
        import json as _json

        path = (_req.path or "")
        if not path.startswith("/api/vsp/run_status_v1/"):
            return resp

        # force allow body read/replace
        try:
            resp.direct_passthrough = False
        except Exception:
            pass

        raw = ""
        try:
            raw = resp.get_data(as_text=True) or ""
        except Exception:
            return resp

        if not raw.strip():
            return resp

        try:
            obj = _json.loads(raw)
        except Exception:
            return resp

        if not isinstance(obj, dict):
            return resp

        if "kics_tail" not in obj:
            ci = obj.get("ci_run_dir") or obj.get("ci_dir") or obj.get("ci_run") or ""
            kt = _vsp_kics_tail_from_ci(ci) if ci else ""
            obj["kics_tail"] = kt if isinstance(kt, str) else str(kt)
        else:
            kt = obj.get("kics_tail")
            if kt is None:
                obj["kics_tail"] = ""
            elif not isinstance(kt, str):
                obj["kics_tail"] = str(kt)

        obj.setdefault("_handler", "after_request_inject:/api/vsp/run_status_v1")

        resp.set_data(_json.dumps(obj, ensure_ascii=False))
        resp.mimetype = "application/json"
        try:
            resp.headers["X-VSP-KICS-TAIL"] = "1"
        except Exception:
            pass
        return resp
    except Exception:
        return resp

try:
    @app.after_request
    def __vsp_after_request_kics_tail_v2(resp):
        return _vsp__inject_kics_tail_to_response(resp)
except Exception:
    pass

try:
    @bp.after_request
    def __vsp_bp_after_request_kics_tail_v2(resp):
        return _vsp__inject_kics_tail_to_response(resp)
except Exception:
    pass
# === END VSP_AFTER_REQUEST_INJECT_KICS_TAIL_V2 ===


# === VSP_REGISTER_RESTORED_BLUEPRINTS_V1 ===
try:
    _bps = ["vsp_runs_fs_bp"]
    for _n in _bps:
        _bp = globals().get(_n, None)
        if _bp is None:
            continue
        # avoid double register
        try:
            _have = getattr(app, "blueprints", {})
            if _bp.name in _have:
                continue
        except Exception:
            pass
        try:
            app.register_blueprint(_bp)
        except Exception:
            pass
except Exception:
    pass
# === END VSP_REGISTER_RESTORED_BLUEPRINTS_V1 ===

# === VSP_RUNS_INDEX_V3_FS_RESOLVED_WINLAST_V1 ===
from flask import jsonify, request

def _vsp__call_runs_index_v3_fs_best_effort_v1():
    # Try to find an existing v3_fs handler (not resolved) in globals
    for name, fn in globals().items():
        if callable(fn) and ("runs_index_v3_fs" in name) and ("resolved" not in name):
            try:
                return fn()
            except TypeError:
                # some handlers might require args; skip
                continue
            except Exception:
                continue
    return None

def api_vsp_runs_index_v3_fs_resolved_winlast_v1():
    # Prefer existing v3_fs output; normalize items to list
    r = _vsp__call_runs_index_v3_fs_best_effort_v1()
    data = None
    code = 200
    try:
        if isinstance(r, tuple) and len(r) >= 1:
            resp0 = r[0]
            code = r[1] if len(r) > 1 and isinstance(r[1], int) else 200
            # Flask Response?
            if hasattr(resp0, "get_json"):
                data = resp0.get_json(silent=True)
            elif isinstance(resp0, dict):
                data = resp0
        elif hasattr(r, "get_json"):
            data = r.get_json(silent=True)
        elif isinstance(r, dict):
            data = r
    except Exception:
        data = None

    if not isinstance(data, dict):
        data = {"ok": True, "items": []}

    items = data.get("items", [])
    if items is None or not isinstance(items, list):
        data["items"] = []

    data.setdefault("ok", True)
    data.setdefault("source", "fallback_v3_fs")

    return jsonify(data), code

def _vsp__register_runs_index_v3_fs_resolved_winlast_v1(flask_app):
    if flask_app is None:
        return
    try:
        flask_app.add_url_rule(
            "/api/vsp/runs_index_v3_fs_resolved",
            endpoint="api_vsp_runs_index_v3_fs_resolved_winlast_v1",
            view_func=api_vsp_runs_index_v3_fs_resolved_winlast_v1,
            methods=["GET"],
        )
    except Exception as e:
        msg = str(e)
        if "already exists" in msg or "existing endpoint function" in msg:
            return

# === END VSP_RUNS_INDEX_V3_FS_RESOLVED_WINLAST_V1 ===

_vsp__register_runs_index_v3_fs_resolved_winlast_v1(app)

# === VSP_OVERRIDE_RUNS_INDEX_V3_FS_RESOLVED_WINLAST_V2 ===
from flask import jsonify, request
from pathlib import Path as _Path
import datetime as _dt

def _vsp__find_endpoint_by_rule(app, rule_path: str, method: str = "GET"):
    try:
        for r in app.url_map.iter_rules():
            if r.rule == rule_path and (method in (r.methods or set())):
                return r.endpoint
    except Exception:
        return None
    return None

def _vsp__resp_to_dict_v1(r):
    # r can be dict, Flask Response, or (Response/dict, status)
    try:
        if isinstance(r, tuple) and len(r) >= 1:
            r0 = r[0]
            if hasattr(r0, "get_json"):
                return r0.get_json(silent=True) or {}
            if isinstance(r0, dict):
                return r0
        if hasattr(r, "get_json"):
            return r.get_json(silent=True) or {}
        if isinstance(r, dict):
            return r
    except Exception:
        pass
    return {}

def api_vsp_runs_index_v3_fs_resolved_winlast_v2():
    # Proxy to /api/vsp/runs_index_v3_fs (which is known good), then normalize items=list.
    ep_fs = _vsp__find_endpoint_by_rule(app, "/api/vsp/runs_index_v3_fs", "GET")
    data = {}
    if ep_fs and ep_fs in app.view_functions:
        try:
            r = app.view_functions[ep_fs]()  # handler reads request.args itself
            data = _vsp__resp_to_dict_v1(r)
        except TypeError:
            # handler might require args; ignore
            data = {}
        except Exception:
            data = {}

    if not isinstance(data, dict) or not data:
        # fallback minimal listing (never return items=null)
        base = _Path("/home/test/Data/SECURITY-10-10-v4/out_ci")
        items = []
        try:
            for d in sorted(base.glob("VSP_CI_*"), reverse=True)[: int(request.args.get("limit", "50") or 50)]:
                ts = _dt.datetime.fromtimestamp(d.stat().st_mtime).strftime("%Y-%m-%dT%H:%M:%S")
                items.append({
                    "run_id": "RUN_" + d.name,
                    "created_at": ts,
                    "profile": "",
                    "target": "",
                    "has_findings": 0,
                    "total_findings": 0,
                    "totals": {},
                })
        except Exception:
            items = []
        data = {"ok": True, "items": items, "source": "fallback_fs_scan"}

    items = data.get("items", [])
    if items is None or not isinstance(items, list):
        data["items"] = []

    data["ok"] = True
    data.setdefault("source", "proxy_v3_fs")
    return jsonify(data), 200

def _vsp__override_rule_handler_v1(rule_path: str, method: str, new_fn):
    ep = _vsp__find_endpoint_by_rule(app, rule_path, method)
    if not ep:
        return False, None
    try:
        app.view_functions[ep] = new_fn
        return True, ep
    except Exception:
        return False, ep

_ok, _ep = _vsp__override_rule_handler_v1("/api/vsp/runs_index_v3_fs_resolved", "GET", api_vsp_runs_index_v3_fs_resolved_winlast_v2)
print("[WINLAST] override runs_index_v3_fs_resolved:", _ok, "endpoint=", _ep)
# === END VSP_OVERRIDE_RUNS_INDEX_V3_FS_RESOLVED_WINLAST_V2 ===

# === VSP_OVERRIDE_RUNS_INDEX_RESOLVED_BEFORE_REQUEST_WINLAST_V3 ===
from flask import jsonify, request
from pathlib import Path as _Path
import datetime as _dt

def _vsp__find_endpoint_by_rule_v3(rule_path: str, method: str = "GET"):
    try:
        for r in app.url_map.iter_rules():
            if r.rule == rule_path and (method in (r.methods or set())):
                return r.endpoint
    except Exception:
        return None
    return None

def _vsp__resp_to_dict_v3(r):
    try:
        if isinstance(r, tuple) and len(r) >= 1:
            r0 = r[0]
            if hasattr(r0, "get_json"):
                return r0.get_json(silent=True) or {}
            if isinstance(r0, dict):
                return r0
        if hasattr(r, "get_json"):
            return r.get_json(silent=True) or {}
        if isinstance(r, dict):
            return r
    except Exception:
        pass
    return {}

def api_vsp_runs_index_v3_fs_resolved_winlast_v3():
    # 1) Try proxy to v3_fs handler (known good)
    data = {}
    ep_fs = _vsp__find_endpoint_by_rule_v3("/api/vsp/runs_index_v3_fs", "GET")
    if ep_fs and ep_fs in app.view_functions:
        try:
            r = app.view_functions[ep_fs]()
            data = _vsp__resp_to_dict_v3(r)
        except Exception:
            data = {}

    # 2) If proxy failed, fallback to lightweight FS scan
    if not isinstance(data, dict) or not data:
        base = _Path("/home/test/Data/SECURITY-10-10-v4/out_ci")
        limit = int(request.args.get("limit", "50") or 50)
        items = []
        try:
            for d in sorted(base.glob("VSP_CI_*"), reverse=True)[:limit]:
                ts = _dt.datetime.fromtimestamp(d.stat().st_mtime).strftime("%Y-%m-%dT%H:%M:%S")
                items.append({
                    "run_id": "RUN_" + d.name,
                    "created_at": ts,
                    "profile": "",
                    "target": "",
                    "has_findings": 0,
                    "total_findings": 0,
                    "totals": {},
                })
        except Exception:
            items = []
        data = {"ok": True, "items": items, "source": "fallback_fs_scan"}

    # normalize contract
    items = data.get("items", [])
    if items is None or not isinstance(items, list):
        data["items"] = []
    data["ok"] = True
    data.setdefault("source", "winlast_v3")
    return jsonify(data), 200

_VSP_RUNS_RESOLVED_OVR_DONE_V3 = False

@app.before_request
def _vsp__winlast_override_runs_resolved_v3():
    # Run on demand: if request hits the resolved endpoint, override its endpoint handler for this request
    global _VSP_RUNS_RESOLVED_OVR_DONE_V3
    if request.path != "/api/vsp/runs_index_v3_fs_resolved":
        return None
    ep = getattr(request, "endpoint", None)
    if not ep:
        return None
    # force override every time (cheap + guarantees WIN-LAST)
    app.view_functions[ep] = api_vsp_runs_index_v3_fs_resolved_winlast_v3
    _VSP_RUNS_RESOLVED_OVR_DONE_V3 = True
    return None
# === END VSP_OVERRIDE_RUNS_INDEX_RESOLVED_BEFORE_REQUEST_WINLAST_V3 ===

# === VSP_RUNS_INDEX_RESOLVED_WSGI_WINLAST_V4 ===
import json as _json
from urllib.parse import parse_qs as _parse_qs
from datetime import datetime as _dt
from pathlib import Path as _Path

def _vsp__runs_index_resolved_build_items_v4(limit: int = 50):
    base = _Path("/home/test/Data/SECURITY-10-10-v4/out_ci")
    items = []
    try:
        dirs = sorted(base.glob("VSP_CI_*"), key=lambda x: x.stat().st_mtime, reverse=True)
        for d in dirs[: max(1, limit)]:
            ts = _dt.fromtimestamp(d.stat().st_mtime).strftime("%Y-%m-%dT%H:%M:%S")
            items.append({
                "run_id": "RUN_" + d.name,
                "created_at": ts,
                "profile": "",
                "target": "",
                "has_findings": 0,
                "total_findings": 0,
                "totals": {},
            })
    except Exception:
        items = []
    return items

class _VspWinLastRunsResolvedMiddlewareV4:
    def __init__(self, app_wsgi):
        self.app_wsgi = app_wsgi

    def __call__(self, environ, start_response):
        try:
            path = environ.get("PATH_INFO", "") or ""
            if path == "/api/vsp/runs_index_v3_fs_resolved":
                qs = environ.get("QUERY_STRING", "") or ""
                q = _parse_qs(qs)
                try:
                    limit = int((q.get("limit", ["50"]) or ["50"])[0] or 50)
                except Exception:
                    limit = 50
                data = {
                    "ok": True,
                    "items": _vsp__runs_index_resolved_build_items_v4(limit=limit),
                    "source": "wsgi_winlast_v4"
                }
                body = (_json.dumps(data, ensure_ascii=False) + "\n").encode("utf-8")
                headers = [
                    ("Content-Type", "application/json; charset=utf-8"),
                    ("Content-Length", str(len(body))),
                    ("Cache-Control", "no-store"),
                ]
                start_response("200 OK", headers)
                return [body]
        except Exception:
            pass
        return self.app_wsgi(environ, start_response)

# Install middleware (WIN-LAST)
try:
    app.wsgi_app = _VspWinLastRunsResolvedMiddlewareV4(app.wsgi_app)
except Exception:
    pass
# === END VSP_RUNS_INDEX_RESOLVED_WSGI_WINLAST_V4 ===

# === VSP_RUNS_INDEX_V3_FS_RESOLVED_V4_ENDPOINT ===
from flask import jsonify, request
from pathlib import Path as _Path
from datetime import datetime as _dt


# === VSP_STATUS_V2_INJECT_FIX_NO_CI_RUN_DIR_V1 ===
def _vsp_first_existing_json(paths):
    import json
    from pathlib import Path


# === VSP_RUN_STATUS_V2_POSTPROCESS_V1 ===
def _vsp_first_existing_json(paths):
    import json
    from pathlib import Path
    for pp in paths:
        try:
            fp = Path(pp)
            if fp.exists() and fp.is_file():
                return json.loads(fp.read_text(encoding="utf-8", errors="ignore")), str(fp)
        except Exception:
            continue
    return None, None

def _vsp_inject_tool_summary(resp, ci_dir, tool, summary_name):
    """
    Generic injector for tool summary into run_status_v2 payload.
    - Looks for:  <ci_dir>/<tool>/<summary_name>  OR <ci_dir>/<summary_name>
    - Injects:
        has_<tool> (bool)
        <tool>_verdict (str)
        <tool>_total (int)
        <tool>_counts (dict)
    """
    # === VSP_INJECT_TOOL_SUMMARY_GENERIC_V1 ===
    try:
        import os, json
        from pathlib import Path as _P
        if not isinstance(resp, dict):
            return resp
        ci = str(ci_dir or "")
        if not ci:
            return resp

        tool_key = str(tool or "").strip().lower()
        if not tool_key:
            return resp

        fp1 = _P(ci) / tool_key / str(summary_name)
        fp2 = _P(ci) / str(summary_name)
        fp = fp1 if fp1.exists() else fp2 if fp2.exists() else None
        if fp is None:
            # ensure contract keys exist even if missing
            resp.setdefault(f"has_{tool_key}", False)
            resp.setdefault(f"{tool_key}_verdict", "")
            resp.setdefault(f"{tool_key}_total", 0)
            resp.setdefault(f"{tool_key}_counts", {})
            return resp

        try:
            obj = json.loads(fp.read_text(encoding="utf-8", errors="ignore") or "{}")
        except Exception:
            obj = {}

        if isinstance(obj, dict):
            resp[f"has_{tool_key}"] = True
            resp[f"{tool_key}_verdict"] = str(obj.get("verdict") or "")
            try:
                resp[f"{tool_key}_total"] = int(obj.get("total") or 0)
            except Exception:
                resp[f"{tool_key}_total"] = 0
            cc = obj.get("counts")
            resp[f"{tool_key}_counts"] = cc if isinstance(cc, dict) else {}
        else:
            resp.setdefault(f"has_{tool_key}", False)
            resp.setdefault(f"{tool_key}_verdict", "")
            resp.setdefault(f"{tool_key}_total", 0)
            resp.setdefault(f"{tool_key}_counts", {})

        return resp
    except Exception:
        return resp

def _vsp_inject_run_gate(resp, ci_dir):
    if not isinstance(resp, dict) or not ci_dir:
        return resp
    data, used = _vsp_first_existing_json([f"{ci_dir}/run_gate_summary.json"])
    if not data:
        return resp
    resp["run_gate_summary"] = data
    resp["run_gate_summary_path"] = used
    resp["overall_verdict"] = data.get("overall")
    resp["overall_counts"] = data.get("counts_total")
    return resp

def _vsp_status_v2_postprocess(resp):
    """
    Commercial rule:
    - Always inject summaries if ci_run_dir exists.
    - If final==true and ci_run_dir exists: do NOT report ok=false/500 just because live progress/pid missing.
      Convert to ok=true with warnings so UI can render.
    """
    if not isinstance(resp, dict):
        return resp

    ci_dir = resp.get("ci_run_dir") or resp.get("ci_dir") or resp.get("run_dir")
    # inject P1 summaries
    try:
        resp = _vsp_inject_tool_summary(resp, ci_dir, "semgrep", "semgrep_summary.json")
        resp = _vsp_inject_tool_summary(resp, ci_dir, "trivy",   "trivy_summary.json")
        # === VSP_PREEMPT_INJECT_GITLEAKS_AFTER_TRIVY_ANYVAR_V1 ===
        try:
            if isinstance(resp, dict):
                # avoid nulls in contract
                if resp.get('overall_verdict', None) is None:
                    resp['overall_verdict'] = ''
                resp.setdefault('has_gitleaks', False)
                resp.setdefault('gitleaks_verdict', '')
                resp.setdefault('gitleaks_total', 0)
                resp.setdefault('gitleaks_counts', {})
        except Exception:
            pass
        resp = _vsp_inject_tool_summary(resp, ci_dir, 'gitleaks', 'gitleaks_summary.json')

        # === VSP_PREEMPT_GITLEAKS_AND_OVERALL_V2 ===
        # defaults for commercial contract (avoid nulls)
        resp.setdefault('overall_verdict','')
        resp.setdefault('has_gitleaks', False)
        resp.setdefault('gitleaks_verdict','')
        resp.setdefault('gitleaks_total', 0)
        resp.setdefault('gitleaks_counts', {})
        # inject gitleaks summary like semgrep/trivy
        resp = _vsp_inject_tool_summary(resp, ci_dir, 'gitleaks', 'gitleaks_summary.json')
        # pick overall from run_gate_summary.json if exists
        try:
            from pathlib import Path as _P
            _g = _vsp__read_json_if_exists_v2(_P(ci_dir) / 'run_gate_summary.json')
            if isinstance(_g, dict):
                resp['overall_verdict'] = str(_g.get('overall') or resp.get('overall_verdict') or '')
        except Exception:
            pass

        # === VSP_PREEMPT_ADD_GITLEAKS_TOOLSUMMARY_V1 ===
        resp = _vsp_inject_tool_summary(resp, ci_dir, "gitleaks", "gitleaks_summary.json")

        resp = _vsp_inject_run_gate(resp, ci_dir)
    except Exception:
        pass

    # normalize ok for final runs with artifacts
    try:
        if resp.get("final") is True and ci_dir:
            if resp.get("ok") is False:
                resp.setdefault("warnings", []).append({
                    "reason": "final_run_status_partial",
                    "prev_error": resp.get("error"),
                    "prev_http_code": resp.get("http_code"),
                })
                resp["ok"] = True
                resp["http_code"] = 200
                # keep status as ERROR if you want, but UI should use ok/overall_verdict
                resp["status"] = resp.get("status") or "FINAL"
    except Exception:
        pass

    return resp


    for pp in paths:
        try:
            fp = Path(pp)
            if fp.exists() and fp.is_file():
                return json.loads(fp.read_text(encoding="utf-8", errors="ignore")), str(fp)
        except Exception:
            continue
    return None, None

def _vsp_inject_tool_summary(resp, ci_dir, tool_key, summary_name):
    if not ci_dir:
        return
    data, used = _vsp_first_existing_json([
        f"{ci_dir}/{summary_name}",
        f"{ci_dir}/{tool_key}/{summary_name}",
    ])
    if not data:
        return
    resp[f"{tool_key}_summary"] = data
    resp[f"{tool_key}_verdict"] = data.get("verdict")
    resp[f"{tool_key}_total"] = data.get("total")
    resp[f"{tool_key}_counts"] = data.get("counts")
    resp[f"{tool_key}_summary_path"] = used

def _vsp_inject_run_gate(resp, ci_dir):
    if not ci_dir:
        return
    data, used = _vsp_first_existing_json([f"{ci_dir}/run_gate_summary.json"])
    if not data:
        return
    resp["run_gate_summary"] = data
    resp["run_gate_summary_path"] = used
    resp["overall_verdict"] = data.get("overall")
    resp["overall_counts"] = data.get("counts_total")



def api_vsp_runs_index_v3_fs_resolved_v4():
    base = _Path("/home/test/Data/SECURITY-10-10-v4/out_ci")
    try:
        limit = int(request.args.get("limit", "50") or 50)
    except Exception:
        limit = 50

    items = []
    try:
        dirs = sorted(base.glob("VSP_CI_*"), key=lambda x: x.stat().st_mtime, reverse=True)
        for d in dirs[: max(1, limit)]:
            ts = _dt.fromtimestamp(d.stat().st_mtime).strftime("%Y-%m-%dT%H:%M:%S")
            items.append({
                "run_id": "RUN_" + d.name,
                "created_at": ts,
                "profile": "",
                "target": "",
                "has_findings": 0,
                "total_findings": 0,
                "totals": {},
            })
    except Exception:
        items = []

    return jsonify({"ok": True, "items": items, "source": "resolved_v4_fs_scan"}), 200

try:
    app.add_url_rule(
        "/api/vsp/runs_index_v3_fs_resolved_v4",
        endpoint="api_vsp_runs_index_v3_fs_resolved_v4",
        view_func=api_vsp_runs_index_v3_fs_resolved_v4,
        methods=["GET"],
    )
except Exception:
    pass
# === END VSP_RUNS_INDEX_V3_FS_RESOLVED_V4_ENDPOINT ===





# === VSP_RUN_STATUS_V2_VIEW_WRAPPER_V3 ===
def _vsp_wrap_run_status_v2_endpoint(_app):
    import json
    # find endpoint by rule containing run_status_v2
    ep = None
    try:
        for r in _app.url_map.iter_rules():
            if "run_status_v2" in str(r.rule):
                ep = r.endpoint
                break
    except Exception:
        ep = None

    if not ep:
        return False, "endpoint_not_found"
    if ep not in _app.view_functions:
        return False, f"endpoint_missing_in_view_functions:{ep}"

    orig = _app.view_functions[ep]

    def wrapped(*a, **k):
        rv = orig(*a, **k)

        # normalize anything Flask can return -> Response
        try:
            resp_obj = _app.make_response(rv)
        except Exception:
            return rv

        # try parse JSON payload robustly
        data = None
        try:
            raw = resp_obj.get_data(as_text=True)
            raw = (raw or "").strip()
            if raw.startswith("{") and raw.endswith("}"):
                data = json.loads(raw)
        except Exception:
            data = None

        if isinstance(data, dict):
            # postprocess + inject summaries
            try:
                data2 = _vsp_status_v2_postprocess(data)
            except Exception:
                data2 = data

            # marker proves wrapper executed
            try:
                data2["_postprocess_v3"] = True
            except Exception:
                pass

            # IMPORTANT: if postprocess injected any gate/summary -> soften 500 to 200 for UI render
            try:
                ci_dir = data2.get("ci_run_dir") or data2.get("ci_dir") or data2.get("run_dir")
                has_any_gate = any(k in data2 for k in ("run_gate_summary","semgrep_summary","trivy_summary"))
                if ci_dir and has_any_gate and (data2.get("ok") is False or data2.get("http_code") == 500):
                    data2.setdefault("warnings", []).append({
                        "reason": "soften_http_500_when_gate_exists",
                        "prev_error": data2.get("error"),
                        "prev_http_code": data2.get("http_code"),
                    })
                    data2["ok"] = True
                    data2["http_code"] = 200
            except Exception:
                pass

            from flask import jsonify as _jsonify
            out = _jsonify(data2)

            # keep headers best-effort, but force JSON
            try:
                for hk, hv in resp_obj.headers.items():
                    if hk.lower() not in ("content-length", "content-type"):
                        out.headers[hk] = hv
            except Exception:
                pass

            # set status_code:
            # - prefer data2["http_code"] if present, else keep original
            try:
                out.status_code = int(data2.get("http_code") or resp_obj.status_code or 200)
            except Exception:
                out.status_code = resp_obj.status_code or 200

            return out

        # non-json body => return original response
        return resp_obj

    _app.view_functions[ep] = wrapped
    return True, ep

# run on import
try:
    _ok, _info = _vsp_wrap_run_status_v2_endpoint(app)
    print(f"[VSP_RUN_STATUS_V2_VIEW_WRAPPER_V3] ok={_ok} info={_info}")
except Exception as _e:
    print(f"[VSP_RUN_STATUS_V2_VIEW_WRAPPER_V3] failed: {_e}")




# === VSP_STATUS_V2_AFTER_REQUEST_INJECT_V1 ===
try:
    from flask import request as _vsp_req
    import json as _vsp_json
except Exception:
    _vsp_req = None
    _vsp_json = None

def _vsp_should_inject_status_v2():
    try:
        return _vsp_req is not None and (_vsp_req.path or "").startswith("/api/vsp/run_status_v2/")
    except Exception:
        return False

@app.after_request
def _vsp_after_request_inject_status_v2(resp):
    # only for run_status_v2
    if not _vsp_should_inject_status_v2():
        return resp

    if _vsp_json is None:
        return resp

    try:
        raw = resp.get_data(as_text=True)
        raw = (raw or "").strip()
        if not (raw.startswith("{") and raw.endswith("}")):
            return resp
        data = _vsp_json.loads(raw)
        if not isinstance(data, dict):
            return resp

        data2 = _vsp_status_v2_postprocess(data)

        # marker proves hook executed
        try:
            data2["_postprocess_after_v1"] = True
        except Exception:
            pass

        # soften: if gate/summary exists, don't let 500 block UI
        try:
            ci_dir = data2.get("ci_run_dir") or data2.get("ci_dir") or data2.get("run_dir")
            has_any = any(k in data2 for k in ("run_gate_summary","semgrep_summary","trivy_summary"))
            if ci_dir and has_any and (data2.get("ok") is False or int(data2.get("http_code") or 0) >= 500 or resp.status_code >= 500):
                data2.setdefault("warnings", []).append({
                    "reason": "soften_http_500_when_gate_exists_after_request",
                    "prev_error": data2.get("error"),
                    "prev_http_code": data2.get("http_code"),
                    "prev_status_code": resp.status_code,
                })
                data2["ok"] = True
                data2["http_code"] = 200
        except Exception:
            pass

        # rebuild response JSON but preserve headers best-effort
        new_body = _vsp_json.dumps(data2, ensure_ascii=False)
        resp.set_data(new_body)
        resp.headers["Content-Type"] = "application/json; charset=utf-8"
        try:
            resp.status_code = int(data2.get("http_code") or resp.status_code or 200)
        except Exception:
            pass
        return resp
    except Exception:
        return resp




# === VSP_RUN_STATUS_V2_FORCE_FINAL_FROM_ARTIFACTS_V1 ===
def _vsp_json_load(path):
    import json
    from pathlib import Path
    try:
        fp = Path(path)
        if fp.exists() and fp.is_file():
            return json.loads(fp.read_text(encoding="utf-8", errors="ignore"))
    except Exception:
        pass
    return None

def _vsp_pick_ci_dir_from_rid(rid: str):
    from pathlib import Path
    rid = (rid or "").strip()
    # normalize RUN_VSP_CI_YYYYmmdd_HHMMSS -> VSP_CI_YYYYmmdd_HHMMSS
    rid_norm = rid
    if rid_norm.startswith("RUN_VSP_CI_"):
        rid_norm = rid_norm.replace("RUN_VSP_CI_", "VSP_CI_", 1)
    if rid_norm.startswith("RUN_"):
        # common pattern
        rid_norm = rid_norm.replace("RUN_", "", 1)
    # if already VSP_CI_*
    base = Path("/home/test/Data/SECURITY-10-10-v4/out_ci")
    cand = base / rid_norm
    if cand.exists() and cand.is_dir():
        return str(cand), rid_norm
    # fallback: try direct rid
    cand2 = base / rid
    if cand2.exists() and cand2.is_dir():
        return str(cand2), rid
    return None, rid_norm

def _vsp_build_final_status_from_artifacts(rid: str):
    ci_dir, rid_norm = _vsp_pick_ci_dir_from_rid(rid)
    if not ci_dir:
        return {
            "ok": False,
            "http_code": 501,
            "status": "NOT_FOUND",
            "error": "CI_RUN_DIR_NOT_FOUND",
            "rid": rid,
            "rid_norm": rid_norm,
            "ci_run_dir": None,
            "final": True,
        }

    # load summaries
    kics = _vsp_json_load(f"{ci_dir}/kics_summary.json") or _vsp_json_load(f"{ci_dir}/kics/kics_summary.json")
    semg = _vsp_json_load(f"{ci_dir}/semgrep_summary.json") or _vsp_json_load(f"{ci_dir}/semgrep/semgrep_summary.json")
    triv = _vsp_json_load(f"{ci_dir}/trivy_summary.json") or _vsp_json_load(f"{ci_dir}/trivy/trivy_summary.json")
    gate = _vsp_json_load(f"{ci_dir}/run_gate_summary.json")

    degraded = _vsp_json_load(f"{ci_dir}/degraded_tools.json") or []
    if isinstance(degraded, dict):
        degraded = degraded.get("degraded_tools") or degraded.get("items") or []

    resp = {
        "ok": True,
        "http_code": 200,
        "status": "FINAL",
        "error": None,
        "rid": rid,
        "rid_norm": rid_norm,
        "ci_run_dir": ci_dir,
        "final": True,
        "progress_pct": 100,
        "stage_index": 0,
        "stage_total": 0,
        "stage_name": "FINAL",
        "stage_sig": "FINAL",
        "degraded_tools": degraded if isinstance(degraded, list) else [],
    }

    def inject(tool_key, data):
        if not isinstance(data, dict):
            return
        resp[f"{tool_key}_summary"] = data
        resp[f"{tool_key}_verdict"] = data.get("verdict")
        resp[f"{tool_key}_total"] = data.get("total")
        resp[f"{tool_key}_counts"] = data.get("counts")

    inject("kics", kics)
    inject("semgrep", semg)
    inject("trivy", triv)

    if isinstance(gate, dict):
        resp["run_gate_summary"] = gate
        resp["overall_verdict"] = gate.get("overall")
        resp["overall_counts"] = gate.get("counts_total")

    # marker
    resp["_postprocess_forcefinal_v1"] = True
    return resp

def _vsp_force_override_run_status_v2(_app):
    ep = None
    try:
        for r in _app.url_map.iter_rules():
            if "run_status_v2" in str(r.rule):
                ep = r.endpoint
                break
    except Exception:
        ep = None
    if not ep or ep not in _app.view_functions:
        return False, f"endpoint_not_found:{ep}"

    def fixed(req_id):
        # IMPORTANT: return dict, Flask will jsonify it
        return _vsp_build_final_status_from_artifacts(req_id)

    _app.view_functions[ep] = fixed
    return True, ep

try:
    _ok, _info = _vsp_force_override_run_status_v2(app)
    print(f"[VSP_RUN_STATUS_V2_FORCE_FINAL_FROM_ARTIFACTS_V1] ok={_ok} info={_info}")
except Exception as _e:
    print(f"[VSP_RUN_STATUS_V2_FORCE_FINAL_FROM_ARTIFACTS_V1] failed: {_e}")




# === VSP_RUN_STATUS_V2_PREEMPT_BEFORE_REQUEST_V1 ===
try:
    from flask import request as _vsp_req, jsonify as _vsp_jsonify
except Exception:
    _vsp_req = None
    _vsp_jsonify = None

@app.before_request
def _vsp_preempt_run_status_v2():
    # Hard commercial preempt: bypass legacy/wrappers, always serve FINAL-from-artifacts
    if _vsp_req is None or _vsp_jsonify is None:
        return None
    try:
        path = (_vsp_req.path or "")
        if not path.startswith("/api/vsp/run_status_v2/"):
            return None
        rid = path.split("/api/vsp/run_status_v2/", 1)[-1].strip("/")
        data = _vsp_build_final_status_from_artifacts(rid)
        # marker proves preempt executed
        try:
            data["_preempt_before_request_v1"] = True
        except Exception:
            pass
        resp = _vsp_jsonify(data)
        try:
            resp.status_code = int(data.get("http_code") or 200)
        except Exception:
            resp.status_code = 200
        return resp
    except Exception:
        return None




# === VSP_RUN_STATUS_V2_PREEMPT_FORCEFINAL_V2_BEGIN ===
def _vsp_json_load(path):
    import json
    from pathlib import Path
    try:
        fp = Path(path)
        if fp.exists() and fp.is_file():
            return json.loads(fp.read_text(encoding="utf-8", errors="ignore"))
    except Exception:
        pass
    return None

def _vsp_pick_ci_dir_from_rid(rid: str):
    from pathlib import Path
    rid = (rid or "").strip()
    rid_norm = rid
    if rid_norm.startswith("RUN_VSP_CI_"):
        rid_norm = rid_norm.replace("RUN_VSP_CI_", "VSP_CI_", 1)
    if rid_norm.startswith("RUN_"):
        rid_norm = rid_norm.replace("RUN_", "", 1)
    base = Path("/home/test/Data/SECURITY-10-10-v4/out_ci")
    cand = base / rid_norm
    if cand.exists() and cand.is_dir():
        return str(cand), rid_norm
    cand2 = base / rid
    if cand2.exists() and cand2.is_dir():
        return str(cand2), rid
    return None, rid_norm

def _vsp_build_final_status_from_artifacts_v2(rid: str):
    ci_dir, rid_norm = _vsp_pick_ci_dir_from_rid(rid)
    if not ci_dir:
        return {
            "ok": False, "http_code": 501, "status": "NOT_FOUND",
            "error": "CI_RUN_DIR_NOT_FOUND",
            "rid": rid, "rid_norm": rid_norm, "ci_run_dir": None,
            "final": True, "_preempt_forcefinal_v2": True,
        }

    kics = _vsp_json_load(f"{ci_dir}/kics_summary.json") or _vsp_json_load(f"{ci_dir}/kics/kics_summary.json")
    semg = _vsp_json_load(f"{ci_dir}/semgrep_summary.json") or _vsp_json_load(f"{ci_dir}/semgrep/semgrep_summary.json")
    triv = _vsp_json_load(f"{ci_dir}/trivy_summary.json") or _vsp_json_load(f"{ci_dir}/trivy/trivy_summary.json")
    gate = _vsp_json_load(f"{ci_dir}/run_gate_summary.json")
    degraded = _vsp_json_load(f"{ci_dir}/degraded_tools.json") or []
    if isinstance(degraded, dict):
        degraded = degraded.get("degraded_tools") or degraded.get("items") or []

    resp = {
        "ok": True, "http_code": 200, "status": "FINAL", "error": None,
        "rid": rid, "rid_norm": rid_norm, "ci_run_dir": ci_dir,
        "final": True,
        "progress_pct": 100, "stage_name": "FINAL", "stage_sig": "FINAL",
        "stage_index": 0, "stage_total": 0,
        "degraded_tools": degraded if isinstance(degraded, list) else [],
        "_preempt_forcefinal_v2": True,
    }

    def inject(tool_key, data):
        if not isinstance(data, dict):
            return
        resp[f"{tool_key}_summary"] = data
        resp[f"{tool_key}_verdict"] = data.get("verdict")
        resp[f"{tool_key}_total"] = data.get("total")
        resp[f"{tool_key}_counts"] = data.get("counts")

    inject("kics", kics)
    inject("semgrep", semg)
    inject("trivy", triv)

    if isinstance(gate, dict):
        resp["run_gate_summary"] = gate
        resp["overall_verdict"] = gate.get("overall")
        resp["overall_counts"] = gate.get("counts_total")

    return resp

try:
    from flask import request as _vsp_req, jsonify as _vsp_jsonify
except Exception:
    _vsp_req = None
    _vsp_jsonify = None

@app.before_request
def _vsp_preempt_run_status_v2_forcefinal_v2():
    # HARD preempt: if path matches, we return FINAL object (never null)
    if _vsp_req is None or _vsp_jsonify is None:
        return None
    try:
        path = (_vsp_req.path or "")
        if not path.startswith("/api/vsp/run_status_v2/"):
            return None
        rid = path.split("/api/vsp/run_status_v2/", 1)[-1].strip("/")
        data = _vsp_build_final_status_from_artifacts_v2(rid)

        # log to gunicorn stdout -> out_ci/ui_8910.log
        try:
            print(f"[PREEMPT_FORCEFINAL_V2] path={path} rid={rid} ok={data.get('ok')} http={data.get('http_code')} ci={data.get('ci_run_dir')}")
        except Exception:
            pass

        resp = _vsp_jsonify(data)
        try:
            resp.status_code = int(data.get("http_code") or 200)
        except Exception:
            resp.status_code = 200
        return resp
    except Exception as e:
        try:
            print(f"[PREEMPT_FORCEFINAL_V2] exception: {e}")
        except Exception:
            pass
        return None
# === VSP_RUN_STATUS_V2_PREEMPT_FORCEFINAL_V2_END ===




# === VSP_RUN_STATUS_V2_WSGI_PREEMPT_V1_BEGIN ===
def _vsp_json_load(path):
    import json
    from pathlib import Path
    try:
        fp = Path(path)
        if fp.exists() and fp.is_file():
            return json.loads(fp.read_text(encoding="utf-8", errors="ignore"))
    except Exception:
        pass
    return None

def _vsp_pick_ci_dir_from_rid(rid: str):
    from pathlib import Path
    rid = (rid or "").strip()
    rid_norm = rid
    if rid_norm.startswith("RUN_VSP_CI_"):
        rid_norm = rid_norm.replace("RUN_VSP_CI_", "VSP_CI_", 1)
    if rid_norm.startswith("RUN_"):
        rid_norm = rid_norm.replace("RUN_", "", 1)
    base = Path("/home/test/Data/SECURITY-10-10-v4/out_ci")
    cand = base / rid_norm
    if cand.exists() and cand.is_dir():
        return str(cand), rid_norm
    cand2 = base / rid
    if cand2.exists() and cand2.is_dir():
        return str(cand2), rid
    return None, rid_norm

def _vsp_build_final_status_from_artifacts_w1(rid: str):
    ci_dir, rid_norm = _vsp_pick_ci_dir_from_rid(rid)
    if not ci_dir:
        return {
            "ok": False, "http_code": 501, "status": "NOT_FOUND",
            "error": "CI_RUN_DIR_NOT_FOUND",
            "rid": rid, "rid_norm": rid_norm, "ci_run_dir": None,
            "final": True, "_wsgi_preempt_v1": True,
        }

    kics = _vsp_json_load(f"{ci_dir}/kics_summary.json") or _vsp_json_load(f"{ci_dir}/kics/kics_summary.json")
    semg = _vsp_json_load(f"{ci_dir}/semgrep_summary.json") or _vsp_json_load(f"{ci_dir}/semgrep/semgrep_summary.json")
    triv = _vsp_json_load(f"{ci_dir}/trivy_summary.json") or _vsp_json_load(f"{ci_dir}/trivy/trivy_summary.json")
    gate = _vsp_json_load(f"{ci_dir}/run_gate_summary.json")
    degraded = _vsp_json_load(f"{ci_dir}/degraded_tools.json") or []
    if isinstance(degraded, dict):
        degraded = degraded.get("degraded_tools") or degraded.get("items") or []

    resp = {
        "ok": True, "http_code": 200, "status": "FINAL", "error": None,
        "rid": rid, "rid_norm": rid_norm, "ci_run_dir": ci_dir,
        "final": True,
        "progress_pct": 100, "stage_name": "FINAL", "stage_sig": "FINAL",
        "stage_index": 0, "stage_total": 0,
        "degraded_tools": degraded if isinstance(degraded, list) else [],
        "_wsgi_preempt_v1": True,
    }

    def inject(tool_key, data):
        if not isinstance(data, dict):
            return
        resp[f"{tool_key}_summary"] = data
        resp[f"{tool_key}_verdict"] = data.get("verdict")
        resp[f"{tool_key}_total"] = data.get("total")
        resp[f"{tool_key}_counts"] = data.get("counts")

    inject("kics", kics)
    inject("semgrep", semg)
    inject("trivy", triv)

    if isinstance(gate, dict):
        resp["run_gate_summary"] = gate
        resp["overall_verdict"] = gate.get("overall")
        resp["overall_counts"] = gate.get("counts_total")

    return resp

class _VSPStatusV2PreemptMiddleware:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        try:
            path = (environ.get("PATH_INFO") or "")
            if path.startswith("/api/vsp/run_status_v2/"):
                rid = path.split("/api/vsp/run_status_v2/", 1)[-1].strip("/")
                data = _vsp_build_final_status_from_artifacts_w1(rid)

                import json
                body = json.dumps(data, ensure_ascii=False).encode("utf-8")
                code = int(data.get("http_code") or 200)
                status = f"{code} OK" if code < 400 else f"{code} ERROR"
                headers = [
                    ("Content-Type", "application/json; charset=utf-8"),
                    ("Content-Length", str(len(body))),
                    ("X-VSP-WSGI-PREEMPT", "1"),
                ]
                start_response(status, headers)
                return [body]
        except Exception:
            # if anything goes wrong, fall back to underlying app
            pass

        return self.app(environ, start_response)

# install middleware OUTERMOST
try:
    app.wsgi_app = _VSPStatusV2PreemptMiddleware(app.wsgi_app)
    print("[VSP_WSGI_PREEMPT_V1] installed")
    # install outermost bytes postprocess for statusv2 (gitleaks + gate)
    try:
        app.wsgi_app = _VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_GITLEAKS_V1(app.wsgi_app)
        print('[VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_GITLEAKS_V1] installed')
    except Exception as _e:
        print('[VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_GITLEAKS_V1][WARN] install failed:', _e)
except Exception as _e:
    print(f"[VSP_WSGI_PREEMPT_V1] failed: {_e}")
# === VSP_RUN_STATUS_V2_WSGI_PREEMPT_V1_END ===



# === VSP_REMOVE_GITLEAKS_OVERWRITE_V1 ===



# === VSP_WRAP_STATUS_BY_ENDPOINT_V1 ===
def _vsp__safe_json_from_response(ret):
    try:
        if hasattr(ret, "get_json"):
            data = ret.get_json(silent=True)
            if isinstance(data, dict):
                return data, True
    except Exception:
        pass
    if isinstance(ret, dict):
        return ret, False
    return None, False

def _vsp__pick_latest_ci_dir():
    import glob, os
    pats = [
        "/home/test/Data/SECURITY-10-10-v4/out_ci/VSP_CI_*",
        "/home/test/Data/*/out_ci/VSP_CI_*",
    ]
    cands = []
    for pat in pats:
        cands.extend(glob.glob(pat))
    cands = [c for c in cands if os.path.isdir(c)]
    cands.sort(reverse=True)
    return cands[0] if cands else ""

def _vsp__postprocess_status_v1(ret):
    import datetime, os, json
    from flask import request
    data, is_resp = _vsp__safe_json_from_response(ret)
    if not isinstance(data, dict):
        return ret

    # normalize empties
    data["stage_name"] = data.get("stage_name") or ""
    data["ci_run_dir"] = data.get("ci_run_dir") or ""
    if data.get("pct", None) is None:
        data["pct"] = None

    rid = ""
    try:
        rid = (request.path or "").rstrip("/").split("/")[-1]
    except Exception:
        rid = ""

    # resolve ci_run_dir if empty: fallback newest CI dir
    if not data["ci_run_dir"]:
        data["ci_run_dir"] = _vsp__pick_latest_ci_dir()

    # persist uireq state (commercial)
    try:
        base = os.path.join(os.path.dirname(__file__), "out_ci", "uireq_v1")
        os.makedirs(base, exist_ok=True)
        if rid:
            sp = os.path.join(base, f"{rid}.json")
            payload = dict(data)
            payload["req_id"] = rid
            payload["ts_persist"] = datetime.datetime.utcnow().isoformat() + "Z"
            open(sp, "w", encoding="utf-8").write(json.dumps(payload, ensure_ascii=False, indent=2))
    except Exception:
        pass

    if is_resp:
        try:
            from flask import jsonify
            return jsonify(data)
        except Exception:
            return ret
    return data

def _vsp__postprocess_status_v2(ret):
    import os, json
    data, is_resp = _vsp__safe_json_from_response(ret)
    if not isinstance(data, dict):
        return ret

    ci = data.get("ci_run_dir") or data.get("ci") or data.get("run_dir") or ""
    codeql_dir = os.path.join(ci, "codeql") if ci else ""
    summary = os.path.join(codeql_dir, "codeql_summary.json") if codeql_dir else ""

    data.setdefault("has_codeql", False)
    data.setdefault("codeql_verdict", None)
    data.setdefault("codeql_total", 0)

    try:
        if codeql_dir and os.path.isdir(codeql_dir):
            if os.path.isfile(summary):
                try:
                    j = json.load(open(summary, "r", encoding="utf-8"))
                except Exception:
                    j = {}
                data["has_codeql"] = True
                data["codeql_verdict"] = j.get("verdict") or j.get("overall_verdict") or "AMBER"
                try:
                    data["codeql_total"] = int(j.get("total") or 0)
                except Exception:
                    data["codeql_total"] = 0
            else:
                sarifs = [x for x in os.listdir(codeql_dir) if x.lower().endswith(".sarif")]
                if sarifs:
                    data["has_codeql"] = True
                    data["codeql_verdict"] = data.get("codeql_verdict") or "AMBER"
    except Exception:
        pass

    if is_resp:
        try:
            from flask import jsonify
            return jsonify(data)
        except Exception:
            return ret
    return data

def _vsp__install_status_wrappers(app):
    # Wrap actual endpoints by URL rule contains substr (no parsing return statement)
    try:
        from functools import wraps
        def wrap_rule(substr, post_fn):
            for r in list(app.url_map.iter_rules()):
                if substr in (r.rule or ""):
                    ep = r.endpoint
                    orig = app.view_functions.get(ep)
                    if not orig or getattr(orig, "_vsp_wrapped", False):
                        continue
                    @wraps(orig)
                    def wrapped(*a, __orig=orig, __post=post_fn, **kw):
                        ret = __orig(*a, **kw)
                        return __post(ret)
                    wrapped._vsp_wrapped = True
                    app.view_functions[ep] = wrapped
                    try:
                        print("[VSP_WRAP] wrapped", ep, r.rule)
                    except Exception:
                        pass
        wrap_rule("/api/vsp/run_status_v1", _vsp__postprocess_status_v1)
        wrap_rule("/api/vsp/run_status_v2", _vsp__postprocess_status_v2)
    except Exception as e:
        try:
            print("[VSP_WRAP][WARN]", e)
        except Exception:
            pass

try:
    # app object exists in module scope
    _vsp__install_status_wrappers(app)
except Exception:
    pass




# === VSP_FORCE_CODEQL_IN_STATUSV2_WRAPPER_V1 ===
def _vsp__postprocess_status_v2(ret):
    import os, json
    # ALWAYS convert to dict if possible
    data = None
    try:
        if hasattr(ret, "get_json"):
            data = ret.get_json(silent=True)
        elif isinstance(ret, dict):
            data = ret
    except Exception:
        data = None

    if not isinstance(data, dict):
        return ret

    # resolve ci dir from multiple possible keys
    ci = data.get("ci_run_dir") or data.get("ci") or data.get("run_dir") or data.get("ci_dir") or ""
    codeql_dir = os.path.join(ci, "codeql") if ci else ""
    summary = os.path.join(codeql_dir, "codeql_summary.json") if codeql_dir else ""

    # inject defaults (force keys exist)
    data["has_codeql"] = bool(data.get("has_codeql", False))
    data["codeql_verdict"] = data.get("codeql_verdict", None)
    data["codeql_total"] = int(data.get("codeql_total") or 0) if str(data.get("codeql_total") or "0").isdigit() else 0

    try:
        if codeql_dir and os.path.isdir(codeql_dir):
            if os.path.isfile(summary):
                try:
                    j = json.load(open(summary, "r", encoding="utf-8"))
                except Exception:
                    j = {}
                data["has_codeql"] = True
                data["codeql_verdict"] = j.get("verdict") or j.get("overall_verdict") or "AMBER"
                try:
                    data["codeql_total"] = int(j.get("total") or 0)
                except Exception:
                    data["codeql_total"] = 0
            else:
                sarifs = [x for x in os.listdir(codeql_dir) if x.lower().endswith(".sarif")]
                if sarifs:
                    data["has_codeql"] = True
                    data["codeql_verdict"] = data.get("codeql_verdict") or "AMBER"
                    data["codeql_total"] = data.get("codeql_total") or 0
    except Exception:
        pass

    # CRITICAL: always jsonify so wrapper output wins
    try:
        from flask import jsonify
        return jsonify(data)
    except Exception:
        return data




# === VSP_FORCE_WRAP_STATUSV2_CODEQL_LASTMILE_V1 ===
def _vsp__inject_codeql_fields(data: dict):
    import os, json
    ci = data.get("ci_run_dir") or data.get("ci") or data.get("run_dir") or data.get("ci_dir") or ""
    codeql_dir = os.path.join(ci, "codeql") if ci else ""
    summary = os.path.join(codeql_dir, "codeql_summary.json") if codeql_dir else ""

    # force keys exist (never null)
    data["has_codeql"] = bool(data.get("has_codeql") or False)
    data["codeql_verdict"] = data.get("codeql_verdict") or None
    try:
        data["codeql_total"] = int(data.get("codeql_total") or 0)
    except Exception:
        data["codeql_total"] = 0

    try:
        if codeql_dir and os.path.isdir(codeql_dir):
            if os.path.isfile(summary):
                try:
                    j = json.load(open(summary, "r", encoding="utf-8"))
                except Exception:
                    j = {}
                data["has_codeql"] = True
                data["codeql_verdict"] = j.get("verdict") or j.get("overall_verdict") or "AMBER"
                try:
                    data["codeql_total"] = int(j.get("total") or 0)
                except Exception:
                    data["codeql_total"] = 0
            else:
                sarifs = [x for x in os.listdir(codeql_dir) if x.lower().endswith(".sarif")]
                if sarifs:
                    data["has_codeql"] = True
                    data["codeql_verdict"] = data.get("codeql_verdict") or "AMBER"
    except Exception:
        pass
    return data

def _vsp__force_wrap_status_v2_endpoint():
    # Unconditional re-wrap status_v2 endpoint so our injector runs LAST.
    try:
        from functools import wraps
        from flask import jsonify
        for r in list(app.url_map.iter_rules()):
            if "/api/vsp/run_status_v2" in (r.rule or ""):
                ep = r.endpoint
                orig = app.view_functions.get(ep)
                if not orig:
                    continue

                @wraps(orig)
                def wrapped(*a, __orig=orig, **kw):
                    ret = __orig(*a, **kw)

                    # Get dict from Response/dict
                    data = None
                    try:
                        if hasattr(ret, "get_json"):
                            data = ret.get_json(silent=True)
                        elif isinstance(ret, dict):
                            data = ret
                    except Exception:
                        data = None

                    if not isinstance(data, dict):
                        return ret

                    data = _vsp__inject_codeql_fields(data)
                    return jsonify(data)

                app.view_functions[ep] = wrapped
                try:
                    print("[VSP_FORCE_WRAP_V2] wrapped", ep, r.rule)
                except Exception:
                    pass
    except Exception as e:
        try:
            print("[VSP_FORCE_WRAP_V2][WARN]", e)
        except Exception:
            pass

try:
    _vsp__force_wrap_status_v2_endpoint()
except Exception:
    pass




# === VSP_FORCE_WRAP_STATUSV2_CODEQL_LASTMILE_V2 ===
def _vsp__parse_json_any(ret):
    import json
    # 1) normal get_json
    try:
        if hasattr(ret, "get_json"):
            d = ret.get_json(silent=True)
            if isinstance(d, dict):
                return d
    except Exception:
        pass
    # 2) dict direct
    if isinstance(ret, dict):
        return ret
    # 3) parse bytes/text body even if content-type not json
    try:
        if hasattr(ret, "get_data"):
            s = ret.get_data(as_text=True)
            if isinstance(s, str) and s.strip().startswith("{"):
                d = json.loads(s)
                if isinstance(d, dict):
                    return d
    except Exception:
        pass
    return None

def _vsp__resolve_ci_dir_from_rid(rid: str):
    import glob, os
    rid2 = (rid or "").strip()
    if rid2.startswith("RUN_"):
        rid2 = rid2[4:]
    if not rid2:
        return ""
    pats = [
        f"/home/test/Data/SECURITY-10-10-v4/out_ci/{rid2}",
        f"/home/test/Data/SECURITY-10-10-v4/out_ci/{rid2}*",
        f"/home/test/Data/*/out_ci/{rid2}",
        f"/home/test/Data/*/out_ci/{rid2}*",
        f"/home/test/Data/*/out_ci/*{rid2}*",
    ]
    cands = []
    for pat in pats:
        cands.extend(glob.glob(pat))
    cands = [c for c in cands if os.path.isdir(c)]
    cands.sort(reverse=True)
    return cands[0] if cands else ""

def _vsp__inject_codeql(data: dict, rid: str):
    import os, json
    # ensure keys never null
    data["has_codeql"] = False
    data["codeql_verdict"] = "NOT_RUN"
    data["codeql_total"] = 0

    ci = data.get("ci_run_dir") or data.get("ci") or data.get("run_dir") or data.get("ci_dir") or ""
    if not ci:
        # try rid_norm if present
        rn = data.get("rid_norm") or ""
        if rn:
            ci = _vsp__resolve_ci_dir_from_rid(rn)
    if not ci:
        ci = _vsp__resolve_ci_dir_from_rid(rid)

    codeql_dir = os.path.join(ci, "codeql") if ci else ""
    summary = os.path.join(codeql_dir, "codeql_summary.json") if codeql_dir else ""

    try:
        if codeql_dir and os.path.isdir(codeql_dir):
            # treat as at least ran/exists
            data["has_codeql"] = True
            data["codeql_verdict"] = "AMBER"
            if os.path.isfile(summary):
                try:
                    j = json.load(open(summary, "r", encoding="utf-8"))
                except Exception:
                    j = {}
                data["has_codeql"] = True
                data["codeql_verdict"] = j.get("verdict") or j.get("overall_verdict") or "AMBER"
                try:
                    data["codeql_total"] = int(j.get("total") or 0)
                except Exception:
                    data["codeql_total"] = 0
            else:
                sarifs = [x for x in os.listdir(codeql_dir) if x.lower().endswith(".sarif")]
                if sarifs:
                    data["has_codeql"] = True
                    data["codeql_verdict"] = data.get("codeql_verdict") or "AMBER"
    except Exception:
        pass
    return data

def _vsp__force_wrap_status_v2_endpoint_v2():
    try:
        from functools import wraps
        from flask import jsonify, request
        for r in list(app.url_map.iter_rules()):
            if "/api/vsp/run_status_v2" in (r.rule or ""):
                ep = r.endpoint
                orig = app.view_functions.get(ep)
                if not orig:
                    continue

                @wraps(orig)
                def wrapped(*a, __orig=orig, **kw):
                    ret = __orig(*a, **kw)
                    data = _vsp__parse_json_any(ret)
                    if not isinstance(data, dict):
                        return ret
                    rid = ""
                    try:
                        rid = (request.path or "").rstrip("/").split("/")[-1]
                    except Exception:
                        rid = ""
                    data = _vsp__inject_codeql(data, rid)
                    return jsonify(data)

                app.view_functions[ep] = wrapped
                try:
                    print("[VSP_FORCE_WRAP_V2B] wrapped", ep, r.rule)
                except Exception:
                    pass
    except Exception as e:
        try:
            print("[VSP_FORCE_WRAP_V2B][WARN]", e)
        except Exception:
            pass

try:
    _vsp__force_wrap_status_v2_endpoint_v2()
except Exception:
    pass




# === VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_CODEQL_LAST_V1 ===
def _vsp__inject_codeql_fields_statusv2(data: dict):
    import os, json
    # force keys exist (never null)
    data["has_codeql"] = False if data.get("has_codeql") in (None, False, "null") else bool(data.get("has_codeql"))
    data["codeql_verdict"] = None if data.get("codeql_verdict") in ("null", "") else data.get("codeql_verdict")
    try:
        data["codeql_total"] = int(data.get("codeql_total") or 0)
    except Exception:
        data["codeql_total"] = 0

    ci = data.get("ci_run_dir") or data.get("ci") or data.get("run_dir") or ""
    codeql_dir = os.path.join(ci, "codeql") if ci else ""
    summary = os.path.join(codeql_dir, "codeql_summary.json") if codeql_dir else ""

    # 1) prefer real summary
    try:
        if summary and os.path.isfile(summary):
            try:
                j = json.load(open(summary, "r", encoding="utf-8"))
            except Exception:
                j = {}
            data["has_codeql"] = True
            data["codeql_verdict"] = j.get("verdict") or j.get("overall_verdict") or "AMBER"
            try:
                data["codeql_total"] = int(j.get("total") or 0)
            except Exception:
                data["codeql_total"] = 0
            return data
    except Exception:
        pass

    # 2) fallback from run_gate_summary.by_tool.CODEQL (you already have this in payload)
    try:
        rg = data.get("run_gate_summary") or {}
        bt = (rg.get("by_tool") or {})
        cq = bt.get("CODEQL") or bt.get("CodeQL") or {}
        if isinstance(cq, dict) and cq:
            data["has_codeql"] = True
            data["codeql_verdict"] = cq.get("verdict") or "AMBER"
            try:
                data["codeql_total"] = int(cq.get("total") or 0)
            except Exception:
                data["codeql_total"] = 0
            return data
    except Exception:
        pass

    # 3) fallback sarif presence
    try:
        if codeql_dir and os.path.isdir(codeql_dir):
            sarifs = [x for x in os.listdir(codeql_dir) if x.lower().endswith(".sarif")]
            if sarifs:
                data["has_codeql"] = True
                data["codeql_verdict"] = data.get("codeql_verdict") or "AMBER"
    except Exception:
        pass

    return data

def _vsp__wsgi_bytes_statusv2_codeql_last_v1(inner_app):
    import json
    def app(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_status_v2/"):
            return inner_app(environ, start_response)

        status_box = {"status": None, "headers": None}
        def _sr(status, headers, exc_info=None):
            status_box["status"] = status
            status_box["headers"] = list(headers or [])
            return start_response(status, headers, exc_info)

        resp_iter = inner_app(environ, _sr)
        try:
            body = b"".join(resp_iter)
        finally:
            try:
                if hasattr(resp_iter, "close"):
                    resp_iter.close()
            except Exception:
                pass

        # only attempt json object bodies
        try:
            txt = body.decode("utf-8", errors="ignore").strip()
            if not txt.startswith("{"):
                return [body]
            data = json.loads(txt)
            if not isinstance(data, dict):
                return [body]
        except Exception:
            return [body]

        try:
            data = _vsp__inject_codeql_fields_statusv2(data)
            out = json.dumps(data, ensure_ascii=False).encode("utf-8")
        except Exception:
            return [body]

        # fix Content-Length header (if present)
        try:
            hs = status_box.get("headers") or []
            new_h = []
            for (k, v) in hs:
                if str(k).lower() == "content-length":
                    continue
                new_h.append((k, v))
            new_h.append(("Content-Length", str(len(out))))
            # re-send headers with same status
            start_response(status_box.get("status") or "200 OK", new_h)
        except Exception:
            # if header rewrite fails, just return out
            pass

        return [out]
    return app

try:
    app.wsgi_app = _vsp__wsgi_bytes_statusv2_codeql_last_v1(app.wsgi_app)
    try:
        print("[VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_CODEQL_LAST_V1] installed")
    except Exception:
        pass
except Exception as e:
    try:
        print("[VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_CODEQL_LAST_V1][WARN]", e)
    except Exception:
        pass




# === VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_CODEQL_LAST_V2 ===
def _vsp__unwrap_one_wsgilayer(maybe_app):
    # Try to unwrap closures like our previous _vsp__wsgi_bytes_* wrapper.
    try:
        f = maybe_app.wsgi_app
        for _ in range(4):
            if not callable(f): break
            cl = getattr(f, "__closure__", None)
            if not cl: break
            inner = None
            for cell in cl:
                try:
                    v = cell.cell_contents
                except Exception:
                    continue
                # pick a callable that looks like wsgi(environ,start_response)
                if callable(v) and hasattr(v, "__code__") and v.__code__.co_argcount >= 2:
                    inner = v
                    break
            if inner is None: break
            # avoid infinite loop
            if inner is f: break
            f = inner
        maybe_app.wsgi_app = f
        try:
            print("[VSP_WSGI_UNWRAP] unwrapped to", getattr(f, "__name__", str(f)))
        except Exception:
            pass
        return True
    except Exception as e:
        try:
            print("[VSP_WSGI_UNWRAP][WARN]", e)
        except Exception:
            pass
        return False

def _vsp__inject_codeql_fields_statusv2_v2(data: dict):
    import os, json
    # force keys exist (never null)
    data["has_codeql"] = bool(data.get("has_codeql") or False)
    data["codeql_verdict"] = data.get("codeql_verdict") or None
    try:
        data["codeql_total"] = int(data.get("codeql_total") or 0)
    except Exception:
        data["codeql_total"] = 0

    ci = data.get("ci_run_dir") or data.get("ci") or data.get("run_dir") or ""
    codeql_dir = os.path.join(ci, "codeql") if ci else ""
    summary = os.path.join(codeql_dir, "codeql_summary.json") if codeql_dir else ""

    # 1) prefer real summary
    try:
        if summary and os.path.isfile(summary):
            try:
                j = json.load(open(summary, "r", encoding="utf-8"))
            except Exception:
                j = {}
            data["has_codeql"] = True
            data["codeql_verdict"] = j.get("verdict") or j.get("overall_verdict") or "AMBER"
            try:
                data["codeql_total"] = int(j.get("total") or 0)
            except Exception:
                data["codeql_total"] = 0
            return data
    except Exception:
        pass

    # 2) fallback from run_gate_summary.by_tool.CODEQL
    try:
        rg = data.get("run_gate_summary") or {}
        bt = (rg.get("by_tool") or {})
        cq = bt.get("CODEQL") or bt.get("CodeQL") or {}
        if isinstance(cq, dict) and cq:
            data["has_codeql"] = True
            data["codeql_verdict"] = cq.get("verdict") or "AMBER"
            try:
                data["codeql_total"] = int(cq.get("total") or 0)
            except Exception:
                data["codeql_total"] = 0
            return data
    except Exception:
        pass

    # 3) fallback sarif presence
    try:
        if codeql_dir and os.path.isdir(codeql_dir):
            sarifs = [x for x in os.listdir(codeql_dir) if x.lower().endswith(".sarif")]
            if sarifs:
                data["has_codeql"] = True
                data["codeql_verdict"] = data.get("codeql_verdict") or "AMBER"
    except Exception:
        pass

    return data

def _vsp__wsgi_bytes_statusv2_codeql_last_v2(inner_app):
    import json
    def app2(environ, start_response):
        path = (environ.get("PATH_INFO") or "")
        if not path.startswith("/api/vsp/run_status_v2/"):
            return inner_app(environ, start_response)

        captured = {"status": None, "headers": None}
        chunks = []

        def _sr_capture(status, headers, exc_info=None):
            captured["status"] = status
            captured["headers"] = list(headers or [])
            def _write(b):
                try:
                    if b:
                        chunks.append(b)
                except Exception:
                    pass
            return _write

        resp_iter = inner_app(environ, _sr_capture)
        try:
            for part in resp_iter:
                if part:
                    chunks.append(part)
        finally:
            try:
                if hasattr(resp_iter, "close"):
                    resp_iter.close()
            except Exception:
                pass

        body = b"".join(chunks)

        # only attempt rewrite for JSON object
        try:
            txt = body.decode("utf-8", errors="ignore").strip()
            if not txt.startswith("{"):
                # pass-through (but must call real start_response)
                start_response(captured["status"] or "200 OK", captured["headers"] or [])
                return [body]
            data = json.loads(txt)
            if not isinstance(data, dict):
                start_response(captured["status"] or "200 OK", captured["headers"] or [])
                return [body]
        except Exception:
            start_response(captured["status"] or "200 OK", captured["headers"] or [])
            return [body]

        try:
            data = _vsp__inject_codeql_fields_statusv2_v2(data)
            out = json.dumps(data, ensure_ascii=False).encode("utf-8")
        except Exception:
            start_response(captured["status"] or "200 OK", captured["headers"] or [])
            return [body]

        # rebuild headers, fix content-length
        hs = captured["headers"] or []
        new_h = []
        for (k, v) in hs:
            if str(k).lower() == "content-length":
                continue
            new_h.append((k, v))
        new_h.append(("Content-Length", str(len(out))))
        new_h.append(("X-VSP-WSGI-CODEQL", "1"))
        start_response(captured["status"] or "200 OK", new_h)
        return [out]
    return app2

try:
    # unwrap the buggy layer(s) we previously installed, then install fixed one
    _vsp__unwrap_one_wsgilayer(app)
    app.wsgi_app = _vsp__wsgi_bytes_statusv2_codeql_last_v2(app.wsgi_app)
    try:
        print("[VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_CODEQL_LAST_V2] installed")
    except Exception:
        pass
except Exception as e:
    try:
        print("[VSP_WSGI_BYTES_POSTPROCESS_STATUSV2_CODEQL_LAST_V2][WARN]", e)
    except Exception:
        pass




# === VSP_UI_4TABS_ROUTE_V1 ===
try:
    from flask import render_template
except Exception:
    render_template = None

@app.route("/vsp4")
def vsp_ui_4tabs_commercial_v1():
    if render_template is None:
        return "render_template missing", 500
    return render_template("vsp_4tabs_commercial_v1.html")



# === VSP_RUN_EXPORT_V3_GATEWAY_V1 ===
import os, glob
from flask import request, send_file

def _vsp__export_pick_run_dir(rid: str, ci: str|None):
    # prefer explicit ci_run_dir from UI (validated)
    if ci:
        ci = str(ci)
        # allow only under /home/test/Data and must contain "/out_ci/"
        if ci.startswith("/home/test/Data/") and "/out_ci/" in ci and os.path.isdir(ci):
            return ci
    # fallback: try locate by folder name under /home/test/Data/*/out_ci/<rid_norm>
    rid_norm = rid
    if rid_norm.startswith("RUN_"):
        rid_norm = rid_norm[4:]
    # rid_norm like VSP_CI_YYYY...
    targets = []
    for root in ["/home/test/Data"]:
        # shallow walk to avoid heavy
        for base in glob.glob(root+"/*/out_ci/"+rid_norm):
            if os.path.isdir(base):
                targets.append(base)
    if targets:
        targets.sort(key=lambda x: os.path.getmtime(x), reverse=True)
        return targets[0]
    return None

def _vsp__export_pick_file(run_dir: str, fmt: str):
    fmt = (fmt or "html").lower()
    # common candidates
    if fmt == "html":
        cands = [
            os.path.join(run_dir, "reports", "*.html"),
            os.path.join(run_dir, "report*.html"),
            os.path.join(run_dir, "*.html"),
        ]
    elif fmt == "pdf":
        # === VSP_EXPORT_PDF_NO404_PICKFILE_V2 ===
        # Commercial behavior:
        # - Never return 404 for pdf export
        # - If pdf exists => send newest + X-VSP-EXPORT-AVAILABLE: 1
        # - If not => 200 empty body + X-VSP-EXPORT-AVAILABLE: 0
        files = []
        globs = [
            os.path.join(run_dir, "report*.pdf"),
            os.path.join(run_dir, "reports", "report*.pdf"),
            os.path.join(run_dir, "*.pdf"),
            os.path.join(run_dir, "reports", "*.pdf"),
        ]
        for g in globs:
            try:
                files += glob.glob(g)
            except Exception:
                pass

        # de-dup + keep only real files
        try:
            files = sorted({f for f in files if isinstance(f, str) and os.path.isfile(f)})
        except Exception:
            files = [f for f in files if isinstance(f, str) and os.path.isfile(f)]

        if not files:
            # keep endpoint alive (commercial), but mark unavailable
            return ("", 200, {
                "X-VSP-EXPORT-AVAILABLE": "0",
                "Content-Type": "application/pdf",
            })

        # pick newest file
        try:
            pick = max(files, key=lambda x: os.path.getmtime(x))
        except Exception:
            pick = files[-1]

        rsp = send_file(
            pick,
            mimetype="application/pdf",
            as_attachment=True,
            download_name=os.path.basename(pick),
        )
        rsp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        return rsp

    if fmt == "pdf":  mt = "application/pdf"
    if fmt == "zip":  mt = "application/zip"
    return send_file(f, mimetype=mt, as_attachment=(fmt!="html"))


# === VSP_RULE_OVERRIDES_API_V1 ===
VSP_RULE_OVERRIDES_PATH = "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/vsp_rule_overrides_v1.json"

def _vsp_rule_overrides_default_v1():
    return {
        "ok": True,
        "version": 1,
        "updated_at": None,
        "rules": [],
        "note": "Commercial: rules apply on findings at read-time (Data Source / Reports).",
    }

def _vsp_rule_overrides_load_v1():
    try:
        import json, os
        if os.path.isfile(VSP_RULE_OVERRIDES_PATH):
            with open(VSP_RULE_OVERRIDES_PATH, "r", encoding="utf-8", errors="ignore") as f:
                d = json.load(f)
            if isinstance(d, dict) and "rules" in d:
                d.setdefault("ok", True)
                d.setdefault("version", 1)
                return d
    except Exception:
        pass
    return _vsp_rule_overrides_default_v1()

def _vsp_rule_overrides_save_v1(payload: dict):
    import json, os, datetime
    os.makedirs(os.path.dirname(VSP_RULE_OVERRIDES_PATH), exist_ok=True)
    payload = payload if isinstance(payload, dict) else _vsp_rule_overrides_default_v1()
    payload.setdefault("version", 1)
    payload["updated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    if "rules" not in payload or not isinstance(payload["rules"], list):
        payload["rules"] = []
    with open(VSP_RULE_OVERRIDES_PATH, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    return payload

@app.route("/api/vsp/rule_overrides_v1", methods=["GET","POST"])
def api_vsp_rule_overrides_v1():
    # GET: return current override file (or default)
    if request.method == "GET":
        d = _vsp_rule_overrides_load_v1()
        return jsonify(d)

    # POST: save new overrides
    try:
        payload = request.get_json(force=True, silent=True) or {}
    except Exception:
        payload = {}
    saved = _vsp_rule_overrides_save_v1(payload)
    saved["ok"] = True
    return jsonify(saved)
# --- end rule overrides ---




# === VSP_EXPORT_OVERRIDE_VIEWFUNC_V3 ===
import os, glob

def _vsp__get_flask_app():
    # support both naming styles
    a = globals().get("app", None)
    if a is not None and hasattr(a, "url_map") and hasattr(a, "view_functions"):
        return a
    a = globals().get("application", None)
    if a is not None and hasattr(a, "url_map") and hasattr(a, "view_functions"):
        return a
    return None

def _vsp_norm_rid(rid: str) -> str:
    rid = (rid or "").strip()
    return rid[4:] if rid.startswith("RUN_") else rid

def _vsp_ci_root() -> str:
    return os.environ.get("VSP_CI_OUT_ROOT") or "/home/test/Data/SECURITY-10-10-v4/out_ci"

def _vsp_resolve_ci_dir(rid: str) -> str:
    rn = _vsp_norm_rid(rid)
    base = _vsp_ci_root()
    cand = os.path.join(base, rn)
    if os.path.isdir(cand):
        return cand
    # fallback: substring match in latest dirs
    gl = sorted(glob.glob(os.path.join(base, "VSP_CI_*")), reverse=True)
    for d in gl:
        if rn in os.path.basename(d):
            return d
    return ""

def _pick_newest(patterns):
    best = ""
    best_m = -1.0
    for pat in patterns:
        for f in glob.glob(pat):
            try:
                m = os.path.getmtime(f)
            except Exception:
                continue
            if m > best_m:
                best_m = m
                best = f
    return best

def _pick_pdf(ci_dir: str) -> str:
    return _pick_newest([os.path.join(ci_dir, "reports", "*.pdf"), os.path.join(ci_dir, "*.pdf")])

def _pick_html(ci_dir: str) -> str:
    return _pick_newest([os.path.join(ci_dir, "reports", "*.html"), os.path.join(ci_dir, "*.html")])

def _pick_zip(ci_dir: str) -> str:
    return _pick_newest([os.path.join(ci_dir, "reports", "*.zip"), os.path.join(ci_dir, "*.zip")])

def _vsp_export_v3_override(**kwargs):
    from flask import request, jsonify, send_file
    # rid param name may vary (rid/run_id/...)
    rid = kwargs.get("rid") or kwargs.get("run_id")
    if not rid and kwargs:
        rid = list(kwargs.values())[0]

    fmt = (request.args.get("fmt") or "html").lower().strip()
    ci_dir = _vsp_resolve_ci_dir(rid or "")

    if not ci_dir:
        resp = jsonify({"ok": False, "http_code": 501, "error": "EXPORT_CI_DIR_NOT_FOUND", "rid": rid, "rid_norm": _vsp_norm_rid(rid or "")})
        resp.status_code = 404
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp

    if fmt == "pdf":
        f = _pick_pdf(ci_dir)
        if f and os.path.isfile(f):
            resp = send_file(f, mimetype="application/pdf", as_attachment=True, download_name=os.path.basename(f))
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            resp.headers["X-VSP-EXPORT-FILE"] = os.path.basename(f)
            return resp
        resp = jsonify({"ok": False, "http_code": 501, "error": "pdf_not_enabled", "ci_run_dir": ci_dir})
        resp.status_code = 501
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp

    if fmt == "zip":
        f = _pick_zip(ci_dir)
        if f and os.path.isfile(f):
            resp = send_file(f, mimetype="application/zip", as_attachment=True, download_name=os.path.basename(f))
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
            resp.headers["X-VSP-EXPORT-FILE"] = os.path.basename(f)
            return resp
        resp = jsonify({"ok": False, "http_code": 501, "error": "ZIP_NOT_FOUND", "ci_run_dir": ci_dir})
        resp.status_code = 404
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
        return resp

    # default html
    f = _pick_html(ci_dir)
    if f and os.path.isfile(f):
        resp = send_file(f, mimetype="text/html", as_attachment=True, download_name=os.path.basename(f))
        resp.headers["X-VSP-EXPORT-AVAILABLE"] = "1"
        resp.headers["X-VSP-EXPORT-FILE"] = os.path.basename(f)
        return resp
    resp = jsonify({"ok": False, "http_code": 501, "error": "HTML_NOT_FOUND", "ci_run_dir": ci_dir})
    resp.status_code = 404
    resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
    return resp

# bind override to the REAL endpoint for /api/vsp/run_export_v3/*
try:
    _a = _vsp__get_flask_app()
    _ep = None
    _rules = []
    if _a is not None:
        for _r in _a.url_map.iter_rules():
            if "/api/vsp/run_export_v3/" in (_r.rule or ""):
                _rules.append((_r.rule, _r.endpoint, sorted(list(_r.methods or []))))
        # pick the most relevant: has variable segment "<...>"
        for rule, ep, methods in _rules:
            if "<" in rule and "GET" in methods:
                _ep = ep
                break
        if not _ep and _rules:
            _ep = _rules[0][1]

    if _a is not None and _ep and _ep in _a.view_functions:
        _a.view_functions[_ep] = _vsp_export_v3_override
        print("[VSP_EXPORT_OVERRIDE_V3] bound endpoint=", _ep)
        print("[VSP_EXPORT_OVERRIDE_V3] candidates=", _rules[:5])
    else:
        print("[VSP_EXPORT_OVERRIDE_V3][WARN] app/endpoint not found; app=", type(_a), "ep=", _ep, "candidates=", _rules[:5])
except Exception as _e:
    try:
        print("[VSP_EXPORT_OVERRIDE_V3][ERR]", repr(_e))
    except Exception:
        pass




# === VSP_RULE_OVERRIDES_FULL_V1 ===
import os, json, fnmatch
from datetime import datetime, timezone
from flask import request, jsonify, send_from_directory

def _vsp_now_iso():
    return datetime.now(timezone.utc).isoformat()

def _vsp_rule_overrides_path():
    return os.environ.get("VSP_RULE_OVERRIDES_FILE") or "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/vsp_rule_overrides_v1.json"

def _vsp_load_overrides():
    path = _vsp_rule_overrides_path()
    try:
        with open(path, "r", encoding="utf-8") as f:
            obj = json.load(f)
    except Exception:
        obj = {"version": 1, "updated_at": None, "items": []}
    if not isinstance(obj, dict):
        obj = {"version": 1, "updated_at": None, "items": []}
    obj.setdefault("version", 1)
    obj.setdefault("updated_at", None)
    obj.setdefault("items", [])
    if not isinstance(obj["items"], list):
        obj["items"] = []
    return obj

def _vsp_atomic_write(path, obj):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)

def _norm_sev(s):
    if s is None: return "INFO"
    x = str(s).strip().upper()
    m = {
      "CRITICAL":"CRITICAL","HIGH":"HIGH","MEDIUM":"MEDIUM","LOW":"LOW","INFO":"INFO","TRACE":"TRACE",
      "WARN":"LOW","WARNING":"LOW","ERROR":"MEDIUM","ERR":"MEDIUM","NOTE":"INFO","UNKNOWN":"INFO","NONE":"INFO"
    }
    return m.get(x, "INFO")

def _match_one(f, m):
    # f: finding dict, m: match dict
    if not isinstance(m, dict): return False
    # exact fields
    for k in ("rule_id","tool","cwe"):
        if k in m and m[k]:
            if str(f.get(k,"")) != str(m[k]): return False
    # glob path
    pg = m.get("path_glob")
    if pg:
        path = f.get("path") or f.get("file") or f.get("filename") or ""
        if not fnmatch.fnmatch(path, pg): return False
    # substring message
    mc = m.get("message_contains")
    if mc:
        msg = f.get("message") or f.get("title") or ""
        if str(mc).lower() not in str(msg).lower(): return False
    return True

def _is_expired(expires_at: str|None):
    if not expires_at: return False
    try:
        # allow YYYY-MM-DD
        if len(expires_at) == 10:
            dt = datetime.fromisoformat(expires_at + "T00:00:00+00:00")
        else:
            dt = datetime.fromisoformat(expires_at.replace("Z","+00:00"))
        return datetime.now(timezone.utc) > dt
    except Exception:
        return False

def _apply_overrides(items, overrides, show_suppressed=False):
    applied = {"suppressed": 0, "downgraded": 0, "expired_skipped": 0}
    out = []
    for f in (items or []):
        if not isinstance(f, dict):
            out.append(f); continue
        # normalize severity first
        sev0 = f.get("severity") or f.get("severity_norm") or f.get("level")
        sevN = _norm_sev(sev0)
        f["severity_norm"] = sevN

        suppressed = False
        for r in overrides.get("items", []) or []:
            if not isinstance(r, dict): 
                continue
            if _is_expired(r.get("expires_at")):
                applied["expired_skipped"] += 1
                continue
            if not _match_one(f, r.get("match", {})):
                continue
            act = (r.get("action") or "").lower().strip()
            if act == "suppress":
                suppressed = True
                f["suppressed"] = True
                f["override_action"] = "suppress"
                f["override_justification"] = r.get("justification")
                f["override_id"] = r.get("id") or None
                applied["suppressed"] += 1
                break
            if act == "downgrade":
                newsev = _norm_sev(r.get("set_severity") or "INFO")
                if f.get("severity_norm") != newsev:
                    f["severity_orig"] = f.get("severity_norm")
                    f["severity_norm"] = newsev
                    f["override_action"] = "downgrade"
                    f["override_justification"] = r.get("justification")
                    f["override_id"] = r.get("id") or None
                    applied["downgraded"] += 1
                # do not break: allow later suppress to win (but if you want first-hit wins, break here)
        if suppressed and not show_suppressed:
            continue
        out.append(f)
    return out, applied

def _wrap_json_view(func):
    def _wrapped(*args, **kwargs):
        resp = func(*args, **kwargs)
        # resp may be (json, code) or Response
        try:
            from flask import Response
            if isinstance(resp, Response):
                if resp.mimetype != "application/json":
                    return resp
                data = resp.get_json(silent=True) or {}
                code = resp.status_code
            elif isinstance(resp, tuple):
                data = resp[0] if isinstance(resp[0], dict) else {}
                code = resp[1] if len(resp) > 1 and isinstance(resp[1], int) else 200
            elif isinstance(resp, dict):
                data = resp; code = 200
            else:
                return resp
        except Exception:
            return resp

        # apply only when findings list present
        overrides = _vsp_load_overrides()
        show_supp = (request.args.get("show_suppressed") or "0").strip() in ("1","true","yes","on")
        limit = request.args.get("limit")
        try:
            limit_n = int(limit) if limit else None
        except Exception:
            limit_n = None

        key = None
        if isinstance(data, dict):
            if isinstance(data.get("items"), list): key = "items"
            elif isinstance(data.get("findings"), list): key = "findings"
        if key:
            items = data.get(key) or []
            if limit_n is not None:
                items = items[:limit_n]
            new_items, applied = _apply_overrides(items, overrides, show_suppressed=show_supp)
            data[key] = new_items
            data["rule_overrides"] = {"updated_at": overrides.get("updated_at"), "applied": applied, "show_suppressed": show_supp}
            # recompute totals best-effort
            try:
                data["items_n"] = len(new_items)
            except Exception:
                pass
        return jsonify(data), code
    _wrapped.__name__ = getattr(func, "__name__", "wrapped_findings")
    return _wrapped

def _install_rule_overrides(appobj):
    # API
    @appobj.route("/api/vsp/rule_overrides_v1", methods=["GET"])
    def api_vsp_rule_overrides_get_v1():
        obj = _vsp_load_overrides()
        return jsonify(obj)

    @appobj.route("/api/vsp/rule_overrides_v1", methods=["POST"])
    def api_vsp_rule_overrides_post_v1():
        obj = request.get_json(silent=True) or {}
        if not isinstance(obj, dict):
            return jsonify({"ok": False, "error": "invalid_json"}), 400
        obj.setdefault("version", 1)
        obj.setdefault("items", [])
        if not isinstance(obj["items"], list):
            return jsonify({"ok": False, "error": "items_must_be_list"}), 400
        # minimal validation
        norm_items = []
        for it in obj["items"]:
            if not isinstance(it, dict): 
                continue
            match = it.get("match") or {}
            if not isinstance(match, dict): 
                match = {}
            action = (it.get("action") or "").lower().strip()
            if action not in ("suppress","downgrade"):
                continue
            just = (it.get("justification") or "").strip()
            if not just:
                continue
            nid = it.get("id") or f"ovr_{int(datetime.now(timezone.utc).timestamp()*1000)}"
            out = {
              "id": nid,
              "match": match,
              "action": action,
              "justification": just,
              "expires_at": it.get("expires_at") or None
            }
            if action == "downgrade":
                out["set_severity"] = _norm_sev(it.get("set_severity") or "INFO")
            norm_items.append(out)
        obj["items"] = norm_items
        obj["updated_at"] = _vsp_now_iso()

        path = _vsp_rule_overrides_path()
        try:
            _vsp_atomic_write(path, obj)
        except Exception as e:
            return jsonify({"ok": False, "error": "write_failed", "detail": str(e)}), 500
        return jsonify(obj)

    # UI page (standalone, doesn't break dashboard)
    @appobj.route("/vsp/rule_overrides", methods=["GET"])
    def vsp_rule_overrides_page_v1():
        # render template if exists, else return simple text
        try:
            from flask import render_template
            return render_template("vsp_rule_overrides_v1.html")
        except Exception:
            return "Rule Overrides UI missing template", 500

    # Wrap findings preview endpoints best-effort
    try:
        rules = list(appobj.url_map.iter_rules())
        cand = []
        for r in rules:
            rr = (r.rule or "")
            if rr.startswith("/api/vsp/") and "findings" in rr and ("GET" in (r.methods or set())):
                cand.append((rr, r.endpoint))
        for rr, ep in cand:
            if ep in appobj.view_functions:
                appobj.view_functions[ep] = _wrap_json_view(appobj.view_functions[ep])
        try:
            print("[VSP_RULE_OVERRIDES] wrapped_findings_endpoints=", [c[0] for c in cand][:10])
        except Exception:
            pass
    except Exception:
        pass

# install on existing flask app object
try:
    _a = globals().get("app") or globals().get("application")
    if _a is not None:
        _install_rule_overrides(_a)
        try:
            print("[VSP_RULE_OVERRIDES] installed api/ui/apply ok file=", _vsp_rule_overrides_path())
        except Exception:
            pass
except Exception as _e:
    try:
        print("[VSP_RULE_OVERRIDES][ERR]", str(_e))
    except Exception:
        pass


# === VSP COMMERCIAL: gate_policy_v2 (resolve ci_run_dir via uireq mapping / run_status_v2) ===
import glob
from flask import jsonify

def _vsp_try_resolve_run_dir_from_uireq(rid: str):
    # uireq_v1 persist location (per your commercial design)
    cand_dirs = [
        "out_ci/uireq_v1",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1_state",
    ]
    names = [
        f"{rid}.json",
        f"{rid}_state.json",
        f"{rid}.state.json",
    ]
    for d in cand_dirs:
        try:
            for nm in names:
                fp = os.path.join(d, nm)
                if os.path.isfile(fp):
                    try:
                        j = json.load(open(fp, "r", encoding="utf-8"))
                    except Exception:
                        continue
                    run_dir = j.get("ci_run_dir") or j.get("ci") or j.get("run_dir") or j.get("RUN_DIR")
                    if run_dir and os.path.isdir(str(run_dir)):
                        return str(run_dir)
        except Exception:
            pass

    # last fallback: glob (bounded)
    for d in cand_dirs:
        try:
            if not os.path.isdir(d):
                continue
            pats = [
                os.path.join(d, f"{rid}*.json"),
                os.path.join(d, f"*{rid}*.json"),
            ]
            hits = []
            for pat in pats:
                hits += glob.glob(pat)[:20]
            for fp in hits[:20]:
                try:
                    j = json.load(open(fp, "r", encoding="utf-8"))
                except Exception:
                    continue
                run_dir = j.get("ci_run_dir") or j.get("ci") or j.get("run_dir") or j.get("RUN_DIR")
                if run_dir and os.path.isdir(str(run_dir)):
                    return str(run_dir)
        except Exception:
            pass
    return None

def _vsp_try_resolve_run_dir_from_statusv2_http(rid: str):
    # safest fallback; ok in gunicorn multi-worker. If single worker, still usually fine.
    try:
        import urllib.request
        url = f"http://127.0.0.1:8910/api/vsp/run_status_v2/{rid}"
        with urllib.request.urlopen(url, timeout=2.5) as r:
            raw = r.read().decode("utf-8", "ignore")
        j = json.loads(raw)
        run_dir = j.get("ci_run_dir") or j.get("ci") or j.get("run_dir")
        if run_dir and os.path.isdir(str(run_dir)):
            return str(run_dir)
    except Exception:
        return None
    return None

@app.route("/api/vsp/gate_policy_v2/<rid>", methods=["GET"])
def api_vsp_gate_policy_v2(rid):
    # Reject traversal
    if not rid or "/" in rid or ".." in rid:
        return jsonify({"ok": False, "error": "bad_rid", "run_id": rid}), 400

    # 1) try mapping uireq
    run_dir = _vsp_try_resolve_run_dir_from_uireq(rid)

    # 2) try old heuristic (folder name)
    if not run_dir:
        run_dir = _vsp_gate_policy_find_run_dir(rid)

    # 3) fallback via run_status_v2
    if not run_dir:
        run_dir = _vsp_try_resolve_run_dir_from_statusv2_http(rid)

    if not run_dir:
        return jsonify({"ok": False, "error": "run_dir_not_found", "run_id": rid}), 404

    out = _vsp_gate_policy_load(run_dir)
    out.update({"ok": True, "run_id": rid, "ci_run_dir": run_dir, "_resolver": "v2"})
    return jsonify(out)


# === VSP_PDF_DISABLED_V1 (fallback route wrapper) ===
@app.after_request
def _vsp_disable_pdf_after_request(resp):
    try:
        from flask import request as _r
        if _r.path.startswith("/api/vsp/run_export_v3") and (_r.args.get("fmt","").lower() == "pdf"):
            resp.status_code = 501
            resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
    except Exception:
        pass
    return resp
# === /VSP_PDF_DISABLED_V1 ===


# === VSP_PDF_FORCE_501_V2 (commercial) ===
from flask import request as _vsp_req, jsonify as _vsp_jsonify

@app.before_request
def _vsp_block_pdf_export_v2():
    try:
        if _vsp_req.path.startswith("/api/vsp/run_export_v3/"):
            fmt = (_vsp_req.args.get("fmt") or "").lower()
            if fmt == "pdf":
                resp = _vsp_jsonify({
                    "ok": False,
                    "error": "pdf_not_enabled",
                    "message": "PDF export is disabled in this commercial build. Use fmt=html or fmt=zip."
                })
                resp.status_code = 501
                resp.headers["X-VSP-EXPORT-AVAILABLE"] = "0"
                return resp
    except Exception:
        return None
    return None
# === /VSP_PDF_FORCE_501_V2 ===


# === VSP_PDF_NF_TO_501_V1 ===


# === VSP_GATE_POLICY_V3_BATCH_V1 ===
import os, json, glob
from flask import request as _gp_req, jsonify as _gp_jsonify

def _gp_norm_verdict(v):
    if not v: return "UNKNOWN"
    v=str(v).upper()
    if v in ("GREEN","PASS","OK"): return "GREEN"
    if v in ("AMBER","WARN","WARNING"): return "AMBER"
    if v in ("RED","FAIL","FAILED","ERROR"): return "RED"
    return v

def _gp_load_json(path):
    try:
        with open(path,"r",encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None

def _gp_degraded(run_dir):
    dd=os.path.join(run_dir,"degraded")
    items=[]
    if os.path.isdir(dd):
        for fn in sorted(glob.glob(os.path.join(dd,"*.txt"))):
            items.append(os.path.basename(fn))
    return items

def _gp_pick_run_dir(rid, ci_run_dir=None):
    # deterministic if ci_run_dir provided
    if ci_run_dir and os.path.isdir(ci_run_dir):
        return ci_run_dir
    rid2 = rid[4:] if rid.startswith("RUN_") else rid
    # best-effort fallback (common roots)
    roots = [
        "/home/test/Data/SECURITY-10-10-v4/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/ui/out_ci",
        "/home/test/Data/SECURITY_BUNDLE/out",
    ]
    for root in roots:
        cand=os.path.join(root, rid2)
        if os.path.isdir(cand):
            return cand
    return None

def _gp_build(rid, ci_run_dir=None):
    run_dir=_gp_pick_run_dir(rid, ci_run_dir)
    resp={
        "ok": False,
        "run_id": rid,
        "ci_run_dir": run_dir,
        "verdict": "UNKNOWN",
        "reasons": [],
        "degraded_items": [],
        "degraded_n": 0,
        "source": None,
    }
    if not run_dir:
        resp["error"]="run_dir_not_found"
        return resp

    deg=_gp_degraded(run_dir)
    resp["degraded_items"]=deg
    resp["degraded_n"]=len(deg)

    gp_path=os.path.join(run_dir,"gate_policy.json")
    if os.path.isfile(gp_path):
        gp=_gp_load_json(gp_path) or {}
        resp["verdict"]=_gp_norm_verdict(gp.get("verdict") or gp.get("overall_verdict") or gp.get("overall") or "UNKNOWN")
        rs=gp.get("reasons") or []
        if isinstance(rs,str): rs=[rs]
        resp["reasons"]=rs if isinstance(rs,list) else []
        resp["ok"]=True
        resp["source"]="gate_policy.json"
        return resp

    # fallback: run_gate_summary.json (autogate) so UI still shows a badge
    rg_path=os.path.join(run_dir,"run_gate_summary.json")
    if os.path.isfile(rg_path):
        rg=_gp_load_json(rg_path) or {}
        resp["verdict"]=_gp_norm_verdict(rg.get("overall") or rg.get("overall_status") or rg.get("overall_verdict") or "UNKNOWN")
        resp["reasons"]=[f"fallback:run_gate_summary ({resp['verdict']})", "gate_policy.json missing"]
        resp["ok"]=True
        resp["source"]="run_gate_summary.json"
        return resp

    # --- VSP_GATE_POLICY_V3_LOG_FALLBACK_V2 ---
    # fallback: parse SUMMARY.txt / runner.log so UI always has a badge
    try:
        import re as _re
        def _read_txt(_p):
            try:
                with open(_p, "r", encoding="utf-8", errors="ignore") as _f:
                    return _f.read()
            except Exception:
                return ""

        summ = _read_txt(os.path.join(run_dir, "SUMMARY.txt"))
        rlog = _read_txt(os.path.join(run_dir, "runner.log"))

        # 1) Prefer SUMMARY.txt line: [GATE_POLICY] verdict=RED reasons=...
        mm = _re.search(r"\[GATE_POLICY\]\s+verdict=([A-Z]+)\s+reasons=([^\n]+)", summ)
        if mm:
            resp["verdict"] = _gp_norm_verdict(mm.group(1))
            resp["reasons"] = [mm.group(2).strip(), "fallback:SUMMARY.txt", "gate_policy.json missing"]
            resp["ok"] = True
            resp["source"] = "SUMMARY.txt"
            return resp

        # 2) Fallback runner.log: [RUN_GATE][OK] overall=RED ...
        mm = _re.search(r"\[RUN_GATE\]\[OK\]\s+overall=([A-Z]+)\b", rlog)
        if mm:
            resp["verdict"] = _gp_norm_verdict(mm.group(1))
            resp["reasons"] = [f"fallback:runner.log overall={resp['verdict']}", "gate_policy.json missing", "run_gate_summary.json missing"]
            resp["ok"] = True
            resp["source"] = "runner.log"
            return resp

    except Exception:
        pass

    resp["reasons"] = ["gate_policy.json missing", "run_gate_summary.json missing"]
    resp["ok"] = True
    resp["source"] = "none"
    return resp
# --- /VSP_GATE_POLICY_V3_LOG_FALLBACK_V2 ---

@app.get("/api/vsp/gate_policy_v3/<rid>")
def api_vsp_gate_policy_v3(rid):
    ci_run_dir=_gp_req.args.get("ci_run_dir")
    out=_gp_build(rid, ci_run_dir=ci_run_dir)
    return _gp_jsonify(out)

@app.post("/api/vsp/gate_policy_batch_v1")
def api_vsp_gate_policy_batch_v1():
    data=_gp_req.get_json(silent=True) or {}
    items=data.get("items") or []
    out=[]
    for it in items:
        rid=(it.get("rid") or it.get("run_id") or "").strip()
        if not rid:
            continue
        ci=it.get("ci_run_dir")
        out.append(_gp_build(rid, ci_run_dir=ci))
    return _gp_jsonify({"ok": True, "items_n": len(out), "items": out})
# === /VSP_GATE_POLICY_V3_BATCH_V1 ===


### [COMMERCIAL] FORCE_FS_EXPORT_V1C ###
def _nowz_v1c():
    return datetime.now(timezone.utc).isoformat(timespec="microseconds").replace("+00:00","Z")

def _find_run_dir_v1c(rid_norm: str):
    cands = []
    cands += glob.glob("/home/test/Data/SECURITY-*/out_ci/" + rid_norm)
    cands += glob.glob("/home/test/Data/*/out_ci/" + rid_norm)
    for x in cands:
        try:
            if os.path.isdir(x):
                return x
        except Exception:
            pass
    return None

def _ensure_report_v1c(run_dir: str):
    report_dir = os.path.join(run_dir, "report")
    os.makedirs(report_dir, exist_ok=True)

    src_json = os.path.join(run_dir, "findings_unified.json")
    dst_json = os.path.join(report_dir, "findings_unified.json")
    if os.path.isfile(src_json) and (not os.path.isfile(dst_json)):
        try:
            shutil.copy2(src_json, dst_json)
        except Exception:
            pass

    dst_csv = os.path.join(report_dir, "findings_unified.csv")
    if (not os.path.isfile(dst_csv)) and os.path.isfile(dst_json):
        cols = ["tool","severity","title","file","line","cwe","fingerprint"]
        try:
            data = json.load(open(dst_json, "r", encoding="utf-8"))
            items = data.get("items") or []
            with open(dst_csv, "w", encoding="utf-8", newline="") as f:
                w = csv.DictWriter(f, fieldnames=cols)
                w.writeheader()
                for it in items:
                    cwe = it.get("cwe")
                    if isinstance(cwe, list):
                        cwe = ",".join(cwe)
                    w.writerow({
                        "tool": it.get("tool"),
                        "severity": (it.get("severity_norm") or it.get("severity")),
                        "title": it.get("title"),
                        "file": it.get("file"),
                        "line": it.get("line"),
                        "cwe": cwe,
                        "fingerprint": it.get("fingerprint"),
                    })
        except Exception:
            pass

    html_path = os.path.join(report_dir, "export_v3.html")
    if not (os.path.isfile(html_path) and os.path.getsize(html_path) > 0):
        total = 0
        sev_counts = {}
        try:
            if os.path.isfile(dst_json):
                d = json.load(open(dst_json, "r", encoding="utf-8"))
                items = d.get("items") or []
                total = len(items)
                for it in items:
                    sev = (it.get("severity_norm") or it.get("severity") or "INFO").upper()
                    sev_counts[sev] = sev_counts.get(sev, 0) + 1
        except Exception:
            pass

        def rows(d):
            if not d:
                return "<tr><td colspan='2'>(none)</td></tr>"
            out = []
            for k,v in sorted(d.items(), key=lambda kv:(-kv[1],kv[0])):
                out.append(f"<tr><td>{k}</td><td>{v}</td></tr>")
            return "\n".join(out)

        html = "<!doctype html><html><head><meta charset='utf-8'/>" \
               "<title>VSP Export</title>" \
               "<style>body{font-family:Arial;padding:24px} table{border-collapse:collapse;width:100%}" \
               "td,th{border:1px solid #eee;padding:6px 8px}</style></head><body>" \
               f"<h2>VSP Export v3</h2><p>Generated at: {_nowz_v1c()}</p><p><b>Total findings:</b> {total}</p>" \
               "<h3>By severity</h3><table><tr><th>Severity</th><th>Count</th></tr>" + rows(sev_counts) + "</table>" \
               "</body></html>"
        try:
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(html)
        except Exception:
            pass

    return report_dir

def _zip_report_v1c(report_dir: str):
    tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".zip", delete=False)
    tmp.close()
    with zipfile.ZipFile(tmp.name, "w", compression=zipfile.ZIP_DEFLATED) as z:
        for root, _, files in os.walk(report_dir):
            for fn in files:
                ap = os.path.join(root, fn)
                rel = os.path.relpath(ap, report_dir)
                z.write(ap, arcname=rel)
    return tmp.name

def _pdf_from_html_wk_v1c(html_file: str, timeout_sec: int = 180):
    exe = shutil.which("wkhtmltopdf")
    if not exe:
        return None, "wkhtmltopdf_missing"
    tmp = tempfile.NamedTemporaryFile(prefix="vsp_export_", suffix=".pdf", delete=False)
    tmp.close()
    try:
        subprocess.run([exe, "--quiet", html_file, tmp.name], timeout=timeout_sec, check=True)
        if os.path.isfile(tmp.name) and os.path.getsize(tmp.name) > 0:
            return tmp.name, None
        return None, "wkhtmltopdf_empty_output"
    except Exception as ex:
        return None, "wkhtmltopdf_failed:" + type(ex).__name__

