from __future__ import annotations
import json
import os
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime

from flask import Flask, render_template, send_file, abort, request

BASE_DIR = Path(__file__).resolve().parent.parent  # .../SECURITY_BUNDLE
OUT_DIR = BASE_DIR / "out"
UI_DIR = BASE_DIR / "ui"
TOOL_CONFIG_PATH = UI_DIR / "tool_config.json"
DASHBOARD_STATE_PATH = UI_DIR / "dashboard_state.json"

app = Flask(__name__)


def get_run_dirs() -> List[Path]:
    if not OUT_DIR.is_dir():
        return []
    dirs = [p for p in OUT_DIR.iterdir() if p.is_dir() and p.name.startswith("RUN_")]
    dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return dirs


def load_summary_for_run(run_dir: Path) -> Dict[str, Any]:
    summary_candidates = [
        run_dir / "summary_unified.json",
        run_dir / "summary.json",
        run_dir / "SUMMARY.json",
        run_dir / "SUMMARY.txt",
        run_dir / "summary" / "summary_unified.json",
        run_dir / "summary" / "summary.json",
        run_dir / "summary" / "SUMMARY.json",
        run_dir / "summary" / "SUMMARY.txt",
    ]

    for p in summary_candidates:
        if p.is_file():
            try:
                if p.suffix.lower() == ".txt":
                    return {
                        "source": str(p.relative_to(run_dir)),
                        "raw_text": p.read_text(encoding="utf-8", errors="ignore"),
                    }
                data = json.loads(p.read_text(encoding="utf-8"))
                if isinstance(data, dict):
                    data.setdefault("source", str(p.relative_to(run_dir)))
                return data
            except Exception as e:
                return {
                    "error": f"Error reading {p.name}: {e}",
                    "source": str(p.relative_to(run_dir)),
                }

    findings_candidates = [
        run_dir / "findings_unified.json",
        run_dir / "findings.json",
        run_dir / "summary" / "findings_unified.json",
        run_dir / "summary" / "findings.json",
    ]

    for p in findings_candidates:
        if not p.is_file():
            continue
        try:
            raw = json.loads(p.read_text(encoding="utf-8"))
            if isinstance(raw, dict) and "findings" in raw:
                items = raw["findings"]
            else:
                items = raw

            sev_counts: Dict[str, int] = {}
            tool_counts: Dict[str, int] = {}

            if isinstance(items, list):
                for f in items:
                    if not isinstance(f, dict):
                        continue
                    sev = (
                        str(
                            f.get("severity")
                            or f.get("level")
                            or f.get("severity_label")
                            or ""
                        )
                        .upper()
                        .strip()
                    )
                    if sev:
                        sev_counts[sev] = sev_counts.get(sev, 0) + 1

                    tool = (
                        f.get("tool")
                        or f.get("source")
                        or f.get("engine")
                        or f.get("scanner")
                    )
                    if tool:
                        tool = str(tool)
                        tool_counts[tool] = tool_counts.get(tool, 0) + 1

            total = sum(sev_counts.values()) if sev_counts else None

            return {
                "source": str(p.relative_to(run_dir)),
                "total_findings": total,
                "by_severity": sev_counts,
                "by_tool": tool_counts,
                "note": "Summary auto-built from findings file because no explicit summary_* file was found.",
            }
        except Exception as e:
            return {
                "error": f"Error building summary from {p.name}: {e}",
                "source": str(p.relative_to(run_dir)),
            }

    return {}


def extract_severity(summary: Dict[str, Any]) -> Dict[str, int]:
    if not isinstance(summary, dict):
        return {}
    for key in ("by_severity", "severity_count", "severity"):
        val = summary.get(key)
        if isinstance(val, dict):
            return {
                str(k): int(v)
                for k, v in val.items()
                if isinstance(v, (int, float))
            }
    return {}


def extract_tools(summary: Dict[str, Any]) -> Dict[str, int]:
    if not isinstance(summary, dict):
        return {}
    for key in ("by_tool", "tool_count", "tools"):
        val = summary.get(key)
        if isinstance(val, dict):
            return {
                str(k): int(v)
                for k, v in val.items()
                if isinstance(v, (int, float))
            }
    return {}


def extract_total(summary: Dict[str, Any]) -> Optional[int]:
    if not isinstance(summary, dict):
        return None
    for key in ("total_findings", "total", "count", "total_issues"):
        v = summary.get(key)
        if isinstance(v, (int, float)):
            return int(v)
    sev = extract_severity(summary)
    if sev:
        return sum(sev.values())
    return None


def load_tool_config() -> Any:
    if TOOL_CONFIG_PATH.is_file():
        try:
            return json.loads(TOOL_CONFIG_PATH.read_text(encoding="utf-8"))
        except Exception as e:
            return {"error": f"Error reading tool_config.json: {e}"}
    return {"info": "tool_config.json not found in ui/."}


def load_dashboard_state() -> Dict[str, Any]:
    if DASHBOARD_STATE_PATH.is_file():
        try:
            return json.loads(DASHBOARD_STATE_PATH.read_text(encoding="utf-8"))
        except Exception:
            return {}
    return {}


def save_dashboard_state(state: Dict[str, Any]) -> None:
    try:
        DASHBOARD_STATE_PATH.write_text(
            json.dumps(state, ensure_ascii=False, indent=2),
            encoding="utf-8",
        )
    except Exception:
        pass


def get_latest_run_with_summary() -> (Optional[Path], Dict[str, Any]):
    for rd in get_run_dirs():
        s = load_summary_for_run(rd)
        if s:  # có gì đó (summary/findings) thì dùng
            return rd, s
    return None, {}


@app.route("/")
def index():
    # Dashboard main: latest RUN_* summary_unified.json + findings.json
    import json
    from pathlib import Path

    root = Path(__file__).resolve().parent.parent  # /home/test/Data/SECURITY_BUNDLE
    out_dir = root / "out"

    run_dirs = sorted(
        [p for p in out_dir.glob("RUN_*") if p.is_dir() and not p.name.startswith("RUN_DEMO_")],
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )

    summary = {
        "run_id": None,
        "src": "",
        "total": 0,
        "critical": 0,
        "high": 0,
        "medium": 0,
        "low": 0,
        "info": 0,
        "tools": [],
        "critical_pct": 0,
        "high_pct": 0,
        "medium_pct": 0,
        "low_pct": 0,
        "info_pct": 0,
    }

    trend = []
    top_risks = []

    def parse_summary(path, run_name):
        try:
            raw = json.loads(path.read_text(encoding="utf-8"))
        except Exception as e:
            print(f"[ERR][INDEX] cannot read {path}: {e}")
            return None

        total = (
            raw.get("total_findings")
            or raw.get("TOTAL_FINDINGS")
            or raw.get("total")
            or raw.get("total_findings_all")
            or 0
        )

        sev_raw = (
            raw.get("severity_counts")
            or raw.get("SEVERITY_COUNTS")
            or raw.get("by_severity")
            or raw.get("severity")
            or {}
        )
        sev = {str(k).upper(): int(v) for k, v in sev_raw.items()}

        return {
            "run_id": run_name,
            "src": raw.get("src") or raw.get("SRC") or "",
            "total": int(total),
            "critical": sev.get("CRITICAL", 0),
            "high": sev.get("HIGH", 0),
            "medium": sev.get("MEDIUM", 0),
            "low": sev.get("LOW", 0),
            "info": sev.get("INFO", 0),
        }

    if run_dirs:
        # latest run
        run_dir = run_dirs[0]
        report_dir = run_dir / "report"
        summary_path = report_dir / "summary_unified.json"
        findings_path = report_dir / "findings.json"

        parsed = parse_summary(summary_path, run_dir.name)
        if parsed:
            summary.update(parsed)

        # percentages for severity bar chart
        max_bucket = max(
            summary["critical"],
            summary["high"],
            summary["medium"],
            summary["low"],
            summary["info"],
            1,
        )
        if max_bucket > 0:
            summary["critical_pct"] = int(summary["critical"] * 100 / max_bucket)
            summary["high_pct"] = int(summary["high"] * 100 / max_bucket)
            summary["medium_pct"] = int(summary["medium"] * 100 / max_bucket)
            summary["low_pct"] = int(summary["low"] * 100 / max_bucket)
            summary["info_pct"] = int(summary["info"] * 100 / max_bucket)

        # per-tool counts
        try:
            raw2 = json.loads(summary_path.read_text(encoding="utf-8"))
        except Exception:
            raw2 = {}
        tools_raw = raw2.get("by_tool") or raw2.get("BY_TOOL") or raw2.get("tools") or {}
        tools = []
        for name, counts in tools_raw.items():
            if isinstance(counts, dict):
                count_val = int(counts.get("count", 0))
            else:
                try:
                    count_val = int(counts)
                except Exception:
                    count_val = 0
            tools.append({"name": name, "count": count_val})
        summary["tools"] = tools

        # Trend – last runs (up to 6)
        for rd in run_dirs[:6]:
            sp = rd / "report" / "summary_unified.json"
            if not sp.is_file():
                continue
            parsed_trend = parse_summary(sp, rd.name)
            if parsed_trend:
                trend.append(parsed_trend)

        # Top risk findings from findings.json
        try:
            raw_findings = json.loads(findings_path.read_text(encoding="utf-8"))
            if isinstance(raw_findings, dict) and "items" in raw_findings:
                items = raw_findings.get("items") or []
            elif isinstance(raw_findings, list):
                items = raw_findings
            else:
                items = []
        except Exception as e:
            print(f"[WARN][INDEX] cannot read findings from {findings_path}: {e}")
            items = []

        def pick(d, keys, default=""):
            for k in keys:
                if k in d and d[k]:
                    return d[k]
            return default

        severity_order = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1, "INFO": 0}

        for it in items:
            if not isinstance(it, dict):
                continue
            sev_raw_item = str(pick(it, ["severity_norm", "SEVERITY", "severity"], "INFO")).upper()
            sev_rank = severity_order.get(sev_raw_item, 0)
            rule_id = pick(it, ["rule_id", "id", "check_id", "rule", "type"], "")
            tool = pick(it, ["tool", "source", "scanner"], "")
            msg = pick(it, ["message_short", "message", "msg", "description", "detail"], "")
            path_val = pick(it, ["file", "path", "target", "location"], "")
            line_val = pick(it, ["line", "line_number", "start_line"], "")

            top_risks.append(
                {
                    "severity": sev_raw_item,
                    "severity_rank": sev_rank,
                    "rule_id": rule_id,
                    "tool": tool,
                    "msg": msg,
                    "path": path_val,
                    "line": line_val,
                }
            )

        top_risks.sort(key=lambda x: (x["severity_rank"], x["rule_id"]), reverse=True)
        top_risks = top_risks[:10]

    print(
        f"[INFO][INDEX] RUN={summary['run_id']}, total={summary['total']}, "
        f"C={summary['critical']}, H={summary['high']}, "
        f"M={summary['medium']}, L={summary['low']}"
    )

    return render_template("index.html", summary=summary, trend=trend, top_risks=top_risks)



@app.route("/run/<run_id>")
def run_detail(run_id: str):
    run_dir = OUT_DIR / run_id
    if not run_dir.is_dir():
        abort(404, description=f"Run directory not found: {run_id}")

    summary = load_summary_for_run(run_dir)
    sev = extract_severity(summary)
    tools = extract_tools(summary)
    total = extract_total(summary)

    reports = []
    report_dir = run_dir / "report"
    if report_dir.is_dir():
        for fname, label in [
            ("security_resilient.html", "Security Resilient"),
            ("pm_style_report.html", "PM-style (HTML)"),
            ("pm_style_report_print.html", "PM-style (Print/PDF)"),
            ("simple_report.html", "Checkmarx-style (simple_report)"),
        ]:
            p = report_dir / fname
            if p.is_file():
                reports.append({"name": fname, "label": label})

    return render_template(
        "run_detail.html",
        run_id=run_id,
        summary=summary,
        sev=sev,
        tools=tools,
        total=total,
        reports=reports,
    )


@app.route("/report/<run_id>/<report_name>")
def serve_report(run_id: str, report_name: str):
    run_dir = OUT_DIR / run_id
    report_dir = run_dir / "report"
    file_path = report_dir / report_name

    if not report_dir.is_dir() or not file_path.is_file():
        abort(404, description=f"Report not found: {run_id}/{report_name}")

    return send_file(file_path)


@app.route("/settings")
def settings():
    cfg = load_tool_config()
    return render_template("settings_v2.html", tool_config=cfg)


@app.route("/datasource")
def datasource():
    return render_template(
        "datasource.html",
        out_dir=str(OUT_DIR),
        ui_dir=str(UI_DIR),
    )


@app.route("/run_scan", methods=["POST"])
def run_scan():
    data = request.get_json(silent=True) or {}
    src_folder = (data.get("src_folder") or "").strip()
    profile = (data.get("profile") or "").strip()
    mode = (data.get("mode") or "").strip()
    target_url = (data.get("target_url") or "").strip()

    if not src_folder:
        return {"ok": False, "error": "SRC folder trống."}, 400

    src_path = Path(src_folder).expanduser()
    if not src_path.is_dir():
        return {"ok": False, "error": f"SRC folder không tồn tại: {src_path}"}, 400

    script = BASE_DIR / "bin" / "run_security_bundle_real.sh"
    if not script.is_file():
        return {"ok": False, "error": f"Không tìm thấy script: {script}"}, 500

    # Lưu cấu hình Dashboard để lần sau load lại (TARGET/SRC/PROFILE/MODE)
    save_dashboard_state(
        {
            "src_folder": str(src_path),
            "profile": profile,
            "mode": mode,
            "target_url": target_url,
        }
    )

    try:
        env = os.environ.copy()
        env["SB_PROFILE"] = profile
        env["SB_MODE"] = mode
        env["SB_TARGET_URL"] = target_url

        subprocess.Popen(
            [str(script), str(src_path)],
            cwd=str(BASE_DIR),
            env=env,
        )
    except Exception as e:
        return {"ok": False, "error": f"Không chạy được script: {e}"}, 500

    return {"ok": True, "message": f"Đã start scan với SRC={src_path}"}


@app.route("/api/tool_config/save", methods=["POST"])
def api_save_tool_config():
    data = request.get_json(silent=True)
    if not isinstance(data, list):
        return {"ok": False, "error": "Payload phải là list các tool."}, 400

    try:
        TOOL_CONFIG_PATH.write_text(
            json.dumps(data, ensure_ascii=False, indent=2),
            encoding="utf-8",
        )
    except Exception as e:
        return {"ok": False, "error": f"Không ghi được tool_config.json: {e}"}, 500

    return {"ok": True, "message": "Đã lưu tool_config.json thành công."}



@app.route('/pm_report/<run_id>/<fmt>')
def pm_style_report_v2(run_id, fmt):
    """Serve PM-style HTML/PDF report cho một RUN_*"""
    import os
    from flask import abort, send_file

    # /home/test/Data/SECURITY_BUNDLE/ui/app.py
    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    run_dir = os.path.join(base_dir, 'out', run_id, 'report')

    if not os.path.isdir(run_dir):
        abort(404)

    if fmt == 'html':
        candidates = ['pm_style_report.html', 'pm_style_report_print.html']
    elif fmt == 'pdf':
        candidates = ['pm_style_report.pdf', 'pm_style_report_print.pdf']
    else:
        abort(404)

    for name in candidates:
        p = os.path.join(run_dir, name)
        if os.path.exists(p):
            return send_file(p)

    abort(404)

@app.route("/data-source")
def data_source():
    """Trang Data Source – cho biết SECURITY_BUNDLE đang đọc dữ liệu từ đâu."""
    from pathlib import Path
    import os
    import re

    root = Path("/home/test/Data/SECURITY_BUNDLE")
    out_dir = root / "out"

    runs = []
    run_path_map = {}

    if out_dir.is_dir():
        for p in sorted(out_dir.iterdir(), key=lambda p: p.name):
            if p.is_dir() and p.name.startswith("RUN_"):
                rid = p.name
                runs.append(rid)
                run_path_map[rid] = p

    has_data = bool(runs)

    real_runs = [r for r in runs if re.match(r"^RUN_[0-9]{8}_[0-9]{6}$", r)]

    def has_unified(rid):
        rp = run_path_map[rid]
        candidates = [
            rp / "report" / "findings_unified.json",
            rp / "report" / "findings_unified_all_tools.json",
            rp / "findings_unified.json",
            rp / "findings_unified_all_tools.json",
        ]
        return any(c.is_file() for c in candidates)

    candidates = [r for r in real_runs if has_unified(r)] or real_runs or runs

    last_run_id = candidates[-1] if candidates else None
    last_run_path = run_path_map[last_run_id] if last_run_id else None

    files = []
    tool_dirs = []

    def add_file(label, rel_path):
        if not last_run_path:
            return
        p = last_run_path / rel_path
        exists = p.is_file()
        size = p.stat().st_size if exists else 0
        files.append(
            {
                "label": label,
                "rel": rel_path,
                "path": str(p),
                "exists": exists,
                "size": size,
            }
        )

    if last_run_path:
        add_file("Unified findings (findings_unified.json)", "report/findings_unified.json")
        add_file("Unified findings – all tools", "report/findings_unified_all_tools.json")
        add_file("Summary unified (summary_unified.json)", "report/summary_unified.json")
        add_file("PM-style HTML report", "report/pm_style_report.html")
        add_file("PM-style HTML (print)", "report/pm_style_report_print.html")
        add_file("PM-style PDF", "report/pm_style_report_print.pdf")
        add_file("Simple HTML report", "report/simple_report.html")
        add_file("Checkmarx-like HTML report", "report/checkmarx_like.html")

        for sub in sorted(last_run_path.iterdir(), key=lambda p: p.name):
            if not sub.is_dir():
                continue
            if sub.name.lower() == "report":
                continue
            file_count = 0
            for _root, _dirs, fns in os.walk(sub):
                file_count += len(fns)
            tool_dirs.append(
                {
                    "name": sub.name,
                    "path": str(sub),
                    "file_count": file_count,
                }
            )

    cfg_path = root / "ui" / "tool_config.json"
    cfg_info = {
        "path": str(cfg_path),
        "exists": cfg_path.is_file(),
    }

    ds = {
        "has_data": has_data,
        "runs": runs,
        "last_run_id": last_run_id,
        "last_run_path": str(last_run_path) if last_run_path else "",
        "files": files,
        "tool_dirs": tool_dirs,
        "tool_config": cfg_info,
    }

    return render_template("data_source.html", data_source=ds)


# === DASHBOARD_DATA_API_V1 ===
from flask import jsonify, send_from_directory, abort

def _sb_list_runs():
    from pathlib import Path
    root = Path("/home/test/Data/SECURITY_BUNDLE")
    out = root / "out"
    runs = []
    if not out.is_dir():
        return runs
    for p in out.iterdir():
        if not p.is_dir():
            continue
        name = p.name
        if not name.startswith("RUN_"):
            continue
        # RUN_YYYYmmdd_HHMMSS = 19 ký tự
        if len(name) != 19:
            continue
        date_part = name[4:12]
        time_part = name[13:]
        if not (date_part.isdigit() and time_part.isdigit()):
            continue
        runs.append(p)
    runs.sort(key=lambda x: x.name)
    return runs

def _sb_pick_summary_file(run_dir):
    from pathlib import Path
    candidates = [
        run_dir / "summary_unified.json",
        run_dir / "summary.json",
        run_dir / "report" / "summary_unified.json",
        run_dir / "report" / "summary.json",
    ]
    for c in candidates:
        if c.is_file():
            return c
    return None

def _sb_pick_findings_file(run_dir):
    from pathlib import Path
    candidates = [
        run_dir / "findings_unified.json",
        run_dir / "report" / "findings_unified.json",
        run_dir / "report" / "findings.json",
    ]
    for c in candidates:
        if c.is_file():
            return c
    return None

def _sb_extract_counts_from_summary_dict(data):
    """
    Rút trích (total, CRIT, HIGH, MED, LOW) từ một dict summary.

    Hỗ trợ nhiều dạng:
    - {"total":..., "by_severity": {...}}
    - {"summary_all": {"total_findings":..., "severity_buckets": {...}}}
    - severity_buckets có thể là:
        * dict: {"CRITICAL": 0, "HIGH": 10, ...}
        * list: [{"severity": "HIGH", "count": 10}, ...]
    """
    total = 0
    crit = high = medium = low = 0

    # Có thể là { "summary_all": {...} }
    if isinstance(data, dict) and "summary_all" in data and isinstance(data["summary_all"], dict):
        data = data["summary_all"]

    if not isinstance(data, dict):
        return total, crit, high, medium, low

    total = (
        data.get("total")
        or data.get("total_findings")
        or data.get("findings_total")
        or 0
    )

    sev = (
        data.get("by_severity")
        or data.get("severity_buckets")
        or data.get("severity")
        or {}
    ) or {}

    # Nếu sev là list (vd: [{"severity":"HIGH","count":10}, ...]) thì convert thành dict
    if not isinstance(sev, dict):
        if isinstance(sev, list):
            tmp = {}
            for item in sev:
                if not isinstance(item, dict):
                    continue
                key = (
                    item.get("severity")
                    or item.get("sev")
                    or item.get("name")
                    or ""
                )
                key = str(key).upper()
                if not key:
                    continue
                val = (
                    item.get("count")
                    or item.get("value")
                    or item.get("total")
                    or 0
                )
                try:
                    val = int(val or 0)
                except Exception:
                    val = 0
                tmp[key] = tmp.get(key, 0) + val
            sev = tmp
        else:
            sev = {}

    # Chuẩn hoá key upper
    sev_up = {}
    for k, v in sev.items():
        try:
            kk = str(k).upper()
            vv = int(v or 0)
        except Exception:
            continue
        sev_up[kk] = sev_up.get(kk, 0) + vv

    crit = sev_up.get("CRITICAL", 0)
    high = sev_up.get("HIGH", 0)
    medium = sev_up.get("MEDIUM", 0)
    low = (
        sev_up.get("LOW", 0)
        + sev_up.get("INFO", 0)
        + sev_up.get("UNKNOWN", 0)
    )

    return int(total or 0), crit, high, medium, low


def _sb_extract_counts_from_findings_list(items):
    from collections import Counter
    total = len(items)
    c = Counter()
    for it in items:
        if not isinstance(it, dict):
            continue
        sev = (it.get("severity") or it.get("sev") or "").upper()
        c[sev] += 1
    crit = c.get("CRITICAL", 0)
    high = c.get("HIGH", 0)
    medium = c.get("MEDIUM", 0)
    low = c.get("LOW", 0) + c.get("INFO", 0) + c.get("UNKNOWN", 0)
    return total, crit, high, medium, low

def _sb_pick_report_html(run_dir):
    from pathlib import Path
    rep = run_dir / "report"
    if not rep.is_dir():
        return None
    candidates = [
        "pm_style_report.html",
        "pm_style_report_print.html",
        "simple_report.html",
        "checkmarx_like.html",
        "security_resilient.html",
    ]
    for name in candidates:
        p = rep / name
        if p.is_file():
            return name
    return None

@app.route("/api/runs", methods=["GET"])
def api_runs():
    """API cho tab Run & Report: trả danh sách RUN_*"""
    from pathlib import Path
    from flask import jsonify
    import json, datetime, re

    root = Path("/home/test/Data/SECURITY_BUNDLE")
    out_dir = root / "out"
    runs = []

    if not out_dir.is_dir():
        return jsonify({"runs": []})

    entries = []
    for p in out_dir.iterdir():
        if not p.is_dir():
            continue
        name = p.name
        if not re.match(r"^RUN_\d{8}_\d{6}$", name):
            continue
        if name.startswith("RUN_DEMO"):
            continue
        entries.append(p)

    entries.sort(key=lambda p: p.name, reverse=True)

    for run_dir in entries:
        name = run_dir.name
        report_dir = run_dir / "report"
        summary_path = report_dir / "summary_unified.json"

        total = 0
        crit = 0
        high = 0
        has_counts = False

        if summary_path.is_file():
            try:
                with summary_path.open("r", encoding="utf-8") as f:
                    summary = json.load(f)

                if isinstance(summary, dict):
                    buckets = (
                        summary.get("severity_buckets")
                        or summary.get("severityBuckets")
                        or summary.get("buckets")
                        or {}
                    )
                    if isinstance(buckets, dict):
                        crit = int(buckets.get("critical", 0) or 0)
                        high = int(buckets.get("high", 0) or 0)
                        med = int(buckets.get("medium", 0) or 0)
                        low = int(buckets.get("low", 0) or 0)
                        total = int(
                            summary.get("total_findings", crit + high + med + low) or 0
                        )
                        has_counts = True

                if not has_counts and isinstance(summary, list):
                    total_tmp = 0
                    crit_tmp = 0
                    high_tmp = 0
                    for item in summary:
                        if not isinstance(item, dict):
                            continue
                        sev = str(item.get("severity", "")).lower()
                        cnt = int(item.get("count", 0) or 0)
                        total_tmp += cnt
                        if sev == "critical":
                            crit_tmp += cnt
                        elif sev == "high":
                            high_tmp += cnt
                    if total_tmp > 0 or crit_tmp > 0 or high_tmp > 0:
                        total = total_tmp
                        crit = crit_tmp
                        high = high_tmp
                        has_counts = True

            except Exception as e:  # noqa: BLE001
                print(f"[WARN][API] Runs: error reading {summary_path}: {e!r}")

        if not has_counts:
            total = int(total or 0)
            crit = int(crit or 0)
            high = int(high or 0)

        crit_high = crit + high

        try:
            mtime = datetime.datetime.fromtimestamp(run_dir.stat().st_mtime)
            time_str = mtime.strftime("%Y-%m-%d %H:%M:%S")
        except Exception:  # noqa: BLE001
            time_str = ""

        runs.append(
            {
                "run_id": name,
                "time": time_str,
                "total": total,
                "critical": crit,
                "high": high,
                "crit_high": crit_high,
                "report_url": f"/report/{name}/html",
            }
        )

    return jsonify({"runs": runs})
@app.route("/report/<run_id>/html", methods=["GET"])
def report_html(run_id):
    """Main HTML report view for a RUN.

    Priority:
      - pm_style_report.html (if file is not a tiny stub)
      - pm_style_report_print.html
      - simple_report.html
      - checkmarx_like.html
      - security_resilient.html
    """
    from pathlib import Path
    from flask import send_file

    root = Path("/home/test/Data/SECURITY_BUNDLE")
    run_dir = root / "out" / run_id
    report_dir = run_dir / "report"

    if not report_dir.is_dir():
        return f"Report folder not found for {run_id}: {report_dir}", 404

    candidates = [
        "pm_style_report.html",
        "pm_style_report_print.html",
        "simple_report.html",
        "checkmarx_like.html",
        "security_resilient.html",
    ]

    for name in candidates:
        f = report_dir / name
        if not f.is_file():
            continue

        # Skip tiny pm_style_* stubs (< 2KB)
        try:
            size = f.stat().st_size
        except OSError:
            size = 0

        if name.startswith("pm_style") and size < 2048:
            print(f"[WARN][REPORT_HTML] Skip tiny pm-style file: {f} (size={size})")
            continue

        print(f"[INFO][REPORT_HTML] Using {f} (size={size})")
        return send_file(str(f), conditional=False)

    html_files = sorted(p.name for p in report_dir.glob("*.html"))
    listing = ", ".join(html_files) if html_files else "(no .html files)"

    msg = (
        f"No suitable HTML report found in {report_dir}. "
        f"Existing HTML files: {listing}"
    )
    print(f"[WARN][REPORT_HTML] {msg}")
    return msg, 404


@app.route("/report/<run_id>/simple", methods=["GET"])
def report_simple(run_id):
    """
    View Checkmarx-style / simple report cho một RUN.
    """
    from pathlib import Path
    from flask import send_file

    root = Path("/home/test/Data/SECURITY_BUNDLE")
    run_dir = root / "out" / run_id
    report_dir = run_dir / "report"

    if not report_dir.is_dir():
        return f"Không tìm thấy thư mục report cho {run_id}: {report_dir}", 404

    # Ưu tiên simple_report.html, fallback sang checkmarx_like.html nếu cần.
    candidates = ["simple_report.html", "checkmarx_like.html"]

    for name in candidates:
        f = report_dir / name
        if f.is_file():
            print(f"[INFO][REPORT_SIMPLE] Dùng {f}")
            return send_file(str(f), conditional=False)

    msg = (
        f"Không tìm thấy simple_report.html/checkmarx_like.html trong {report_dir}"
    )
    print(f"[WARN][REPORT_SIMPLE] {msg}")
    return msg, 404


@app.route("/runs", methods=["GET"])
def runs_page():
    """
    Trang Run & Report – frontend sẽ fetch /api/runs để lấp data.
    """
    return render_template("runs.html")

@app.route("/settings", methods=["GET"])
def settings_page():
    """
    Trang Settings – xem Tool config (dùng dữ liệu từ /api/dashboard_data).
    Hiện tại read-only; chỉnh sửa vẫn làm bằng file tool_config.json.
    """
    return render_template("settings.html")


# === API_RUN_SCAN_V1 ===
@app.route("/api/run_scan_v2", methods=["POST"])
def api_run_scan_v2():
    """
    Trigger SECURITY_BUNDLE scan từ UI Dashboard.
    Gọi: bin/run_scan_and_refresh_ui.sh "<SRC_FOLDER>"
    Sau khi xong sẽ đọc RUN_* mới nhất + summary_unified.json để trả về.
    """
    import os, re, json, subprocess
    from flask import request, jsonify  # chắc chắn đã import

    data = request.get_json(silent=True) or {}

    src_folder = (data.get("src_folder") or "/home/test/Data/Khach").strip()
    target_url = (data.get("target_url") or "").strip()
    profile    = (data.get("profile") or "").strip()
    mode       = (data.get("mode") or "").strip()

    root = "/home/test/Data/SECURITY_BUNDLE"
    out_dir = os.path.join(root, "out")

    if not src_folder:
        src_folder = "/home/test/Data/Khach"

    cmd = [
        "bash", "-lc",
        f'cd "{root}" && bin/run_scan_and_refresh_ui.sh "{src_folder}"'
    ]

    print("[API][RUN_SCAN_V2] CMD:", " ".join(cmd), flush=True)
    rc = subprocess.call(cmd)
    print("[API][RUN_SCAN_V2] DONE rc =", rc, flush=True)

    # Tìm RUN_* mới nhất sau khi quét
    last_run = None
    if os.path.isdir(out_dir):
        run_dirs = sorted(
            [d for d in os.listdir(out_dir)
             if re.match(r"^RUN_[0-9]{8}_[0-9]{6}$", d)],
            reverse=True,
        )
        if run_dirs:
            last_run = run_dirs[0]

    summary = {}
    if last_run:
        summary_path = os.path.join(out_dir, last_run, "report", "summary_unified.json")
        try:
            with open(summary_path, "r", encoding="utf-8") as f:
                summary = json.load(f)
        except Exception as e:
            print("[API][RUN_SCAN_V2] WARN: không đọc được summary_unified.json:", e, flush=True)

    return jsonify({
        "ok": (rc == 0),
        "rc": int(rc),
        "last_run_id": last_run,
        "summary": summary,
        "src_folder": src_folder,
        "target_url": target_url,
        "profile": profile,
        "mode": mode,
    })

# ================== ANY-URL / SECURITY_BUNDLE – API DASHBOARD DATA ==================
# ================== API: Dashboard data ==================


from pathlib import Path as _PathTop
import json as _jsonTop

def _get_last_run_with_report():
    root = _PathTop("/home/test/Data/SECURITY_BUNDLE/out")
    if not root.is_dir():
        return None
    candidates = []
    for p in root.glob("RUN_*"):
        report = p / "report" / "summary_unified.json"
        if report.is_file():
            try:
                mtime = report.stat().st_mtime
            except Exception:
                mtime = p.stat().st_mtime
            candidates.append((mtime, p))
    if not candidates:
        return None
    candidates.sort(reverse=True)
    _, run_dir = candidates[0]
    return run_dir

@app.route("/api/top_risks_any", methods=["GET"])
def api_top_risks_any():
    """Top Critical/High findings từ findings_unified.json của RUN_* mới nhất."""
    run_dir = _get_last_run_with_report()
    if run_dir is None:
        return jsonify([])
    fpath = run_dir / "report" / "findings_unified.json"
    if not fpath.is_file():
        return jsonify([])
    try:
        raw = fpath.read_text(encoding="utf-8")
        data = _jsonTop.loads(raw)
    except Exception as e:
        print("[ERR][TOP_RISKS_ANY] Lỗi đọc findings_unified.json:", e)
        return jsonify([])
    weights = {"CRITICAL": 2, "HIGH": 1}
    items = []
    if isinstance(data, list):
        for it in data:
            sev = str(it.get("severity", "")).upper()
            if sev not in weights:
                continue
            items.append({
                "severity": sev,
                "tool": it.get("tool") or "",
                "rule": it.get("rule") or it.get("check_id") or "",
                "location": it.get("location") or it.get("path") or "",
            })
    items.sort(key=lambda x: (-weights[x["severity"]], x["tool"], x["rule"], x["location"]))
    return jsonify(items[:10])



@app.route("/api/top_risks_v3", methods=["GET"])
def api_top_risks_v3():
    """
    Trả về top 10 findings CRITICAL/HIGH của RUN_* mới nhất
    (dựa trên file findings_unified.json trong thư mục report/).
    """
    import json
    from pathlib import Path
    from flask import jsonify

    root = Path(__file__).resolve().parent.parent  # .../SECURITY_BUNDLE
    out_dir = root / "out"

    run_dirs = sorted(
        [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_")]
    )
    if not run_dirs:
        return jsonify({"items": []})

    last = run_dirs[-1]
    findings_file = last / "report" / "findings_unified.json"
    if not findings_file.is_file():
        return jsonify({"items": []})

    try:
        raw = json.loads(findings_file.read_text(encoding="utf-8"))
    except Exception:
        return jsonify({"items": []})

    if isinstance(raw, dict) and "findings" in raw:
        findings = raw["findings"]
    else:
        findings = raw

    sev_weight = {
        "CRITICAL": 4, "Critical": 4,
        "HIGH": 3, "High": 3,
        "MEDIUM": 2, "Medium": 2,
        "LOW": 1, "Low": 1,
        "INFO": 0, "Information": 0,
    }

    rows = []
    for f in findings:
        sev = str(f.get("severity", "")).strip()
        if not sev:
            continue
        # Chuẩn hoá và lọc CRITICAL / HIGH
        sev_norm = sev.upper()
        w = sev_weight.get(sev, sev_weight.get(sev_norm, -1))
        if w < 3:
            continue

        rows.append({
            "severity": sev_norm,
            "tool": (f.get("tool") or "").strip(),
            "rule": str(f.get("rule") or f.get("id") or ""),
            "location": (f.get("location") or f.get("path") or ""),
        })

    rows.sort(key=lambda r: sev_weight.get(r["severity"], 0), reverse=True)
    rows = rows[:10]

    return jsonify({"items": rows})


from pathlib import Path
import json
from flask import render_template, send_file, abort

ROOT = Path("/home/test/Data/SECURITY_BUNDLE")
OUT_DIR = ROOT / "out"

def _collect_runs():
    """Đọc toàn bộ *_RUN_* trong out/ và xây list cho tab Runs & Reports."""
    runs = []
    if not OUT_DIR.exists():
        return runs

    def sort_key(p: Path):
        # sort theo tên (RUN_YYYYmmdd_HHMMSS hoặc PREFIX_RUN_YYYYmmdd_HHMMSS)
        return p.name

    for p in sorted(OUT_DIR.glob("*_RUN_*"), key=sort_key, reverse=True):
        run_id = p.name
        report_dir = p / "report"
        summary = report_dir / "summary_unified.json"

        total = 0
        crit = 0
        high = 0
        if summary.exists():
            try:
                data = json.loads(summary.read_text(encoding="utf-8"))
            except Exception:
                data = {}
            total = data.get("total") or data.get("TOTAL") or 0
            sev = (
                data.get("severity_counts")
                or data.get("severity")
                or data.get("sev")
                or {}
            )
            crit = sev.get("CRITICAL") or sev.get("critical") or 0
            high = sev.get("HIGH") or sev.get("high") or 0

        src_guess = "-"
        if "_RUN_" in run_id:
            src_guess = run_id.split("_RUN_", 1)[0]

        runs.append({
            "id": run_id,
            "src": src_guess,
            "total": int(total),
            "crit": int(crit),
            "high": int(high),
            "mode": "Offline · aggr",
        })

    return runs


@app.route('/runs')
def runs_view():
    """Trang lịch sử RUN: lấy list từ out/*_RUN_*"""
    runs = _collect_runs()
    return render_template('runs.html', runs=runs)


@app.route('/pm_report/<run_id>/<fmt>')
def pm_report(run_id, fmt):
    """Mở HTML/PDF report cho từng RUN.

    URL:
      /pm_report/<RUN_ID>/html
      /pm_report/<RUN_ID>/pdf
    """
    report_dir = OUT_DIR / run_id / "report"
    if not report_dir.exists():
        abort(404)

    if fmt == "html":
        # Ưu tiên pm_style_report.html, không có thì fallback
        for name in ["pm_style_report.html", "security_resilient.html", "simple_report.html"]:
            f = report_dir / name
            if f.exists():
                return send_file(str(f), mimetype="text/html")
        abort(404)

    elif fmt == "pdf":
        for name in ["pm_style_report.pdf", "security_resilient.pdf"]:
            f = report_dir / name
            if f.exists():
                return send_file(str(f), mimetype="application/pdf")
        abort(404)

    abort(404)


if __name__ == '__main__':
    # main block luôn ở cuối file sau khi định nghĩa route
    app.run(debug=True, host='0.0.0.0', port=8905)


@app.route('/api/runs_table')
def api_runs_table():
    """Trả JSON list các *_RUN_* trong out/ cho tab Runs & Reports."""
    from pathlib import Path
    import json, datetime
    root = Path('/home/test/Data/SECURITY_BUNDLE')
    out_dir = root / 'out'
    rows = []
    if out_dir.is_dir():
        for p in sorted(out_dir.glob('*_RUN_*')):
            if not p.is_dir():
                continue
            report_dir = p / 'report'
            summary = report_dir / 'summary_unified.json'
            total = crit = high = 0
            mode = '-'
            src = '-'
            if summary.is_file():
                try:
                    data = json.loads(summary.read_text(encoding='utf-8'))
                    total = int(data.get('total', 0))
                    crit = int(data.get('critical', 0))
                    high = int(data.get('high', 0))
                    src = data.get('src_folder') or data.get('src') or '-'
                    mode = data.get('mode') or '-'
                except Exception:
                    pass
            mtime = datetime.datetime.fromtimestamp(p.stat().st_mtime)
            rows.append({
                "run": p.name,
                "time": mtime.strftime('%Y-%m-%d %H:%M:%S'),
                "src": src,
                "total": total,
                "crit": crit,
                "high": high,
                "mode": mode,
            })
        rows.sort(key=lambda r: r["time"], reverse=True)
    return jsonify(rows)
