from __future__ import annotations
import json
import subprocess
import datetime
from pathlib import Path
from typing import Dict, Any, List

from flask import Flask, render_template, jsonify, request

ROOT = Path("/home/test/Data/SECURITY_BUNDLE").resolve()
OUT_ROOT = ROOT / "out"

app = Flask(__name__, template_folder="templates", static_folder="static")


def find_run_dirs() -> List[Path]:
    if not OUT_ROOT.exists():
        return []
    runs = [p for p in OUT_ROOT.iterdir() if p.is_dir() and p.name.startswith("RUN_")]
    runs.sort(key=lambda p: p.name, reverse=True)
    return runs


def get_latest_run_dir() -> Path | None:
    runs = find_run_dirs()
    return runs[0] if runs else None


def load_summary(run_dir: Path) -> Dict[str, Any]:
    summary_path = run_dir / "report" / "summary_unified.json"
    if not summary_path.exists():
        return {}
    try:
        return json.loads(summary_path.read_text(encoding="utf-8"))
    except Exception as e:
        print("[ERR] load_summary:", e)
        return {}


@app.route("/")
def vsp_dashboard():
    return render_template("vsp_dashboard_2025.html")






@app.route("/api/vsp/dashboard", methods=["GET"])
def api_vsp_dashboard():
    import json
    from pathlib import Path

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"

    # Tìm summary_unified.json mới nhất dưới out/RUN_*/report/
    candidates = []
    for p in out_dir.glob("RUN_*/report/summary_unified.json"):
        try:
            mtime = p.stat().st_mtime
        except OSError:
            continue
        candidates.append((mtime, p))

    candidates.sort(reverse=True)
    summary_data = None
    run_id = None
    if candidates:
        mtime, latest_path = candidates[0]
        run_id = latest_path.parent.parent.name
        try:
            summary_data = json.loads(latest_path.read_text(encoding="utf-8"))
        except Exception:
            summary_data = None

    sev_keys = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]
    sev = {k: 0 for k in sev_keys}
    total_findings = 0
    top_tool = None
    top_cwe = None
    top_module = None

    def _extract_count(v):
        if isinstance(v, dict):
            for key in ("count", "total", "value", "n"):
                if key in v:
                    try:
                        return int(v[key] or 0)
                    except Exception:
                        return 0
            return 0
        try:
            return int(v or 0)
        except Exception:
            return 0

    def _find_severity_dict(obj):
        # Đệ quy tìm dict có nhiều key thuộc sev_keys
        if isinstance(obj, dict):
            keys = obj.keys()
            match = sum(1 for k in sev_keys if k in keys)
            if match >= 3:
                return obj
            for v in obj.values():
                found = _find_severity_dict(v)
                if found is not None:
                    return found
        elif isinstance(obj, (list, tuple)):
            for it in obj:
                found = _find_severity_dict(it)
                if found is not None:
                    return found
        return None

    if isinstance(summary_data, dict):
        # 1) Thử tìm dict severity "thông minh"
        raw_sev = _find_severity_dict(summary_data)
        if isinstance(raw_sev, dict):
            for k in sev_keys:
                if k in raw_sev:
                    sev[k] = _extract_count(raw_sev.get(k))

        # 2) Nếu vẫn 0 hết, fallback thêm vài đường cũ
        if all(v == 0 for v in sev.values()):
            direct = (
                summary_data.get("severity")
                or summary_data.get("severity_buckets")
                or summary_data.get("severity_breakdown")
            )
            if isinstance(direct, dict):
                for k in sev_keys:
                    if k in direct:
                        sev[k] = _extract_count(direct.get(k))

        if all(v == 0 for v in sev.values()):
            for k in sev_keys:
                if k in summary_data:
                    sev[k] = _extract_count(summary_data.get(k))

        # 3) Tổng findings
        total_findings = summary_data.get("total_findings")
        if total_findings is None or total_findings == 0:
            total_findings = sum(sev.values())
        try:
            total_findings = int(total_findings or 0)
        except Exception:
            total_findings = sum(sev.values())

        # 4) Top tool / CWE / module nếu có
        per_tool = summary_data.get("by_tool") or summary_data.get("tool_counts") or {}
        if isinstance(per_tool, dict) and per_tool:
            top_tool = max(per_tool.items(), key=lambda kv: kv[1])[0]

        cwe_counts = summary_data.get("cwe_counts") or {}
        if isinstance(cwe_counts, dict) and cwe_counts:
            top_cwe = max(cwe_counts.items(), key=lambda kv: kv[1])[0]

        module_counts = summary_data.get("module_counts") or {}
        if isinstance(module_counts, dict) and module_counts:
            top_module = max(module_counts.items(), key=lambda kv: kv[1])[0]

    crit = sev["CRITICAL"]
    high = sev["HIGH"]
    penalty = crit * 8 + high * 3
    posture_score = 100 - penalty
    if posture_score < 0:
        posture_score = 0
    if posture_score > 100:
        posture_score = 100

    return jsonify(
        posture_score=posture_score,
        run_id=run_id,
        severity=sev,
        top_cwe=top_cwe,
        top_module=top_module,
        top_tool=top_tool,
        total_findings=total_findings,
    )


@app.route("/api/vsp/runs_index")
def api_vsp_runs_index():
    """Trả list RUN cho tab Runs & Reports (sau này dùng)."""
    runs = []
    for d in find_run_dirs():
        summary = load_summary(d)
        sev = summary.get("severity_buckets", {}) or summary.get("severity", {})
        runs.append({
            "run_id": d.name,
            "total_findings": int(summary.get("total_findings", 0) or 0),
            "profile": summary.get("profile", "EXT"),
            "src_path": summary.get("src_path", "-"),
            "url": summary.get("url", "-"),
            "severity": {
                "CRIT": int(sev.get("CRITICAL", 0) or 0),
                "HIGH": int(sev.get("HIGH", 0) or 0),
                "MED": int(sev.get("MEDIUM", 0) or 0),
                "LOW": int(sev.get("LOW", 0) or 0),
                "INFO": int(sev.get("INFO", 0) or 0),
                "TRACE": int(sev.get("TRACE", 0) or 0),
            },
        })
    return jsonify({"runs": runs})


@app.route("/api/vsp/run_full_ext", methods=["POST"])
def api_vsp_run_full_ext():
    """
    Nhập SRC trên UI -> gọi run_all_tools_v2.sh -> unify -> trả run_id.
    Chạy đồng bộ cho bản đầu (run xong mới trả JSON).
    """
    payload = request.get_json(silent=True) or {}
    src_path = payload.get("src_path")
    if not src_path:
        return jsonify({"ok": False, "error": "Missing src_path"}), 400

    src = Path(src_path).expanduser().resolve()
    if not src.exists():
        return jsonify({"ok": False, "error": f"SRC không tồn tại: {src}"}), 400

    ts = datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    run_id = f"RUN_VSP_FULL_EXT_{ts}"
    out_dir = OUT_ROOT / run_id
    out_dir.mkdir(parents=True, exist_ok=True)

    import os
    env = dict(os.environ)
    env["SRC"] = str(src)
    env["OUT_DIR"] = str(out_dir)

    try:
        # 1) Chạy full 8 tool
        subprocess.run(
            ["bash", "bin/run_all_tools_v2.sh", str(src), str(out_dir), "EXT"],
            cwd=str(ROOT),
            env=env,
            check=True,
        )
        # 2) Unify
        subprocess.run(
            ["python3", "bin/unify_findings_all_tools.py", str(out_dir)],
            cwd=str(ROOT),
            env=env,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        return jsonify({
            "ok": False,
            "error": f"run_all_tools_v2 hoặc unify bị lỗi (rc={e.returncode})",
            "run_id": run_id,
        }), 500

    return jsonify({"ok": True, "run_id": run_id})


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8910, debug=False)
