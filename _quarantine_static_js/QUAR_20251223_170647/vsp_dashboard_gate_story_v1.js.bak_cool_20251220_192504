/* VSP_P1_GATE_ROOT_PROXY_V2
 * Commercial fix: stop probing wrong RID via BOTH fetch + XMLHttpRequest.
 * - Wait /api/vsp/runs => rid_latest_gate_root || rid_latest_gate || rid_latest
 * - Rewrite /api/vsp/run_file_allow:
 *     rid  = gate_root rid
 *     path = run_gate_summary.json
 */
(()=> {
  try {
    if (window.__vsp_p1_gate_root_proxy_v2) return;
    window.__vsp_p1_gate_root_proxy_v2 = true;

    const ORIGIN = location.origin;

    const pickRid = (j)=> {
      try {
        if (!j) return "";
        const rid = (j.rid_latest_gate_root || j.rid_latest_gate || j.rid_latest || "").toString().trim();
        if (!rid) return "";
        window.vsp_rid_latest = rid;
        try {
          localStorage.setItem("vsp_rid_latest_gate_root_v1", rid);
          localStorage.setItem("vsp_rid_latest_v1", rid);
        } catch(e){}
        return rid;
      } catch(e){ return ""; }
    };

    const cachedRid = ()=> {
      try {
        return (localStorage.getItem("vsp_rid_latest_gate_root_v1")
          || localStorage.getItem("vsp_rid_latest_v1")
          || "").toString().trim();
      } catch(e){ return ""; }
    };

    const RUNS_URL = ORIGIN + "/api/vsp/runs?limit=10&_=" + Date.now();
    window.__vsp_gate_root_rid_promise = window.__vsp_gate_root_rid_promise
      || fetch(RUNS_URL, {cache:"no-store"})
          .then(r => r.json().catch(()=>null))
          .then(j => pickRid(j) || cachedRid())
          .catch(()=> cachedRid());

    const rewriteRunFileAllow = (url0, rid)=> {
      const u = new URL(url0, ORIGIN);
      if (rid) u.searchParams.set("rid", rid);
      u.searchParams.set("path", "run_gate_summary.json");
      return u.toString();
    };

    // ---- fetch hook ----
    const origFetch = window.fetch.bind(window);
    window.fetch = function(input, init){
      try{
        const url0 = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
        if (url0 && url0.indexOf("/api/vsp/run_file_allow") >= 0) {
          return window.__vsp_gate_root_rid_promise.then((rid)=>{
            const url1 = rewriteRunFileAllow(url0, rid);
            if (typeof input !== "string" && input && input.url) {
              const req = new Request(url1, input);
              return origFetch(req, init);
            }
            return origFetch(url1, init);
          });
        }
      }catch(e){}
      return origFetch(input, init);
    };

    // ---- XMLHttpRequest hook (this is the missing piece) ----
    const XHR = window.XMLHttpRequest;
    if (XHR && XHR.prototype) {
      const _open = XHR.prototype.open;
      const _send = XHR.prototype.send;

      XHR.prototype.open = function(method, url, async, user, password){
        try{
          const url0 = (url || "").toString();
          if (url0.indexOf("/api/vsp/run_file_allow") >= 0) {
            // delay open until send, after we know rid
            this.__vsp_gate_root_pending_open = [method, url0, async, user, password];
            this.__vsp_gate_root_is_pending = true;
            return; // do NOT call original open now
          }
        }catch(e){}
        return _open.apply(this, arguments);
      };

      XHR.prototype.send = function(body){
        try{
          if (this.__vsp_gate_root_is_pending && this.__vsp_gate_root_pending_open) {
            const args = this.__vsp_gate_root_pending_open;
            this.__vsp_gate_root_is_pending = false;
            this.__vsp_gate_root_pending_open = null;

            const origUrl = args[1];
            const self = this;
            return window.__vsp_gate_root_rid_promise.then((rid)=>{
              const url1 = rewriteRunFileAllow(origUrl, rid);
              _open.call(self, args[0], url1, args[2], args[3], args[4]);
              return _send.call(self, body);
            });
          }
        }catch(e){}
        return _send.apply(this, arguments);
      };
    }

    console.log("[GateStoryV1][%s] installed", "VSP_P1_GATE_ROOT_PROXY_V2");
  } catch(e){}
})();

/* VSP_P1_GATE_STORY_FORCE_PAINT_V1B */
(() => {
  // NOTE: do NOT early-return even if previous version set a flag;
  // we want "self-healing" behavior on blank pages.
  if (window.__vsp_gate_story_force_paint_v1b) return;
  window.__vsp_gate_story_force_paint_v1b = true;

  const CFG = {
    runsUrl: "/api/vsp/runs?limit=1",
    fileUrl: (rid) => `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&name=${encodeURIComponent("run_gate.json")}`,
    timeoutMs: 8000,
    tools: ["bandit","semgrep","gitleaks","kics","trivy","syft","grype","codeql"],
    refreshMs: 15000,      // refresh data
    healEveryMs: 600,      // re-insert panel if removed
    healMaxMs: 20000,      // keep healing for 20s after load
  };

  const now = () => Date.now();
  const log = (...a) => console.log("[GateStoryV1B]", ...a);

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

  function pick(obj, path, defv){
    try{
      const ps = path.split(".");
      let cur = obj;
      for (const k of ps){
        if (!cur) return defv;
        cur = cur[k];
      }
      return (cur === undefined || cur === null) ? defv : cur;
    } catch { return defv; }
  }

  function normOverall(v){
    const s = String(v ?? "").toUpperCase().trim();
    if (["RED","FAIL","FAILED","BLOCK","BLOCKED","CRITICAL"].includes(s)) return "RED";
    if (["AMBER","WARN","WARNING","DEGRADED","YELLOW"].includes(s)) return "AMBER";
    if (["GREEN","PASS","PASSED","OK"].includes(s)) return "GREEN";
    return s || "UNKNOWN";
  }

  function tone(overall){
    if (overall === "RED") return "tone-red";
    if (overall === "AMBER") return "tone-amber";
    if (overall === "GREEN") return "tone-green";
    return "tone-unk";
  }

  function toolTone(st){
    const s = String(st ?? "").toUpperCase();
    if (["PASS","OK","GREEN"].includes(s)) return "t-ok";
    if (["FAIL","RED","BLOCKED"].includes(s)) return "t-bad";
    if (["DEGRADED","AMBER","WARN","TIMEOUT"].includes(s)) return "t-warn";
    if (["MISSING","SKIP","SKIPPED","N/A","NA"].includes(s)) return "t-mute";
    return "t-unk";
  }

  function ensureStyle(){
    if (document.getElementById("vsp_gate_story_v1b_style")) return;
    const st = document.createElement("style");
    st.id = "vsp_gate_story_v1b_style";
    st.textContent = `
      body{ background:#0b1220; }
      .vspgs-wrap{ margin:14px; }
      .vspgs-card{
        border:1px solid rgba(255,255,255,.10);
        background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
        border-radius:16px;
        padding:14px;
        box-shadow: 0 14px 34px rgba(0,0,0,.45);
        color: rgba(226,232,240,.96);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      .vspgs-top{display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:flex-start;}
      .vspgs-title{display:flex; gap:10px; align-items:flex-start;}
      .vspgs-dot{width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,.25);margin-top:4px;}
      .vspgs-h{font-weight:800; letter-spacing:.3px; font-size:14px;}
      .vspgs-sub{font-size:12px; opacity:.74; margin-top:2px;}
      .vspgs-kpis{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
      .pill{border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.22); border-radius:999px; padding:6px 10px; font-size:12px; display:flex; gap:8px; align-items:center;}
      .ov{font-weight:900; letter-spacing:1px; padding:6px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.16);}
      .tone-red{background: rgba(255,73,73,.16); color: rgba(255,165,165,.98);}
      .tone-amber{background: rgba(255,193,7,.14); color: rgba(255,228,141,.98);}
      .tone-green{background: rgba(46,204,113,.12); color: rgba(165,255,205,.98);}
      .tone-unk{background: rgba(148,163,184,.12); color: rgba(226,232,240,.95);}
      .mid{display:flex; gap:14px; margin-top:10px; flex-wrap:wrap;}
      .left{flex:1 1 460px; min-width:320px;}
      .right{flex:0 0 360px; min-width:320px;}
      .muted{opacity:.72;}
      .small{font-size:12px; opacity:.82; line-height:1.25rem;}
      .reasons{margin:8px 0 0 0; padding:0 0 0 18px;}
      .reasons li{margin:6px 0; font-size:13px; line-height:1.25rem;}
      .strip{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
      .tool{font-size:11px; padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.22); display:flex; gap:6px; align-items:center;}
      .tool b{letter-spacing:.3px;}
      .t-ok{color: rgba(165,255,205,.98);}
      .t-warn{color: rgba(255,228,141,.98);}
      .t-bad{color: rgba(255,165,165,.98);}
      .t-mute{color: rgba(203,213,225,.72);}
      .t-unk{color: rgba(226,232,240,.92);}
      .actions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-top:10px;}
      .btn{cursor:pointer; border:1px solid rgba(255,255,255,.16); background: rgba(0,0,0,.22); color: rgba(226,232,240,.95);
           border-radius:12px; padding:8px 10px; font-size:12px; text-decoration:none;}
      .btn:hover{background: rgba(255,255,255,.06);}
      .hr{height:1px; background: rgba(255,255,255,.08); margin-top:10px;}
    `;
    document.head.appendChild(st);
  }

  function ensurePanel(){
    ensureStyle();
    let wrap = document.getElementById("vsp_gate_story_panel_v1b");
    if (wrap) return wrap;

    wrap = document.createElement("div");
    wrap.id = "vsp_gate_story_panel_v1b";
    wrap.className = "vspgs-wrap";
    wrap.innerHTML = `
      <div class="vspgs-card">
        <div class="vspgs-top">
          <div class="vspgs-title">
            <div class="vspgs-dot"></div>
            <div>
              <div class="vspgs-h">Gate Story</div>
              <div class="vspgs-sub muted">overall + top reasons + degraded/tools (latest)</div>
            </div>
          </div>
          <div class="vspgs-kpis">
            <div class="pill"><span class="muted">Overall</span> <span id="gs_overall" class="ov tone-unk">…</span></div>
            <div class="pill"><span class="muted">Degraded</span> <b id="gs_degraded">…</b></div>
            <div class="pill"><span class="muted">Total</span> <b id="gs_total">…</b></div>
          </div>
        </div>

        <div class="mid">
          <div class="left">
            <div class="small muted">Top reasons (3)</div>
            <ol class="reasons" id="gs_reasons"><li class="muted">Loading gate…</li></ol>
            <div class="hr"></div>
            <div class="small muted">Tool strip (8)</div>
            <div class="strip" id="gs_strip"></div>
          </div>
          <div class="right">
            <div class="small muted">Latest run</div>
            <div class="small" id="gs_meta">…</div>
            <div class="actions" id="gs_actions"></div>
          </div>
        </div>
      </div>
    `;

    // Force insert at body top even if other scripts wipe containers
    if (document.body.firstChild) document.body.insertBefore(wrap, document.body.firstChild);
    else document.body.appendChild(wrap);

    return wrap;
  }

  function setOverall(v){
    const el = document.getElementById("gs_overall");
    if (!el) return;
    const o = normOverall(v);
    el.textContent = o;
    el.classList.remove("tone-red","tone-amber","tone-green","tone-unk");
    el.classList.add(tone(o));
  }

  function setText(id, v){
    const el = document.getElementById(id);
    if (el) el.textContent = String(v ?? "");
  }

  function renderStrip(toolState){
    const box = document.getElementById("gs_strip");
    if (!box) return;
    box.innerHTML = "";
    for (const t of CFG.tools){
      const st = String(toolState[t] ?? "UNKNOWN").toUpperCase();
      const chip = document.createElement("div");
      chip.className = `tool ${toolTone(st)}`;
      chip.innerHTML = `<b>${esc(t.toUpperCase())}</b><span class="muted">•</span><span>${esc(st)}</span>`;
      box.appendChild(chip);
    }
  }

  function renderReasons(arr){
    const ol = document.getElementById("gs_reasons");
    if (!ol) return;
    const rs = (arr && arr.length) ? arr.slice(0,3) : ["No reasons available (fallback)."];
    ol.innerHTML = rs.map(x => `<li>${esc(x)}</li>`).join("");
  }

  function renderMeta(rid, run, sevText){
    const el = document.getElementById("gs_meta");
    if (!el) return;
    const started = (run && (run.started_at || run.created_at || run.ts || run.time)) || "";
    const ro = normOverall((run && (run.overall || run.overall_status || run.status || run.verdict)) || "");
    el.innerHTML =
      `<div><b>RID</b>: <span class="muted">${esc(rid)}</span></div>` +
      (started ? `<div><b>Time</b>: <span class="muted">${esc(started)}</span></div>` : "") +
      `<div><b>Run overall</b>: <span class="muted">${esc(ro || "UNKNOWN")}</span></div>` +
      (sevText ? `<div><b>Sev</b>: <span class="muted">${esc(sevText)}</span></div>` : "");
  }

  function renderActions(rid){
    const box = document.getElementById("gs_actions");
    if (!box) return;
    const url = CFG.fileUrl(rid);
    box.innerHTML = `
      <a class="btn" href="${esc(url)}" target="_blank" rel="noopener">Open run_gate.json</a>
      <a class="btn" href="/runs" target="_blank" rel="noopener">Runs &amp; Reports</a>
      <a class="btn" href="/data_source" target="_blank" rel="noopener">Data Source</a>
    `;
  }

  async function fetchJson(url){
    const ac = new AbortController();
    const t = setTimeout(() => ac.abort(), CFG.timeoutMs);
    try{
      const r = await fetch(url, {signal: ac.signal, headers: {"Accept":"application/json"}});
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    } finally { clearTimeout(t); }
  }

  function normalizeTools(summary){
    const byTool = summary.by_tool || summary.tools || summary.tool_results || {};
    const toolState = {};
    let degradedCount = 0;

    for (const t of CFG.tools){
      let ent = byTool[t] || byTool[t.toUpperCase()] || byTool[t.toLowerCase()];
      let st = "UNKNOWN";
      let dg = false;

      if (ent && typeof ent === "object"){
        st = String(ent.status || ent.state || ent.verdict || ent.result || "UNKNOWN").toUpperCase();
        dg = !!(ent.degraded || ent.is_degraded || ent.timeout || ent.timed_out);
        if (dg && (st === "PASS" || st === "OK" || st === "GREEN")) st = "DEGRADED";
      } else {
        // fallback flat fields
        const st2 = summary[`${t}_status`];
        const dg2 = summary[`${t}_degraded`];
        if (st2) st = String(st2).toUpperCase();
        if (dg2 !== undefined) dg = !!dg2;
        if (dg && (st === "PASS" || st === "OK")) st = "DEGRADED";
      }

      toolState[t] = st;
      if (dg) degradedCount++;
    }
    return {toolState, degradedCount};
  }

  function extractTotals(summary){
    const sev = summary.counts_by_severity || summary.severity_counts || summary.by_severity || null;
    if (sev && typeof sev === "object"){
      const c = Number(sev.CRITICAL ?? sev.critical ?? 0) || 0;
      const h = Number(sev.HIGH ?? sev.high ?? 0) || 0;
      const m = Number(sev.MEDIUM ?? sev.medium ?? 0) || 0;
      const l = Number(sev.LOW ?? sev.low ?? 0) || 0;
      const i = Number(sev.INFO ?? sev.info ?? 0) || 0;
      const t = Number(sev.TRACE ?? sev.trace ?? 0) || 0;
      const total = Number(summary.total_findings ?? summary.findings_total ?? (c+h+m+l+i+t)) || (c+h+m+l+i+t);
      return { total, sevText: `C/H/M/L/I/T = ${c}/${h}/${m}/${l}/${i}/${t}` };
    }
    // best-effort
    const total = Number(summary.total_findings ?? summary.findings_total ?? summary.total ?? 0) || 0;
    return total ? { total, sevText: "" } : null;
  }

  function extractReasons(summary, rid, degradedCount, totals){
    let rs = summary.top_reasons || summary.reasons || summary.why || summary.verdict_reasons || [];
    if (typeof rs === "string") rs = rs.split("\n").map(x=>x.trim()).filter(Boolean);
    if (Array.isArray(rs)) rs = rs.map(x => typeof x === "string" ? x : (x && x.text ? x.text : JSON.stringify(x)));

    rs = (rs || []).filter(Boolean).slice(0,3);
    if (rs.length < 3){
      if (totals && totals.total) rs.push(`Tổng findings: ${totals.total}.`);
      if (degradedCount > 0) rs.push(`Degraded tools: ${degradedCount}/${CFG.tools.length}.`);
      rs.push(`RID: ${rid}.`);
      rs = rs.slice(0,3);
    }
    return rs;
  }

  async function refreshOnce(){
    ensurePanel();

    const runs = await fetchJson(CFG.runsUrl);
    const run = (runs && Array.isArray(runs.items) && runs.items[0]) ? runs.items[0] : null;
    const rid = (run && (run.run_id || run.rid || run.id)) || null;

    if (!rid){
      setOverall("UNKNOWN");
      renderReasons(["Không lấy được RID từ /api/vsp/runs?limit=1."]);
      renderStrip(Object.fromEntries(CFG.tools.map(t=>[t,"UNKNOWN"])));
      setText("gs_degraded", `0/${CFG.tools.length}`);
      setText("gs_total", "—");
      return;
    }

    let summary = null;
    try { summary = await fetchJson(CFG.fileUrl(rid)); } catch { summary = null; }

    const overall = normOverall(
      (summary && (summary.overall || summary.overall_status || summary.status || summary.verdict)) ||
      (run && (run.overall || run.overall_status || run.status || run.verdict)) ||
      "UNKNOWN"
    );
    setOverall(overall);

    const totals = summary ? extractTotals(summary) : null;
    setText("gs_total", totals ? String(totals.total) : "—");

    const {toolState, degradedCount} = summary ? normalizeTools(summary) : {toolState: Object.fromEntries(CFG.tools.map(t=>[t,"UNKNOWN"])), degradedCount: 0};
    setText("gs_degraded", `${degradedCount}/${CFG.tools.length}`);
    renderStrip(toolState);

    const reasons = summary ? extractReasons(summary, rid, degradedCount, totals) : [
      "Không đọc được run_gate.json (fallback).",
      `Degraded tools: ${degradedCount}/${CFG.tools.length}.`,
      `RID: ${rid}.`,
    ];
    renderReasons(reasons);

    renderMeta(rid, run || {}, totals ? totals.sevText : "");
    renderActions(rid);
  }

  function start(){
    // Always paint immediately so page is not blank
    ensurePanel();
    setOverall("UNKNOWN");
    renderStrip(Object.fromEntries(CFG.tools.map(t=>[t,"…"])));
    renderReasons(["Loading…"]);

    // Data refresh
    refreshOnce().catch(e => {
      log("refresh error:", e?.message || e);
      renderReasons([`Lỗi tải gate: ${String(e?.message || e).slice(0,120)}`]);
    });

    // Heal loop: if any legacy script wipes DOM, reinsert panel
    const t0 = now();
    const heal = setInterval(() => {
      if (now() - t0 > CFG.healMaxMs) { clearInterval(heal); return; }
      if (!document.getElementById("vsp_gate_story_panel_v1b")) {
        log("heal: panel missing -> reinsert");
        ensurePanel();
      }
    }, CFG.healEveryMs);

    // Periodic refresh
    setInterval(() => refreshOnce().catch(()=>{}), CFG.refreshMs);

    log("loaded + running");
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", start, {once:true});
  else start();
})();

/* VSP_P1_GATE_STORY_REWIRE_RUN_FILE_ALLOW_V1B */
console.log('[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] rewire: run_file -> run_file_allow');


/* VSP_P1_GATE_STORY_FIX_RUNFILE_ALLOW_PARAMS_V2 */
(()=> {
  if (window.__vsp_p1_gate_story_fix_runfile_allow_params_v2) return;
  window.__vsp_p1_gate_story_fix_runfile_allow_params_v2 = true;

  function getRidFromDom(){
    try{
      const txt = (document.body && document.body.textContent) ? document.body.textContent : "";
      const m = txt.match(/RID:\s*([A-Za-z0-9_.\-]+)/);
      return m ? m[1] : "";
    }catch(e){ return ""; }
  }

  const origFetch = window.fetch;
  window.fetch = function(input, init){
    try{
      if (typeof input === "string" && input.includes("/api/vsp/run_file_allow")){
        let url = input;

        // If rid missing, try to attach from DOM
        if (!/[?&]rid=/.test(url)){
          const rid = getRidFromDom();
          if (rid){
            url += (url.includes("?") ? "&" : "?") + "rid=" + encodeURIComponent(rid);
          }
        }
        // If path missing, force run_gate.json (backend will fallback to run_gate_summary.json)
        if (!/[?&]path=/.test(url)){
          url += (url.includes("?") ? "&" : "?") + "path=" + encodeURIComponent("run_gate.json");
        }

        input = url;
      }
    }catch(e){}
    return origFetch(input, init);
  };

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V2 fix: force rid+path for run_file_allow, path=run_gate.json");
})();

/* VSP_P1_GATE_STORY_FIX_RUNFILE_ALLOW_PARAMS_V2 */



/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V3
   - capture gate json from /api/vsp/run_file_allow
   - apply to DOM: Run overall + tool badges (fix UNKNOWN) without relying on internal GateStory code
*/
(()=> {
  if (window.__vsp_p1_gate_story_apply_gate_to_dom_v3) return;
  window.__vsp_p1_gate_story_apply_gate_to_dom_v3 = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];

  function norm(s){ return (s||"").toString().trim().toUpperCase(); }

  function statusFromCounts(ct){
    ct = ct || {};
    const c = (ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0), l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h > 0) return "RED";
    if (m > 0) return "AMBER";
    if (l+i+t > 0) return "GREEN";
    return "UNKNOWN";
  }

  function computeToolStatus(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const k of TOOLS){
      const o = bt[k] || bt[k.toLowerCase()] || null;
      if (!o){ out[k]="UNKNOWN"; continue; }
      const st = norm(o.status || o.overall || o.verdict);
      if (st && st !== "UNKNOWN"){
        // normalize common variants
        if (st === "PASS" || st === "OK" || st === "GREEN") out[k]="GREEN";
        else if (st === "WARN" || st === "AMBER") out[k]="AMBER";
        else if (st === "FAIL" || st === "BLOCK" || st === "RED") out[k]="RED";
        else out[k]=st;
      } else {
        const ct = o.counts_total || o.counts || o.totals || {};
        out[k] = statusFromCounts(ct);
      }
    }
    return out;
  }

  function applyRunOverall(gate){
    const ov = norm(gate && (gate.overall || gate.overall_status));
    if (!ov) return;
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(el => (el.childElementCount===0) && /Run overall:/i.test(el.textContent||""));
    for (const el of nodes.slice(0,5)){
      const t = el.textContent || "";
      el.textContent = t.replace(/Run overall:\s*\w+/i, "Run overall: " + ov);
    }
  }

  function applyToolBadges(map){
    const all = Array.from(document.querySelectorAll("button,span,div"))
      .filter(el => (el.childElementCount===0) && (el.textContent||"").length < 60);

    for (const tool of TOOLS){
      const st = map[tool] || "UNKNOWN";
      for (const el of all){
        const txt = (el.textContent||"").trim();
        if (!txt) continue;
        // match "TOOL - XXX" or "TOOL · XXX"
        const re = new RegExp("^\\s*"+tool+"\\s*([\\-·:\\|])\\s*(GREEN|AMBER|RED|UNKNOWN)\\s*$","i");
        if (re.test(txt)){
          el.textContent = txt.replace(re, tool + " $1 " + st);
        }
      }
    }
  }

  function applyGate(gate){
    if (!gate || typeof gate !== "object") return;
    applyRunOverall(gate);
    const map = computeToolStatus(gate);
    applyToolBadges(map);
  }

  // --- capture gate json from fetch ---
  const prevFetch = window.fetch;
  window.fetch = async function(input, init){
    const res = await prevFetch(input, init);
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url && url.includes("/api/vsp/run_file_allow")){
        // clone + try json
        const c = res.clone();
        c.json().then(j=>{
          if (j && typeof j === "object" && (j.by_tool || j.counts_total || j.overall || j.overall_status)){
            window.__vsp_gate_latest_v3 = j;
            applyGate(j);
          }
        }).catch(()=>{});
      }
    }catch(e){}
    return res;
  };

  // --- periodic apply (in case DOM rerender) ---
  setInterval(()=>{ try{ if (window.__vsp_gate_latest_v3) applyGate(window.__vsp_gate_latest_v3); }catch(e){} }, 1000);

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V3 apply DOM: Run overall + tool UNKNOWN fill (by_tool)");
})();

/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V3 */



/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V4B
   - fix JS syntax; sync "Run overall" + normalize tool badges using latest gate json
*/
(()=> {
  if (window.__vsp_p1_gate_story_apply_gate_to_dom_v4b) return;
  window.__vsp_p1_gate_story_apply_gate_to_dom_v4b = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];
  const norm = (x)=> (x||"").toString().trim().toUpperCase();

  function statusFromCounts(ct){
    ct = ct || {};
    const c=(ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0), l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h>0) return "RED";
    if (m>0) return "AMBER";
    if (l+i+t>0) return "GREEN";
    return "UNKNOWN";
  }

  function computeToolStatus(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const k of TOOLS){
      const o = bt[k] || bt[k.toLowerCase()] || null;
      if (!o){ out[k]="UNKNOWN"; continue; }
      const st0 = norm(o.status || o.overall || o.verdict);
      if (st0 && st0 !== "UNKNOWN"){
        if (st0==="PASS"||st0==="OK"||st0==="GREEN") out[k]="GREEN";
        else if (st0==="WARN"||st0==="AMBER") out[k]="AMBER";
        else if (st0==="FAIL"||st0==="BLOCK"||st0==="RED") out[k]="RED";
        else out[k]=st0;
      } else {
        const ct = o.counts_total || o.counts || o.totals || {};
        out[k] = statusFromCounts(ct);
      }
    }
    return out;
  }

  function applyRunOverall(gate){
    const ov = norm(gate && (gate.overall || gate.overall_status));
    if (!ov) return;
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(el => (el.textContent||"").includes("Run overall:"))
      .sort((a,b)=> (a.textContent||"").length - (b.textContent||"").length);
    for (const el of nodes.slice(0,8)){
      try{
        const t = el.textContent || "";
        const t2 = t.replace(/Run overall:\s*[A-Za-z_]+/i, "Run overall: " + ov);
        if (t2 !== t) el.textContent = t2;
      }catch(e){}
    }
  }

  function applyToolBadges(map){
    const nodes = Array.from(document.querySelectorAll("button,span,div"))
      .filter(el => (el.textContent||"").length < 80);

    for (const tool of TOOLS){
      const st = map[tool] || "UNKNOWN";
      const re = new RegExp("^\\s*" + tool + "\\s*([\\-·:\\|])\\s*(GREEN|AMBER|RED|UNKNOWN)\\s*$","i");
      for (const el of nodes){
        const txt = (el.textContent||"").trim();
        if (!txt) continue;
        if (!txt.toUpperCase().includes(tool)) continue;
        if (re.test(txt)){
          el.textContent = txt.replace(re, tool + " $1 " + st);
        }
      }
    }
  }

  function applyGate(gate){
    if (!gate || typeof gate !== "object") return;
    applyRunOverall(gate);
    applyToolBadges(computeToolStatus(gate));
  }

  const prevFetch = window.fetch;
  window.fetch = async function(input, init){
    const res = await prevFetch(input, init);
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url && url.includes("/api/vsp/run_file_allow")){
        const c = res.clone();
        c.json().then(j=>{
          if (j && typeof j === "object" && (j.by_tool || j.counts_total || j.overall || j.overall_status)){
            window.__vsp_gate_latest_v4b = j;
            applyGate(j);
          }
        }).catch(()=>{});
      }
    }catch(e){}
    return res;
  };

  setInterval(()=>{ try{ if (window.__vsp_gate_latest_v4b) applyGate(window.__vsp_gate_latest_v4b); }catch(e){} }, 900);

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V4B apply DOM: Run overall + tool badge normalize");
})();

/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V4B */



/* VSP_P1_GATE_STORY_AUTOFETCH_GATE_V5
   - poll /api/vsp/runs -> get latest rid -> fetch /api/vsp/run_file_allow?rid=...&path=run_gate.json
   - triggers existing DOM apply hooks (V3/V4B) because run_file_allow fetch happens
*/
(()=> {
  if (window.__vsp_p1_gate_story_autofetch_gate_v5) return;
  window.__vsp_p1_gate_story_autofetch_gate_v5 = true;

  const BASE = ""; // same-origin
  const RUNS_URL = BASE + "/api/vsp/runs?limit=1&offset=0";
  const POLL_MS = 8000;

  let lastRid = "";
  let inflight = false;

  async function fetchJson(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error("HTTP "+r.status+" "+url);
    return await r.json();
  }

  async function tick(){
    if (document.hidden) return;
    if (inflight) return;
    inflight = true;
    try{
      const j = await fetchJson(RUNS_URL);
      const it = (j && j.items && j.items[0]) ? j.items[0] : {};
      const rid = (it.rid || it.run_id || "").toString();
      if (rid && rid !== lastRid){
        lastRid = rid;
        const gateUrl = BASE + "/api/vsp/run_file_allow?rid=" + encodeURIComponent(rid) +
                        "&path=" + encodeURIComponent("run_gate.json");
        console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V5 fetch gate:", rid);
        // this will be captured by V3/V4B fetch hook and applied to DOM
        fetch(gateUrl, { cache: "no-store" }).catch(()=>{});
      }
    }catch(e){
      console.warn("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V5 tick err:", e && e.message ? e.message : e);
    }finally{
      inflight = false;
    }
  }

  // kick immediately + interval
  setTimeout(tick, 50);
  setInterval(tick, POLL_MS);

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V5 installed: auto-fetch run_gate.json from latest RID");
})();

/* VSP_P1_GATE_STORY_AUTOFETCH_GATE_V5 */



/* VSP_P1_GATE_STORY_RUN_OVERALL_TEXTNODE_FIX_V6
   - Update "Run overall" using TEXT NODE walker (works even if split spans)
   - Reads latest gate from __vsp_gate_latest_v4b (set by V4B) or tries __vsp_gate_latest_v3
*/
(()=> {
  if (window.__vsp_p1_gate_story_run_overall_textnode_fix_v6) return;
  window.__vsp_p1_gate_story_run_overall_textnode_fix_v6 = true;

  const norm = (x)=> (x||"").toString().trim().toUpperCase();
  const STATUSES = ["UNKNOWN","GREEN","AMBER","RED"];

  function getOverall(){
    const g = window.__vsp_gate_latest_v4b || window.__vsp_gate_latest_v3 || window.__vsp_gate_latest_v3 || null;
    return g ? norm(g.overall || g.overall_status) : "";
  }

  function patchTextNodes(ov){
    if (!ov) return 0;
    let n=0;
    try{
      const w = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
      let node;
      while ((node = w.nextNode())) {
        const t = node.nodeValue || "";
        if (t.includes("Run overall:")) {
          const t2 = t.replace(/Run overall:\s*(UNKNOWN|GREEN|AMBER|RED)/i, "Run overall: " + ov);
          if (t2 !== t) { node.nodeValue = t2; n++; }
        }
      }
    }catch(e){}
    return n;
  }

  function patchSplitSpans(ov){
    if (!ov) return 0;
    let n=0;
    try{
      // Find containers that mention "Run overall" and flip any child that is a status token
      const nodes = Array.from(document.querySelectorAll("*"))
        .filter(el => (el.textContent||"").includes("Run overall"));
      for (const el of nodes.slice(0,30)){
        const kids = el.querySelectorAll("span,div,b,i,strong,small");
        for (const k of kids){
          const tx = norm(k.textContent);
          if (STATUSES.includes(tx)) {
            k.textContent = ov;
            n++;
          }
        }
      }
    }catch(e){}
    return n;
  }

  function tick(){
    const ov = getOverall();
    if (!ov) return;
    const a = patchTextNodes(ov);
    const b = patchSplitSpans(ov);
    // only log once when we successfully patched something
    if ((a+b) > 0 && !window.__vsp_p1_gate_story_run_overall_textnode_fix_v6_logged){
      window.__vsp_p1_gate_story_run_overall_textnode_fix_v6_logged = true;
      console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V6 patched Run overall =>", ov, "nodes=", (a+b));
    }
  }

  setInterval(tick, 500);
  setTimeout(tick, 80);
  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V6 installed: Run overall textnode patcher");
})();

/* VSP_P1_GATE_STORY_RUN_OVERALL_TEXTNODE_FIX_V6 */



/* VSP_P1_GATE_STORY_TOOL_TRUTH_V7C (SAFE)
   - DO NOT brute-force rewrite random text nodes
   - Render a dedicated strip container + only update single-tool badges
*/
(()=> {
  if (window.__vsp_p1_gate_story_tool_truth_v7c) return;
  window.__vsp_p1_gate_story_tool_truth_v7c = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];
  const TOKENS = ["GREEN","AMBER","RED","UNKNOWN","MISSING","DEGRADED"];
  const norm = (x)=> (x||"").toString().trim().toUpperCase();

  function getGate(){
    return window.__vsp_gate_latest_v4b
        || window.__vsp_gate_latest_v6
        || window.__vsp_gate_latest_v5
        || window.__vsp_gate_latest_v3
        || window.__vsp_gate_latest
        || null;
  }

  function statusFromCounts(ct){
    ct = ct || {};
    const c=(ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0);
    const l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h>0) return "RED";
    if (m>0) return "AMBER";
    if (l+i+t>0) return "GREEN";
    return "UNKNOWN";
  }

  function mapVerdict(x){
    x = norm(x);
    if (!x) return "";
    if (["OK","PASS","GREEN"].includes(x)) return "GREEN";
    if (["WARN","WARNING","AMBER"].includes(x)) return "AMBER";
    if (["FAIL","FAILED","BLOCK","BLOCKED","ERROR","RED"].includes(x)) return "RED";
    if (TOKENS.includes(x)) return x;
    return x;
  }

  function computeToolMap(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const tool of TOOLS){
      const o = bt[tool] || bt[tool.toLowerCase()] || null;
      if (!o){ out[tool] = "MISSING"; continue; }

      const degraded = !!(o.degraded || o.timeout || o.timed_out || o.time_out);
      if (degraded){ out[tool] = "DEGRADED"; continue; }

      let st = mapVerdict(o.verdict || o.status || o.overall || o.verdict_status);
      if (!st || st==="UNKNOWN"){
        st = statusFromCounts(o.counts || o.counts_total || o.totals || {});
      }
      out[tool] = st || "UNKNOWN";
    }
    return out;
  }

  function findGateStoryRoot(){
    // try known hooks first
    let r = document.querySelector("#vsp5") || document.querySelector("#app") || document.body;

    // prefer area around "Gate Story"
    const all = Array.from(document.querySelectorAll("div,section,main,article"));
    for (const el of all){
      const t = (el.textContent||"").trim();
      if (t.startsWith("Gate Story") && t.length < 60) return el.parentElement || el;
    }
    return r;
  }

  function ensureStripContainer(root){
    let box = document.getElementById("vsp_tool_truth_strip_v7c");
    if (box) return box;

    box = document.createElement("div");
    box.id = "vsp_tool_truth_strip_v7c";
    box.style.display = "flex";
    box.style.flexWrap = "wrap";
    box.style.gap = "8px";
    box.style.marginTop = "10px";

    const label = document.createElement("div");
    label.textContent = "Tool truth (V7C):";
    label.style.opacity = "0.85";
    label.style.fontSize = "12px";
    label.style.marginRight = "10px";
    label.style.alignSelf = "center";

    const row = document.createElement("div");
    row.id = "vsp_tool_truth_strip_v7c_row";
    row.style.display = "flex";
    row.style.flexWrap = "wrap";
    row.style.gap = "8px";

    box.appendChild(label);
    box.appendChild(row);

    // insert near the existing "Tool strip (8)" line if possible
    const nodes = Array.from(document.querySelectorAll("div,span,p"));
    let anchor = null;
    for (const el of nodes){
      const tx=(el.textContent||"").trim();
      if (/^Tool strip/i.test(tx)) { anchor = el; break; }
    }
    if (anchor && anchor.parentElement){
      anchor.parentElement.appendChild(box);
    } else {
      root.appendChild(box);
    }
    return box;
  }

  function pill(tool, st){
    const b = document.createElement("span");
    b.textContent = `${tool} - ${st}`;
    b.setAttribute("data-vsp-tool", tool);
    b.setAttribute("data-vsp-status", st);
    b.style.padding = "4px 10px";
    b.style.borderRadius = "999px";
    b.style.fontSize = "12px";
    b.style.border = "1px solid rgba(255,255,255,0.12)";
    b.style.background = "rgba(255,255,255,0.04)";
    b.style.userSelect = "text";
    return b;
  }

  function renderStrip(mp){
    const root = findGateStoryRoot();
    const box = ensureStripContainer(root);
    const row = document.getElementById("vsp_tool_truth_strip_v7c_row");
    if (!row) return;

    // rebuild row
    row.innerHTML = "";
    for (const tool of TOOLS){
      row.appendChild(pill(tool, mp[tool] || "UNKNOWN"));
    }
  }

  function fixSingleToolBadges(mp){
    // only touch elements that look like EXACTLY one tool badge
    const els = Array.from(document.querySelectorAll("button,span,div,a"));
    for (const el of els){
      const txt = (el.textContent||"").trim();
      if (!txt || txt.length > 40) continue;

      // skip if contains 2+ tool keywords
      let hits = 0;
      for (const t of TOOLS) if (txt.toUpperCase().includes(t)) hits++;
      if (hits != 1) continue;

      for (const tool of TOOLS){
        if (!txt.toUpperCase().includes(tool)) continue;
        const st = mp[tool] || "UNKNOWN";

        const re1 = new RegExp("^\\s*"+tool+"\\s*[-:·\\|]\\s*("+TOKENS.join("|")+")\\s*$","i");
        const re2 = new RegExp("^\\s*"+tool+"\\s*$","i");
        if (re1.test(txt)) el.textContent = txt.replace(re1, tool+" - "+st);
        else if (re2.test(txt)) el.textContent = tool+" - "+st;
        el.setAttribute("data-vsp-status", st);
      }
    }
  }

  let lastSig = "";
  function tick(){
    const g = getGate();
    if (!g) return;
    const mp = computeToolMap(g);

    renderStrip(mp);
    fixSingleToolBadges(mp);

    const sig = JSON.stringify(mp);
    if (sig !== lastSig){
      lastSig = sig;
      console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V7C tool truth:", mp);
    }
  }

  setTimeout(tick, 120);
  setInterval(tick, 1200);
  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V7C installed: safe tool truth strip renderer");
})();

/* VSP_P1_GATE_STORY_TOOL_TRUTH_V7C */



/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V1 */
(()=> {
  if (window.__vsp_p1_hide_legacy_strip_v1) return;
  window.__vsp_p1_hide_legacy_strip_v1 = true;

  function tick(){
    const v7c = document.getElementById("vsp_tool_truth_strip_v7c");
    if (!v7c) return;

    // Heuristic: legacy tool strip line often contains "Tool strip" text
    const nodes = Array.from(document.querySelectorAll("div,span,p"));
    for (const el of nodes){
      const tx = (el.textContent||"").trim();
      if (/^Tool strip\s*\(/i.test(tx)){
        el.style.display = "none";
        const parent = el.parentElement;
        if (parent && parent.children && parent.children.length <= 3){
          // hide the whole legacy block if it's just label+badges
          parent.style.display = "none";
        }
      }
    }
  }
  setTimeout(tick, 200);
  setInterval(tick, 1500);
  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] hide legacy tool strip when V7C present");
})();

/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V1 */



/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V2 */
(()=> {
  if (window.__vsp_p1_hide_legacy_strip_v2) return;
  window.__vsp_p1_hide_legacy_strip_v2 = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];

  function toolHits(txt){
    txt = (txt||"");
    let h=0;
    for (const t of TOOLS) if (txt.includes(t)) h++;
    return h;
  }

  function isLegacyBadgeRow(el, v7c){
    if (!el || !el.textContent) return false;
    if (el === v7c) return false;
    if (v7c && (v7c.contains(el) || el.contains(v7c))) return false;

    const tx = (el.textContent||"").trim();
    if (!tx) return false;
    if (tx.includes("Tool truth")) return false; // đừng đụng V7C
    // row badge thường chứa nhiều tool names
    return toolHits(tx) >= 4;
  }

  function hideLegacy(){
    const v7c = document.getElementById("vsp_tool_truth_strip_v7c");
    if (!v7c) return;

    // 1) hide label "Tool strip..."
    for (const el of Array.from(document.querySelectorAll("div,span,p,strong,small"))){
      const tx = (el.textContent||"").trim();
      if (/^Tool\s*strip\b/i.test(tx)){
        el.style.display="none";
        if (el.parentElement) el.parentElement.style.display="none";
      }
    }

    // 2) hide legacy badge row(s) that appear BEFORE v7c in DOM order
    const candidates = Array.from(document.querySelectorAll("div,section,article,span"));
    let hidden=0;
    for (const el of candidates){
      if (!isLegacyBadgeRow(el, v7c)) continue;

      // el is before v7c?
      const rel = el.compareDocumentPosition(v7c);
      const elIsBefore = (rel & Node.DOCUMENT_POSITION_FOLLOWING) !== 0;

      if (elIsBefore){
        el.style.display="none";
        hidden++;
      }
    }

    if (!window.__vsp_p1_hide_legacy_strip_v2_logged){
      window.__vsp_p1_hide_legacy_strip_v2_logged = true;
      console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] hide legacy strip V2: hidden=", hidden);
    }
  }

  setTimeout(hideLegacy, 150);
  setTimeout(hideLegacy, 600);
  setInterval(hideLegacy, 2000);
})();

/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V2 */


/* VSP_P1_HIDE_LEGACY_STRIP_BY_ID_V3B */
(()=> {
  try{
    if (window.__vsp_hide_legacy_by_id_v3b) return;
    window.__vsp_hide_legacy_by_id_v3b = true;

    const hide = ()=>{
      const el = document.getElementById('vsp_tool_strip_legacy');
      if (el) { el.style.display='none'; el.setAttribute('data-hidden','1'); }
    };

    setTimeout(hide, 50);
    setTimeout(hide, 250);
    setTimeout(hide, 900);
    setInterval(hide, 2500);

    console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V3B hide legacy by id installed");
  }catch(e){
    console.warn("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V3B hide legacy failed:", e);
  }
})();


/* VSP_P1_GATE_STORY_REWIRE_ALLOW_EVERYWHERE_V8 */
console.log('[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V8 rewire allow everywhere applied');


/* VSP_P1_GATE_STORY_FETCH_FALLBACK_LASTGOOD_V9
   If latest RID has no gate artifact -> auto fallback to last_good RID stored in localStorage.
*/
(()=> {
  if (window.__vsp_gate_story_lastgood_v9) return;
  window.__vsp_gate_story_lastgood_v9 = true;

  const LS_KEY = "vsp_last_good_gate_rid_v1";

  function isGateUrl(u){
    try{
      const url = new URL(u, window.location.origin);
      if (!url.pathname.includes("/api/vsp/run_file_allow")) return false;
      const path = (url.searchParams.get("path")||"");
      return /run_gate(_summary)?\.json$/i.test(path);
    }catch(e){ return false; }
  }
  function getRid(u){
    try{ return new URL(u, window.location.origin).searchParams.get("rid")||""; }catch(e){ return ""; }
  }
  function setLastGood(rid){
    if (!rid) return;
    try{ localStorage.setItem(LS_KEY, rid); }catch(e){}
  }
  function getLastGood(){
    try{ return localStorage.getItem(LS_KEY)||""; }catch(e){ return ""; }
  }
  function swapRid(u, rid){
    const url = new URL(u, window.location.origin);
    url.searchParams.set("rid", rid);
    return url.toString();
  }

  const _fetch = window.fetch.bind(window);
  window.fetch = async (input, init) => {
    const url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
    if (!url || !isGateUrl(url)) return _fetch(input, init);

    const rid = getRid(url);
    const lastGood = getLastGood();

    // try original
    const r1 = await _fetch(input, init);
    if (r1 && r1.ok) {
      // mark last good on ok
      setLastGood(rid);
      return r1;
    }

    // fallback if we have last good
    if (lastGood && lastGood !== rid) {
      const u2 = swapRid(url, lastGood);
      console.warn("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1][V9] gate fetch failed for rid=", rid, "=> fallback to last_good=", lastGood);
      // NOTE: if input is Request, we rebuild a Request
      if (typeof input === "string") return _fetch(u2, init);
      try{
        const req2 = new Request(u2, input);
        return _fetch(req2, init);
      }catch(e){
        return _fetch(u2, init);
      }
    }

    return r1;
  };

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V9 installed: fetch fallback to last_good RID");
})();



/* VSP_P1_GATE_STORY_AUTOPICK_GATEJSON_HIDE_LEGACY_V10 */
(()=> {
  if (window.__vsp_gate_story_v10) return;
  window.__vsp_gate_story_v10 = true;
  const TAG = "[GateStoryV10]";
  const TOOL_ORDER = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];
  const GATE_PATHS = ["run_gate_summary.json","run_gate.json","reports/run_gate_summary.json","reports/run_gate.json"];

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  function findGatePanel(){
    // find element whose text is exactly "Gate Story", then pick a reasonable container
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(n => n && n.childElementCount===0 && (n.textContent||"").trim()==="Gate Story");
    for (const n of nodes){
      const box = n.closest("div");
      if (box) return box;
    }
    return document.body;
  }

  function hideLegacyToolStrip(){
    // Hide any block that contains "Tool strip" label + its badge row (next sibling)
    const all = Array.from(document.querySelectorAll("*"));
    for (const el of all){
      const t = (el.textContent||"").trim();
      if (!t) continue;
      if (/^Tool strip\s*\(/i.test(t) || t==="Tool strip" || t.startsWith("Tool strip ")){
        const parent = el.parentElement;
        if (parent) parent.style.display = "none";
        const next = parent ? parent.nextElementSibling : el.nextElementSibling;
        if (next && next.querySelectorAll && next.querySelectorAll("span,button,div").length>=3){
          next.style.display = "none";
        }
      }
    }
    // Also hide the older concatenated strip line if exists (defensive)
    const bad = all.filter(el => (el.textContent||"").includes("BANDIT -") && (el.textContent||"").includes("SEMGREP -") && el.childElementCount===0);
    for (const el of bad){
      const parent = el.parentElement;
      if (parent) parent.style.display = "none";
      else el.style.display = "none";
    }
    console.log(TAG, "hideLegacyToolStrip done");
  }

  async function fetchGateJsonStrict(rid){
    for (const path of GATE_PATHS){
      const url = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=${encodeURIComponent(path)}`;
      let r;
      try{
        r = await fetch(url, {cache:"no-store"});
      }catch(e){
        continue;
      }
      if (!r || !r.ok) continue;

      const ct = (r.headers.get("content-type")||"").toLowerCase();
      if (!ct.includes("application/json")){
        // Important: run_file_allow may "fallback" to SUMMARY.txt as text/plain -> treat as missing
        console.warn(TAG, "non-json gate response => treat missing", {rid, path, ct});
        continue;
      }
      try{
        const j = await r.json();
        if (j && typeof j === "object" && (j.overall || j.overall_status) && (j.by_tool || j.counts_total)){
          return { rid, path, gate: j };
        }
      }catch(e){
        console.warn(TAG, "json parse failed", {rid, path, e});
      }
    }
    return null;
  }

  async function pickLastGoodGate(){
    // scan recent runs and pick the first RID that has real gate JSON
    const runsUrl = "/api/vsp/runs?limit=120&offset=0";
    let data = null;
    try{
      const r = await fetch(runsUrl, {cache:"no-store"});
      if (!r.ok) return null;
      data = await r.json();
    }catch(e){
      return null;
    }
    const items = data?.items || data?.runs || [];
    for (const it of items){
      const rid = it?.run_id || it?.rid || it?.id;
      if (!rid) continue;
      const g = await fetchGateJsonStrict(rid);
      if (g) return g;
      await sleep(10);
    }
    return null;
  }

  function setTextStartsWith(prefix, newText){
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(n => n && n.childElementCount===0 && ((n.textContent||"").trim().startsWith(prefix)));
    if (nodes[0]) nodes[0].textContent = newText;
  }

  function renderToolTruth(panel, gateObj){
    const overall = (gateObj.overall || gateObj.overall_status || "UNKNOWN");
    const byTool = gateObj.by_tool || {};

    // Update "RID:" and "Run overall:"
    // (RID is on screen already; we update to picked rid in caller)
    setTextStartsWith("Run overall:", `Run overall: ${overall}`);

    // Update the overall pill if we can find it
    const candidates = Array.from(document.querySelectorAll("span,div,button"))
      .filter(n => /^(UNKNOWN|RED|AMBER|GREEN)$/i.test(((n.textContent||"").trim())) );
    // prefer one that lives inside the Gate panel
    const pill = candidates.find(n => panel.contains(n));
    if (pill) pill.textContent = overall;

    // Render a dedicated strip (V10)
    let box = document.getElementById("vsp_gate_story_tool_truth_v10");
    if (!box){
      box = document.createElement("div");
      box.id = "vsp_gate_story_tool_truth_v10";
      box.style.marginTop = "10px";
      box.style.paddingTop = "8px";
      box.style.borderTop = "1px solid rgba(255,255,255,0.10)";
      panel.appendChild(box);
    }
    box.innerHTML = "";

    const title = document.createElement("div");
    title.textContent = "Tool truth (Gate JSON V10):";
    title.style.fontSize = "12px";
    title.style.opacity = "0.85";
    title.style.marginBottom = "6px";
    box.appendChild(title);

    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.flexWrap = "wrap";
    row.style.gap = "6px";
    box.appendChild(row);

    for (const t of TOOL_ORDER){
      const o = byTool[t] || {};
      const v = (o.verdict || o.status || "MISSING");
      const chip = document.createElement("span");
      chip.textContent = `${t}: ${v}`;
      chip.style.padding = "4px 10px";
      chip.style.borderRadius = "999px";
      chip.style.border = "1px solid rgba(255,255,255,0.14)";
      chip.style.fontSize = "12px";
      chip.style.lineHeight = "16px";
      row.appendChild(chip);
    }
  }

  async function main(){
    const panel = findGatePanel();
    hideLegacyToolStrip();

    const picked = await pickLastGoodGate();
    if (!picked){
      console.warn(TAG, "no gate JSON found in recent runs");
      return;
    }

    // Update RID line on screen
    setTextStartsWith("RID:", `RID: ${picked.rid}`);
    console.log(TAG, "picked last-good gate", picked.rid, "path=", picked.path);

    renderToolTruth(panel, picked.gate);
  }

  // run after other patches executed
  setTimeout(main, 250);
})();

