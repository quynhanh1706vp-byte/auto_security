/* VSP_P1_FORCE_XHR_RUNS_V1 20251219_191524 */
(function(){
  if (window.__VSP_P1_FORCE_XHR_RUNS_V1__) return;
  window.__VSP_P1_FORCE_XHR_RUNS_V1__ = true;

  function xhrGet(url){
    return new Promise(function(resolve, reject){
      try{
        var x = new XMLHttpRequest();
        x.open('GET', url, true);
        try { x.setRequestHeader('Cache-Control', 'no-store'); } catch(_){}
        x.onreadystatechange = function(){
          if (x.readyState !== 4) return;
          resolve({ status: x.status || 0, text: x.responseText || '' });
        };
        x.onerror = function(){ reject(new Error('xhr error')); };
        x.send(null);
      }catch(e){ reject(e); }
    });
  }

  var origFetch = window.fetch ? window.fetch.bind(window) : null;

  window.fetch = function(input, init){
    var url = (typeof input === 'string') ? input : (input && input.url) ? input.url : (''+input);
    if (url.indexOf('/api/vsp/runs') !== -1){
      return xhrGet(url).then(function(r){
        var status = r.status || 503;
        try{
          return new Response(r.text, {
            status: status,
            headers: {
              'content-type': 'application/json; charset=utf-8',
              'cache-control': 'no-store'
            }
          });
        }catch(e){
          // ultra-safe fallback (should not happen)
          return {
            ok: status >= 200 && status < 300,
            status: status,
            json: function(){ return Promise.resolve(JSON.parse(r.text || '{}')); },
            text: function(){ return Promise.resolve(r.text || ''); }
          };
        }
      }).catch(function(err){
        if (origFetch) return origFetch(input, init);
        throw err;
      });
    }
    return origFetch ? origFetch(input, init) : Promise.reject(new Error('fetch missing'));
  };
})();

/* VSP_P1_FETCH_HARDENER_COMMERCIAL_V1 20251219_180634 */
(function(){
  try{
    if (window.__VSP_P1_FETCH_HARDENER_COMMERCIAL_V1__) return;
    window.__VSP_P1_FETCH_HARDENER_COMMERCIAL_V1__ = true;

    const _fetch = (window.fetch && window.fetch.bind) ? window.fetch.bind(window) : null;
    if (!_fetch) return;

    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    function isTarget(url){
      try{
        if(!url) return false;
        return (
          url.indexOf("/api/vsp/runs") >= 0 ||
          url.indexOf("/api/vsp/dash") >= 0 ||
          url.indexOf("/api/vsp/dashboard") >= 0 ||
          url.indexOf("/api/vsp/summary") >= 0
        );
      }catch(e){ return false; }
    }

    async function hardFetch(input, init){
      let url = "";
      try{
        url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      }catch(e){ url=""; }

      if(!isTarget(url)) return _fetch(input, init);

      // Only harden GET-like calls
      const baseInit = Object.assign({cache:"no-store", credentials:"same-origin"}, init||{});
      const method = (baseInit.method || "GET").toUpperCase();
      if(method !== "GET" && method !== "HEAD") return _fetch(input, init);

      try{
        baseInit.headers = Object.assign({"Cache-Control":"no-store","Pragma":"no-cache"}, baseInit.headers||{});
      }catch(e){}

      let lastResp = null;
      let lastErr = null;

      // Retry up to 4 times, backoff 200/400/600/800ms
      for(let i=0;i<4;i++){
        try{
          const r = await _fetch(url, baseInit);
          lastResp = r;
          if(r && r.status < 500) return r;
        }catch(e){
          lastErr = e;
        }
        await sleep(200*(i+1));
      }

      if(lastResp) return lastResp;

      // Degraded synthetic response (keeps UI alive)
      const body = JSON.stringify({
        ok: true,
        rid_latest: null,
        items: [],
        degraded: true,
        error: String(lastErr || "runs_fetch_failed")
      });
      try{
        return new Response(body, {
          status: 200,
          headers: {
            "Content-Type":"application/json; charset=utf-8",
            "Cache-Control":"no-store",
            "X-VSP-DEGRADED":"1"
          }
        });
      }catch(e){
        return _fetch(url, baseInit); // last resort
      }
    }

    window.fetch = hardFetch;
  }catch(e){}
})();

/* VSP_P1_PRELOAD_DISABLE_CACHED_RID_V1 20251219_175959
   Force UI to ignore cached RID in localStorage so it must follow /api/vsp/runs rid_latest.
*/
(function(){
  try{
    const K = new Set(['vsp_active_rid','vsp_latest_rid','vsp_selected_rid','vsp_rid','rid','rid_latest']);
    // clear once (best-effort)
    for(const k of K){ try{ localStorage.removeItem(k); }catch(e){} }
    // override Storage.getItem globally
    const _get = Storage.prototype.getItem;
    Storage.prototype.getItem = function(k){
      if(K.has(String(k))) return null;
      return _get.call(this, k);
    };
  }catch(e){}
})();

/* VSP_P1_PAGE_BOOT_V1
 * P1 bootstrap for standalone pages: /, /data_source, /settings, /rule_overrides
 * Contract:
 *  - GET /api/vsp/runs?limit=1  -> latest RID
 *  - GET /api/vsp/run_file?rid=RID&name=reports/<file>
 *  - GET /api/vsp/rule_overrides (optional UI v1 endpoint if exists)
 *  - GET settings endpoints (best-effort) -> render JSON
 */
(function(){
  "use strict";

  const MARK="VSP_P1_PAGE_BOOT_V1";
  if (window.__VSP_P1_BOOTED__) return;
  window.__VSP_P1_BOOTED__ = true;

  const $ = (sel, root=document) => root.querySelector(sel);
  const el = (tag, attrs={}, html="") => {
    const n=document.createElement(tag);
    for(const k of Object.keys(attrs||{})) n.setAttribute(k, attrs[k]);
    if(html) n.innerHTML=html;
    return n;
  };

  function ensureStyle(){
    if (document.getElementById("vsp-p1-style")) return;
    const s = el("style",{id:"vsp-p1-style"},`
      .vsp-p1-wrap{max-width:1200px;margin:18px auto;padding:0 14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;}
      .vsp-p1-card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:14px 14px;margin:12px 0;box-shadow:0 10px 30px rgba(0,0,0,.18)}
      .vsp-p1-row{display:flex;gap:12px;flex-wrap:wrap;align-items:stretch}
      .vsp-p1-kpi{flex:1;min-width:200px}
      .vsp-p1-kpi b{display:block;font-size:18px;margin-top:4px}
      .vsp-p1-muted{opacity:.78;font-size:12px}
      .vsp-p1-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;white-space:pre-wrap;word-break:break-word}
      .vsp-p1-input{width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:inherit}
      .vsp-p1-table{width:100%;border-collapse:collapse;font-size:12px}
      .vsp-p1-table th,.vsp-p1-table td{border-bottom:1px solid rgba(255,255,255,.08);padding:8px 8px;vertical-align:top}
      .vsp-p1-pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08)}
      .vsp-p1-badge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.16)}
    `);
    document.head.appendChild(s);
  }

  async function fetchJson(url, ms=12000){
    const ctl = new AbortController();
    const t = setTimeout(()=>ctl.abort(), ms);
    try{
      const r = await fetch(url, {signal: ctl.signal, credentials:"same-origin"});
      if(!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  }

  function esc(s){ return (""+s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m])); }

  async function getLatestRid(){
    // VSP_P1_RID_CACHE_ANTI503_V1
    // Prefer cached RID to avoid poll-guard 503 on /api/vsp/runs
    try{
      const cached = sessionStorage.getItem("vsp_latest_rid") || "";
      const ts = parseInt(sessionStorage.getItem("vsp_latest_rid_ts") || "0", 10);
      if(cached && ts && (Date.now()-ts) < 30000) return cached; // 30s cache
    }catch(_e){}

    // If /vsp5 page already stored something
    try{
      if(window.__VSP_LAST_RID__ && String(window.__VSP_LAST_RID__).length>5){
        const r = String(window.__VSP_LAST_RID__);
        try{ sessionStorage.setItem("vsp_latest_rid", r); sessionStorage.setItem("vsp_latest_rid_ts", String(Date.now())); }catch(_e){}
        return r;
      }
    }catch(_e){}

    // Try fetch latest RID
    try{
      const data = await fetchJson("/api/vsp/runs?limit=1");
      const rid = data && data.items && data.items[0] && data.items[0].run_id ? data.items[0].run_id : "";
      if(rid){
        try{ sessionStorage.setItem("vsp_latest_rid", rid); sessionStorage.setItem("vsp_latest_rid_ts", String(Date.now())); }catch(_e){}
        return rid;
      }
    }catch(_e){
      // fallback: use any cached RID even if stale (avoid hard fail on 503)
      try{
        const cached = sessionStorage.getItem("vsp_latest_rid") || "";
        if(cached) return cached;
      }catch(__e){}
      throw _e;
    }
    throw new Error("no rid");
  }

  async function getRunFileJson(rid, name){
    const q = encodeURIComponent(name);
    const url = `/api/vsp/run_file?rid=${encodeURIComponent(rid)}&name=${q}`;
    return await fetchJson(url);
  }

  function pick(obj, keys){
    for(const k of keys){
      if(obj && Object.prototype.hasOwnProperty.call(obj,k) && obj[k] !== undefined && obj[k] !== null) return obj[k];
    }
    return null;
  }

  function normSev(x){
    const s=(x||"").toString().toUpperCase();
    if(["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"].includes(s)) return s;
    if(s==="WARN"||s==="WARNING") return "LOW";
    if(s==="ERROR") return "HIGH";
    return s || "INFO";
  }

  function mountRoot(){
    ensureStyle();
    let root = document.getElementById("vsp-p1-root");
    if(!root){
      root = el("div",{id:"vsp-p1-root", class:"vsp-p1-wrap"});
      // put near top of body but after nav if exists
      const nav = document.getElementById("vspNav5");
      if(nav && nav.parentNode) nav.parentNode.insertBefore(root, nav.nextSibling);
      else document.body.insertBefore(root, document.body.firstChild);
    }
    return root;
  }

  async function bootDashboard(){
    const root = mountRoot();
    root.innerHTML = "";
    const h = el("div",{class:"vsp-p1-card"},`<div class="vsp-p1-muted">${MARK} • Dashboard</div><div style="font-weight:900;font-size:20px;margin-top:6px">Dashboard (P1)</div>`);
    root.appendChild(h);

    const card = el("div",{class:"vsp-p1-card"});
    card.innerHTML = `<div class="vsp-p1-muted">Loading latest RID + gate summary…</div>`;
    root.appendChild(card);

    try{
      const rid = await getLatestRid();
      if(!rid) throw new Error("no rid");
      const gate = await getRunFileJson(rid, "reports/run_gate_summary.json").catch(()=>null);
      const findings = await getRunFileJson(rid, "reports/findings_unified.json").catch(()=>null);

      const overall = gate ? (pick(gate, ["overall_status","overall","verdict","status"]) || pick(gate.gate||{}, ["overall","overall_status","verdict","status"])) : null;

      // severity counts (best effort)
      const sevCnt = {CRITICAL:0,HIGH:0,MEDIUM:0,LOW:0,INFO:0,TRACE:0};
      const toolCnt = {};
      let total = 0;

      const arr = (findings && (findings.items||findings.findings||findings.results||findings.data)) || (Array.isArray(findings)?findings:[]);
      if(Array.isArray(arr)){
        for(const it of arr){
          total++;
          const sev = normSev(pick(it, ["severity","sev","level","priority"]) || "INFO");
          if(sevCnt[sev]===undefined) sevCnt[sev]=0;
          sevCnt[sev]++;
          const tool = (pick(it, ["tool","scanner","engine","source"]) || "unknown").toString();
          toolCnt[tool]=(toolCnt[tool]||0)+1;
        }
      }

      const topTools = Object.entries(toolCnt).sort((a,b)=>b[1]-a[1]).slice(0,8);

      card.innerHTML = `
        <div class="vsp-p1-muted">Latest RID</div>
        <div class="vsp-p1-mono">${esc(rid)}</div>
        <div class="vsp-p1-row" style="margin-top:10px">
          <div class="vsp-p1-card vsp-p1-kpi">
            <div class="vsp-p1-muted">Overall</div>
            <b>${esc(overall || "N/A")}</b>
          </div>
          <div class="vsp-p1-card vsp-p1-kpi">
            <div class="vsp-p1-muted">Findings total</div>
            <b>${total}</b>
          </div>
          <div class="vsp-p1-card vsp-p1-kpi">
            <div class="vsp-p1-muted">CRITICAL / HIGH</div>
            <b>${sevCnt.CRITICAL} / ${sevCnt.HIGH}</b>
          </div>
          <div class="vsp-p1-card vsp-p1-kpi">
            <div class="vsp-p1-muted">MED / LOW</div>
            <b>${sevCnt.MEDIUM} / ${sevCnt.LOW}</b>
          </div>
        </div>

        <div class="vsp-p1-card" style="margin-top:12px">
          <div class="vsp-p1-muted">Top tools</div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            ${topTools.map(([k,v])=>`<span class="vsp-p1-badge">${esc(k)}: <b>${v}</b></span>`).join("") || `<span class="vsp-p1-muted">N/A</span>`}
          </div>
        </div>

        <details class="vsp-p1-card" style="margin-top:12px">
          <summary style="cursor:pointer;font-weight:700">Raw gate summary (json)</summary>
          <pre class="vsp-p1-mono">${esc(JSON.stringify(gate||{}, null, 2))}</pre>
        </details>
      `;
    }catch(e){
      card.innerHTML = `<div class="vsp-p1-muted">Failed to load dashboard data</div><pre class="vsp-p1-mono">${esc(e && e.message ? e.message : String(e))}</pre>`;
    }
  }

  async function bootDataSource(){
    const root = mountRoot();
    root.innerHTML = "";
    root.appendChild(el("div",{class:"vsp-p1-card"},`<div class="vsp-p1-muted">${MARK} • Data Source</div><div style="font-weight:900;font-size:20px;margin-top:6px">Data Source (P1)</div>`));

    const card = el("div",{class:"vsp-p1-card"},`<div class="vsp-p1-muted">Loading findings_unified.json…</div>`);
    root.appendChild(card);

    try{
      const rid = await getLatestRid();
      if(!rid) throw new Error("no rid");
      const findings = await getRunFileJson(rid, "reports/findings_unified.json");
      const arr = (findings && (findings.items||findings.findings||findings.results||findings.data)) || (Array.isArray(findings)?findings:[]);
      if(!Array.isArray(arr)) throw new Error("findings not array-like");

      const input = el("input",{class:"vsp-p1-input", placeholder:"Search (severity/tool/rule/file/message)…"});
      const tableWrap = el("div",{style:"overflow:auto;border-radius:14px"});
      const table = el("table",{class:"vsp-p1-table"});
      table.innerHTML = `<thead><tr>
        <th>Severity</th><th>Tool</th><th>Rule</th><th>File</th><th>Message</th>
      </tr></thead><tbody></tbody>`;
      const tb = table.querySelector("tbody");

      function rowObj(it){
        const sev = normSev(pick(it, ["severity","sev","level","priority"]) || "INFO");
        const tool = pick(it, ["tool","scanner","engine","source"]) || "";
        const rule = pick(it, ["rule_id","check_id","id","rule","name"]) || "";
        const file = pick(it, ["path","file","filename","location","target"]) || "";
        const msg  = pick(it, ["message","title","desc","description","summary"]) || "";
        return {sev, tool, rule, file, msg, raw: it};
      }

      const rows = arr.slice(0, 5000).map(rowObj); // P1 guard
      function render(filter){
        const q=(filter||"").toLowerCase().trim();
        tb.innerHTML="";
        let shown=0;
        for(const r of rows){
          const hay = `${r.sev} ${r.tool} ${r.rule} ${r.file} ${r.msg}`.toLowerCase();
          if(q && !hay.includes(q)) continue;
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><span class="vsp-p1-pill">${esc(r.sev)}</span></td>
            <td>${esc(r.tool)}</td>
            <td class="vsp-p1-mono">${esc(r.rule)}</td>
            <td class="vsp-p1-mono">${esc(r.file)}</td>
            <td>${esc(r.msg)}</td>
          `;
          tr.style.cursor="pointer";
          tr.addEventListener("click", ()=>{
            const d = document.getElementById("vsp-p1-detail");
            if(d) d.remove();
            const det = el("div",{id:"vsp-p1-detail", class:"vsp-p1-card"},`
              <div class="vsp-p1-muted">Detail</div>
              <pre class="vsp-p1-mono">${esc(JSON.stringify(r.raw, null, 2))}</pre>
            `);
            root.appendChild(det);
            det.scrollIntoView({behavior:"smooth", block:"start"});
          });
          tb.appendChild(tr);
          shown++;
          if(shown>=1500) break; // P1 guard
        }
        cnt.innerHTML = `<span class="vsp-p1-muted">RID:</span> <span class="vsp-p1-mono">${esc(rid)}</span>
          <span class="vsp-p1-muted" style="margin-left:10px">rows:</span> <b>${shown}</b> / ${rows.length}`;
      }

      const cnt = el("div",{class:"vsp-p1-muted", style:"margin-top:10px"});
      input.addEventListener("input", ()=>render(input.value));

      card.innerHTML="";
      card.appendChild(input);
      card.appendChild(cnt);
      tableWrap.appendChild(table);
      card.appendChild(tableWrap);

      render("");
    }catch(e){
      card.innerHTML = `<div class="vsp-p1-muted">Failed to load datasource</div><pre class="vsp-p1-mono">${esc(e && e.message ? e.message : String(e))}</pre>`;
    }
  }

  async function bootSettings(){
    const root = mountRoot();
    root.innerHTML = "";
    root.appendChild(el("div",{class:"vsp-p1-card"},`<div class="vsp-p1-muted">${MARK} • Settings</div><div style="font-weight:900;font-size:20px;margin-top:6px">Settings (P1)</div>`));

    const card = el("div",{class:"vsp-p1-card"},`<div class="vsp-p1-muted">Loading settings (best effort)…</div>`);
    root.appendChild(card);

    const endpoints = ["/api/vsp/settings_ui_v1","/api/vsp/settings/get","/api/vsp/settings"];
    let data = null, used = "";

    for(const ep of endpoints){
      try{ data = await fetchJson(ep, 8000); used = ep; break; }catch(_e){}
    }
    if(!data){
      data = { ok:false, note:"No settings endpoint detected. This is P1 read-only skeleton.", endpoints_tried:endpoints };
      used = "none";
    }

    card.innerHTML = `
      <div class="vsp-p1-muted">Source: <span class="vsp-p1-mono">${esc(used)}</span></div>
      <div class="vsp-p1-card" style="margin-top:10px">
        <div class="vsp-p1-muted">P1 note</div>
        <div>Save chưa cần backend. Khi có POST /api/vsp/settings, chỉ cần gửi payload JSON từ UI.</div>
      </div>
      <details class="vsp-p1-card" style="margin-top:10px" open>
        <summary style="cursor:pointer;font-weight:700">Settings JSON</summary>
        <pre class="vsp-p1-mono">${esc(JSON.stringify(data, null, 2))}</pre>
      </details>
    `;
  }

  async function bootRuleOverrides(){
    const root = mountRoot();
    root.innerHTML = "";
    root.appendChild(el("div",{class:"vsp-p1-card"},`<div class="vsp-p1-muted">${MARK} • Rule Overrides</div><div style="font-weight:900;font-size:20px;margin-top:6px">Rule Overrides (P1)</div>`));

    const card = el("div",{class:"vsp-p1-card"},`<div class="vsp-p1-muted">Loading /api/vsp/rule_overrides…</div>`);
    root.appendChild(card);

    const endpoints = ["/api/vsp/rule_overrides_ui_v1","/api/vsp/rule_overrides"];
    let data=null, used="";
    for(const ep of endpoints){
      try{ data = await fetchJson(ep, 8000); used=ep; break; }catch(_e){}
    }
    if(!data){
      data = { ok:false, note:"Cannot load rule_overrides. Check backend endpoint.", endpoints_tried:endpoints };
      used="none";
    }

    card.innerHTML = `
      <div class="vsp-p1-muted">Source: <span class="vsp-p1-mono">${esc(used)}</span></div>
      <details class="vsp-p1-card" style="margin-top:10px" open>
        <summary style="cursor:pointer;font-weight:700">Rule overrides JSON</summary>
        <pre class="vsp-p1-mono">${esc(JSON.stringify(data, null, 2))}</pre>
      </details>
    `;
  }

  function route(){
    const p = (location.pathname || "/").toLowerCase();
    if(p === "/" || p.includes("dashboard")) return "dashboard";
    if(p.includes("data_source") || p.includes("datasource")) return "datasource";
    if(p.includes("settings")) return "settings";
    if(p.includes("rule_overrides") || p.includes("rules")) return "rules";
    return "dashboard";
  }

  // Boot after DOM
  function main(){
    const r = route();
    if(r==="dashboard") return bootDashboard();
    if(r==="datasource") return bootDataSource();
    if(r==="settings") return bootSettings();
    if(r==="rules") return bootRuleOverrides();
  }

  if(document.readyState === "loading") document.addEventListener("DOMContentLoaded", main);
  else main();
})();



/* VSP_P1_DEDUP_NAVBARS_P1_V1 */
(function(){
  function _txt(el){
    try{ return (el.innerText||"").toLowerCase(); }catch(_){ return ""; }
  }
  function _hasAllTabs(t){
    // heuristic: must contain at least 3 of these to be considered a nav/tabs bar
    const keys = ["dashboard","runs","reports","data source","settings","rule overrides"];
    let hit=0;
    for(const k of keys){ if (t.includes(k)) hit++; }
    return hit >= 3;
  }
  function _dedup(){
    try{
      if (window.__vsp_p1_dedup_navbars_p1_v1) return;
      window.__vsp_p1_dedup_navbars_p1_v1 = true;

      // style for hiding
      if (!document.getElementById("VSP_P1_DEDUP_NAV_STYLE")){
        const st=document.createElement("style");
        st.id="VSP_P1_DEDUP_NAV_STYLE";
        st.textContent = ".vspP1NavHidden{display:none !important;} body{scroll-behavior:auto;}";
        document.head.appendChild(st);
      }

      // candidate containers
      const cand = [];
      const nodes = document.querySelectorAll("nav, header, .top, .tabs, .navbar, .nav, .tabbar, .wrap");
      nodes.forEach(el=>{
        const t=_txt(el);
        if (!_hasAllTabs(t)) return;
        // avoid picking huge containers
        const h = (el.getBoundingClientRect ? el.getBoundingClientRect().height : 0);
        if (h > 260) return;
        cand.push(el);
      });

      if (cand.length <= 1) return;

      // pick the earliest visible one on page (top-most)
      cand.sort((a,b)=>{
        const ay=a.getBoundingClientRect().top + window.scrollY;
        const by=b.getBoundingClientRect().top + window.scrollY;
        return ay-by;
      });

      const keep = cand[0];
      for (let i=1;i<cand.length;i++){
        const el=cand[i];
        if (el === keep) continue;
        el.classList.add("vspP1NavHidden");
      }

      console.info("[VSP][boot] dedup navbars:", cand.length, "kept:", keep);
    }catch(e){
      try{ console.warn("[VSP][boot] dedup navbars error", e); }catch(_){}
    }
  }

  // run after DOM is ready + after boot injects nav
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", ()=> setTimeout(_dedup, 50));
  } else {
    setTimeout(_dedup, 50);
  }
  // also rerun once more (some pages inject later)
  setTimeout(_dedup, 250);
})();




/* VSP_P1_HIDE_SECONDARY_TABBAR_P1_V1 */
(function(){
  const KEYS = ["dashboard","runs","reports","data source","settings","rule overrides"];

  function scoreText(t){
    t=(t||"").toLowerCase();
    let hit=0;
    for(const k of KEYS){ if (t.includes(k)) hit++; }
    return hit;
  }

  function hasManyButtons(el){
    try{
      const n = el.querySelectorAll("a,button").length;
      return n >= 4;
    }catch(_){ return false; }
  }

  function hideSecondary(){
    try{
      const cand=[];
      const all=document.querySelectorAll("div,section,nav,header");
      all.forEach(el=>{
        // don’t touch the top header/nav area too aggressively
        const r = el.getBoundingClientRect();
        if (!r || r.height <= 0) return;
        if (r.height > 220) return;              // avoid big containers
        const top = r.top + window.scrollY;
        const t = (el.innerText||"");
        const sc = scoreText(t);
        if (sc < 3) return;                      // must look like a tabbar
        if (!hasManyButtons(el)) return;         // must actually be a button/link bar
        cand.push({el, top, sc, h:r.height});
      });

      if (cand.length <= 1) return;

      // keep the top-most candidate (your main nav) and hide the rest
      cand.sort((a,b)=>a.top-b.top);
      const keep = cand[0].el;

      // add hide css
      if (!document.getElementById("VSP_P1_HIDE2NDNAV_STYLE")){
        const st=document.createElement("style");
        st.id="VSP_P1_HIDE2NDNAV_STYLE";
        st.textContent=".vspP1SecondaryNavHidden{display:none!important;}";
        document.head.appendChild(st);
      }

      for (let i=1;i<cand.length;i++){
        const el=cand[i].el;
        if (el===keep) continue;
        el.classList.add("vspP1SecondaryNavHidden");
      }

      console.info("[VSP][boot] hide secondary tabbars:", cand.length-1);
    }catch(e){
      try{ console.warn("[VSP][boot] hide secondary tabbar err", e); }catch(_){}
    }
  }

  if (document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", ()=>setTimeout(hideSecondary, 80));
  } else setTimeout(hideSecondary, 80);

  setTimeout(hideSecondary, 300); // rerun once
})();




// VSP_P1_LIVE_RID_AND_RUNS_HEALTH_V1
;(()=> {
  const MARK="VSP_P1_LIVE_RID_AND_RUNS_HEALTH_V1";
  if (window[MARK]) return; window[MARK]=1;

  const POLL_MS = 2500;

  function dedupNavbars(){
    const keys=["Dashboard","Runs & Reports","Data Source","Settings","Rule Overrides"];
    const nodes=Array.from(document.querySelectorAll("nav,div,ul"));
    const cands=[];
    for (const el of nodes){
      const t=((el.innerText||"").replace(/\s+/g," ").trim());
      if(!t) continue;
      let hit=0;
      for (const k of keys) if (t.includes(k)) hit++;
      if (hit>=3) cands.push(el);
    }
    if (cands.length<=1) return;
    cands.sort((a,b)=>a.getBoundingClientRect().top-b.getBoundingClientRect().top);
    const keep=cands[0];
    for (let i=1;i<cands.length;i++){
      const x=cands[i];
      if (x===keep) continue;
      x.style.display="none";
    }
  }

  function setPill(ok,msg){
    let pill=document.getElementById("vsp_live_runs_pill");
    if(!pill){
      pill=document.createElement("div");
      pill.id="vsp_live_runs_pill";
      pill.style.cssText=[
        "position:fixed","top:10px","right:12px","z-index:99999",
        "padding:6px 10px","border-radius:999px",
        "font:12px/1.2 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial",
        "background:rgba(0,0,0,.55)","border:1px solid rgba(255,255,255,.12)",
        "color:#e5e7eb","backdrop-filter: blur(8px)",
        "box-shadow: 0 10px 30px rgba(0,0,0,.35)"
      ].join(";");
      document.body.appendChild(pill);
    }
    pill.textContent=msg||"";
    pill.style.borderColor = ok ? "rgba(34,197,94,.45)" : "rgba(239,68,68,.45)";
  }

  function clearStickyBanners(){
    const all=Array.from(document.querySelectorAll("div,span,a,button"));
    for (const el of all){
      const t=(el.textContent||"").trim();
      if(!t) continue;
      if (t.includes("RUNS API FAIL") || (t.includes("RUNS API") && t.includes("Error:"))){
        el.textContent="RUNS API OK";
      }
    }
  }

  function setTopLinks(rid){
    if(!rid) return;
    const as=Array.from(document.querySelectorAll("a"));
    for (const a of as){
      const t=((a.textContent||"").trim().toLowerCase());
      if (t==="open data source"){
        a.href="/data_source?rid="+encodeURIComponent(rid);
        a.target="_blank";
      } else if (t==="open summary"){
        a.href="/api/vsp/run_file?rid="+encodeURIComponent(rid)+"&name="+encodeURIComponent("reports/run_gate_summary.json");
        a.target="_blank";
      }
    }
  }

  async function poll(){
    const url="/api/vsp/runs?limit=1&_="+Date.now();
    try{
      const r=await fetch(url,{cache:"no-store",credentials:"same-origin"});
      if(!r.ok) throw new Error("HTTP "+r.status);
      const j=await r.json();
      if(!j || j.ok!==true) throw new Error("bad_json");
      const rid=(j.rid_latest || (j.items && j.items[0] && j.items[0].run_id) || null);

      window.__VSP_RID_LATEST__=rid;
      try{ localStorage.setItem("vsp_rid_latest", rid||""); }catch(_e){}

      clearStickyBanners();
      setTopLinks(rid);
      dedupNavbars();

      const tag=(j.degraded ? "DEGRADED" : "OK");
      setPill(true, `RUNS ${tag} • rid_latest=${rid || "N/A"}`);
    }catch(e){
      dedupNavbars();
      setPill(false, `RUNS FAIL • ${String(e)}`);
    }
  }

  poll();
  setInterval(poll, POLL_MS);
  setTimeout(dedupNavbars, 600);
  setTimeout(dedupNavbars, 1500);
})();



/* VSP_P1_FORCE_DASHBOARD_LATEST_RID_V1 20251219_175431
   Goal: Dashboard 'Latest RID' must follow /api/vsp/runs rid_latest (ignore old cached rid text)
*/
(function(){
  async function _vspFetchJSON(url){
    const r = await fetch(url, {cache:'no-store', credentials:'same-origin'});
    if(!r.ok) throw new Error('HTTP '+r.status+' '+url);
    return await r.json();
  }

  function _setTextIf(el, txt){ try{ if(el && typeof txt==='string' && txt) el.textContent = txt; }catch(e){} }

  async function _forceLatestRidOnPage(){
    let j=null;
    try{ j = await _vspFetchJSON('/api/vsp/runs?limit=1'); }catch(e){ return; }
    const rid = (j && (j.rid_latest || (j.items && j.items[0] && j.items[0].run_id))) || null;
    if(!rid) return;

    // overwrite common cache keys (best-effort)
    try{ localStorage.setItem('vsp_active_rid', rid); }catch(e){}
    try{ localStorage.setItem('vsp_latest_rid', rid); }catch(e){}

    // 1) update known selectors if exist
    document.querySelectorAll('#latestRid,.latest-rid,.vsp-latest-rid,[data-latest-rid]')
      .forEach(el => _setTextIf(el, rid));

    // 2) heuristic: find "Latest RID" label and replace nearby rid-looking text
    const labs=[...document.querySelectorAll('*')].filter(el => (el.textContent||'').trim()==='Latest RID');
    for(const lab of labs){
      const scope = lab.closest('div') || lab.parentElement;
      if(!scope) continue;
      const cand=[...scope.querySelectorAll('*')].find(e => /(^|\b)([A-Za-z0-9_-]+_RUN_|RUN_)/.test((e.textContent||'').trim()));
      if(cand) _setTextIf(cand, rid);
    }

    // 3) also update any header chip that contains old rid
    const chips=[...document.querySelectorAll('*')].filter(el => /RUN_/.test((el.textContent||'')) && (el.textContent||'').length<120);
    for(const c of chips){
      if((c.textContent||'').includes('btl86-') || (c.textContent||'').includes('_RUN_')) {
        // only update the ones that look like "rid:" or "VSP_*"
        if(/VSP_|rid|RUN/.test(c.textContent||'')) _setTextIf(c, c.textContent.replace(/\S*RUN_\d{8}_\d{6}\S*/g, rid));
      }
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(_forceLatestRidOnPage, 80);
  });
})();



/* VSP_P1_XHR_RUNS_FALLBACK_V4 20251219_184124 */

(function(){
  try{
    if (window.__VSP_P1_XHR_RUNS_FALLBACK_V4__) return;
    window.__VSP_P1_XHR_RUNS_FALLBACK_V4__ = true;

    function xhrJson(url, timeoutMs){
      return new Promise(function(resolve, reject){
        try{
          var x = new XMLHttpRequest();
          x.open("GET", url, true);
          x.timeout = timeoutMs || 8000;
          x.setRequestHeader("Cache-Control", "no-store");
          x.setRequestHeader("Pragma", "no-cache");
          x.onreadystatechange = function(){
            if (x.readyState !== 4) return;
            var st = x.status || 0;
            if (st !== 200) return reject({status: st});
            try{
              resolve(JSON.parse(x.responseText || "{}"));
            }catch(e){
              reject({status: 598});
            }
          };
          x.ontimeout = function(){ reject({status: 599}); };
          x.onerror = function(){ reject({status: 597}); };
          x.send();
        }catch(e){
          reject({status: 596});
        }
      });
    }

    function ensureBanner(msg){
      try{
        var id = "vsp_degraded_banner_v4";
        var el = document.getElementById(id);
        if (!el){
          el = document.createElement("div");
          el.id = id;
          el.className = "vsp-degraded-banner";
          (document.querySelector(".vsp-card,.card,.panel,.box") || document.body).prepend(el);
        }
        el.textContent = msg;
      }catch(_){}
    }

    async function run(){
      var path = (location.pathname || "");
      if (!path.includes("vsp5")) return;

      try{
        var runs = await xhrJson("/api/vsp/runs?limit=1&_ts=" + Date.now(), 8000);
        if (runs && runs.ok && runs.rid_latest){
          window.__VSP_RID_LATEST__ = runs.rid_latest;
          return;
        }
        ensureBanner("DEGRADED: runs api non-ok (UI continues)");
      }catch(e){
        ensureBanner("DEGRADED: cannot load runs via XHR (status=" + (e && e.status) + ") (UI continues)");
      }
    }

    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", run);
    else run();
  }catch(_){}
})();



/* VSP_P1_RUNS_THROTTLE_QUEUE_V1 20251219_185817 */

(function(){
  try{
    if (window.__VSP_P1_RUNS_THROTTLE_QUEUE_V1__) return;
    window.__VSP_P1_RUNS_THROTTLE_QUEUE_V1__ = true;

    var realFetch = window.fetch ? window.fetch.bind(window) : null;
    if (!realFetch) return;

    var lastRunsAt = 0;
    var lastDashAt = 0;
    var q = Promise.resolve();

    function sleep(ms){ return new Promise(function(r){ setTimeout(r, ms); }); }

    function isRuns(u){ return (typeof u === "string") && u.indexOf("/api/vsp/runs") !== -1; }
    function isDash(u){ return (typeof u === "string") && u.indexOf("/api/vsp/dashboard") !== -1; }

    function clearFailedBox(){
      try{
        // clear common “Failed to load … HTTP …” area
        var nodes = document.querySelectorAll("body *");
        for (var i=0;i<nodes.length;i++){
          var t = (nodes[i].textContent || "").trim();
          if (t.startsWith("Failed to load dashboard data") || t.indexOf("HTTP 503 /api/vsp/runs") !== -1){
            nodes[i].textContent = "";
          }
        }
      }catch(_){}
    }

    window.fetch = function(input, init){
      var url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
      if (isRuns(url) || isDash(url)){
        q = q.then(async function(){
          var now = Date.now();
          var minMs = isRuns(url) ? 1200 : 800; // thương mại: throttle nhưng KHÔNG fail
          var last = isRuns(url) ? lastRunsAt : lastDashAt;
          var wait = (last + minMs) - now;
          if (wait > 0) await sleep(wait);
          if (isRuns(url)) lastRunsAt = Date.now(); else lastDashAt = Date.now();
          var r = await realFetch(input, init);
          try{
            if (isRuns(url) && r && r.status === 200) clearFailedBox();
          }catch(_){}
          return r;
        });
        return q;
      }
      return realFetch(input, init);
    };

  }catch(_){}
})();

