/* VSP_P1_GATE_STORY_FORCE_PAINT_V1B */
(() => {
  // NOTE: do NOT early-return even if previous version set a flag;
  // we want "self-healing" behavior on blank pages.
  if (window.__vsp_gate_story_force_paint_v1b) return;
  window.__vsp_gate_story_force_paint_v1b = true;

  const CFG = {
    runsUrl: "/api/vsp/runs?limit=1",
    fileUrl: (rid) => `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&name=${encodeURIComponent("run_gate.json")}`,
    timeoutMs: 8000,
    tools: ["bandit","semgrep","gitleaks","kics","trivy","syft","grype","codeql"],
    refreshMs: 15000,      // refresh data
    healEveryMs: 600,      // re-insert panel if removed
    healMaxMs: 20000,      // keep healing for 20s after load
  };

  const now = () => Date.now();
  const log = (...a) => console.log("[GateStoryV1B]", ...a);

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

  function pick(obj, path, defv){
    try{
      const ps = path.split(".");
      let cur = obj;
      for (const k of ps){
        if (!cur) return defv;
        cur = cur[k];
      }
      return (cur === undefined || cur === null) ? defv : cur;
    } catch { return defv; }
  }

  function normOverall(v){
    const s = String(v ?? "").toUpperCase().trim();
    if (["RED","FAIL","FAILED","BLOCK","BLOCKED","CRITICAL"].includes(s)) return "RED";
    if (["AMBER","WARN","WARNING","DEGRADED","YELLOW"].includes(s)) return "AMBER";
    if (["GREEN","PASS","PASSED","OK"].includes(s)) return "GREEN";
    return s || "UNKNOWN";
  }

  function tone(overall){
    if (overall === "RED") return "tone-red";
    if (overall === "AMBER") return "tone-amber";
    if (overall === "GREEN") return "tone-green";
    return "tone-unk";
  }

  function toolTone(st){
    const s = String(st ?? "").toUpperCase();
    if (["PASS","OK","GREEN"].includes(s)) return "t-ok";
    if (["FAIL","RED","BLOCKED"].includes(s)) return "t-bad";
    if (["DEGRADED","AMBER","WARN","TIMEOUT"].includes(s)) return "t-warn";
    if (["MISSING","SKIP","SKIPPED","N/A","NA"].includes(s)) return "t-mute";
    return "t-unk";
  }

  function ensureStyle(){
    if (document.getElementById("vsp_gate_story_v1b_style")) return;
    const st = document.createElement("style");
    st.id = "vsp_gate_story_v1b_style";
    st.textContent = `
      body{ background:#0b1220; }
      .vspgs-wrap{ margin:14px; }
      .vspgs-card{
        border:1px solid rgba(255,255,255,.10);
        background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
        border-radius:16px;
        padding:14px;
        box-shadow: 0 14px 34px rgba(0,0,0,.45);
        color: rgba(226,232,240,.96);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      .vspgs-top{display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:flex-start;}
      .vspgs-title{display:flex; gap:10px; align-items:flex-start;}
      .vspgs-dot{width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,.25);margin-top:4px;}
      .vspgs-h{font-weight:800; letter-spacing:.3px; font-size:14px;}
      .vspgs-sub{font-size:12px; opacity:.74; margin-top:2px;}
      .vspgs-kpis{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
      .pill{border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.22); border-radius:999px; padding:6px 10px; font-size:12px; display:flex; gap:8px; align-items:center;}
      .ov{font-weight:900; letter-spacing:1px; padding:6px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.16);}
      .tone-red{background: rgba(255,73,73,.16); color: rgba(255,165,165,.98);}
      .tone-amber{background: rgba(255,193,7,.14); color: rgba(255,228,141,.98);}
      .tone-green{background: rgba(46,204,113,.12); color: rgba(165,255,205,.98);}
      .tone-unk{background: rgba(148,163,184,.12); color: rgba(226,232,240,.95);}
      .mid{display:flex; gap:14px; margin-top:10px; flex-wrap:wrap;}
      .left{flex:1 1 460px; min-width:320px;}
      .right{flex:0 0 360px; min-width:320px;}
      .muted{opacity:.72;}
      .small{font-size:12px; opacity:.82; line-height:1.25rem;}
      .reasons{margin:8px 0 0 0; padding:0 0 0 18px;}
      .reasons li{margin:6px 0; font-size:13px; line-height:1.25rem;}
      .strip{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
      .tool{font-size:11px; padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.22); display:flex; gap:6px; align-items:center;}
      .tool b{letter-spacing:.3px;}
      .t-ok{color: rgba(165,255,205,.98);}
      .t-warn{color: rgba(255,228,141,.98);}
      .t-bad{color: rgba(255,165,165,.98);}
      .t-mute{color: rgba(203,213,225,.72);}
      .t-unk{color: rgba(226,232,240,.92);}
      .actions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-top:10px;}
      .btn{cursor:pointer; border:1px solid rgba(255,255,255,.16); background: rgba(0,0,0,.22); color: rgba(226,232,240,.95);
           border-radius:12px; padding:8px 10px; font-size:12px; text-decoration:none;}
      .btn:hover{background: rgba(255,255,255,.06);}
      .hr{height:1px; background: rgba(255,255,255,.08); margin-top:10px;}
    `;
    document.head.appendChild(st);
  }

  function ensurePanel(){
    ensureStyle();
    let wrap = document.getElementById("vsp_gate_story_panel_v1b");
    if (wrap) return wrap;

    wrap = document.createElement("div");
    wrap.id = "vsp_gate_story_panel_v1b";
    wrap.className = "vspgs-wrap";
    wrap.innerHTML = `
      <div class="vspgs-card">
        <div class="vspgs-top">
          <div class="vspgs-title">
            <div class="vspgs-dot"></div>
            <div>
              <div class="vspgs-h">Gate Story</div>
              <div class="vspgs-sub muted">overall + top reasons + degraded/tools (latest)</div>
            </div>
          </div>
          <div class="vspgs-kpis">
            <div class="pill"><span class="muted">Overall</span> <span id="gs_overall" class="ov tone-unk">…</span></div>
            <div class="pill"><span class="muted">Degraded</span> <b id="gs_degraded">…</b></div>
            <div class="pill"><span class="muted">Total</span> <b id="gs_total">…</b></div>
          </div>
        </div>

        <div class="mid">
          <div class="left">
            <div class="small muted">Top reasons (3)</div>
            <ol class="reasons" id="gs_reasons"><li class="muted">Loading gate…</li></ol>
            <div class="hr"></div>
            <div class="small muted">Tool strip (8)</div>
            <div class="strip" id="gs_strip"></div>
          </div>
          <div class="right">
            <div class="small muted">Latest run</div>
            <div class="small" id="gs_meta">…</div>
            <div class="actions" id="gs_actions"></div>
          </div>
        </div>
      </div>
    `;

    // Force insert at body top even if other scripts wipe containers
    if (document.body.firstChild) document.body.insertBefore(wrap, document.body.firstChild);
    else document.body.appendChild(wrap);

    return wrap;
  }

  function setOverall(v){
    const el = document.getElementById("gs_overall");
    if (!el) return;
    const o = normOverall(v);
    el.textContent = o;
    el.classList.remove("tone-red","tone-amber","tone-green","tone-unk");
    el.classList.add(tone(o));
  }

  function setText(id, v){
    const el = document.getElementById(id);
    if (el) el.textContent = String(v ?? "");
  }

  function renderStrip(toolState){
    const box = document.getElementById("gs_strip");
    if (!box) return;
    box.innerHTML = "";
    for (const t of CFG.tools){
      const st = String(toolState[t] ?? "UNKNOWN").toUpperCase();
      const chip = document.createElement("div");
      chip.className = `tool ${toolTone(st)}`;
      chip.innerHTML = `<b>${esc(t.toUpperCase())}</b><span class="muted">•</span><span>${esc(st)}</span>`;
      box.appendChild(chip);
    }
  }

  function renderReasons(arr){
    const ol = document.getElementById("gs_reasons");
    if (!ol) return;
    const rs = (arr && arr.length) ? arr.slice(0,3) : ["No reasons available (fallback)."];
    ol.innerHTML = rs.map(x => `<li>${esc(x)}</li>`).join("");
  }

  function renderMeta(rid, run, sevText){
    const el = document.getElementById("gs_meta");
    if (!el) return;
    const started = (run && (run.started_at || run.created_at || run.ts || run.time)) || "";
    const ro = normOverall((run && (run.overall || run.overall_status || run.status || run.verdict)) || "");
    el.innerHTML =
      `<div><b>RID</b>: <span class="muted">${esc(rid)}</span></div>` +
      (started ? `<div><b>Time</b>: <span class="muted">${esc(started)}</span></div>` : "") +
      `<div><b>Run overall</b>: <span class="muted">${esc(ro || "UNKNOWN")}</span></div>` +
      (sevText ? `<div><b>Sev</b>: <span class="muted">${esc(sevText)}</span></div>` : "");
  }

  function renderActions(rid){
    const box = document.getElementById("gs_actions");
    if (!box) return;
    const url = CFG.fileUrl(rid);
    box.innerHTML = `
      <a class="btn" href="${esc(url)}" target="_blank" rel="noopener">Open run_gate.json</a>
      <a class="btn" href="/runs" target="_blank" rel="noopener">Runs &amp; Reports</a>
      <a class="btn" href="/data_source" target="_blank" rel="noopener">Data Source</a>
    `;
  }

  async function fetchJson(url){
    const ac = new AbortController();
    const t = setTimeout(() => ac.abort(), CFG.timeoutMs);
    try{
      const r = await fetch(url, {signal: ac.signal, headers: {"Accept":"application/json"}});
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    } finally { clearTimeout(t); }
  }

  function normalizeTools(summary){
    const byTool = summary.by_tool || summary.tools || summary.tool_results || {};
    const toolState = {};
    let degradedCount = 0;

    for (const t of CFG.tools){
      let ent = byTool[t] || byTool[t.toUpperCase()] || byTool[t.toLowerCase()];
      let st = "UNKNOWN";
      let dg = false;

      if (ent && typeof ent === "object"){
        st = String(ent.status || ent.state || ent.verdict || ent.result || "UNKNOWN").toUpperCase();
        dg = !!(ent.degraded || ent.is_degraded || ent.timeout || ent.timed_out);
        if (dg && (st === "PASS" || st === "OK" || st === "GREEN")) st = "DEGRADED";
      } else {
        // fallback flat fields
        const st2 = summary[`${t}_status`];
        const dg2 = summary[`${t}_degraded`];
        if (st2) st = String(st2).toUpperCase();
        if (dg2 !== undefined) dg = !!dg2;
        if (dg && (st === "PASS" || st === "OK")) st = "DEGRADED";
      }

      toolState[t] = st;
      if (dg) degradedCount++;
    }
    return {toolState, degradedCount};
  }

  function extractTotals(summary){
    const sev = summary.counts_by_severity || summary.severity_counts || summary.by_severity || null;
    if (sev && typeof sev === "object"){
      const c = Number(sev.CRITICAL ?? sev.critical ?? 0) || 0;
      const h = Number(sev.HIGH ?? sev.high ?? 0) || 0;
      const m = Number(sev.MEDIUM ?? sev.medium ?? 0) || 0;
      const l = Number(sev.LOW ?? sev.low ?? 0) || 0;
      const i = Number(sev.INFO ?? sev.info ?? 0) || 0;
      const t = Number(sev.TRACE ?? sev.trace ?? 0) || 0;
      const total = Number(summary.total_findings ?? summary.findings_total ?? (c+h+m+l+i+t)) || (c+h+m+l+i+t);
      return { total, sevText: `C/H/M/L/I/T = ${c}/${h}/${m}/${l}/${i}/${t}` };
    }
    // best-effort
    const total = Number(summary.total_findings ?? summary.findings_total ?? summary.total ?? 0) || 0;
    return total ? { total, sevText: "" } : null;
  }

  function extractReasons(summary, rid, degradedCount, totals){
    let rs = summary.top_reasons || summary.reasons || summary.why || summary.verdict_reasons || [];
    if (typeof rs === "string") rs = rs.split("\n").map(x=>x.trim()).filter(Boolean);
    if (Array.isArray(rs)) rs = rs.map(x => typeof x === "string" ? x : (x && x.text ? x.text : JSON.stringify(x)));

    rs = (rs || []).filter(Boolean).slice(0,3);
    if (rs.length < 3){
      if (totals && totals.total) rs.push(`Tổng findings: ${totals.total}.`);
      if (degradedCount > 0) rs.push(`Degraded tools: ${degradedCount}/${CFG.tools.length}.`);
      rs.push(`RID: ${rid}.`);
      rs = rs.slice(0,3);
    }
    return rs;
  }

  async function refreshOnce(){
    ensurePanel();

    const runs = await fetchJson(CFG.runsUrl);
    const run = (runs && Array.isArray(runs.items) && runs.items[0]) ? runs.items[0] : null;
    const rid = (run && (run.run_id || run.rid || run.id)) || null;

    if (!rid){
      setOverall("UNKNOWN");
      renderReasons(["Không lấy được RID từ /api/vsp/runs?limit=1."]);
      renderStrip(Object.fromEntries(CFG.tools.map(t=>[t,"UNKNOWN"])));
      setText("gs_degraded", `0/${CFG.tools.length}`);
      setText("gs_total", "—");
      return;
    }

    let summary = null;
    try { summary = await fetchJson(CFG.fileUrl(rid)); } catch { summary = null; }

    const overall = normOverall(
      (summary && (summary.overall || summary.overall_status || summary.status || summary.verdict)) ||
      (run && (run.overall || run.overall_status || run.status || run.verdict)) ||
      "UNKNOWN"
    );
    setOverall(overall);

    const totals = summary ? extractTotals(summary) : null;
    setText("gs_total", totals ? String(totals.total) : "—");

    const {toolState, degradedCount} = summary ? normalizeTools(summary) : {toolState: Object.fromEntries(CFG.tools.map(t=>[t,"UNKNOWN"])), degradedCount: 0};
    setText("gs_degraded", `${degradedCount}/${CFG.tools.length}`);
    renderStrip(toolState);

    const reasons = summary ? extractReasons(summary, rid, degradedCount, totals) : [
      "Không đọc được run_gate.json (fallback).",
      `Degraded tools: ${degradedCount}/${CFG.tools.length}.`,
      `RID: ${rid}.`,
    ];
    renderReasons(reasons);

    renderMeta(rid, run || {}, totals ? totals.sevText : "");
    renderActions(rid);
  }

  function start(){
    // Always paint immediately so page is not blank
    ensurePanel();
    setOverall("UNKNOWN");
    renderStrip(Object.fromEntries(CFG.tools.map(t=>[t,"…"])));
    renderReasons(["Loading…"]);

    // Data refresh
    refreshOnce().catch(e => {
      log("refresh error:", e?.message || e);
      renderReasons([`Lỗi tải gate: ${String(e?.message || e).slice(0,120)}`]);
    });

    // Heal loop: if any legacy script wipes DOM, reinsert panel
    const t0 = now();
    const heal = setInterval(() => {
      if (now() - t0 > CFG.healMaxMs) { clearInterval(heal); return; }
      if (!document.getElementById("vsp_gate_story_panel_v1b")) {
        log("heal: panel missing -> reinsert");
        ensurePanel();
      }
    }, CFG.healEveryMs);

    // Periodic refresh
    setInterval(() => refreshOnce().catch(()=>{}), CFG.refreshMs);

    log("loaded + running");
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", start, {once:true});
  else start();
})();

/* VSP_P1_GATE_STORY_REWIRE_RUN_FILE_ALLOW_V1B */
console.log('[GateStoryV1] rewire: run_file -> run_file_allow');


/* VSP_P1_GATE_STORY_FIX_RUNFILE_ALLOW_PARAMS_V2 */
(()=> {
  if (window.__vsp_p1_gate_story_fix_runfile_allow_params_v2) return;
  window.__vsp_p1_gate_story_fix_runfile_allow_params_v2 = true;

  function getRidFromDom(){
    try{
      const txt = (document.body && document.body.textContent) ? document.body.textContent : "";
      const m = txt.match(/RID:\s*([A-Za-z0-9_.\-]+)/);
      return m ? m[1] : "";
    }catch(e){ return ""; }
  }

  const origFetch = window.fetch;
  window.fetch = function(input, init){
    try{
      if (typeof input === "string" && input.includes("/api/vsp/run_file_allow")){
        let url = input;

        // If rid missing, try to attach from DOM
        if (!/[?&]rid=/.test(url)){
          const rid = getRidFromDom();
          if (rid){
            url += (url.includes("?") ? "&" : "?") + "rid=" + encodeURIComponent(rid);
          }
        }
        // If path missing, force run_gate.json (backend will fallback to run_gate_summary.json)
        if (!/[?&]path=/.test(url)){
          url += (url.includes("?") ? "&" : "?") + "path=" + encodeURIComponent("run_gate.json");
        }

        input = url;
      }
    }catch(e){}
    return origFetch(input, init);
  };

  console.log("[GateStoryV1] V2 fix: force rid+path for run_file_allow, path=run_gate.json");
})();

/* VSP_P1_GATE_STORY_FIX_RUNFILE_ALLOW_PARAMS_V2 */



/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V3
   - capture gate json from /api/vsp/run_file_allow
   - apply to DOM: Run overall + tool badges (fix UNKNOWN) without relying on internal GateStory code
*/
(()=> {
  if (window.__vsp_p1_gate_story_apply_gate_to_dom_v3) return;
  window.__vsp_p1_gate_story_apply_gate_to_dom_v3 = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];

  function norm(s){ return (s||"").toString().trim().toUpperCase(); }

  function statusFromCounts(ct){
    ct = ct || {};
    const c = (ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0), l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h > 0) return "RED";
    if (m > 0) return "AMBER";
    if (l+i+t > 0) return "GREEN";
    return "UNKNOWN";
  }

  function computeToolStatus(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const k of TOOLS){
      const o = bt[k] || bt[k.toLowerCase()] || null;
      if (!o){ out[k]="UNKNOWN"; continue; }
      const st = norm(o.status || o.overall || o.verdict);
      if (st && st !== "UNKNOWN"){
        // normalize common variants
        if (st === "PASS" || st === "OK" || st === "GREEN") out[k]="GREEN";
        else if (st === "WARN" || st === "AMBER") out[k]="AMBER";
        else if (st === "FAIL" || st === "BLOCK" || st === "RED") out[k]="RED";
        else out[k]=st;
      } else {
        const ct = o.counts_total || o.counts || o.totals || {};
        out[k] = statusFromCounts(ct);
      }
    }
    return out;
  }

  function applyRunOverall(gate){
    const ov = norm(gate && (gate.overall || gate.overall_status));
    if (!ov) return;
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(el => (el.childElementCount===0) && /Run overall:/i.test(el.textContent||""));
    for (const el of nodes.slice(0,5)){
      const t = el.textContent || "";
      el.textContent = t.replace(/Run overall:\s*\w+/i, "Run overall: " + ov);
    }
  }

  function applyToolBadges(map){
    const all = Array.from(document.querySelectorAll("button,span,div"))
      .filter(el => (el.childElementCount===0) && (el.textContent||"").length < 60);

    for (const tool of TOOLS){
      const st = map[tool] || "UNKNOWN";
      for (const el of all){
        const txt = (el.textContent||"").trim();
        if (!txt) continue;
        // match "TOOL - XXX" or "TOOL · XXX"
        const re = new RegExp("^\\s*"+tool+"\\s*([\\-·:\\|])\\s*(GREEN|AMBER|RED|UNKNOWN)\\s*$","i");
        if (re.test(txt)){
          el.textContent = txt.replace(re, tool + " $1 " + st);
        }
      }
    }
  }

  function applyGate(gate){
    if (!gate || typeof gate !== "object") return;
    applyRunOverall(gate);
    const map = computeToolStatus(gate);
    applyToolBadges(map);
  }

  // --- capture gate json from fetch ---
  const prevFetch = window.fetch;
  window.fetch = async function(input, init){
    const res = await prevFetch(input, init);
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url && url.includes("/api/vsp/run_file_allow")){
        // clone + try json
        const c = res.clone();
        c.json().then(j=>{
          if (j && typeof j === "object" && (j.by_tool || j.counts_total || j.overall || j.overall_status)){
            window.__vsp_gate_latest_v3 = j;
            applyGate(j);
          }
        }).catch(()=>{});
      }
    }catch(e){}
    return res;
  };

  // --- periodic apply (in case DOM rerender) ---
  setInterval(()=>{ try{ if (window.__vsp_gate_latest_v3) applyGate(window.__vsp_gate_latest_v3); }catch(e){} }, 1000);

  console.log("[GateStoryV1] V3 apply DOM: Run overall + tool UNKNOWN fill (by_tool)");
})();

/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V3 */



/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V4B
   - fix JS syntax; sync "Run overall" + normalize tool badges using latest gate json
*/
(()=> {
  if (window.__vsp_p1_gate_story_apply_gate_to_dom_v4b) return;
  window.__vsp_p1_gate_story_apply_gate_to_dom_v4b = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];
  const norm = (x)=> (x||"").toString().trim().toUpperCase();

  function statusFromCounts(ct){
    ct = ct || {};
    const c=(ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0), l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h>0) return "RED";
    if (m>0) return "AMBER";
    if (l+i+t>0) return "GREEN";
    return "UNKNOWN";
  }

  function computeToolStatus(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const k of TOOLS){
      const o = bt[k] || bt[k.toLowerCase()] || null;
      if (!o){ out[k]="UNKNOWN"; continue; }
      const st0 = norm(o.status || o.overall || o.verdict);
      if (st0 && st0 !== "UNKNOWN"){
        if (st0==="PASS"||st0==="OK"||st0==="GREEN") out[k]="GREEN";
        else if (st0==="WARN"||st0==="AMBER") out[k]="AMBER";
        else if (st0==="FAIL"||st0==="BLOCK"||st0==="RED") out[k]="RED";
        else out[k]=st0;
      } else {
        const ct = o.counts_total || o.counts || o.totals || {};
        out[k] = statusFromCounts(ct);
      }
    }
    return out;
  }

  function applyRunOverall(gate){
    const ov = norm(gate && (gate.overall || gate.overall_status));
    if (!ov) return;
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(el => (el.textContent||"").includes("Run overall:"))
      .sort((a,b)=> (a.textContent||"").length - (b.textContent||"").length);
    for (const el of nodes.slice(0,8)){
      try{
        const t = el.textContent || "";
        const t2 = t.replace(/Run overall:\s*[A-Za-z_]+/i, "Run overall: " + ov);
        if (t2 !== t) el.textContent = t2;
      }catch(e){}
    }
  }

  function applyToolBadges(map){
    const nodes = Array.from(document.querySelectorAll("button,span,div"))
      .filter(el => (el.textContent||"").length < 80);

    for (const tool of TOOLS){
      const st = map[tool] || "UNKNOWN";
      const re = new RegExp("^\\s*" + tool + "\\s*([\\-·:\\|])\\s*(GREEN|AMBER|RED|UNKNOWN)\\s*$","i");
      for (const el of nodes){
        const txt = (el.textContent||"").trim();
        if (!txt) continue;
        if (!txt.toUpperCase().includes(tool)) continue;
        if (re.test(txt)){
          el.textContent = txt.replace(re, tool + " $1 " + st);
        }
      }
    }
  }

  function applyGate(gate){
    if (!gate || typeof gate !== "object") return;
    applyRunOverall(gate);
    applyToolBadges(computeToolStatus(gate));
  }

  const prevFetch = window.fetch;
  window.fetch = async function(input, init){
    const res = await prevFetch(input, init);
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url && url.includes("/api/vsp/run_file_allow")){
        const c = res.clone();
        c.json().then(j=>{
          if (j && typeof j === "object" && (j.by_tool || j.counts_total || j.overall || j.overall_status)){
            window.__vsp_gate_latest_v4b = j;
            applyGate(j);
          }
        }).catch(()=>{});
      }
    }catch(e){}
    return res;
  };

  setInterval(()=>{ try{ if (window.__vsp_gate_latest_v4b) applyGate(window.__vsp_gate_latest_v4b); }catch(e){} }, 900);

  console.log("[GateStoryV1] V4B apply DOM: Run overall + tool badge normalize");
})();

/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V4B */
