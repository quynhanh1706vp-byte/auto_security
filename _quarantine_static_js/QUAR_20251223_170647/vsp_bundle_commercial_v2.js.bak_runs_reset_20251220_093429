


// VSP_P1_DASH_RENDER_V6C_IN_BUNDLE
(function(){
  if (window.__VSP_DASH_RENDER_V6C) return;
  window.__VSP_DASH_RENDER_V6C = true;

  function ensureCanvas(holderId){
    var el = document.getElementById(holderId);
    if (!el) return null;
    var tag = (el.tagName||"").toLowerCase();
    if (tag === "canvas") return el;
    var c = el.querySelector && el.querySelector("canvas");
    if (!c){
      c = document.createElement("canvas");
      c.style.width="100%";
      c.style.height="260px";
      el.innerHTML="";     // clear placeholder
      el.appendChild(c);
    }
    return c;
  }

  async function getRid(){
    try{
      var u = new URL(window.location.href);
      var rid = u.searchParams.get("rid");
      if (rid) return rid;
    }catch(e){}
    try{
      var r = await (window.VSP_RUNS_GUARD && window.VSP_RUNS_GUARD.fetchJson ? window.VSP_RUNS_GUARD.fetchJson("/api/vsp/runs?limit=1", 6000) : fetch("/api/vsp/runs?limit=1"));
      var j = await r.json();
      if (j && j.items && j.items[0] && j.items[0].run_id) return j.items[0].run_id;
    }catch(e){}
    return "";
  }

  function parseDonut(j){
    if (j?.charts?.severity?.donut) return j.charts.severity.donut;
    if (j?.donut?.labels && j?.donut?.values) return j.donut;
    if (Array.isArray(j?.severity_distribution))
      return { labels: j.severity_distribution.map(x=>x.sev), values: j.severity_distribution.map(x=>x.count) };
    return null;
  }
  function parseTrend(j){
    if (j?.charts?.trend?.series) return j.charts.trend.series;
    if (j?.trend?.labels && j?.trend?.values) return j.trend;
    if (Array.isArray(j?.findings_trend))
      return { labels: j.findings_trend.map(x=>x.rid), values: j.findings_trend.map(x=>x.total) };
    return null;
  }
  function parseBarCritHigh(j){
    if (j?.charts?.crit_high_by_tool?.bar) return j.charts.crit_high_by_tool.bar;
    if (j?.bar_crit_high?.labels) return j.bar_crit_high;
    if (Array.isArray(j?.critical_high_by_tool)){
      var labels = j.critical_high_by_tool.map(x=>x.tool);
      var crit = j.critical_high_by_tool.map(x=>x.critical||0);
      var high = j.critical_high_by_tool.map(x=>x.high||0);
      return { labels: labels, series: [{name:"CRITICAL",data:crit},{name:"HIGH",data:high}] };
    }
    return null;
  }
  function parseTopCwe(j){
    if (j?.charts?.top_cwe?.series) return j.charts.top_cwe.series;
    if (j?.top_cwe?.labels && j?.top_cwe?.values) return j.top_cwe;
    if (Array.isArray(j?.top_cwe_exposure))
      return { labels: j.top_cwe_exposure.map(x=>x.cwe), values: j.top_cwe_exposure.map(x=>x.count) };
    return { labels: [], values: [] };
  }

  function destroyKey(k){ try{ window[k]?.destroy?.(); }catch(e){} window[k]=null; }

  async function renderOnce(){
    if (!window.Chart) return false;

    var a=document.getElementById("vsp-chart-severity");
    var b=document.getElementById("vsp-chart-trend");
    var c=document.getElementById("vsp-chart-bytool");
    var d=document.getElementById("vsp-chart-topcwe");
    if (!a || !b || !c || !d) return false;

    var rid = await getRid();
    if (!rid) return false;

    var resp = await fetch("/api/vsp/dash_charts?rid="+encodeURIComponent(rid), {cache:"no-store"});
    var j = await resp.json();

    var donut=parseDonut(j), trend=parseTrend(j), bar=parseBarCritHigh(j), top=parseTopCwe(j);

    var c1=ensureCanvas("vsp-chart-severity");
    if (c1 && donut){
      destroyKey("__VSP_DONUT_V6C");
      window.__VSP_DONUT_V6C = new Chart(c1, {type:"doughnut",
        data:{labels:donut.labels,datasets:[{data:donut.values}]},
        options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false}}
      });
    }

    var c2=ensureCanvas("vsp-chart-trend");
    if (c2 && trend){
      destroyKey("__VSP_TREND_V6C");
      window.__VSP_TREND_V6C = new Chart(c2, {type:"line",
        data:{labels:trend.labels,datasets:[{data:trend.values}]},
        options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false}}
      });
    }

    var c3=ensureCanvas("vsp-chart-bytool");
    if (c3 && bar){
      destroyKey("__VSP_BYTOOL_V6C");
      var s0=bar.series?.[0]?.data||[], s1=bar.series?.[1]?.data||[];
      window.__VSP_BYTOOL_V6C = new Chart(c3, {type:"bar",
        data:{labels:bar.labels,datasets:[{label:"CRITICAL",data:s0},{label:"HIGH",data:s1}]},
        options:{responsive:true,maintainAspectRatio:false}
      });
    }

    var c4=ensureCanvas("vsp-chart-topcwe");
    if (c4 && top){
      destroyKey("__VSP_TOPCWE_V6C");
      window.__VSP_TOPCWE_V6C = new Chart(c4, {type:"bar",
        data:{labels:top.labels,datasets:[{data:top.values}]},
        options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false}}
      });
    }

    console.log("[VSP][DASH][V6C] rendered rid=", rid);
    return true;
  }

  var tries=0;
  var t=setInterval(function(){
    tries++;
    renderOnce().then(function(ok){
      if (ok || tries>=20){
        clearInterval(t);
        if (!ok) console.warn("[VSP][DASH][V6C] gave up (Chart/container missing)");
      }
    }).catch(function(e){
      if (tries>=20){ clearInterval(t); console.warn("[VSP][DASH][V6C] error", e); }
    });
  }, 500);
})();




// VSP_P1_DASH_CANVAS_FALLBACK_V6D
(function(){
  if (window.__VSP_DASH_RENDER_V6D) return;
  window.__VSP_DASH_RENDER_V6D = true;

  function ensureCanvas(holderId){
    var el = document.getElementById(holderId);
    if (!el) return null;
    var tag = (el.tagName||"").toLowerCase();
    if (tag === "canvas") return el;

    var c = el.querySelector && el.querySelector("canvas");
    if (!c){
      c = document.createElement("canvas");
      c.width = 900; c.height = 300;
      c.style.width="100%";
      c.style.height="260px";
      el.innerHTML=""; // clear placeholder
      el.appendChild(c);
    }
    return c;
  }

  async function getRid(){
    try{
      var u = new URL(window.location.href);
      var rid = u.searchParams.get("rid");
      if (rid) return rid;
    }catch(e){}
    try{
      var r = await (window.VSP_RUNS_GUARD && window.VSP_RUNS_GUARD.fetchJson ? window.VSP_RUNS_GUARD.fetchJson("/api/vsp/runs?limit=1", 6000) : fetch("/api/vsp/runs?limit=1"));
      var j = await r.json();
      if (j && j.items && j.items[0] && j.items[0].run_id) return j.items[0].run_id;
    }catch(e){}
    return "";
  }

  function parseDonut(j){
    if (j?.charts?.severity?.donut) return j.charts.severity.donut;
    if (j?.donut?.labels && j?.donut?.values) return j.donut;
    if (Array.isArray(j?.severity_distribution))
      return { labels: j.severity_distribution.map(x=>x.sev), values: j.severity_distribution.map(x=>x.count) };
    return null;
  }
  function parseTrend(j){
    if (j?.charts?.trend?.series) return j.charts.trend.series;
    if (j?.trend?.labels && j?.trend?.values) return j.trend;
    if (Array.isArray(j?.findings_trend))
      return { labels: j.findings_trend.map(x=>x.rid), values: j.findings_trend.map(x=>x.total) };
    return null;
  }
  function parseBarCritHigh(j){
    if (j?.charts?.crit_high_by_tool?.bar) return j.charts.crit_high_by_tool.bar;
    if (j?.bar_crit_high?.labels) return j.bar_crit_high;
    if (Array.isArray(j?.critical_high_by_tool)){
      var labels = j.critical_high_by_tool.map(x=>x.tool);
      var crit = j.critical_high_by_tool.map(x=>x.critical||0);
      var high = j.critical_high_by_tool.map(x=>x.high||0);
      return { labels: labels, series: [{name:"CRITICAL",data:crit},{name:"HIGH",data:high}] };
    }
    return null;
  }
  function parseTopCwe(j){
    if (j?.charts?.top_cwe?.series) return j.charts.top_cwe.series;
    if (j?.top_cwe?.labels && j?.top_cwe?.values) return j.top_cwe;
    if (Array.isArray(j?.top_cwe_exposure))
      return { labels: j.top_cwe_exposure.map(x=>x.cwe), values: j.top_cwe_exposure.map(x=>x.count) };
    return { labels: [], values: [] };
  }

  // ---- Canvas drawing helpers (no Chart.js) ----
  function ctx2d(canvas){
    var ctx = canvas.getContext("2d");
    var w = canvas.width, h = canvas.height;
    // handle hiDPI
    var dpr = window.devicePixelRatio || 1;
    var cssW = canvas.clientWidth || w;
    var cssH = canvas.clientHeight || h;
    canvas.width = Math.max(300, Math.floor(cssW * dpr));
    canvas.height = Math.max(200, Math.floor(cssH * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return ctx;
  }

  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    // subtle grid bg
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,w,h);
    ctx.globalAlpha = 1;
  }

  function textCenter(ctx, w, h, msg){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(msg, w/2, h/2);
    ctx.restore();
  }

  function drawDonut(canvas, labels, values){
    var ctx = ctx2d(canvas);
    var w = canvas.clientWidth || 900, h = canvas.clientHeight || 260;
    clear(ctx, w, h);
    var total = values.reduce((a,b)=>a+(+b||0),0);
    if (!total){ textCenter(ctx,w,h,"No data"); return; }

    var cx=w/2, cy=h/2, r=Math.min(w,h)*0.32, rIn=r*0.55;
    var ang=-Math.PI/2;

    var palette=["#ef4444","#f59e0b","#3b82f6","#22c55e","#a855f7","#94a3b8"];
    for (var i=0;i<values.length;i++){
      var v=+values[i]||0;
      var a=(v/total)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.fillStyle=palette[i%palette.length];
      ctx.globalAlpha=0.85;
      ctx.arc(cx,cy,r,ang,ang+a);
      ctx.closePath();
      ctx.fill();
      ang+=a;
    }
    // hole
    ctx.globalAlpha=1;
    ctx.beginPath();
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.arc(cx,cy,rIn,0,Math.PI*2);
    ctx.fill();

    // center text
    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.font="bold 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(String(total), cx, cy-2);
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle="rgba(255,255,255,0.7)";
    ctx.fillText("total", cx, cy+16);
  }

  function drawLine(canvas, labels, values){
    var ctx = ctx2d(canvas);
    var w = canvas.clientWidth || 900, h = canvas.clientHeight || 260;
    clear(ctx, w, h);
    if (!values || !values.length){ textCenter(ctx,w,h,"No data"); return; }

    var padL=46, padR=14, padT=14, padB=30;
    var plotW=w-padL-padR, plotH=h-padT-padB;

    var maxV=Math.max.apply(null, values.map(v=>+v||0));
    var minV=Math.min.apply(null, values.map(v=>+v||0));
    if (maxV===minV) maxV=minV+1;

    // axes
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT);
    ctx.lineTo(padL,padT+plotH);
    ctx.lineTo(padL+plotW,padT+plotH);
    ctx.stroke();

    // line
    ctx.strokeStyle="rgba(59,130,246,0.9)";
    ctx.lineWidth=2;
    ctx.beginPath();
    for (var i=0;i<values.length;i++){
      var x = padL + (i/(Math.max(1,values.length-1)))*plotW;
      var y = padT + (1-((+values[i]||0)-minV)/(maxV-minV))*plotH;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // points
    ctx.fillStyle="rgba(59,130,246,0.95)";
    for (var i=0;i<values.length;i++){
      var x = padL + (i/(Math.max(1,values.length-1)))*plotW;
      var y = padT + (1-((+values[i]||0)-minV)/(maxV-minV))*plotH;
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
    }

    // y labels
    ctx.fillStyle="rgba(255,255,255,0.7)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign="right"; ctx.textBaseline="middle";
    ctx.fillText(String(maxV), padL-8, padT);
    ctx.fillText(String(minV), padL-8, padT+plotH);
  }

  function drawBars(canvas, labels, s0, s1){
    var ctx = ctx2d(canvas);
    var w = canvas.clientWidth || 900, h = canvas.clientHeight || 260;
    clear(ctx, w, h);
    if (!labels || !labels.length){ textCenter(ctx,w,h,"No data"); return; }

    var padL=46, padR=14, padT=14, padB=30;
    var plotW=w-padL-padR, plotH=h-padT-padB;

    var maxV=0;
    for (var i=0;i<labels.length;i++){
      maxV=Math.max(maxV, (+s0[i]||0)+(+s1[i]||0), (+s0[i]||0), (+s1[i]||0));
    }
    if (!maxV) maxV=1;

    // axes
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT);
    ctx.lineTo(padL,padT+plotH);
    ctx.lineTo(padL+plotW,padT+plotH);
    ctx.stroke();

    var n=labels.length;
    var groupW = plotW / n;
    var barW = Math.max(6, groupW*0.28);

    for (var i=0;i<n;i++){
      var x0 = padL + i*groupW + groupW*0.18;
      var v0 = +s0[i]||0;
      var v1 = +s1[i]||0;

      var h0 = (v0/maxV)*plotH;
      var h1 = (v1/maxV)*plotH;

      // critical
      ctx.fillStyle="rgba(239,68,68,0.85)";
      ctx.fillRect(x0, padT+plotH-h0, barW, h0);

      // high (next to)
      ctx.fillStyle="rgba(245,158,11,0.85)";
      ctx.fillRect(x0+barW+4, padT+plotH-h1, barW, h1);
    }
  }

  async function renderOnce(){
    var a=document.getElementById("vsp-chart-severity");
    var b=document.getElementById("vsp-chart-trend");
    var c=document.getElementById("vsp-chart-bytool");
    var d=document.getElementById("vsp-chart-topcwe");
    if (!a || !b || !c || !d) return false;

    var rid = await getRid();
    if (!rid) return false;

    var resp = await fetch("/api/vsp/dash_charts?rid="+encodeURIComponent(rid), {cache:"no-store"});
    var j = await resp.json();

    var donut=parseDonut(j);
    var trend=parseTrend(j);
    var bar=parseBarCritHigh(j);
    var top=parseTopCwe(j);

    // DONUT
    var c1=ensureCanvas("vsp-chart-severity");
    if (c1 && donut) drawDonut(c1, donut.labels||[], donut.values||[]);

    // TREND
    var c2=ensureCanvas("vsp-chart-trend");
    if (c2 && trend) drawLine(c2, trend.labels||[], trend.values||[]);

    // BYTOOL
    var c3=ensureCanvas("vsp-chart-bytool");
    if (c3 && bar){
      var s0 = bar.series?.[0]?.data || [];
      var s1 = bar.series?.[1]?.data || [];
      drawBars(c3, bar.labels||[], s0, s1);
    }

    // TOPCWE (single series)
    var c4=ensureCanvas("vsp-chart-topcwe");
    if (c4 && top){
      drawBars(c4, top.labels||[], top.values||[], new Array((top.labels||[]).length).fill(0));
    }

    console.log("[VSP][DASH][V6D] canvas-rendered rid=", rid, "ChartJS=", !!window.Chart);
    return true;
  }

  var tries=0;
  var t=setInterval(function(){
    tries++;
    renderOnce().then(function(ok){
      if (ok || tries>=20){
        clearInterval(t);
        if (!ok) console.warn("[VSP][DASH][V6D] gave up: containers/rid missing");
      }
    }).catch(function(e){
      if (tries>=20){ clearInterval(t); console.warn("[VSP][DASH][V6D] error", e); }
    });
  }, 500);
})();




// VSP_P1_DASH_RID_RESOLVER_CANVAS_V6E
(function(){
  if (window.__VSP_DASH_V6E) return;
  window.__VSP_DASH_V6E = true;

  function qs(id){ return document.getElementById(id); }

  function ensureCanvas(holderId){
    var el = qs(holderId);
    if (!el) return null;
    if ((el.tagName||"").toLowerCase()==="canvas") return el;
    var c = el.querySelector && el.querySelector("canvas");
    if (!c){
      c=document.createElement("canvas");
      c.style.width="100%";
      c.style.height="260px";
      el.innerHTML="";
      el.appendChild(c);
    }
    return c;
  }

  function setupCtx(canvas){
    var ctx=canvas.getContext("2d");
    var dpr=window.devicePixelRatio||1;
    var w=Math.max(320, canvas.clientWidth||900);
    var h=Math.max(220, canvas.clientHeight||260);
    canvas.width=Math.floor(w*dpr);
    canvas.height=Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {ctx,w,h};
  }

  function clearBg(ctx,w,h){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle="rgba(255,255,255,0.03)";
    ctx.fillRect(0,0,w,h);
  }

  function drawText(ctx,w,h,msg){
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(msg, w/2, h/2);
  }

  function drawDonut(canvas, labels, values){
    var o=setupCtx(canvas), ctx=o.ctx, w=o.w, h=o.h;
    clearBg(ctx,w,h);
    var total=(values||[]).reduce((a,b)=>a+(+b||0),0);
    if (!total){ drawText(ctx,w,h,"No data"); return; }
    var cx=w/2, cy=h/2, r=Math.min(w,h)*0.32, rIn=r*0.55;
    var ang=-Math.PI/2;
    var pal=["#ef4444","#f59e0b","#3b82f6","#22c55e","#a855f7","#94a3b8"];
    for (var i=0;i<values.length;i++){
      var v=+values[i]||0, a=(v/total)*Math.PI*2;
      ctx.beginPath(); ctx.moveTo(cx,cy);
      ctx.fillStyle=pal[i%pal.length];
      ctx.globalAlpha=0.85;
      ctx.arc(cx,cy,r,ang,ang+a);
      ctx.closePath(); ctx.fill();
      ang+=a;
    }
    ctx.globalAlpha=1;
    ctx.beginPath(); ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.arc(cx,cy,rIn,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.font="bold 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(String(total), cx, cy-2);
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle="rgba(255,255,255,0.65)";
    ctx.fillText("total", cx, cy+16);
  }

  function drawLine(canvas, labels, values){
    var o=setupCtx(canvas), ctx=o.ctx, w=o.w, h=o.h;
    clearBg(ctx,w,h);
    if (!values || !values.length){ drawText(ctx,w,h,"No data"); return; }
    var padL=46,padR=14,padT=14,padB=30;
    var pw=w-padL-padR, ph=h-padT-padB;
    var maxV=Math.max.apply(null, values.map(v=>+v||0));
    var minV=Math.min.apply(null, values.map(v=>+v||0));
    if (maxV===minV) maxV=minV+1;

    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT);
    ctx.lineTo(padL,padT+ph);
    ctx.lineTo(padL+pw,padT+ph);
    ctx.stroke();

    ctx.strokeStyle="rgba(59,130,246,0.9)";
    ctx.lineWidth=2;
    ctx.beginPath();
    for (var i=0;i<values.length;i++){
      var x=padL+(i/(Math.max(1,values.length-1)))*pw;
      var y=padT+(1-((+values[i]||0)-minV)/(maxV-minV))*ph;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  function drawBars(canvas, labels, a0, a1){
    var o=setupCtx(canvas), ctx=o.ctx, w=o.w, h=o.h;
    clearBg(ctx,w,h);
    if (!labels || !labels.length){ drawText(ctx,w,h,"No data"); return; }
    var padL=46,padR=14,padT=14,padB=30;
    var pw=w-padL-padR, ph=h-padT-padB;
    var maxV=1;
    for (var i=0;i<labels.length;i++){
      maxV=Math.max(maxV, (+a0[i]||0), (+a1[i]||0), (+a0[i]||0)+(+a1[i]||0));
    }

    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT);
    ctx.lineTo(padL,padT+ph);
    ctx.lineTo(padL+pw,padT+ph);
    ctx.stroke();

    var n=labels.length;
    var gw=pw/n;
    var bw=Math.max(6, gw*0.28);
    for (var i=0;i<n;i++){
      var x0=padL+i*gw+gw*0.18;
      var v0=+a0[i]||0, v1=+a1[i]||0;
      var h0=(v0/maxV)*ph, h1=(v1/maxV)*ph;
      ctx.fillStyle="rgba(239,68,68,0.85)";
      ctx.fillRect(x0, padT+ph-h0, bw, h0);
      ctx.fillStyle="rgba(245,158,11,0.85)";
      ctx.fillRect(x0+bw+4, padT+ph-h1, bw, h1);
    }
  }

  function parse(j){
    var donut=null, trend=null, bar=null, top=null;

    if (Array.isArray(j?.severity_distribution))
      donut={labels:j.severity_distribution.map(x=>x.sev), values:j.severity_distribution.map(x=>x.count)};

    if (Array.isArray(j?.findings_trend))
      trend={labels:j.findings_trend.map(x=>x.rid), values:j.findings_trend.map(x=>x.total)};

    if (Array.isArray(j?.critical_high_by_tool)){
      bar={labels:j.critical_high_by_tool.map(x=>x.tool),
           s0:j.critical_high_by_tool.map(x=>x.critical||0),
           s1:j.critical_high_by_tool.map(x=>x.high||0)};
    }

    if (Array.isArray(j?.top_cwe_exposure))
      top={labels:j.top_cwe_exposure.map(x=>x.cwe), values:j.top_cwe_exposure.map(x=>x.count)};

    return {donut,trend,bar,top};
  }

  function ridFromText(){
    try{
      var t=(document.body && (document.body.innerText||document.body.textContent)||"");
      var m=t.match(/rid_latest\s*=\s*([A-Za-z0-9_\-\.]+)/i) || t.match(/rid_latest\s*:\s*([A-Za-z0-9_\-\.]+)/i);
      return m ? (m[1]||"") : "";
    }catch(e){ return ""; }
  }

  async function resolveRid(){
    // 1) URL param
    try{
      var u=new URL(window.location.href);
      var rid=u.searchParams.get("rid");
      if (rid) return rid;
    }catch(e){}

    // 2) hidden input / element
    var el=qs("vsp_live_rid");
    if (el){
      var v = (el.value!=null ? el.value : "") || (el.textContent||"").trim();
      if (v) return v;
    }

    // 3) text regex (your “OK rid_latest=...”)
    var r3 = ridFromText();
    if (r3) return r3;

    // 4) API fallback
    try{
      var r=await (window.VSP_RUNS_GUARD && window.VSP_RUNS_GUARD.fetchJson ? window.VSP_RUNS_GUARD.fetchJson("/api/vsp/runs?limit=1", 6000) : fetch("/api/vsp/runs?limit=1"));
      var j=await r.json();
      var rid2=j?.items?.[0]?.run_id || "";
      return rid2;
    }catch(e){
      return "";
    }
  }

  async function render(){
    // only on /vsp5
    if (!(location.pathname||"").includes("/vsp5")) return false;

    var ids=["vsp-chart-severity","vsp-chart-trend","vsp-chart-bytool","vsp-chart-topcwe"];
    var okIds = ids.every(id=>!!qs(id));
    var rid = await resolveRid();

    console.log("[VSP][DASH][V6E] check ids=", okIds, "rid=", rid);

    if (!okIds || !rid) return false;

    // fetch charts once
    var resp=await fetch("/api/vsp/dash_charts?rid="+encodeURIComponent(rid), {cache:"no-store"});
    var j=await resp.json();
    var o=parse(j);

    var c1=ensureCanvas("vsp-chart-severity"); if (c1 && o.donut) drawDonut(c1, o.donut.labels, o.donut.values);
    var c2=ensureCanvas("vsp-chart-trend"); if (c2 && o.trend) drawLine(c2, o.trend.labels, o.trend.values);
    var c3=ensureCanvas("vsp-chart-bytool"); if (c3 && o.bar) drawBars(c3, o.bar.labels, o.bar.s0, o.bar.s1);
    var c4=ensureCanvas("vsp-chart-topcwe"); if (c4 && o.top) drawBars(c4, o.top.labels, o.top.values, new Array(o.top.labels.length).fill(0));

    console.log("[VSP][DASH][V6E] rendered rid=", rid);
    return true;
  }

  function start(){
    var tries=0;
    var t=setInterval(function(){
      tries++;
      render().then(function(ok){
        if (ok || tries>=60){ // 30s
          clearInterval(t);
          if (!ok) console.warn("[VSP][DASH][V6E] gave up (rid/ids still missing)");
        }
      }).catch(function(e){
        if (tries>=60){ clearInterval(t); console.warn("[VSP][DASH][V6E] error", e); }
      });
    }, 500);
  }

  if (document.readyState==="complete") start();
  else window.addEventListener("load", start);
})();




// VSP_P1_DASH_RID_WAIT_CANVAS_V6F
(function(){
  if (window.__VSP_DASH_V6F) return;
  window.__VSP_DASH_V6F = true;

  function id(x){ return document.getElementById(x); }

  function extractRidFromText(t){
    if (!t) return "";
    // accept rid_latest: XXX or rid_latest=XXX or FORCE rid=XXX
    var m = String(t).match(/rid_latest\s*[:=]\s*([A-Za-z0-9_\-\.]+)/i) ||
            String(t).match(/FORCE\s*rid\s*=\s*([A-Za-z0-9_\-\.]+)/i);
    return m ? (m[1]||"") : "";
  }

  function isGoodRid(r){
    if (!r) return false;
    if (r === "N/A" || r === "..." || r === "NA") return false;
    if (r.indexOf("rid_latest")>=0) return false;
    if (r.indexOf(":")>=0 || r.indexOf(" ")>=0) return false;
    return true;
  }

  async function resolveRidStrong(){
    // 1) URL param
    try{
      var u=new URL(location.href);
      var rid=u.searchParams.get("rid");
      if (isGoodRid(rid)) return rid;
    }catch(e){}

    // 2) #vsp_live_rid text (it will become: "rid_latest: REAL_RID")
    var el=id("vsp_live_rid");
    if (el){
      var t=(el.value!=null ? el.value : "") || (el.textContent||"");
      var r2 = extractRidFromText(t) || String(t).trim();
      if (isGoodRid(r2)) return r2;
    }

    // 3) badge (if exists)
    var b=id("vsp_rid_latest_badge");
    if (b){
      var r3=extractRidFromText(b.textContent||"");
      if (isGoodRid(r3)) return r3;
    }

    // 4) /api/vsp/runs (best fallback)
    try{
      var r=await (window.VSP_RUNS_GUARD && window.VSP_RUNS_GUARD.fetchJson ? window.VSP_RUNS_GUARD.fetchJson("/api/vsp/runs?limit=1", 6000) : fetch("/api/vsp/runs?limit=1"));
      var j=await r.json();
      var ridLatest = j && j.rid_latest ? j.rid_latest : "";
      if (isGoodRid(ridLatest)) return ridLatest;
      var rid0 = j?.items?.[0]?.run_id || "";
      if (isGoodRid(rid0)) return rid0;
    }catch(e){}

    return "";
  }

  function ensureCanvas(holderId){
    var el=id(holderId);
    if (!el) return null;
    if ((el.tagName||"").toLowerCase()==="canvas") return el;
    var c = el.querySelector && el.querySelector("canvas");
    if (!c){
      c=document.createElement("canvas");
      c.style.width="100%";
      c.style.height="260px";
      el.innerHTML="";
      el.appendChild(c);
    }
    return c;
  }

  function setupCtx(canvas){
    var ctx=canvas.getContext("2d");
    var dpr=window.devicePixelRatio||1;
    var w=Math.max(320, canvas.clientWidth||900);
    var h=Math.max(220, canvas.clientHeight||260);
    canvas.width=Math.floor(w*dpr);
    canvas.height=Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return {ctx,w,h};
  }
  function clearBg(ctx,w,h){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle="rgba(255,255,255,0.03)";
    ctx.fillRect(0,0,w,h);
  }
  function textCenter(ctx,w,h,msg){
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(msg, w/2, h/2);
  }
  function drawDonut(canvas, labels, values){
    var o=setupCtx(canvas), ctx=o.ctx, w=o.w, h=o.h;
    clearBg(ctx,w,h);
    var total=(values||[]).reduce((a,b)=>a+(+b||0),0);
    if (!total){ textCenter(ctx,w,h,"No data"); return; }
    var cx=w/2, cy=h/2, r=Math.min(w,h)*0.32, rIn=r*0.55;
    var ang=-Math.PI/2;
    var pal=["#ef4444","#f59e0b","#3b82f6","#22c55e","#a855f7","#94a3b8"];
    for (var i=0;i<values.length;i++){
      var v=+values[i]||0, a=(v/total)*Math.PI*2;
      ctx.beginPath(); ctx.moveTo(cx,cy);
      ctx.fillStyle=pal[i%pal.length];
      ctx.globalAlpha=0.85;
      ctx.arc(cx,cy,r,ang,ang+a);
      ctx.closePath(); ctx.fill();
      ang+=a;
    }
    ctx.globalAlpha=1;
    ctx.beginPath(); ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.arc(cx,cy,rIn,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.font="bold 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(String(total), cx, cy-2);
    ctx.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle="rgba(255,255,255,0.65)";
    ctx.fillText("total", cx, cy+16);
  }
  function drawLine(canvas, labels, values){
    var o=setupCtx(canvas), ctx=o.ctx, w=o.w, h=o.h;
    clearBg(ctx,w,h);
    if (!values || !values.length){ textCenter(ctx,w,h,"No data"); return; }
    var padL=46,padR=14,padT=14,padB=30;
    var pw=w-padL-padR, ph=h-padT-padB;
    var maxV=Math.max.apply(null, values.map(v=>+v||0));
    var minV=Math.min.apply(null, values.map(v=>+v||0));
    if (maxV===minV) maxV=minV+1;
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT); ctx.lineTo(padL,padT+ph); ctx.lineTo(padL+pw,padT+ph);
    ctx.stroke();
    ctx.strokeStyle="rgba(59,130,246,0.9)";
    ctx.lineWidth=2;
    ctx.beginPath();
    for (var i=0;i<values.length;i++){
      var x=padL+(i/(Math.max(1,values.length-1)))*pw;
      var y=padT+(1-((+values[i]||0)-minV)/(maxV-minV))*ph;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  function drawBars(canvas, labels, a0, a1){
    var o=setupCtx(canvas), ctx=o.ctx, w=o.w, h=o.h;
    clearBg(ctx,w,h);
    if (!labels || !labels.length){ textCenter(ctx,w,h,"No data"); return; }
    var padL=46,padR=14,padT=14,padB=30;
    var pw=w-padL-padR, ph=h-padT-padB;
    var maxV=1;
    for (var i=0;i<labels.length;i++){
      maxV=Math.max(maxV, (+a0[i]||0), (+a1[i]||0), (+a0[i]||0)+(+a1[i]||0));
    }
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT); ctx.lineTo(padL,padT+ph); ctx.lineTo(padL+pw,padT+ph);
    ctx.stroke();
    var n=labels.length, gw=pw/n, bw=Math.max(6, gw*0.28);
    for (var i=0;i<n;i++){
      var x0=padL+i*gw+gw*0.18;
      var v0=+a0[i]||0, v1=+a1[i]||0;
      var h0=(v0/maxV)*ph, h1=(v1/maxV)*ph;
      ctx.fillStyle="rgba(239,68,68,0.85)";
      ctx.fillRect(x0, padT+ph-h0, bw, h0);
      ctx.fillStyle="rgba(245,158,11,0.85)";
      ctx.fillRect(x0+bw+4, padT+ph-h1, bw, h1);
    }
  }

  function parseCharts(j){
    var donut=null, trend=null, bar=null, top=null;
    if (Array.isArray(j?.severity_distribution))
      donut={labels:j.severity_distribution.map(x=>x.sev), values:j.severity_distribution.map(x=>x.count)};
    if (Array.isArray(j?.findings_trend))
      trend={labels:j.findings_trend.map(x=>x.rid), values:j.findings_trend.map(x=>x.total)};
    if (Array.isArray(j?.critical_high_by_tool))
      bar={labels:j.critical_high_by_tool.map(x=>x.tool),
           a0:j.critical_high_by_tool.map(x=>x.critical||0),
           a1:j.critical_high_by_tool.map(x=>x.high||0)};
    if (Array.isArray(j?.top_cwe_exposure))
      top={labels:j.top_cwe_exposure.map(x=>x.cwe), values:j.top_cwe_exposure.map(x=>x.count)};
    return {donut,trend,bar,top};
  }

  async function renderOnce(){
    if (!(location.pathname||"").includes("/vsp5")) return false;

    var ids=["vsp-chart-severity","vsp-chart-trend","vsp-chart-bytool","vsp-chart-topcwe"];
    var okIds=ids.every(x=>!!id(x));
    var rid=await resolveRidStrong();

    console.log("[VSP][DASH][V6F] ids=", okIds, "rid=", rid);

    if (!okIds || !isGoodRid(rid)) return false;

    var resp=await fetch("/api/vsp/dash_charts?rid="+encodeURIComponent(rid), {cache:"no-store"});
    if (!resp.ok){
      console.warn("[VSP][DASH][V6F] dash_charts HTTP", resp.status);
      return false;
    }
    var j=await resp.json();
    var o=parseCharts(j);

    var c1=ensureCanvas("vsp-chart-severity"); if (c1 && o.donut) drawDonut(c1, o.donut.labels, o.donut.values);
    var c2=ensureCanvas("vsp-chart-trend");    if (c2 && o.trend) drawLine(c2, o.trend.labels, o.trend.values);
    var c3=ensureCanvas("vsp-chart-bytool");   if (c3 && o.bar)   drawBars(c3, o.bar.labels, o.bar.a0, o.bar.a1);
    var c4=ensureCanvas("vsp-chart-topcwe");   if (c4 && o.top)   drawBars(c4, o.top.labels, o.top.values, new Array(o.top.labels.length).fill(0));

    console.log("[VSP][DASH][V6F] rendered rid=", rid);
    return true;
  }

  function start(){
    var tries=0;
    var t=setInterval(function(){
      tries++;
      renderOnce().then(function(ok){
        if (ok || tries>=80){
          clearInterval(t);
          if (!ok) console.warn("[VSP][DASH][V6F] gave up (rid still not ready)");
        }
      }).catch(function(e){
        if (tries>=80){ clearInterval(t); console.warn("[VSP][DASH][V6F] error", e); }
      });
    }, 500);
  }

  if (document.readyState==="complete") start();
  else window.addEventListener("load", start);
})();


/* ===== VSP_P1_DASH_RENDER_STABLE_V1 (NO Chart.js) ===== */
(function(){
  const LOGP = "[VSP][DASH][STABLE_V1]";
  const $ = (id)=>document.getElementById(id);
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const now = ()=>Date.now();

  function onReady(fn){
    if (document.readyState === "complete" || document.readyState === "interactive") return fn();
    document.addEventListener("DOMContentLoaded", fn, {once:true});
  }

  async function fetchJSON(url){
    const u = url + (url.includes("?") ? "&" : "?") + "_=" + now();
    const r = await fetch(u, {cache:"no-store", credentials:"same-origin"});
    const t = await r.text();
    try { return JSON.parse(t); } catch(e){
      console.warn(LOGP, "bad json from", u, "len=", (t||"").length);
      throw e;
    }
  }

  function fitCanvas(canvas, w, h){
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.max(10, Math.floor(w * dpr));
    canvas.height = Math.max(10, Math.floor(h * dpr));
    canvas.style.width  = Math.max(10, Math.floor(w)) + "px";
    canvas.style.height = Math.max(10, Math.floor(h)) + "px";
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return ctx;
  }

  function ensureCanvasIn(containerId, minH){
    const box = $(containerId);
    if (!box) return null;
    box.textContent = ""; // clear placeholder
    const c = document.createElement("canvas");
    c.setAttribute("aria-label", containerId);
    c.style.display = "block";
    c.style.width = "100%";
    c.style.height = (minH||220) + "px";
    box.appendChild(c);

    const w = box.clientWidth || 800;
    const h = Math.max(minH||220, box.clientHeight || 0, 200);
    const ctx = fitCanvas(c, w, h);
    return {box, canvas:c, ctx, w, h};
  }

  function drawTextCenter(ctx, w, h, txt){
    ctx.clearRect(0,0,w,h);
    ctx.globalAlpha = 1;
    ctx.font = "13px sans-serif";
    ctx.fillStyle = "rgba(220,230,255,0.75)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(txt, w/2, h/2);
  }

  function drawDonut(ctx, w, h, items){
    // items: [{sev,count}]
    const total = items.reduce((a,x)=>a+(+x.count||0),0) || 1;
    const cx=w/2, cy=h/2, r=Math.min(w,h)*0.32;
    const r2=r*0.62;
    let a0 = -Math.PI/2;

    ctx.clearRect(0,0,w,h);
    ctx.lineWidth = 18;
    const palette = [
      "rgba(255,80,80,0.85)",   // CRITICAL
      "rgba(255,160,80,0.85)",  // HIGH
      "rgba(255,220,80,0.85)",  // MEDIUM
      "rgba(160,220,120,0.85)", // LOW
      "rgba(120,180,255,0.85)", // INFO
      "rgba(180,180,200,0.65)"  // TRACE
    ];
    items.forEach((it, i)=>{
      const v = (+it.count||0);
      const a1 = a0 + (v/total)*Math.PI*2;
      ctx.beginPath();
      ctx.strokeStyle = palette[i % palette.length];
      ctx.arc(cx,cy,r,a0,a1,false);
      ctx.stroke();
      a0 = a1;
    });

    // hole
    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.arc(cx,cy,r2,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";

    // center text
    ctx.font="12px sans-serif";
    ctx.fillStyle="rgba(220,230,255,0.85)";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText("TOTAL", cx, cy-8);
    ctx.font="14px sans-serif";
    ctx.fillText(String(total), cx, cy+10);
  }

  function drawBars(ctx, w, h, rows, keyA, keyB){
    // rows: [{tool, critical, high}] -> stacked bar
    ctx.clearRect(0,0,w,h);
    const pad=18, left=80, top=14, bottom=24;
    const innerW = w-left-pad, innerH = h-top-bottom;

    const maxV = Math.max(1, ...rows.map(r=>(+r[keyA]||0)+(+r[keyB]||0)));
    ctx.font="12px sans-serif";
    ctx.textBaseline="middle";

    rows.slice(0,8).forEach((r, idx)=>{
      const y = top + idx*(innerH/8) + (innerH/8)/2;
      const total = (+r[keyA]||0)+(+r[keyB]||0);
      const bw = (total/maxV)*innerW;

      // label
      ctx.fillStyle="rgba(220,230,255,0.75)";
      ctx.textAlign="right";
      ctx.fillText(String(r.tool||"").slice(0,10), left-8, y);

      // bar
      ctx.fillStyle="rgba(255,120,120,0.75)";
      ctx.fillRect(left, y-7, Math.max(2,bw), 14);

      // value
      ctx.textAlign="left";
      ctx.fillStyle="rgba(220,230,255,0.65)";
      ctx.fillText(String(total), left + Math.max(2,bw) + 6, y);
    });
  }

  function drawTopCWE(ctx, w, h, rows){
    // rows: [{cwe,count}]
    ctx.clearRect(0,0,w,h);
    const pad=18, left=90, top=14, bottom=22;
    const innerW=w-left-pad, innerH=h-top-bottom;

    const maxV = Math.max(1, ...rows.map(r=>(+r.count||0)));
    ctx.font="12px sans-serif";
    rows.slice(0,8).forEach((r, idx)=>{
      const y = top + idx*(innerH/8) + 6;
      const bw = ((+r.count||0)/maxV)*innerW;

      ctx.fillStyle="rgba(220,230,255,0.75)";
      ctx.textAlign="right";
      ctx.fillText(String(r.cwe||"").slice(0,14), left-8, y+6);

      ctx.fillStyle="rgba(120,180,255,0.65)";
      ctx.fillRect(left, y, Math.max(2,bw), 12);

      ctx.textAlign="left";
      ctx.fillStyle="rgba(220,230,255,0.6)";
      ctx.fillText(String(+r.count||0), left + Math.max(2,bw) + 6, y+6);
    });
  }

  function drawTrend(ctx, w, h, points){
    // points: [{rid,total_findings}] (càng mới càng phải)
    ctx.clearRect(0,0,w,h);
    const pad=18, left=40, top=14, bottom=28;
    const innerW=w-left-pad, innerH=h-top-bottom;

    const ys = points.map(p=>(+p.total_findings||0));
    const maxY = Math.max(1, ...ys);
    const minY = Math.min(...ys, 0);

    // axes
    ctx.strokeStyle="rgba(220,230,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(left, top);
    ctx.lineTo(left, top+innerH);
    ctx.lineTo(left+innerW, top+innerH);
    ctx.stroke();

    if(points.length < 2){
      drawTextCenter(ctx,w,h,"trend: not enough points");
      return;
    }

    // line
    ctx.strokeStyle="rgba(160,220,120,0.85)";
    ctx.lineWidth=2;
    ctx.beginPath();
    points.forEach((p,i)=>{
      const x = left + (i/(points.length-1))*innerW;
      const yv = (+p.total_findings||0);
      const y = top + innerH - ((yv-minY)/(maxY-minY||1))*innerH;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  function setText(id, val){
    const el=$(id);
    if(!el) return;
    el.textContent = (val===null || val===undefined) ? "N/A" : String(val);
  }

  function setGate(id, overall){
    const el=$(id);
    if(!el) return;
    const s = String(overall||"").toUpperCase();
    el.textContent = (s || "N/A") + (s==="RED" ? " • Blocking pipeline" : "");
    el.classList.remove("vsp-gate-red","vsp-gate-amber","vsp-gate-green");
    if(s==="RED") el.classList.add("vsp-gate-red");
    else if(s==="AMBER") el.classList.add("vsp-gate-amber");
    else if(s==="GREEN") el.classList.add("vsp-gate-green");
  }

  async function resolveRidLatest(){
    const j = await fetchJSON("/api/vsp/runs?limit=1");
    return (j && (j.rid_latest || (j.items && j.items[0] && j.items[0].run_id))) || null;
  }

  async function runOnce(){
    // đảm bảo containers có mặt
    const ids = ["vsp-chart-severity","vsp-chart-trend","vsp-chart-bytool","vsp-chart-topcwe"];
    const miss = ids.filter(x=>!$(x));
    if(miss.length){
      console.warn(LOGP, "missing containers:", miss.join(","));
      return;
    }

    const rid = await resolveRidLatest();
    setText("vsp-header-run-id", rid || "N/A");
    setText("vsp_live_rid", "rid_latest: " + (rid||"N/A"));

    if(!rid){
      console.debug(LOGP, "rid_latest N/A");
      return;
    }

    const kpis = await fetchJSON("/api/vsp/dash_kpis?rid=" + encodeURIComponent(rid));
    const charts = await fetchJSON("/api/vsp/dash_charts?rid=" + encodeURIComponent(rid));

    // KPI mapping
    setText("vsp-kpi-total-findings", kpis.total_findings);
    setText("vsp-kpi-critical", (kpis.counts_total && kpis.counts_total.CRITICAL));
    setText("vsp-kpi-high",     (kpis.counts_total && kpis.counts_total.HIGH));
    setText("vsp-kpi-medium",   (kpis.counts_total && kpis.counts_total.MEDIUM));
    setText("vsp-kpi-low",      (kpis.counts_total && kpis.counts_total.LOW));
    setText("vsp-kpi-score",    kpis.security_score);
    setText("vsp-kpi-top-tool", kpis.top_risky_tool);
    setText("vsp-kpi-top-cwe",  kpis.top_impacted_cwe);
    setText("vsp-kpi-top-module", kpis.top_vulnerable_module);
    setGate("vsp-kpi-ci-gate", kpis.overall);

    // charts
    const sevBox = ensureCanvasIn("vsp-chart-severity", 220);
    if(sevBox) drawDonut(sevBox.ctx, sevBox.w, sevBox.h, (charts.severity_distribution||[]));

    const trBox = ensureCanvasIn("vsp-chart-trend", 220);
    if(trBox) drawTrend(trBox.ctx, trBox.w, trBox.h, (charts.findings_trend||[]));

    const btBox = ensureCanvasIn("vsp-chart-bytool", 220);
    if(btBox) drawBars(btBox.ctx, btBox.w, btBox.h, (charts.critical_high_by_tool||[]), "critical", "high");

    const cweBox = ensureCanvasIn("vsp-chart-topcwe", 220);
    if(cweBox) drawTopCWE(cweBox.ctx, cweBox.w, cweBox.h, (charts.top_cwe_exposure||[]));

    console.log(LOGP, "rendered OK rid=", rid);
  }

  async function runWithRetry(){
    // Retry vài lần vì bundle có thể chạy trước khi DOM layout ổn định
    for(let i=0;i<8;i++){
      try{
        await runOnce();
        return;
      }catch(e){
        console.warn(LOGP, "retry", i, e && e.message ? e.message : e);
        await sleep(250);
      }
    }
    console.warn(LOGP, "gave up after retries");
  }

  onReady(()=>{ setTimeout(runWithRetry, 0); });
})();


/* VSP_P1_FETCH_WRAP_RUNS_V1
   - retry /api/vsp/runs fetch (503/502/504/throw)
   - degrade to JSON 200 if still failing (avoid UI crash)
   - warnOnce for noisy console warnings
*/
(function(){
  try{
    if (window.__VSP_P1_FETCH_WRAP_RUNS_V1) return;
    window.__VSP_P1_FETCH_WRAP_RUNS_V1 = true;

    const _fetch = (window.fetch ? window.fetch.bind(window) : null);
    if (!_fetch) return;

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    const _warn = console.warn ? console.warn.bind(console) : function(){};
    const _seen = new Set();
    const warnOnce = (k, msg) => {
      if (_seen.has(k)) return;
      _seen.add(k);
      _warn(msg);
    };

    // reduce spam from known noisy warnings
    const _warn_orig = console.warn ? console.warn.bind(console) : null;
    if (_warn_orig) {
      console.warn = function(...args){
        try{
          const s = args.map(x => String(x)).join(" ");
          if (s.includes("Chart/container missing") || s.includes("containers/rid missing")) {
            const key = "noisy:" + s;
            if (_seen.has(key)) return;
            _seen.add(key);
          }
        } catch(e){}
        return _warn_orig.apply(console, args);
      };
    }

    window.fetch = async function(input, init){
      let url = "";
      try{
        url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
      }catch(e){ url=""; }

      // Only protect /api/vsp/runs calls
      if (url && url.includes("/api/vsp/runs")) {
        let lastErr = null;
        for (let i=0;i<3;i++){
          try{
            const resp = await _fetch(input, init);
            const st = resp ? resp.status : 0;
            if ((st === 503 || st === 502 || st === 504) && i < 2) {
              await sleep(250 * (i+1));
              continue;
            }
            return resp;
          } catch(e){
            lastErr = e;
            if (i < 2) await sleep(250 * (i+1));
          }
        }

        warnOnce("runs_fetch_fail", "[VSP][P1] /api/vsp/runs fetch failed after retry -> degraded list (UI continues)");
        const body = JSON.stringify({
          ok: true,  // keep JS happy (always ok)
          degraded: true,
          items: [],
          _note: "degraded runs list due to fetch error",
          _err: String(lastErr || "fetch_fail")
        });

        try{
          return new Response(body, { status: 200, headers: { "Content-Type": "application/json; charset=utf-8", "Cache-Control": "no-store" } });
        } catch(e){
          // very old browsers: fallback to original fetch result
          return _fetch(input, init);
        }
      }

      return _fetch(input, init);
    };

    warnOnce("fetchwrap_on", "[VSP][P1] fetch wrapper enabled for /api/vsp/runs (retry+degrade)");
  } catch(e){
    try{ console.warn("[VSP][P1] fetch wrapper init failed:", e); } catch(_){}
  }
})();



/* VSP_P1_RUNS_FAIL_BANNER_CLEAR_V1
   Auto-clear stale "RUNS API FAIL" banner once /api/vsp/runs returns 200 again.
*/
(function(){
  try {
    if (window.__VSP_P1_RUNS_FAIL_BANNER_CLEAR_V1) return;
    window.__VSP_P1_RUNS_FAIL_BANNER_CLEAR_V1 = true;

    const log = (...a)=>{ try{ console.log(...a); }catch(e){} };
    const warn = (...a)=>{ try{ console.warn(...a); }catch(e){} };

    function clearRunsFailBanner(reason){
      try {
        const nodes = Array.from(document.querySelectorAll("div,span,p,small,button,a,li,td,th"));
        let cleared = 0;
        for (const el of nodes) {
          const t = (el && el.textContent) ? el.textContent.trim() : "";
          if (!t) continue;
          if (t.includes("RUNS API FAIL") || t.includes("runs api fail") || t.includes("/api/vsp/runs")) {
            // hide the smallest meaningful container
            el.style.display = "none";
            cleared++;
          }
        }
        if (cleared > 0) log("[VSP][P1] cleared stale RUNS API FAIL banner:", cleared, "reason=", reason||"ok");
      } catch(e) {
        warn("[VSP][P1] clearRunsFailBanner error:", e);
      }
    }

    // clear on load (in case it was cached on the DOM)
    setTimeout(()=>clearRunsFailBanner("boot"), 900);

    const _fetch = (window.fetch ? window.fetch.bind(window) : null);
    if (!_fetch) {
      log("[VSP][P1] runs-fail auto-clear enabled (no fetch hook)");
      return;
    }

    window.fetch = async function(input, init) {
      let url = "";
      try { url = (typeof input === "string") ? input : (input && input.url) ? input.url : ""; } catch(e){}
      try {
        const resp = await _fetch(input, init);
        if (url && url.includes("/api/vsp/runs") && resp && resp.status === 200) {
          // success => clear stale banner
          setTimeout(()=>clearRunsFailBanner("runs200"), 50);
        }
        return resp;
      } catch (e) {
        // keep old behavior; do not throw extra
        return _fetch(input, init);
      }
    };

    log("[VSP][P1] runs-fail banner auto-clear enabled");
  } catch(e) {
    try{ console.warn("[VSP][P1] runs-fail banner auto-clear init failed:", e); }catch(_e){}
  }
})();


/* === VSP_P1_POLISH_ALL3_V1 (nav dedupe + pagination default + mismatch fixes) === */
(function(){
  'use strict';
  const MARK = 'VSP_P1_POLISH_ALL3_V1';

  // ---- logOnce / warnOnce (avoid console spam) ----
  const __once = new Set();
  function logOnce(k, ...a){ if(__once.has(k)) return; __once.add(k); try{ console.log('[VSP][P1]', ...a); }catch(_){ } }
  function warnOnce(k, ...a){ if(__once.has(k)) return; __once.add(k); try{ console.warn('[VSP][P1]', ...a); }catch(_){ } }

  // ---- helper: find elements by exact-ish text ----
  function elsByText(tagList, text){
    const out=[];
    const tags = tagList.split(',').map(x=>x.trim()).filter(Boolean);
    for(const t of tags){
      document.querySelectorAll(t).forEach(el=>{
        const tx=(el.textContent||'').trim();
        if(tx===text) out.push(el);
      });
    }
    return out;
  }

  // ---- 1) NAV DEDUPE (hide duplicate secondary nav buttons) ----
  function navDedupe(){
    try{
      const labels = ['Data Source','Settings','Rule Overrides','Runs & Reports','Dashboard'];
      for(const lab of labels){
        const hits = elsByText('a,button,div,span', lab);
        if(hits.length > 1){
          // keep first visible occurrence; hide later ones (usually inside big hero panel)
          for(let i=1;i<hits.length;i++){
            const el = hits[i];
            // don't hide top-left small "VSP" area etc; only hide if it's a big pill/button container
            const box = el.closest('a,button,[role="button"],.btn,.pill,.tab,.nav-item,div');
            const tgt = box || el;
            tgt.style.display = 'none';
          }
        }
      }
      logOnce(MARK+':nav', 'nav dedupe applied');
    }catch(e){
      warnOnce(MARK+':naverr', 'nav dedupe error', e);
    }
  }

  // ---- 2) PAGINATION / LIMIT DEFAULT (runs + findings) ----
  function patchFetchLimit(){
    if(window.__vsp_fetch_patched_all3) return;
    window.__vsp_fetch_patched_all3 = true;

    const origFetch = window.fetch.bind(window);
    window.fetch = async function(input, init){
      try{
        let url = (typeof input === 'string') ? input : (input && input.url) ? input.url : '';
        if(typeof url === 'string' && url){
          const isRuns = url.includes('/api/vsp/runs');
          const isFindings = url.includes('/api/vsp/findings') || url.includes('/api/vsp/unified') || url.includes('/api/vsp/data_source');
          if(isRuns || isFindings){
            // normalize limit: if missing -> 50; if limit=1 -> 50
            const hasQ = url.includes('?');
            const hasLimit = /[?&]limit=\d+/i.test(url);
            if(!hasLimit){
              url = url + (hasQ ? '&' : '?') + 'limit=50';
            }else{
              url = url.replace(/([?&]limit=)(1)(\b)/i, '$150$3');
            }
            if(typeof input !== 'string'){
              // rebuild Request
              input = new Request(url, input);
            }else{
              input = url;
            }
          }
        }
      }catch(_){ /* best effort */ }
      return origFetch(input, init);
    };

    logOnce(MARK+':fetch', 'fetch limit patched (runs/findings default limit=50)');
  }

  // ---- 2b) SHOW "Showing X of TOTAL" badges (Runs & Reports + Findings) ----
  function addShowingBadges(){
    // Runs
    function ensureBadgeRuns(){
      const hdr = Array.from(document.querySelectorAll('*')).find(el => (el.textContent||'').trim()==='Runs & Reports');
      if(!hdr) return;
      if(document.getElementById('vsp_p1_runs_showing_badge')) return;

      const b=document.createElement('div');
      b.id='vsp_p1_runs_showing_badge';
      b.style.fontSize='12px';
      b.style.opacity='0.85';
      b.style.marginTop='6px';
      b.textContent='Showing …';
      hdr.parentElement && hdr.parentElement.appendChild(b);

      const mo=new MutationObserver(()=>{
        try{
          // count rows in runs table (best-effort)
          const rows = document.querySelectorAll('table tbody tr').length || 0;
          // read TOTAL RUNS KPI if present
          let total = '';
          const kpi = Array.from(document.querySelectorAll('*')).find(el => (el.textContent||'').trim()==='TOTAL RUNS');
          if(kpi){
            // next numbers often near it
            const box = kpi.closest('div') || kpi.parentElement;
            const num = box ? (box.textContent||'').match(/TOTAL RUNS\s*([0-9][0-9,]*)/i) : None;
          }
          // fallback: search any big number near TOTAL RUNS
          if(!total){
            const cand = Array.from(document.querySelectorAll('*')).find(el => /TOTAL RUNS/i.test(el.textContent||''));
            if(cand){
              const m=(cand.textContent||'').match(/TOTAL RUNS\s*([0-9][0-9,]*)/i);
              if(m) total=m[1];
            }
          }
          const __txt = (total ? `Showing ${rows} of ${total}` : `Showing ${rows}`); if (b.textContent !== __txt) b.textContent = __txt;
        }catch(_){}
      });
      mo.observe(document.body, {subtree:true, childList:true});
    }

    // Findings (Data Source)
    function ensureBadgeFindings(){
      const hdr = Array.from(document.querySelectorAll('*')).find(el => (el.textContent||'').trim()==='Unified Findings');
      if(!hdr) return;
      if(document.getElementById('vsp_p1_findings_showing_badge')) return;

      const b=document.createElement('div');
      b.id='vsp_p1_findings_showing_badge';
      b.style.fontSize='12px';
      b.style.opacity='0.85';
      b.style.marginTop='6px';
      b.textContent='Showing …';
      hdr.parentElement && hdr.parentElement.appendChild(b);

      const mo=new MutationObserver(()=>{
        try{
          const tables = document.querySelectorAll('table');
          let rows=0;
          tables.forEach(t=>{
            const h=(t.parentElement && t.parentElement.textContent||'');
            if(/Unified Findings/i.test(h)) rows = Math.max(rows, t.querySelectorAll('tbody tr').length);
          });
          const __txt = (`Showing ${rows} (limit auto=50)`); if (b.textContent !== __txt) b.textContent = __txt;
        }catch(_){}
      });
      mo.observe(document.body, {subtree:true, childList:true});
    }

    ensureBadgeRuns();
    ensureBadgeFindings();
  }

  // ---- 3) FIX DASHBOARD donut mismatch: show "sample / total" ----
  function fixDonutTotal(){
    try{
      // read TOTAL FINDINGS number
      let totalFindings = '';
      const tf = Array.from(document.querySelectorAll('*')).find(el => (el.textContent||'').trim()==='TOTAL FINDINGS');
      if(tf){
        const box = tf.closest('div') || tf.parentElement;
        const m = (box ? (box.textContent||'') : '').match(/TOTAL FINDINGS\s*([0-9][0-9,]*)/i);
        if(m) totalFindings = m[1].replace(/,/g,'');
      }
      if(!totalFindings){
        // fallback search
        const cand = Array.from(document.querySelectorAll('*')).find(el => /TOTAL FINDINGS/i.test(el.textContent||''));
        if(cand){
          const m = (cand.textContent||'').match(/TOTAL FINDINGS\s*([0-9][0-9,]*)/i);
          if(m) totalFindings = m[1].replace(/,/g,'');
        }
      }
      if(!totalFindings) return;

      // find donut center text that contains "total"
      const totalNodes = Array.from(document.querySelectorAll('*'))
        .filter(el => el.children.length===0 && /total/i.test((el.textContent||'').trim()))
        .slice(0,80);

      // pick a node that has like "2500" and "total"
      let center = null;
      for(const el of totalNodes){
        const tx=(el.textContent||'').trim();
        if(/\b\d+\b/.test(tx) && /\btotal\b/i.test(tx)){
          center = el;
          break;
        }
      }
      if(!center) return;

      const tx=(center.textContent||'').trim();
      const m=tx.match(/(\d[\d,]*)\s*total/i);
      if(!m) return;
      const sample = m[1].replace(/,/g,'');

      center.textContent = `${sample} sample / ${totalFindings} total`;
      logOnce(MARK+':donut', 'donut total patched', {sample, total: totalFindings});
    }catch(e){
      warnOnce(MARK+':donuterr','donut patch error', e);
    }
  }

  // ---- 3b) FIX Rule Overrides mismatch: compute overrides count from editor; sync table if missing ----
  function fixRuleOverridesMetrics(){
    try{
      // locate editor panel text
      const editor = Array.from(document.querySelectorAll('pre,code,textarea,div'))
        .find(el => (el.textContent||'').includes('overrides:') && (el.textContent||'').includes('- id:'));
      if(!editor) return;

      const txt = (editor.value || editor.textContent || '');
      const ids = Array.from(txt.matchAll(/\n\s*-\s*id:\s*([A-Z0-9_]+)/g)).map(m=>m[1]);
      const tools = Array.from(txt.matchAll(/\n\s*tool:\s*([a-z0-9_-]+)/ig)).map(m=>m[1]);
      const sevs = Array.from(txt.matchAll(/\n\s*severity:\s*([A-Z]+)/g)).map(m=>m[1]);
      const scopes = Array.from(txt.matchAll(/\n\s*scope:\s*("?[^"\n]*"?)/g)).map(m=>m[1].replace(/"/g,''));

      const n = ids.length || 0;
      if(!n) return;

      // update metrics line if exists
      const metricsNode = Array.from(document.querySelectorAll('*'))
        .find(el => el.children.length===0 && /^Metrics:/i.test((el.textContent||'').trim()));
      if(metricsNode){
        metricsNode.textContent = `Metrics: ${n} overrides active (auto-synced from editor).`;
      }

      // sync table rows (best effort)
      const table = Array.from(document.querySelectorAll('table')).find(t => /Rule Override Table/i.test(t.parentElement ? (t.parentElement.textContent||'') : ''));
      if(table){
        const tbody = table.querySelector('tbody') || table;
        const existingRows = tbody.querySelectorAll('tr').length;
        if(existingRows < n){
          // append missing rows
          for(let i=existingRows;i<n;i++){
            const tr = document.createElement('tr');
            const id = ids[i] || '';
            const tool = tools[i] || '';
            const sev = sevs[i] || '';
            const scope = scopes[i] || '';
            tr.innerHTML = `
              <td>${id}</td>
              <td>${tool}</td>
              <td>-</td>
              <td>${sev}</td>
              <td>${scope}</td>
              <td></td>
            `;
            tbody.appendChild(tr);
          }
        }
      }

      logOnce(MARK+':ovr', 'rule overrides metrics/table synced', {overrides:n});
    }catch(e){
      warnOnce(MARK+':ovrerr','rule overrides patch error', e);
    }
  }

  // ---- bootstrap on route changes / tab changes ----
  let __vsp_all3_running=false;
  function runAll(){ if(__vsp_all3_running) return; __vsp_all3_running=true; try{
patchFetchLimit();
    navDedupe();
    addShowingBadges();
    fixDonutTotal();
    fixRuleOverridesMetrics();
  } finally { __vsp_all3_running=false; }
}

  // initial + after a bit (DOM late)
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=>{ runAll(); setTimeout(runAll, 800); setTimeout(runAll, 1800); });
  }else{
    runAll(); setTimeout(runAll, 800); setTimeout(runAll, 1800);
  }

  // re-run when user navigates between tabs (mutation)
  try{
    
    let __t=null;
    const mo = new MutationObserver(()=>{
      if (__t) return;
      __t = setTimeout(()=>{ __t=null; try{ runAll(); }catch(_){ } }, 250);
    });
    mo.observe(document.body, {subtree:true, childList:true});
}catch(_){}

})();


/* === VSP_P1_CONSOLE_CLEAN_DONUT_V1 === */
(function(){
  'use strict';
  const MARK="VSP_P1_CONSOLE_CLEAN_DONUT_V1";
  if (window.__vsp_p1_console_clean_donut_v1) return;
  window.__vsp_p1_console_clean_donut_v1 = true;

  // 1) drop ONLY known noisy logs (keep real errors)
  const DROP_LOG = [
    /\[VSP\]\[DASH\]\[V6[^\]]*\]\s*(check ids|ids=)/i,
    /\bcanvas-rendered\b/i,
    /\bChartJs\s*=\s*false\b/i
  ];
  const DROP_WARN = [
    /\bgave up\b.*\(chart\/container missing\)/i,
    /\bchart\/container missing\b/i
  ];

  function shouldDrop(args, arr){
    try{
      if (!args || !args.length) return false;
      const s0 = (typeof args[0] === "string") ? args[0] : "";
      return arr.some(rx => rx.test(s0));
    }catch(_){ return false; }
  }

  const olog = console.log.bind(console);
  const owarn = console.warn.bind(console);
  console.log = function(...a){ if (shouldDrop(a, DROP_LOG)) return; return olog(...a); };
  console.warn = function(...a){ if (shouldDrop(a, DROP_WARN)) return; return owarn(...a); };

  // 2) Fix donut label: show "sample / total"
  function fixDonutLabel(){
    try{
      // total findings from KPI
      let total='';
      const k = Array.from(document.querySelectorAll('*')).find(el => (el.textContent||'').trim()==='TOTAL FINDINGS');
      if (k){
        const box = k.closest('div') || k.parentElement;
        const m = (box ? (box.textContent||'') : '').match(/TOTAL FINDINGS\s*([0-9][0-9,]*)/i);
        if (m) total = m[1].replace(/,/g,'');
      }
      if (!total) return;

      // find the "SEVERITY DISTRIBUTION" card
      const h = Array.from(document.querySelectorAll('*')).find(el => (el.textContent||'').trim()==='SEVERITY DISTRIBUTION');
      if (!h) return;
      const card = h.closest('div') || h.parentElement;
      if (!card) return;

      // inside that card, find a small text node containing "<num> total"
      const nodes = Array.from(card.querySelectorAll('*'))
        .filter(el => el.children.length===0)
        .slice(0,200);

      let target=null, sample='';
      for (const el of nodes){
        const tx=(el.textContent||'').trim();
        const m=tx.match(/^(\d[\d,]*)\s*total$/i);
        if (m){ target=el; sample=m[1].replace(/,/g,''); break; }
      }
      if (!target || !sample) return;

      const want = `${sample} sample / ${total} total`;
      if ((target.textContent||'').trim() !== want) target.textContent = want;
    }catch(_){}
  }

  // run a few times (DOM loads late)
  setTimeout(fixDonutLabel, 300);
  setTimeout(fixDonutLabel, 900);
  setTimeout(fixDonutLabel, 1800);
})();


/* === VSP_P1_DONUT_OVERLAY_SAMPLE_TOTAL_V2 === */
(()=> {
  if (window.__vsp_p1_donut_overlay_v2) return;
  window.__vsp_p1_donut_overlay_v2 = true;

  function findNumberNearLabel(label){
    try{
      const els = Array.from(document.querySelectorAll('*'));
      const hit = els.find(el => (el.textContent||'').trim() === label);
      if (!hit) return '';
      const box = hit.closest('div') || hit.parentElement;
      if (!box) return '';
      const t = (box.textContent||'').replace(/\s+/g,' ');
      const esc = label.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
      const rx = new RegExp(esc + '\\s*([0-9][0-9,]*)', 'i');
      const m = t.match(rx);
      return m ? m[1].replace(/,/g,'') : '';
    }catch(_){ return ''; }
  }

  function findSampleInSeverityCard(card){
    try{
      const leaf = Array.from(card.querySelectorAll('*')).filter(el => el.children.length===0);
      for (const el of leaf){
        const tx=(el.textContent||'').trim();
        const m = tx.match(/^(\d[\d,]*)\s*total$/i);
        if (m) return {el, n:m[1].replace(/,/g,'')};
      }
    }catch(_){}
    return {el:null, n:''};
  }

  function apply(){
    try{
      const total = findNumberNearLabel('TOTAL FINDINGS');
      if (!total) return;

      const h = Array.from(document.querySelectorAll('*')).find(el => (el.textContent||'').trim()==='SEVERITY DISTRIBUTION');
      if (!h) return;
      const card = h.closest('div') || h.parentElement;
      if (!card) return;

      const {el:oldLabel, n:sample} = findSampleInSeverityCard(card);
      if (!sample) return;

      const id = 'vsp_donut_overlay_sample_total_v2';
      let ov = document.getElementById(id);
      if (!ov){
        ov = document.createElement('div');
        ov.id = id;
        ov.style.position = 'absolute';
        ov.style.inset = '0';
        ov.style.display = 'flex';
        ov.style.alignItems = 'center';
        ov.style.justifyContent = 'center';
        ov.style.pointerEvents = 'none';
        ov.style.fontWeight = '700';
        ov.style.fontSize = '14px';
        ov.style.lineHeight = '1.2';
        ov.style.opacity = '0.92';

        const canvas = card.querySelector('canvas');
        const host = (canvas && canvas.parentElement) ? canvas.parentElement : card;
        const hs = getComputedStyle(host);
        if (hs.position === 'static') host.style.position = 'relative';
        host.appendChild(ov);
      }

      ov.textContent = `${sample} sample / ${total} total`;

      if (oldLabel && oldLabel !== ov){
        oldLabel.style.opacity = '0';
      }
    }catch(_){}
  }

  setTimeout(apply, 300);
  setTimeout(apply, 900);
  setTimeout(apply, 1800);
  setTimeout(apply, 3200);
})();


/* === VSP_P1_POLISH_FINAL_V3B === */
(()=> {
  if (window.__vsp_p1_polish_final_v3b) return;
  window.__vsp_p1_polish_final_v3b = true;

  // A) Clear degraded toast/state once /api/vsp/runs is OK again
  try{
    const _fetch = window.fetch ? window.fetch.bind(window) : null;
    if (_fetch && !window.__vsp_p1_fetchhook_clear_degraded_v3b){
      window.__vsp_p1_fetchhook_clear_degraded_v3b = true;
      window.fetch = /*guarded*/(async ...args) => {
        const res = await _fetch(...args);
        try{
          const u = (args && args[0] && args[0].url) ? String(args[0].url) : String(args[0]||"");
          if (u.includes("/api/vsp/runs") && res && res.ok){
            window.__vsp_runs_last_ok = Date.now();
            if (typeof window.__vsp_set_degraded === "function") window.__vsp_set_degraded(false, "");
            if (window.VSP && typeof window.VSP.setDegraded === "function") window.VSP.setDegraded(false, "");
            // remove any toast-like node containing "degraded" + "runs"
            const cand = Array.from(document.querySelectorAll("div,span")).find(el => {
              const t=(el.textContent||"").toLowerCase();
              return t.includes("degraded") && t.includes("runs");
            });
            if (cand) cand.remove();
          }
        }catch(_){}
        return res;
      };
    }
  }catch(_){}

  // B) Donut overlay: robust attach + z-index above canvas + observer
  function findTotal(){
    try{
      const hit = Array.from(document.querySelectorAll("*")).find(el => (el.textContent||"").trim()==="TOTAL FINDINGS");
      if (!hit) return "";
      const box = hit.closest("div") || hit.parentElement;
      if (!box) return "";
      const t = (box.textContent||"").replace(/\s+/g," ");
      const m = t.match(/TOTAL FINDINGS\s*([0-9][0-9,]*)/i);
      return m ? m[1].replace(/,/g,"") : "";
    }catch(_){ return ""; }
  }

  function getSeverityCard(){
    try{
      const h = Array.from(document.querySelectorAll("*")).find(el => (el.textContent||"").trim()==="SEVERITY DISTRIBUTION");
      if (!h) return null;
      return h.closest("div") || h.parentElement || null;
    }catch(_){ return null; }
  }

  function findSample(card){
    try{
      const leaf = Array.from(card.querySelectorAll("*")).filter(el => el.children.length===0);
      for (const el of leaf){
        const tx = (el.textContent||"").trim();
        const m = tx.match(/^(\d[\d,]*)\s*total$/i);
        if (m) return {el, n:m[1].replace(/,/g,"")};
      }
    }catch(_){}
    return {el:null, n:""};
  }

  function ensureOverlay(card, sample, total){
    const id="vsp_donut_overlay_sample_total_v3b";
    let ov=document.getElementById(id);

    const canvas = card.querySelector("canvas");
    const host = (canvas && canvas.parentElement) ? canvas.parentElement : card;
    if (!host) return;

    const st = getComputedStyle(host);
    if (st.position==="static") host.style.position="relative";

    if (!ov){
      ov=document.createElement("div");
      ov.id=id;
      ov.style.position="absolute";
      ov.style.inset="0";
      ov.style.display="flex";
      ov.style.alignItems="center";
      ov.style.justifyContent="center";
      ov.style.pointerEvents="none";
      ov.style.fontWeight="700";
      ov.style.fontSize="14px";
      ov.style.lineHeight="1.2";
      ov.style.opacity="0.95";
      ov.style.zIndex="999"; // MUST be above canvas
      ov.style.textAlign="center";
      host.appendChild(ov);
    } else {
      if (ov.parentElement !== host) host.appendChild(ov);
      ov.style.zIndex="999";
    }

    ov.textContent = `${sample} sample / ${total} total`;
  }

  function apply(){
    try{
      const total = findTotal();
      const card = getSeverityCard();
      if (!total || !card) return;
      const {el:oldLabel, n:sample} = findSample(card);
      if (!sample) return;

      ensureOverlay(card, sample, total);

      if (oldLabel){
        oldLabel.style.opacity="0";
        oldLabel.style.height="0";
      }
    }catch(_){}
  }

  setTimeout(apply, 300);
  setTimeout(apply, 900);
  setTimeout(apply, 1800);
  setTimeout(apply, 3200);

  try{
    const card = getSeverityCard();
    if (card && !window.__vsp_p1_donut_observer_v3b){
      window.__vsp_p1_donut_observer_v3b=true;
      const mo = new MutationObserver(()=>apply());
      mo.observe(card, {subtree:true, childList:true, characterData:true});
    }
  }catch(_){}
})();

/* ===== VSP_P0_RUNS_REPORTS_COMMERCIAL_POLISH_V1 =====
   - Default no-filter + limit=50
   - Bind row click -> localStorage vsp_rid_selected_v2
   - Fix rid_latest fetch order + reduce noisy warn
   Safe: no-op if elements not present.
*/
(function(){
  try{
    function _qs(sel, root){ try{ return (root||document).querySelector(sel);}catch(e){return null;} }
    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel));}catch(e){return [];} }

    function vspSetSelectedRid(rid){
      if(!rid) return;
      try{ localStorage.setItem('vsp_rid_selected_v2', rid); }catch(e){}
      try{ localStorage.setItem('vsp_rid_selected', rid); }catch(e){} // compat
      // optional badges (nếu có)
      const badge =
        document.getElementById('vsp-selected-rid-badge') ||
        document.getElementById('vsp-rid-selected') ||
        document.getElementById('vsp-rid-latest') ||
        _qs('[data-vsp-selected-rid]') ||
        _qs('[data-selected-rid]');
      if(badge){
        try{ badge.textContent = rid; }catch(e){}
      }
    }

    function vspRunsDefaultNoFilterAndLimit(){
      // cố gắng set default limit=50 nếu có input/select
      const limitEls = [
        document.getElementById('limit'),
        document.getElementById('runs-limit'),
        document.getElementById('vsp-runs-limit'),
        _qs('input[name="limit"]'),
        _qs('select[name="limit"]'),
      ].filter(Boolean);

      for(const el of limitEls){
        try{
          if(el.tagName === 'SELECT'){
            // chọn option 50 nếu có
            const opt = Array.from(el.options||[]).find(o => String(o.value) === '50');
            if(opt){ el.value='50'; }
          }else{
            // input
            if(!el.value || String(el.value).trim()==='' || String(el.value)==='20' || String(el.value)==='10'){
              el.value = '50';
            }
          }
        }catch(e){}
      }

      // đảm bảo default không tick filter
      const ids = [
        'has_json','has_summary','has_html','has_csv','has_sarif',
        'filter','filter_on','hide_empty','only_with_artifacts'
      ];
      for(const id of ids){
        const el = document.getElementById(id);
        if(el && (el.type === 'checkbox' || el.type === 'radio')){
          try{ el.checked = false; }catch(e){}
        }
      }
      // các checkbox theo name (phòng khi id khác)
      _qsa('input[type="checkbox"][name^="has_"], input[type="checkbox"][name*="has"]')
        .forEach(el => { try{ el.checked = false; }catch(e){} });
    }

    function vspBindRidRowClick(){
      // delegate click: tìm ancestor có data-run-id/data-rid
      document.addEventListener('click', function(e){
        const t = e.target;
        if(!t || !t.closest) return;
        const holder = t.closest('[data-run-id],[data-rid],[data-runid],tr[data-run-id],tr[data-rid],tr[data-runid]');
        if(!holder) return;
        const rid = holder.getAttribute('data-run-id') || holder.getAttribute('data-rid') || holder.getAttribute('data-runid');
        if(rid) vspSetSelectedRid(rid);
      }, true);
    }

    async function vspFixRidLatestAfterRunsLoad(){
      // chỉ fetch 1 lần, nhẹ
      try{
        const res = await (window.VSP_RUNS_GUARD && window.VSP_RUNS_GUARD.fetchJson ? window.VSP_RUNS_GUARD.fetchJson('/api/vsp/runs?limit=1', 6000) : fetch('/api/vsp/runs?limit=1'));
        if(!res.ok) return;
        const j = await res.json();
        const rid = (j && j.items && j.items[0] && (j.items[0].run_id || j.items[0].rid)) || j.rid_latest;
        if(rid) vspSetSelectedRid(rid);
      }catch(e){}
    }

    function boot(){
      vspRunsDefaultNoFilterAndLimit();
      vspBindRidRowClick();
      // rid_latest: chạy async sau, tránh log N/A quá sớm
      setTimeout(vspFixRidLatestAfterRunsLoad, 350);
    }

    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', boot);
    }else{
      boot();
    }
  }catch(_e){}
})();

/* ===== VSP_P0_RUN_BADGE_AND_FILTER_RESET_V1 =====
   Goals:
   - Force default Runs tab = no-filter (clear persisted has/filter keys) + limit=50
   - Update header badge "ENV: ... RUN: ..." even if element has no id
   - Refresh runs list once after reset (best-effort)
*/
(function(){
  try{
    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(e){ return []; } }
    function _qs(sel, root){ try{ return (root||document).querySelector(sel); }catch(e){ return null; } }

    function vspUpdateRunBadge(rid){
      if(!rid) return;
      // 1) try known ids first
      const known = [
        'vsp-run-badge','vsp-run-id-badge','vsp-selected-run','vsp-selected-rid-badge',
        'vsp-rid-selected','vsp-rid-latest'
      ];
      for(const id of known){
        const el=document.getElementById(id);
        if(el){ try{ el.textContent = String(el.textContent||'').replace(/RUN:\s*[^|]+/i, 'RUN: '+rid); if(el.textContent===String(el.textContent||'')) el.textContent = rid; }catch(e){} return; }
      }

      // 2) heuristic: find any small badge-like element containing "ENV:" and "RUN:"
      const nodes=_qsa('span,div,small,label');
      for(const el of nodes){
        const t=(el.textContent||'').trim();
        if(!t) continue;
        if(t.includes('ENV:') && t.includes('RUN:')){
          try{
            el.textContent = t.replace(/RUN:\s*[^|]+/i, 'RUN: '+rid);
          }catch(e){}
          return;
        }
      }
    }

    function vspSetSelectedRid(rid){
      if(!rid) return;
      try{ localStorage.setItem('vsp_rid_selected_v2', rid); }catch(e){}
      try{ localStorage.setItem('vsp_rid_selected', rid); }catch(e){}
      vspUpdateRunBadge(rid);
    }

    function vspClearRunsFilterState(){
      // Clear persisted filters that cause "Showing 7 of 298"
      try{
        const ks = Object.keys(localStorage||{});
        for(const k of ks){
          const kl = (k||'').toLowerCase();
          if(
            kl.includes('runs_filter') ||
            kl.includes('vsp_runs') ||
            kl.includes('has_json') || kl.includes('has_summary') || kl.includes('has_html') || kl.includes('has_csv') || kl.includes('has_sarif') ||
            kl.startswith?.('has_') ||
            kl.includes('only_with') ||
            kl.includes('filter_has') ||
            kl.includes('filter_artifact') ||
            kl.includes('runs_limit')
          ){
            try{ localStorage.removeItem(k); }catch(e){}
          }
        }
      }catch(e){}

      // Uncheck any has_* checkbox by id or name
      _qsa('input[type="checkbox"]').forEach(el=>{
        const id=(el.id||'').toLowerCase();
        const nm=(el.name||'').toLowerCase();
        if(id.startsWith('has_') || nm.startsWith('has_') || id.includes('only_with') || nm.includes('only_with')){
          try{ el.checked=false; }catch(e){}
        }
      });

      // Set limit to 50 if there is a limit control
      const limitEls = [
        document.getElementById('limit'),
        document.getElementById('runs-limit'),
        document.getElementById('vsp-runs-limit'),
        _qs('input[name="limit"]'),
        _qs('select[name="limit"]'),
      ].filter(Boolean);

      for(const el of limitEls){
        try{
          if(el.tagName==='SELECT'){
            const opt=Array.from(el.options||[]).find(o=>String(o.value)==='50');
            if(opt) el.value='50';
          }else{
            el.value='50';
          }
        }catch(e){}
      }

      // Clear search box if any
      ['q','runs-q','vsp-runs-q','search','runs-search'].forEach(id=>{
        const el=document.getElementById(id);
        if(el && (el.tagName==='INPUT' || el.tagName==='TEXTAREA')){
          try{ el.value=''; }catch(e){}
        }
      });
    }

    async function vspFixRidLatestAfterRunsLoad(){
      try{
        const res=await (window.VSP_RUNS_GUARD && window.VSP_RUNS_GUARD.fetchJson ? window.VSP_RUNS_GUARD.fetchJson('/api/vsp/runs?limit=1', 6000) : fetch('/api/vsp/runs?limit=1'));
        if(!res.ok) return;
        const j=await res.json();
        const rid=(j && j.items && j.items[0] && (j.items[0].run_id || j.items[0].rid)) || j.rid_latest;
        if(rid) vspSetSelectedRid(rid);
      }catch(e){}
    }

    function vspBestEffortRefreshRuns(){
      // click a refresh button if exists
      const btn =
        document.getElementById('runs-refresh') ||
        _qs('[data-action="refresh-runs"]') ||
        _qs('[data-vsp-refresh-runs]');

      if(btn && btn.click){
        try{ btn.click(); return; }catch(e){}
      }
      // fallback: call common global if present
      const fns = ['refreshRuns','loadRuns','initRunsTab','vspRunsRefresh'];
      for(const n of fns){
        try{
          if(typeof window[n] === 'function'){ window[n](); return; }
        }catch(e){}
      }
    }

    function boot(){
      vspClearRunsFilterState();
      // rid_latest must be set AFTER reset to avoid "N/A"
      setTimeout(vspFixRidLatestAfterRunsLoad, 350);
      // refresh runs after filter reset
      setTimeout(vspBestEffortRefreshRuns, 650);
    }

    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot);
    else boot();
  }catch(_e){}
})();

/* ===== VSP_P0_FORCE_NOFILTER_MUTATION_V1 =====
   Keep default runs filters OFF even if:
   - checkboxes are rendered after DOMContentLoaded
   - HTML has 'checked' attribute
   Stops once user manually toggles any filter checkbox (commercial UX).
*/
(function(){
  try{
    if(window.__VSP_NOFILTER_OBS_V1) return;
    window.__VSP_NOFILTER_OBS_V1 = true;

    let userTouched=false;

    function isFilterCb(el){
      if(!el || el.type!=='checkbox') return false;
      const id=(el.id||'').toLowerCase();
      const nm=(el.name||'').toLowerCase();
      const lb=((el.getAttribute('aria-label')||'')+' '+(el.getAttribute('data-label')||'')).toLowerCase();
      const t=(id+' '+nm+' '+lb);
      return (
        t.includes('has_json') || t.includes('has_summary') || t.includes('has_sum') ||
        t.includes('has_html') || t.includes('has_csv') || t.includes('has_sarif') ||
        t.startsWith('has_') || t.includes('only_with') || t.includes('artifact')
      );
    }

    function forceOff(root){
      if(userTouched) return;
      const cbs = Array.from((root||document).querySelectorAll('input[type="checkbox"]'));
      for(const el of cbs){
        if(!isFilterCb(el)) continue;
        try{
          if(el.checked) el.checked=false;
          if(el.hasAttribute('checked')) el.removeAttribute('checked');
        }catch(e){}
      }
    }

    // Mark userTouched if they manually click any filter checkbox
    document.addEventListener('click', function(e){
      const t=e.target;
      if(t && t.matches && t.matches('input[type="checkbox"]') && isFilterCb(t)){
        userTouched=true;
        try{ window.__VSP_NOFILTER_USER_TOUCHED_V1=true; }catch(_e){}
      }
    }, true);

    // Initial enforce
    if(document.readyState==='loading'){
      document.addEventListener('DOMContentLoaded', ()=>forceOff(document));
    }else{
      forceOff(document);
    }

    // Observe future DOM additions (checkbox rendered later)
    const obs = new MutationObserver((muts)=>{
      if(userTouched) return;
      for(const m of muts){
        for(const n of Array.from(m.addedNodes||[])){
          if(n && n.querySelectorAll) forceOff(n);
        }
      }
    });
    obs.observe(document.documentElement||document.body, {childList:true, subtree:true});

    // periodic safety (very light)
    setInterval(()=>forceOff(document), 1200);
  }catch(_e){}
})();

/* ===== VSP_P0_RUNS_COMMERCIAL_POLISH_V1 =====
   - /runs default: no-filter (has_*) + limit=50
   - clear sticky degraded badge if /api/vsp/runs returns OK
*/
(function(){
  try{
    function onRunsPage(){
      try{
        const p=(location && location.pathname) ? location.pathname : "";
        return p === "/runs" || p.startsWith("/runs/");
      }catch(_e){ return false; }
    }
    if(!onRunsPage()) return;
    if(window.__VSP_RUNS_POLISH_P0_V1) return;
    window.__VSP_RUNS_POLISH_P0_V1 = true;

    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(e){ return []; } }
    function _qs(sel, root){ try{ return (root||document).querySelector(sel); }catch(e){ return null; } }

    function clearLocalStorageFilters(){
      try{
        const ks = Object.keys(localStorage||{});
        for(const k of ks){
          const kl=(k||"").toLowerCase();
          if(
            kl.includes("runs_filter") || kl.includes("vsp_runs") ||
            kl.startsWith("has_") || kl.includes("has_json") || kl.includes("has_sum") || kl.includes("has_summary") ||
            kl.includes("has_html") || kl.includes("has_csv") || kl.includes("has_sarif") ||
            kl.includes("only_with") || kl.includes("artifact") || kl.includes("runs_limit")
          ){
            try{ localStorage.removeItem(k); }catch(_e){}
          }
        }
      }catch(_e){}
    }

    function forceNoFilter(root){
      // uncheck any "has_*" checkboxes (id/name/label)
      const cbs=_qsa('input[type="checkbox"]', root);
      for(const el of cbs){
        const id=(el.id||"").toLowerCase();
        const nm=(el.name||"").toLowerCase();
        const lb=(el.getAttribute("aria-label")||"").toLowerCase();
        const t=id+" "+nm+" "+lb;
        const isHas = t.startsWith("has_") || t.includes("has_json") || t.includes("has_sum") || t.includes("has_summary") ||
                      t.includes("has_html") || t.includes("has_csv") || t.includes("has_sarif") ||
                      t.includes("only_with") || t.includes("artifact");
        if(!isHas) continue;
        try{
          if(el.checked) el.checked=false;
          if(el.hasAttribute("checked")) el.removeAttribute("checked");
        }catch(_e){}
      }

      // set limit to 50 if control exists
      const limitEls=[
        document.getElementById("limit"),
        document.getElementById("runs-limit"),
        document.getElementById("vsp-runs-limit"),
        _qs('input[name="limit"]'),
        _qs('select[name="limit"]'),
      ].filter(Boolean);

      for(const el of limitEls){
        try{
          if(el.tagName==="SELECT"){
            const opt=Array.from(el.options||[]).find(o=>String(o.value)==="50");
            if(opt) el.value="50";
          }else{
            el.value="50";
          }
        }catch(_e){}
      }
    }

    function hideDegradedBadge(){
      // hide any element showing degraded runs api 503
      const nodes=_qsa("div,span,small,label,button");
      for(const el of nodes){
        const t=(el.textContent||"").toLowerCase();
        if(t.includes("degraded") && t.includes("runs") && t.includes("api")){
          try{ el.style.display="none"; }catch(_e){}
        }
      }
    }

    async function clearDegradedIfRunsOk(){
      try{
        const res=await (window.VSP_RUNS_GUARD && window.VSP_RUNS_GUARD.fetchJson ? window.VSP_RUNS_GUARD.fetchJson("/api/vsp/runs?limit=1", 6000) : fetch("/api/vsp/runs?limit=1"));
        if(res && res.ok){
          hideDegradedBadge();
        }
      }catch(_e){}
    }

    function boot(){
      clearLocalStorageFilters();
      forceNoFilter(document);

      // Observe late-render checkboxes and force off
      const obs=new MutationObserver((muts)=>{
        for(const m of muts){
          for(const n of Array.from(m.addedNodes||[])){
            if(n && n.querySelectorAll) forceNoFilter(n);
          }
        }
      });
      try{ obs.observe(document.documentElement||document.body, {childList:true, subtree:true}); }catch(_e){}

      // Clear degraded badge when API OK (a few attempts)
      setTimeout(clearDegradedIfRunsOk, 600);
      setTimeout(clearDegradedIfRunsOk, 2200);
      setTimeout(clearDegradedIfRunsOk, 5200);
    }

    if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", boot);
    else boot();
  }catch(_e){}
})();

/* VSP_P0_DASH_NO_ABORT_MISSING_CONTAINERS_V1: no direct pattern match; no-op */
/* VSP_P0_DASH_V6D_NO_GIVEUP_V1: patched_n=0 */

/* ===== VSP_P0_CLEAR_RUNS_FAIL_ON_SUCCESS_V1 =====
   Clear sticky "RUNS API FAIL" / "degraded (runs API 503)" when any /api/vsp/runs returns OK.
*/
(function(){
  try{
    if(window.__VSP_CLEAR_RUNS_FAIL_V1) return;
    window.__VSP_CLEAR_RUNS_FAIL_V1 = true;

    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(e){ return []; } }

    function hideByText(rx){
      const nodes=_qsa("div,span,small,label,button,a");
      for(const el of nodes){
        const t=(el.textContent||"").trim();
        if(!t) continue;
        if(rx.test(t)){
          try{ el.style.display="none"; }catch(_e){}
        }
      }
    }

    function clearRunsFailUI(){
      // Banner variants
      hideByText(/RUNS\s*API\s*FAIL/i);
      hideByText(/degraded\s*\(runs\s*api\s*503\)/i);
      hideByText(/Error:\s*503\s*\/api\/vsp\/runs/i);

      // If you have specific containers, hide them too (safe if absent)
      const ids=["runs-api-fail","vsp-runs-fail","runs_fail_banner","vsp_runs_fail_banner"];
      for(const id of ids){
        const el=document.getElementById(id);
        if(el){ try{ el.style.display="none"; }catch(_e){} }
      }
    }

    // Wrap fetch (wrap the already-wrapped one) to observe success
    if(window.fetch && !window.__VSP_FETCH_OBS_RUNS_OK_V1){
      window.__VSP_FETCH_OBS_RUNS_OK_V1 = true;
      const orig = window.fetch.bind(window);
      window.fetch = /*guarded*/(async input, init)=>{
        const r = await orig(input, init);
        try{
          let u="";
          try{ u = (typeof input==="string") ? input : (input && input.url) ? input.url : ""; }catch(_e){}
          if(u && u.includes("/api/vsp/runs") && r && r.ok){
            clearRunsFailUI();
          }
        }catch(_e){}
        return r;
      };
    }

    // extra safety: clear after load + after 2s (in case banners render after fetch)
    if(document.readyState==="loading"){
      document.addEventListener("DOMContentLoaded", ()=>setTimeout(clearRunsFailUI, 300));
    }else{
      setTimeout(clearRunsFailUI, 300);
    }
    setTimeout(clearRunsFailUI, 2000);
  }catch(_e){}
})();

/* ===== VSP_P0_RUNS_FAIL_HYSTERESIS_V1 =====
   Goal: stop RUNS API FAIL banner from flipping (transient fail vs OK)
   Logic:
     - on /api/vsp/runs json.ok==true => clear banner + lock-hide for 10s
     - on json.ok==false => increment failCount; show only if >=3
*/
(function(){
  try{
    if(window.__VSP_RUNS_FAIL_HYST_V1) return;
    window.__VSP_RUNS_FAIL_HYST_V1 = true;

    const LOCK_OK_MS = 10000;
    const FAIL_SHOW_THRESHOLD = 3;
    const FAIL_WINDOW_MS = 30000;

    const st = window.__vsp_runs_hyst_state || (window.__vsp_runs_hyst_state = {
      lastOkTs: 0,
      failCount: 0,
      firstFailTs: 0
    });

    function now(){ return Date.now(); }

    function shouldForceHide(){
      return st.lastOkTs && (now() - st.lastOkTs) < LOCK_OK_MS;
    }

    function qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(_e){ return []; } }

    function hideRunsFailUI(){
      // 1) hide by common texts
      const rx = /(RUNS\s*API\s*FAIL|degraded\s*\(runs\s*api\s*503\)|Error:\s*503\s*\/api\/vsp\/runs)/i;
      for(const el of qsa("div,span,small,label,button,a")){
        const t=(el.textContent||"").trim();
        if(t && rx.test(t)){
          try{ el.style.display="none"; el.setAttribute("data-vsp-hide","1"); }catch(_e){}
        }
      }
      // 2) hide common ids if present
      for(const id of ["runs-api-fail","vsp-runs-fail","runs_fail_banner","vsp_runs_fail_banner","vsp_ui_data_panel"]){
        const el=document.getElementById(id);
        if(el){
          const t=(el.textContent||"").toLowerCase();
          if(t.includes("runs api fail") || t.includes("error: 503") || t.includes("degraded")){
            try{ el.style.display="none"; el.setAttribute("data-vsp-hide","1"); }catch(_e){}
          }
        }
      }
    }

    function showRunsFailUI(){
      // allow showing only if threshold reached and not in ok-lock
      if(shouldForceHide()) { hideRunsFailUI(); return; }
      if(st.failCount < FAIL_SHOW_THRESHOLD) { hideRunsFailUI(); return; }

      // if UI has a banner element created elsewhere, we just stop hiding it (remove display:none)
      for(const el of qsa('[data-vsp-hide="1"]')){
        try{ el.style.display=""; el.removeAttribute("data-vsp-hide"); }catch(_e){}
      }
    }

    function onRunsJson(j){
      if(j && j.ok === true){
        st.lastOkTs = now();
        st.failCount = 0;
        st.firstFailTs = 0;
        hideRunsFailUI();
        return;
      }
      // ok=false (or missing)
      const t = now();
      if(!st.firstFailTs || (t - st.firstFailTs) > FAIL_WINDOW_MS){
        st.firstFailTs = t;
        st.failCount = 1;
      }else{
        st.failCount += 1;
      }
      showRunsFailUI();
    }

    // Wrap fetch to inspect /api/vsp/runs payload without breaking caller
    if(window.fetch && !window.__VSP_FETCH_OBS_RUNS_JSON_V1){
      window.__VSP_FETCH_OBS_RUNS_JSON_V1 = true;
      const orig = window.fetch.bind(window);
      window.fetch = /*guarded*/(async input, init)=>{
        const r = await orig(input, init);
        try{
          let u="";
          try{ u = (typeof input==="string") ? input : (input && input.url) ? input.url : ""; }catch(_e){}
          if(u && u.includes("/api/vsp/runs")){
            // clone so we don't consume body
            const rr = r.clone();
            rr.json().then(onRunsJson).catch(()=>{ /* ignore */ });
          }
        }catch(_e){}
        return r;
      };
    }

    // MutationObserver: if ok-lock active, keep hiding any new banner nodes
    const obs = new MutationObserver((_muts)=>{
      if(shouldForceHide()) hideRunsFailUI();
    });
    try{ obs.observe(document.documentElement||document.body, {childList:true, subtree:true}); }catch(_e){}

    // initial sweep
    setTimeout(()=>{ if(shouldForceHide()) hideRunsFailUI(); }, 200);
    setTimeout(()=>{ if(shouldForceHide()) hideRunsFailUI(); }, 1200);
  }catch(_e){}
})();

/* ===== VSP_P0_SUPPRESS_RUNS_DEGRADED_TOAST_V1 =====
   If runs list is rendered (has RUN ids), suppress any "RUNS API FAIL"/"degraded (runs API 503)" UI.
   This stops flip/flap caused by transient ok:false / cached-degrade.
*/
(function(){
  try{
    if(window.__VSP_SUPPRESS_RUNS_DEGRADED_V1) return;
    window.__VSP_SUPPRESS_RUNS_DEGRADED_V1 = true;

    const RX = /(RUNS\s*API\s*FAIL|degraded\s*\(runs\s*api\s*503\)|Error:\s*503\s*\/api\/vsp\/runs)/i;

    function qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(_e){ return []; } }

    function hasRunsRows(){
      try{
        const t = (document.body && (document.body.innerText||document.body.textContent)) ? (document.body.innerText||document.body.textContent) : "";
        // heuristic: run ids usually contain "_RUN_" or "RUN_" pattern
        return /_RUN_\d{8}_\d{6}/.test(t) || /\bRUN_[A-Z0-9_]{6,}\b/.test(t) || /VSP_CI_RUN_\d{8}_\d{6}/.test(t);
      }catch(_e){ return false; }
    }

    function hideDegradedBits(){
      if(!hasRunsRows()) return; // only hide if list actually rendered
      for(const el of qsa("div,span,small,label,button,a")){
        const t=(el.textContent||"").trim();
        if(t && RX.test(t)){
          try{ el.style.display="none"; el.setAttribute("data-vsp-hide-degraded","1"); }catch(_e){}
        }
      }
      // also hide common toast containers if they contain the text
      for(const el of qsa("[role='alert'], .toast, .toaster, .snackbar, .notification")){
        const t=(el.textContent||"").trim();
        if(t && RX.test(t)){
          try{ el.style.display="none"; el.setAttribute("data-vsp-hide-degraded","1"); }catch(_e){}
        }
      }
    }

    // Run a few times after load (covers late-render toast)
    function burst(){
      hideDegradedBits();
      setTimeout(hideDegradedBits, 500);
      setTimeout(hideDegradedBits, 1500);
      setTimeout(hideDegradedBits, 3000);
      setTimeout(hideDegradedBits, 6000);
    }

    if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", burst);
    else burst();

    // MutationObserver: if it pops back, hide again
    const obs=new MutationObserver((_m)=>{ hideDegradedBits(); });
    try{ obs.observe(document.documentElement||document.body, {childList:true, subtree:true}); }catch(_e){}
  }catch(_e){}
})();

/* ===== VSP_P0_RUNS_LATCH_LASTGOOD_V1 =====
   Latch "runs OK" after first successful items[].
   If later /api/vsp/runs returns ok:false / fails, serve last-good and suppress degraded UI.
*/
(function(){
  try{
    if(window.__VSP_RUNS_LATCH_LASTGOOD_V1) return;
    window.__VSP_RUNS_LATCH_LASTGOOD_V1 = true;

    const KEY = "vsp_runs_lastgood_v1";
    const RX_BAD = /(RUNS\s*API\s*FAIL|degraded\s*\(runs\s*api\s*503\)|Error:\s*503\s*\/api\/vsp\/runs)/i;

    let latched = false;

    function _save(obj){
      try{ localStorage.setItem(KEY, JSON.stringify(obj)); }catch(_){}
    }
    function _load(){
      try{
        const raw = localStorage.getItem(KEY);
        return raw ? JSON.parse(raw) : null;
      }catch(_){ return null; }
    }
    function _resp(obj, hdr){
      const h = new Headers({"Content-Type":"application/json; charset=utf-8"});
      try{ if(hdr) for(const [k,v] of Object.entries(hdr)) h.set(k, String(v)); }catch(_){}
      return new Response(JSON.stringify(obj), {status:200, headers:h});
    }

    function _nukeDegradedUI(){
      if(!latched) return;
      try{
        // common alert/toast containers first
        const sel = ["[role='alert']", ".toast", ".toaster", ".snackbar", ".notification", ".banner", ".status", ".vsp-toast", ".vsp-banner"];
        for(const s of sel){
          for(const el of document.querySelectorAll(s)){
            const t = (el.textContent||"").trim();
            if(t && RX_BAD.test(t)){
              el.style.display="none";
              el.setAttribute("data-vsp-hide-degraded","1");
            }
          }
        }
        // lightweight pass on top-level bars only (avoid scanning whole DOM)
        for(const el of document.querySelectorAll("header,nav,main,body")){
          const t = (el.textContent||"").trim();
          if(t && RX_BAD.test(t)){
            // hide only child nodes that match
            for(const c of el.querySelectorAll("div,span,small,label,button,a")){
              const tt = (c.textContent||"").trim();
              if(tt && RX_BAD.test(tt)){
                c.style.display="none";
                c.setAttribute("data-vsp-hide-degraded","1");
              }
            }
          }
        }
      }catch(_){}
    }

    // Clear known sticky flags from older patches (best-effort)
    try{
      for(const k of Object.keys(localStorage)){
        if(/vsp.*runs.*fail|runs.*fail|vsp.*degraded/i.test(k)) localStorage.removeItem(k);
      }
    }catch(_){}

    // Wrap fetch AFTER NetGuard wrapper (we run later), so this is the final guard
    if(window.fetch && !window.__VSP_RUNS_FETCH_WRAPPED_V1){
      window.__VSP_RUNS_FETCH_WRAPPED_V1 = true;
      const orig = window.fetch.bind(window);
      window.fetch = /*guarded*/(async input, init)=>{
        let u="";
        try{ u = (typeof input==="string") ? input : (input && input.url) ? input.url : ""; }catch(_){}
        const isRuns = !!u && u.includes("/api/vsp/runs");
        if(!isRuns) return orig(input, init);

        try{
          const r = await orig(input, init);

          // If request is OK, try to detect items[] and latch/save
          let j = null;
          try{
            const c = r.clone();
            j = await c.json();
          }catch(_){ j = null; }

          const hasItems = !!j && Array.isArray(j.items);
          const itemsN = hasItems ? j.items.length : 0;

          if(hasItems && itemsN > 0){
            latched = true;
            window.__vsp_runs_ok_latched = true;
            _save(j);
            setTimeout(_nukeDegradedUI, 0);
            return r;
          }

          // If response indicates degraded (ok:false) OR empty items AND we are latched -> serve last good
          const looksDegraded = (!!j && j.ok === false) || (!r.ok) || (hasItems && itemsN === 0);
          if(latched && looksDegraded){
            const cached = _load();
            if(cached && Array.isArray(cached.items) && cached.items.length > 0){
              setTimeout(_nukeDegradedUI, 0);
              return _resp(cached, {"X-VSP-Runs-Latched":"1","X-VSP-From":"lastgood"});
            }
          }

          return r;
        }catch(e){
          if(latched){
            const cached = _load();
            if(cached && Array.isArray(cached.items) && cached.items.length > 0){
              setTimeout(_nukeDegradedUI, 0);
              return _resp(cached, {"X-VSP-Runs-Latched":"1","X-VSP-From":"lastgood-ex"});
            }
          }
          throw e;
        }
      };
    }

    // If degraded UI appears later, keep suppressing once latched
    try{
      const obs = new MutationObserver(()=>{ _nukeDegradedUI(); });
      obs.observe(document.documentElement, {childList:true, subtree:true});
    }catch(_){}
  }catch(_){}
})();


;(()=>{ // VSP_P0_RUNS_FETCH_SHIM_DEFINITIVE_P0_V1
  try{
    if (window.__VSP_P0_RUNS_FETCH_SHIM_DEFINITIVE_P0_V1) return;
    window.__VSP_P0_RUNS_FETCH_SHIM_DEFINITIVE_P0_V1 = true;

    const RUNS_RE = /\/api\/vsp\/runs(\?|$)/;
    const CACHE_KEY = "VSP_RUNS_CACHE_BODY_V1";
    const CACHE_TS  = "VSP_RUNS_CACHE_TS_V1";
    const MAX_AGE_MS = 10 * 60 * 1000; // 10 phút: đủ “dịu” để hết nhảy, vẫn không quá stale

    function now(){ return Date.now(); }
    function getCache(){
      try{
        const body = localStorage.getItem(CACHE_KEY);
        const ts   = parseInt(localStorage.getItem(CACHE_TS)||"0",10);
        if (!body) return null;
        if (!ts || (now()-ts)>MAX_AGE_MS) return null;
        return {body, ts};
      }catch(e){ return null; }
    }
    function putCache(body){
      try{
        localStorage.setItem(CACHE_KEY, body);
        localStorage.setItem(CACHE_TS, String(now()));
      }catch(e){}
    }
    function isRunsUrl(u){
      try{
        if (!u) return false;
        if (typeof u === "string") return RUNS_RE.test(u);
        if (u && typeof u.url === "string") return RUNS_RE.test(u.url);
      }catch(e){}
      return false;
    }

    const _fetch = window.fetch.bind(window);

    window.fetch = async function(input, init){
      const runs = isRunsUrl(input);
      if (!runs) return _fetch(input, init);

      // Luôn NO-STORE để tránh trạng thái “nhảy” do cache layer bất định
      const init2 = init ? {...init} : {};
      init2.cache = "no-store";

      try{
        const res = await _fetch(input, init2);

        // Nếu OK: cache body để dùng làm fallback cho lần sau
        if (res && res.ok){
          try{
            const clone = res.clone();
            const txt = await clone.text();
            // chỉ cache nếu có vẻ là JSON
            if (txt && (txt.trim().startsWith("{") || txt.trim().startsWith("["))){
              putCache(txt);
            }
          }catch(e){}
          return res;
        }

        // Nếu lỗi (503/500/timeout gateway…): trả về cache (HTTP 200) để UI không set FAIL
        const c = getCache();
        if (c && c.body){
          const headers = new Headers();
          headers.set("Content-Type","application/json; charset=utf-8");
          headers.set("Cache-Control","no-store");
          headers.set("X-VSP-DEGRADED","1");
          headers.set("X-VSP-RUNS-FALLBACK","1");
          return new Response(c.body, {status:200, headers});
        }

        // Không có cache thì trả nguyên trạng (để bạn vẫn nhìn thấy lỗi thật)
        return res;
      }catch(err){
        const c = getCache();
        if (c && c.body){
          const headers = new Headers();
          headers.set("Content-Type","application/json; charset=utf-8");
          headers.set("Cache-Control","no-store");
          headers.set("X-VSP-DEGRADED","1");
          headers.set("X-VSP-RUNS-FALLBACK","1");
          return new Response(c.body, {status:200, headers});
        }
        throw err;
      }
    };

    console.log("[VSP_RUNS] fetch shim enabled (definitive): cache+fallback for /api/vsp/runs*");
  }catch(e){
    console.warn("[VSP_RUNS] fetch shim init failed:", e);
  }
})();


/* VSP_RUNS_STABLE_FETCH_P0_V2: definitive anti-flicker for /api/vsp/runs (never propagate 5xx to UI) */
(function(){
  'use strict';
  try{
    if (window.__VSP_RUNS_STABLE_FETCH_P0_V2) return;
    window.__VSP_RUNS_STABLE_FETCH_P0_V2 = 1;
  }catch(_){}

  // clear stale fail/degraded flags so they cannot resurrect banner/toast
  try{
    var ks=[];
    for (var i=0;i<localStorage.length;i++){ var k=localStorage.key(i); if(k) ks.push(k); }
    ks.forEach(function(k){
      if(/runs.*fail|vsp_runs|degraded.*runs|runs_api|rid_latest_badge/i.test(k)){
        try{ localStorage.removeItem(k); }catch(_){}
      }
    });
  }catch(_){}

  var _origFetch = (window.fetch && window.fetch.bind) ? window.fetch.bind(window) : null;
  if(!_origFetch) return;

  var lastGoodJson = null;
  var lastGoodAt = 0;

  function isRunsUrl(u){
    try{
      var s = (typeof u === 'string') ? u : (u && u.url) ? u.url : String(u||'');
      return s.indexOf('/api/vsp/runs') >= 0;
    }catch(_){ return false; }
  }

  function mkJsonResp(obj, reason){
    try{
      var o = obj || {};
      // ensure ok=true for UI stability, but keep degraded metadata for debugging
      if (o.ok !== true) o.ok = true;
      if (!o.items) o.items = [];
      o._degraded = true;
      o._degraded_reason = reason || o._degraded_reason || "fallback";
      return new Response(JSON.stringify(o), {
        status: 200,
        headers: {
          "content-type": "application/json; charset=utf-8",
          "cache-control": "no-store",
          "x-vsp-degraded": "1"
        }
      });
    }catch(e){
      return new Response('{"ok":true,"items":[],"_degraded":true,"_degraded_reason":"fallback_min"}', {
        status: 200,
        headers: {"content-type":"application/json; charset=utf-8","cache-control":"no-store","x-vsp-degraded":"1"}
      });
    }
  }

  async function safeFetch(url, opts){
    if(!isRunsUrl(url)) return _origFetch(url, opts);

    // normalize opts (no-store, same-origin)
    var o = opts || {};
    try{
      if(!o.cache) o.cache = "no-store";
      if(!o.credentials) o.credentials = "same-origin";
    }catch(_){}

    try{
      var res = await _origFetch(url, o);

      // If HTTP ok: try capture last-good JSON when payload has ok:true
      try{
        if(res && res.ok){
          var ct = (res.headers && res.headers.get) ? (res.headers.get("content-type")||"") : "";
          if(ct.indexOf("application/json")>=0){
            var j = await res.clone().json().catch(function(){ return null; });
            if(j && j.ok === true){
              lastGoodJson = j;
              lastGoodAt = Date.now();
              // also clear any stale banner keys again after success
              try{
                var ks2=[];
                for (var i=0;i<localStorage.length;i++){ var k=localStorage.key(i); if(k) ks2.push(k); }
                ks2.forEach(function(k){
                  if(/runs.*fail|degraded.*runs|runs_api/i.test(k)){
                    try{ localStorage.removeItem(k); }catch(_){}
                  }
                });
              }catch(_){}
            }
          }
        }
      }catch(_){}

      // If not ok (e.g. 503): DO NOT propagate -> fallback
      if(!res || !res.ok){
        if(lastGoodJson) return mkJsonResp(lastGoodJson, "fallback_http_"+String(res?res.status:0));
        return mkJsonResp({ok:true, items:[], rid_latest:"N/A"}, "fallback_http_nocache_"+String(res?res.status:0));
      }

      return res;
    }catch(e){
      if(lastGoodJson) return mkJsonResp(lastGoodJson, "fallback_exc");
      return mkJsonResp({ok:true, items:[], rid_latest:"N/A"}, "fallback_exc_nocache");
    }
  }

  // hard override (last wins) so any earlier netguard wrapper cannot re-inject 5xx into runs page
  try{
    window.fetch = safeFetch;
  }catch(_){}

  // optional: hide any existing "RUNS API FAIL" remnants in DOM (belt & suspenders)
  function killFailText(){
    try{
      var nodes = document.querySelectorAll("body *");
      for (var i=0;i<nodes.length;i++){
        var el = nodes[i];
        if(!el || !el.textContent) continue;
        if(el.textContent.indexOf("RUNS API FAIL")>=0){
          try{ el.style.display="none"; }catch(_){}
        }
      }
    }catch(_){}
  }
  try{
    if(document.readyState==="loading"){
      document.addEventListener("DOMContentLoaded", function(){
        killFailText();
        setInterval(killFailText, 1200);
      });
    }else{
      killFailText();
      setInterval(killFailText, 1200);
    }
  }catch(_){}
})();


/* VSP_RUNS_STABLE_FETCH_P0_V3: force ok:true for /api/vsp/runs (fix 200-but-ok:false flicker from netguard) */
(function(){
  'use strict';
  try{ if (window.__VSP_RUNS_STABLE_FETCH_P0_V3) return; window.__VSP_RUNS_STABLE_FETCH_P0_V3 = 1; }catch(_){}

  var _origFetch = (window.fetch && window.fetch.bind) ? window.fetch.bind(window) : null;
  if(!_origFetch) return;

  var lastGoodJson = null;
  var lastGoodAt = 0;

  function isRunsUrl(u){
    try{
      var s = (typeof u === 'string') ? u : (u && u.url) ? u.url : String(u||'');
      return s.indexOf('/api/vsp/runs') >= 0;
    }catch(_){ return false; }
  }

  function mkJsonResp(obj, reason){
    var o = obj && typeof obj === "object" ? obj : {};
    if (o.ok !== true) o.ok = true;
    if (!o.items) o.items = [];
    o._degraded = (reason ? true : !!o._degraded);
    if (reason) o._degraded_reason = reason;
    return new Response(JSON.stringify(o), {
      status: 200,
      headers: {
        "content-type": "application/json; charset=utf-8",
        "cache-control": "no-store",
        "x-vsp-runs-shim": "P0_V3"
      }
    });
  }

  async function safeFetch(input, init){
    if(!isRunsUrl(input)) return _origFetch(input, init);

    // ensure stable fetch options
    var o = init || {};
    try{ if(!o.cache) o.cache="no-store"; if(!o.credentials) o.credentials="same-origin"; }catch(_){}

    try{
      var res = await _origFetch(input, o);

      // Try read JSON no matter what status is (netguard can return 200 with ok:false)
      var j = null;
      try{
        var ct = (res && res.headers && res.headers.get) ? (res.headers.get("content-type")||"") : "";
        if(ct.indexOf("application/json")>=0){
          j = await res.clone().json().catch(function(){ return null; });
        }
      }catch(_){ j = null; }

      if(j && j.ok === true){
        lastGoodJson = j;
        lastGoodAt = Date.now();
        return mkJsonResp(j, "pass_ok_true"); // normalize headers + keep ok:true
      }

      // If upstream returns ok:false (even with HTTP 200) => FORCE ok:true using lastGood or empty
      if(lastGoodJson){
        return mkJsonResp(lastGoodJson, "fallback_okfalse");
      }
      if(j){
        return mkJsonResp(j, "force_ok_true_from_upstream_okfalse");
      }
      return mkJsonResp({ok:true, items:[], rid_latest:"N/A"}, "fallback_nojson");
    }catch(e){
      if(lastGoodJson) return mkJsonResp(lastGoodJson, "fallback_exc");
      return mkJsonResp({ok:true, items:[], rid_latest:"N/A"}, "fallback_exc_nocache");
    }
  }

  // last-wins override
  try{ window.fetch = safeFetch; }catch(_){}
  try{ console.log("[VSP_RUNS] stable fetch shim enabled (P0_V3): force ok:true for /api/vsp/runs*"); }catch(_){}
})();


;(()=>{
  const MARK = '__VSP_P0_RUNS_FAIL_BADGE_DOM_KILLER_V2';
  if (window[MARK]) return;
  window[MARK] = true;

  function _txt(el){
    try{ return (el && (el.innerText || el.textContent) || "").trim(); }
    catch(_e){ return ""; }
  }
  function _onRunsPage(){
    try{ return /\/runs(\/|$)/.test(location.pathname); }
    catch(_e){ return false; }
  }
  function _hasRunsData(){
    const kw = ["Open Summary","Open Data Source","SUMMARY","JSON","CSV"];
    const nodes = document.querySelectorAll("a,button,td,span,div");
    let hits = 0;
    for (const n of nodes){
      const t = _txt(n);
      if (!t) continue;
      for (const k of kw){
        if (t.includes(k)){ hits++; break; }
      }
      if (hits >= 2) return true;
    }
    return false;
  }
  function _hideByText(substrs){
    const nodes = document.querySelectorAll("div,span,button,section,header");
    for (const n of nodes){
      const t = _txt(n);
      if (!t) continue;
      for (const s of substrs){
        if (t.includes(s)) {
          try {
            n.style.display = "none";
            n.setAttribute("data-vsp-hidden", "1");
          } catch(_e){}
          break;
        }
      }
    }
  }
  function _tick(){
    if (!_onRunsPage()) return;
    if (!_hasRunsData()) return; // chỉ kill khi đã có data
    _hideByText(["RUNS API FAIL","degraded (runs API","runs API 503","Error: 503"]);
  }

  _tick();
  let n = 0;
  const t = setInterval(()=>{
    try{ _tick(); }catch(_e){}
    n++;
    if (n > 140) clearInterval(t); // ~42s
  }, 300);

  console.log("[VSP][P0] runs FAIL badge DOM-killer armed");
})();



/* VSP_P0_HARD_BYPASS_RUNS_FETCH_XHR_V1
   Purpose: definitive fix for RUNS API flicker (fetch wrappers/cached degraded payloads).
   - Bypass ALL fetch-wrappers for /api/vsp/runs* by using XHR
   - Purge localStorage caches used by older wrappers
   - Aggressively remove RUNS API FAIL banners/toasts that come from stale DOM updates
*/
(()=> {
  try{
    if (window.__vsp_p0_hard_bypass_runs_fetch_xhr_v1) return;
    window.__vsp_p0_hard_bypass_runs_fetch_xhr_v1 = true;

    // 1) purge known caches from old wrappers
    try{
      const keys = [];
      for (let i=0; i<localStorage.length; i++){
        const k = localStorage.key(i);
        if (!k) continue;
        if (k.includes("vsp_api_cache_") || k.includes("vsp_api_cache_v") || k.includes("vsp_api_cache_v7") || k.includes("vsp_api_cache_v7b::")){
          keys.push(k);
        }
      }
      keys.forEach(k=>{ try{ localStorage.removeItem(k); }catch(_){ } });
    }catch(_){}

    // helpers
    function _getUrl(input){
      try{
        if (typeof input === "string") return input;
        if (input && typeof input.url === "string") return input.url;
      }catch(_){}
      return "";
    }
    function _isRuns(u){
      try{
        if (!u) return false;
        // normalize absolute/relative
        const uu = new URL(u, location.origin);
        return uu.pathname === "/api/vsp/runs";
      }catch(_){
        return (String(u).includes("/api/vsp/runs"));
      }
    }
    function _xhrFetchText(url, init){
      return new Promise((resolve, reject)=>{
        try{
          const xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.timeout = 12000;

          // pass headers if any
          try{
            const h = (init && init.headers) ? init.headers : null;
            if (h){
              if (typeof h.forEach === "function"){
                h.forEach((v,k)=>{ try{ xhr.setRequestHeader(k, v); }catch(_){ } });
              }else if (Array.isArray(h)){
                h.forEach(([k,v])=>{ try{ xhr.setRequestHeader(k, v); }catch(_){ } });
              }else if (typeof h === "object"){
                Object.keys(h).forEach(k=>{ try{ xhr.setRequestHeader(k, String(h[k])); }catch(_){ } });
              }
            }
          }catch(_){}

          xhr.onreadystatechange = ()=>{};
          xhr.onload = ()=>{
            try{
              const txt = xhr.responseText || "";
              const headers = new Headers();
              headers.set("Content-Type","application/json; charset=utf-8");
              headers.set("X-VSP-RUNS-BYPASS","XHR_V1");
              // NOTE: preserve real HTTP status (so UI shows real fail if backend truly fails)
              resolve(new Response(txt, {status: xhr.status || 200, headers}));
            }catch(e){ reject(e); }
          };
          xhr.onerror = ()=> reject(new Error("XHR network error"));
          xhr.ontimeout = ()=> reject(new Error("XHR timeout"));
          xhr.send(null);
        }catch(e){ reject(e); }
      });
    }

    // 2) override fetch for runs only (bypass wrappers)
    const prevFetch = window.fetch ? window.fetch.bind(window) : null;
    if (prevFetch){
      window.fetch = /*guarded*/(async input, init)=>{
        const u0 = _getUrl(input);
        if (_isRuns(u0)){
          // always use absolute URL
          let u = u0;
          try{ u = new URL(u0, location.origin).toString(); }catch(_){}
          try{
            const r = await _xhrFetchText(u, init);
            // If backend returns 200 but payload is ok:false (stale), ignore and force one retry quickly.
            try{
              if (r && r.ok){
                const t = await r.clone().text();
                const j = JSON.parse(t);
                if (j && j.ok === false){
                  // one quick retry (true network)
                  const r2 = await _xhrFetchText(u, init);
                  return r2;
                }
              }
            }catch(_){}
            return r;
          }catch(_e){
            // fallback to original fetch if XHR fails (still better than hard failing)
            return prevFetch(input, init);
          }
        }
        return prevFetch(input, init);
      };
      console.log("[VSP_RUNS] HARD bypass installed (XHR) for /api/vsp/runs*");
    }

    // 3) kill stale FAIL banners/toasts that flicker due to older DOM updaters
    function _textOf(el){
      try{ return (el && (el.innerText || el.textContent) || "").trim(); }catch(_){ return ""; }
    }
    function _kill(){
      try{
        const bad = [];
        const all = document.querySelectorAll("body *");
        for (const el of all){
          const t = _textOf(el);
          if (!t) continue;
          if (t.includes("RUNS API FAIL") || t.includes("degraded (runs API 503)") || t.includes("Error: 503") && t.includes("/api/vsp/runs")){
            bad.push(el);
          }
        }
        bad.forEach(el=>{
          try{
            // remove the smallest container that likely holds the badge/toast
            el.style.display = "none";
          }catch(_){}
        });
      }catch(_){}
    }
    // run now + watch mutations
    _kill();
    try{
      const mo = new MutationObserver(()=>_kill());
      mo.observe(document.documentElement, {subtree:true, childList:true, characterData:true});
    }catch(_){}
  }catch(_){}
})();

