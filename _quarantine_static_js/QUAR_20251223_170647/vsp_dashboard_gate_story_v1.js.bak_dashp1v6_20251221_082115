/* VSP_P1_GATE_FETCH_FORCE_GATE_ROOT_V2
 * Force gate fetch to use rid_latest_gate_root and path=run_gate_summary.json.
 * Hooks BOTH fetch + XMLHttpRequest.
 */
(()=> {

/* VSP_P1_DISABLE_GATE_STORY_IF_DASHCOMM_V1 */
try{
  const path = (location && location.pathname) ? location.pathname : "";
  const hasDash = !!document.querySelector('script[src*="vsp_dashboard_commercial_v1.js"]') || !!window.__vsp_dash_commercial_v1_loaded;
  if (path === "/vsp5" || hasDash){
    console.log("[GateStoryV1] disabled (DashCommercialV1 present or /vsp5).");
    return;
  }
}catch(e){}


  if (window.__vsp_gate_fetch_force_gate_root_v2) return;
  window.__vsp_gate_fetch_force_gate_root_v2 = true;

  const LS_GATE_ROOT = 'vsp_rid_latest_gate_root_v1';
  const LS_LATEST    = 'vsp_rid_latest_v1';

  function _log(){ try{ console.log.apply(console, arguments); }catch(_){ } }

  async function getGateRootRid(){
    try{
      if (window.vsp_rid_latest_gate_root && String(window.vsp_rid_latest_gate_root).trim()){
        return String(window.vsp_rid_latest_gate_root).trim();
      }
      const ls = localStorage.getItem(LS_GATE_ROOT);
      if (ls && String(ls).trim()){
        window.vsp_rid_latest_gate_root = String(ls).trim();
        return window.vsp_rid_latest_gate_root;
      }
      const r = await fetch('/api/vsp/runs?limit=5', {cache:'no-store'});
      const j = await r.json().catch(()=>null);
      const rid = (j && (j.rid_latest_gate_root || j.rid_latest_gate || j.rid_latest)) ? String(j.rid_latest_gate_root || j.rid_latest_gate || j.rid_latest).trim() : '';
      if (rid){
        window.vsp_rid_latest_gate_root = rid;
        try{ localStorage.setItem(LS_GATE_ROOT, rid); }catch(_){}
        try{ localStorage.setItem(LS_LATEST, rid); }catch(_){}
      }
      return rid || '';
    }catch(_){
      return '';
    }
  }

  function isGatePath(path){
    path = (path||"").trim();
    return (
      path === 'run_gate.json' ||
      path === 'run_gate_summary.json' ||
      path === 'reports/run_gate.json' ||
      path === 'reports/run_gate_summary.json'
    );
  }

  function rewriteUrl(u, rid){
    try{
      const url = new URL(u, window.location.origin);
      if (!url.pathname.includes('/api/vsp/run_file_allow')) return u;
      const path = (url.searchParams.get('path')||'').trim();
      if (!isGatePath(path)) return u;

      url.searchParams.set('path', 'run_gate_summary.json');
      if (rid && rid.trim()) url.searchParams.set('rid', rid.trim());
      return url.toString();
    }catch(_){
      return u;
    }
  }

  // ---- hook fetch ----
  const _origFetch = window.fetch ? window.fetch.bind(window) : null;
  if (_origFetch){
    window.fetch = async function(input, init){
      try{
        const u = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
        if (u && u.includes('/api/vsp/run_file_allow') && u.includes('path=')){
          const rid = await getGateRootRid();
          const u2 = rewriteUrl(u, rid);
          if (u2 !== u){
            _log("[GateStoryV1][%s] fetch rewrite => %s", "VSP_P1_GATE_FETCH_FORCE_GATE_ROOT_V2", u2);
            if (typeof input === 'string') input = u2;
            else input = new Request(u2, input);
          }
        }
      }catch(_){}
      return _origFetch(input, init);
    };
  }

  // ---- hook XHR ----
  try{
    const _open = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url){
      try{
        if (url && String(url).includes('/api/vsp/run_file_allow') && String(url).includes('path=')){
          const u = String(url);
          let rid = '';
          try{ rid = (window.vsp_rid_latest_gate_root || localStorage.getItem(LS_GATE_ROOT) || '').trim(); }catch(_){}
          const u2 = rewriteUrl(u, rid || '');
          if (u2 !== u){
            _log("[GateStoryV1][%s] xhr rewrite => %s", "VSP_P1_GATE_FETCH_FORCE_GATE_ROOT_V2", u2);
            url = u2;
          }
        }
      }catch(_){}
      return _open.apply(this, arguments);
    };
  }catch(_){}

  _log("[GateStoryV1][%s] installed", "VSP_P1_GATE_FETCH_FORCE_GATE_ROOT_V2");
})();

/* VSP_P1_GATE_FETCH_FORCE_GATE_ROOT_V1
 * Force any gate fetch via /api/vsp/run_file_allow to use rid_latest_gate_root (prefer CI run)
 * and prefer path=run_gate_summary.json to avoid 403/404 + SUMMARY.txt surprises.
 */
(()=> {
  if (window.__vsp_gate_fetch_force_gate_root_v1) return;
  window.__vsp_gate_fetch_force_gate_root_v1 = true;

  const LS_GATE_ROOT = 'vsp_rid_latest_gate_root_v1';
  const LS_LATEST    = 'vsp_rid_latest_v1';

  const _origFetch = window.fetch ? window.fetch.bind(window) : null;
  if (!_origFetch) return;

  async function getGateRootRid(){
    try{
      // 0) in-memory
      if (window.vsp_rid_latest_gate_root && String(window.vsp_rid_latest_gate_root).trim()){
        return String(window.vsp_rid_latest_gate_root).trim();
      }
      // 1) localStorage
      const ls = localStorage.getItem(LS_GATE_ROOT);
      if (ls && String(ls).trim()){
        window.vsp_rid_latest_gate_root = String(ls).trim();
        return window.vsp_rid_latest_gate_root;
      }
      // 2) ask API
      const r = await _origFetch('/api/vsp/runs?limit=5', {cache:'no-store'});
      const j = await r.json().catch(()=>null);
      const rid = (j && (j.rid_latest_gate_root || j.rid_latest_gate || j.rid_latest)) ? String(j.rid_latest_gate_root || j.rid_latest_gate || j.rid_latest).trim() : '';
      if (rid){
        window.vsp_rid_latest_gate_root = rid;
        try { localStorage.setItem(LS_GATE_ROOT, rid); } catch(_){}
        // also keep latest for other parts
        try { localStorage.setItem(LS_LATEST, rid); } catch(_){}
      }
      return rid || '';
    }catch(_){
      return '';
    }
  }

  function rewriteGateUrl(u, rid){
    try{
      const url = new URL(u, window.location.origin);
      if (!url.pathname.includes('/api/vsp/run_file_allow')) return u;

      const path = (url.searchParams.get('path') || '').trim();
      const isGate = (path === 'run_gate.json' || path === 'run_gate_summary.json'
                      || path === 'reports/run_gate.json' || path === 'reports/run_gate_summary.json');
      if (!isGate) return u;

      // force preferred path
      url.searchParams.set('path', 'run_gate_summary.json');

      if (rid && rid.trim()){
        url.searchParams.set('rid', rid.trim());
      }
      return url.toString();
    }catch(_){
      return u;
    }
  }

  window.fetch = async function(input, init){
    try{
      const u = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
      if (u && u.includes('/api/vsp/run_file_allow') && u.includes('path=')){
        // only rewrite gate-related paths
        const rid = await getGateRootRid();
        const u2 = rewriteGateUrl(u, rid);
        if (u2 !== u){
          console.log("[GateStoryV1][%s] fetch rewrite =>", "VSP_P1_GATE_FETCH_FORCE_GATE_ROOT_V1", u2);
          if (typeof input === 'string') input = u2;
          else input = new Request(u2, input);
        }
      }
    }catch(_){}
    return _origFetch(input, init);
  };

  console.log("[GateStoryV1][%s] installed", "VSP_P1_GATE_FETCH_FORCE_GATE_ROOT_V1");
})();

/* VSP_P1_GATE_FETCH_THROTTLE_AND_GATE_ROOT_RID_V1
 * - Throttle / cache repeated GET /api/vsp/run_file_allow (gate json) to stop DevTools spam
 * - If localStorage has vsp_rid_latest_gate_root_v1, rewrite rid=... for gate json requests to gate_root RID
 */
(()=> {
  try {
    if (window.__vsp_p1_gate_fetch_throttle_and_gate_root_rid_v1) return;
    window.__vsp_p1_gate_fetch_throttle_and_gate_root_rid_v1 = true;

    const ORIG_FETCH = window.fetch ? window.fetch.bind(window) : null;
    if (!ORIG_FETCH) return;

    const CACHE = new Map(); // key -> {ts, inflight, text, status, ct}
    const COOLDOWN_MS = 15000; // 15s cache window for SAME URL

    function isRunFileAllowUrl(u){
      return (typeof u === "string") && (u.indexOf("/api/vsp/run_file_allow") >= 0);
    }

    function wantsGateJson(urlObj){
      const path = (urlObj.searchParams.get("path")||"").toLowerCase();
      const name = (urlObj.searchParams.get("name")||"").toLowerCase();
      return (
        path.endsWith("run_gate.json") ||
        path.endsWith("run_gate_summary.json") ||
        name.endsWith("run_gate.json") ||
        name.endsWith("run_gate_summary.json")
      );
    }

    function rewriteToGateRoot(u){
      try{
        const url = new URL(u, window.location.origin);
        if (url.pathname !== "/api/vsp/run_file_allow") return u;

        // only rewrite for gate json requests
        if (!wantsGateJson(url)) return u;

        const gateRid = (localStorage.getItem("vsp_rid_latest_gate_root_v1")||"").trim();
        if (!gateRid) return u;

        const rid = (url.searchParams.get("rid")||"").trim();
        if (!rid || rid !== gateRid) url.searchParams.set("rid", gateRid);

        return url.toString();
      } catch(e){
        return u;
      }
    }

    window.fetch = function(input, init){
      const raw = (typeof input === "string") ? input : (input && input.url ? input.url : String(input));
      const u = isRunFileAllowUrl(raw) ? rewriteToGateRoot(raw) : raw;
      const key = u;
      const now = Date.now();
      const ent = CACHE.get(key);

      // 1) inflight de-dupe
      if (ent && ent.inflight && (now - ent.ts) < COOLDOWN_MS) return ent.inflight;

      // 2) cached response (recreate Response from text)
      if (ent && ent.text && (now - ent.ts) < COOLDOWN_MS) {
        try{
          return Promise.resolve(new Response(ent.text, {
            status: ent.status || 200,
            headers: {"Content-Type": ent.ct || "application/json"}
          }));
        } catch(e) { /* fallthrough */ }
      }

      const p = ORIG_FETCH(u, init).then(async (resp)=>{
        try{
          const ct = (resp.headers && resp.headers.get) ? (resp.headers.get("content-type")||"") : "";
          // Cache only json/text to recreate safely
          if (ct.indexOf("application/json")>=0 || ct.indexOf("text/plain")>=0) {
            const t = await resp.clone().text();
            CACHE.set(key, {ts: Date.now(), inflight: null, text: t, status: resp.status, ct});
          } else {
            CACHE.set(key, {ts: Date.now(), inflight: null});
          }
        } catch(e){
          CACHE.set(key, {ts: Date.now(), inflight: null});
        }
        return resp;
      }).catch(err=>{
        CACHE.delete(key);
        throw err;
      });

      CACHE.set(key, {ts: now, inflight: p});
      return p;
    };

    console.log("[GateStoryV1][%s] fetch throttle installed (cooldown=%sms)", "VSP_P1_GATE_FETCH_THROTTLE_AND_GATE_ROOT_RID_V1", COOLDOWN_MS);
  } catch(e) { /* noop */ }
})();


/* VSP_P1_GATE_STORY_RID_FROM_RESPONSE_V1 */
try{
  if (gate && gate.run_id && typeof gate.run_id === "string" && gate.run_id.trim()){
    rid = gate.run_id.trim();
    try{ window.vsp_rid_latest = rid; }catch(e){}
  }
}catch(e){}


/* VSP_P1_GATE_STORY_COOLDOWN_V1 */
window.__vsp_gate_story_last_ok_ts = window.__vsp_gate_story_last_ok_ts || 0;
window.__vsp_gate_story_cooldown_ms = window.__vsp_gate_story_cooldown_ms || 15000;

/* VSP_P1_GATE_ROOT_PROXY_V2
 * Commercial fix: stop probing wrong RID via BOTH fetch + XMLHttpRequest.
 * - Wait /api/vsp/runs => rid_latest_gate_root || rid_latest_gate || rid_latest
 * - Rewrite /api/vsp/run_file_allow:
 *     rid  = gate_root rid
 *     path = run_gate_summary.json
 */
(()=> {
  try {
    if (window.__vsp_p1_gate_root_proxy_v2) return;
    window.__vsp_p1_gate_root_proxy_v2 = true;

    const ORIGIN = location.origin;

    const pickRid = (j)=> {
      try {
        if (!j) return "";
        const rid = (j.rid_latest_gate_root || j.rid_latest_gate || j.rid_latest || "").toString().trim();
        if (!rid) return "";
        window.vsp_rid_latest = rid;
        try {
          localStorage.setItem("vsp_rid_latest_gate_root_v1", rid);
          localStorage.setItem("vsp_rid_latest_v1", rid);
        } catch(e){}
        return rid;
      } catch(e){ return ""; }
    };

    const cachedRid = ()=> {
      try {
        return (localStorage.getItem("vsp_rid_latest_gate_root_v1")
          || localStorage.getItem("vsp_rid_latest_v1")
          || "").toString().trim();
      } catch(e){ return ""; }
    };

    const RUNS_URL = ORIGIN + "/api/vsp/runs?limit=10&_=" + Date.now();
    window.__vsp_gate_root_rid_promise = window.__vsp_gate_root_rid_promise
      || fetch(RUNS_URL, {cache:"no-store"})
          .then(r => r.json().catch(()=>null))
          .then(j => pickRid(j) || cachedRid())
          .catch(()=> cachedRid());

    const rewriteRunFileAllow = (url0, rid)=> {
      const u = new URL(url0, ORIGIN);
      if (rid) u.searchParams.set("rid", rid);
      u.searchParams.set("path", "run_gate_summary.json");
      return u.toString();
    };

    // ---- fetch hook ----
    const origFetch = window.fetch.bind(window);
    window.fetch = function(input, init){
      try{
        const url0 = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
        if (url0 && url0.indexOf("/api/vsp/run_file_allow") >= 0) {
          return window.__vsp_gate_root_rid_promise.then((rid)=>{
            const url1 = rewriteRunFileAllow(url0, rid);
            if (typeof input !== "string" && input && input.url) {
              const req = new Request(url1, input);
              return origFetch(req, init);
            }
            return origFetch(url1, init);
          });
        }
      }catch(e){}
      return origFetch(input, init);
    };

    // ---- XMLHttpRequest hook (this is the missing piece) ----
    const XHR = window.XMLHttpRequest;
    if (XHR && XHR.prototype) {
      const _open = XHR.prototype.open;
      const _send = XHR.prototype.send;

      XHR.prototype.open = function(method, url, async, user, password){
        try{
          const url0 = (url || "").toString();
          if (url0.indexOf("/api/vsp/run_file_allow") >= 0) {
            // delay open until send, after we know rid
            this.__vsp_gate_root_pending_open = [method, url0, async, user, password];
            this.__vsp_gate_root_is_pending = true;
            return; // do NOT call original open now
          }
        }catch(e){}
        return _open.apply(this, arguments);
      };

      XHR.prototype.send = function(body){
        try{
          if (this.__vsp_gate_root_is_pending && this.__vsp_gate_root_pending_open) {
            const args = this.__vsp_gate_root_pending_open;
            this.__vsp_gate_root_is_pending = false;
            this.__vsp_gate_root_pending_open = null;

            const origUrl = args[1];
            const self = this;
            return window.__vsp_gate_root_rid_promise.then((rid)=>{
              const url1 = rewriteRunFileAllow(origUrl, rid);
              _open.call(self, args[0], url1, args[2], args[3], args[4]);
              return _send.call(self, body);
            });
          }
        }catch(e){}
        return _send.apply(this, arguments);
      };
    }

    console.log("[GateStoryV1][%s] installed", "VSP_P1_GATE_ROOT_PROXY_V2");
  } catch(e){}
})();

/* VSP_P1_GATE_STORY_FORCE_PAINT_V1B */
(() => {
  // NOTE: do NOT early-return even if previous version set a flag;
  // we want "self-healing" behavior on blank pages.
  if (window.__vsp_gate_story_force_paint_v1b) return;
  window.__vsp_gate_story_force_paint_v1b = true;

  const CFG = {
    runsUrl: "/api/vsp/runs?limit=1",
    fileUrl: (rid) => `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&name=${encodeURIComponent("run_gate.json")}`,
    timeoutMs: 8000,
    tools: ["bandit","semgrep","gitleaks","kics","trivy","syft","grype","codeql"],
    refreshMs: 15000,      // refresh data
    healEveryMs: 600,      // re-insert panel if removed
    healMaxMs: 20000,      // keep healing for 20s after load
  };

  const now = () => Date.now();
  const log = (...a) => console.log("[GateStoryV1B]", ...a);

  function esc(s){
    try{ if(Date.now()-window.__vsp_gate_story_last_ok_ts < window.__vsp_gate_story_cooldown_ms){ return; } }catch(e){}
return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

  function pick(obj, path, defv){
    try{
      const ps = path.split(".");
      let cur = obj;
      for (const k of ps){
        if (!cur) return defv;
        cur = cur[k];
      }
      return (cur === undefined || cur === null) ? defv : cur;
    } catch { return defv; }
  }

  function normOverall(v){
    const s = String(v ?? "").toUpperCase().trim();
    if (["RED","FAIL","FAILED","BLOCK","BLOCKED","CRITICAL"].includes(s)) return "RED";
    if (["AMBER","WARN","WARNING","DEGRADED","YELLOW"].includes(s)) return "AMBER";
    if (["GREEN","PASS","PASSED","OK"].includes(s)) return "GREEN";
    return s || "UNKNOWN";
  }

  function tone(overall){
    if (overall === "RED") return "tone-red";
    if (overall === "AMBER") return "tone-amber";
    if (overall === "GREEN") return "tone-green";
    return "tone-unk";
  }

  function toolTone(st){
    const s = String(st ?? "").toUpperCase();
    if (["PASS","OK","GREEN"].includes(s)) return "t-ok";
    if (["FAIL","RED","BLOCKED"].includes(s)) return "t-bad";
    if (["DEGRADED","AMBER","WARN","TIMEOUT"].includes(s)) return "t-warn";
    if (["MISSING","SKIP","SKIPPED","N/A","NA"].includes(s)) return "t-mute";
    return "t-unk";
  }

  function ensureStyle(){
    if (document.getElementById("vsp_gate_story_v1b_style")) return;
    const st = document.createElement("style");
    st.id = "vsp_gate_story_v1b_style";
    st.textContent = `
      body{ background:#0b1220; }
      .vspgs-wrap{ margin:14px; }
      .vspgs-card{
        border:1px solid rgba(255,255,255,.10);
        background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
        border-radius:16px;
        padding:14px;
        box-shadow: 0 14px 34px rgba(0,0,0,.45);
        color: rgba(226,232,240,.96);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      .vspgs-top{display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:flex-start;}
      .vspgs-title{display:flex; gap:10px; align-items:flex-start;}
      .vspgs-dot{width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,.25);margin-top:4px;}
      .vspgs-h{font-weight:800; letter-spacing:.3px; font-size:14px;}
      .vspgs-sub{font-size:12px; opacity:.74; margin-top:2px;}
      .vspgs-kpis{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
      .pill{border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.22); border-radius:999px; padding:6px 10px; font-size:12px; display:flex; gap:8px; align-items:center;}
      .ov{font-weight:900; letter-spacing:1px; padding:6px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.16);}
      .tone-red{background: rgba(255,73,73,.16); color: rgba(255,165,165,.98);}
      .tone-amber{background: rgba(255,193,7,.14); color: rgba(255,228,141,.98);}
      .tone-green{background: rgba(46,204,113,.12); color: rgba(165,255,205,.98);}
      .tone-unk{background: rgba(148,163,184,.12); color: rgba(226,232,240,.95);}
      .mid{display:flex; gap:14px; margin-top:10px; flex-wrap:wrap;}
      .left{flex:1 1 460px; min-width:320px;}
      .right{flex:0 0 360px; min-width:320px;}
      .muted{opacity:.72;}
      .small{font-size:12px; opacity:.82; line-height:1.25rem;}
      .reasons{margin:8px 0 0 0; padding:0 0 0 18px;}
      .reasons li{margin:6px 0; font-size:13px; line-height:1.25rem;}
      .strip{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
      .tool{font-size:11px; padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.22); display:flex; gap:6px; align-items:center;}
      .tool b{letter-spacing:.3px;}
      .t-ok{color: rgba(165,255,205,.98);}
      .t-warn{color: rgba(255,228,141,.98);}
      .t-bad{color: rgba(255,165,165,.98);}
      .t-mute{color: rgba(203,213,225,.72);}
      .t-unk{color: rgba(226,232,240,.92);}
      .actions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-top:10px;}
      .btn{cursor:pointer; border:1px solid rgba(255,255,255,.16); background: rgba(0,0,0,.22); color: rgba(226,232,240,.95);
           border-radius:12px; padding:8px 10px; font-size:12px; text-decoration:none;}
      .btn:hover{background: rgba(255,255,255,.06);}
      .hr{height:1px; background: rgba(255,255,255,.08); margin-top:10px;}
    `;
    document.head.appendChild(st);
  }

  function ensurePanel(){
    ensureStyle();
    let wrap = document.getElementById("vsp_gate_story_panel_v1b");
    if (wrap) return wrap;

    wrap = document.createElement("div");
    wrap.id = "vsp_gate_story_panel_v1b";
    wrap.className = "vspgs-wrap";
    wrap.innerHTML = `
      <div class="vspgs-card">
        <div class="vspgs-top">
          <div class="vspgs-title">
            <div class="vspgs-dot"></div>
            <div>
              <div class="vspgs-h">Gate Story</div>
              <div class="vspgs-sub muted">overall + top reasons + degraded/tools (latest)</div>
            </div>
          </div>
          <div class="vspgs-kpis">
            <div class="pill"><span class="muted">Overall</span> <span id="gs_overall" class="ov tone-unk">…</span></div>
            <div class="pill"><span class="muted">Degraded</span> <b id="gs_degraded">…</b></div>
            <div class="pill"><span class="muted">Total</span> <b id="gs_total">…</b></div>
          </div>
        </div>

        <div class="mid">
          <div class="left">
            <div class="small muted">Top reasons (3)</div>
            <ol class="reasons" id="gs_reasons"><li class="muted">Loading gate…</li></ol>
            <div class="hr"></div>
            <div class="small muted">Tool strip (8)</div>
            <div class="strip" id="gs_strip"></div>
          </div>
          <div class="right">
            <div class="small muted">Latest run</div>
            <div class="small" id="gs_meta">…</div>
            <div class="actions" id="gs_actions"></div>
          </div>
        </div>
      </div>
    `;

    // Force insert at body top even if other scripts wipe containers
    if (document.body.firstChild) document.body.insertBefore(wrap, document.body.firstChild);
    else document.body.appendChild(wrap);

    return wrap;
  }

  function setOverall(v){
    const el = document.getElementById("gs_overall");
    if (!el) return;
    const o = normOverall(v);
    el.textContent = o;
    el.classList.remove("tone-red","tone-amber","tone-green","tone-unk");
    el.classList.add(tone(o));
  }

  function setText(id, v){
    const el = document.getElementById(id);
    if (el) el.textContent = String(v ?? "");
  }

  function renderStrip(toolState){
    const box = document.getElementById("gs_strip");
    if (!box) return;
    box.innerHTML = "";
    for (const t of CFG.tools){
      const st = String(toolState[t] ?? "UNKNOWN").toUpperCase();
      const chip = document.createElement("div");
      chip.className = `tool ${toolTone(st)}`;
      chip.innerHTML = `<b>${esc(t.toUpperCase())}</b><span class="muted">•</span><span>${esc(st)}</span>`;
      box.appendChild(chip);
    }
  }

  function renderReasons(arr){
    const ol = document.getElementById("gs_reasons");
    if (!ol) return;
    const rs = (arr && arr.length) ? arr.slice(0,3) : ["No reasons available (fallback)."];
    ol.innerHTML = rs.map(x => `<li>${esc(x)}</li>`).join("");
  }

  function renderMeta(rid, run, sevText){
    const el = document.getElementById("gs_meta");
    if (!el) return;
    const started = (run && (run.started_at || run.created_at || run.ts || run.time)) || "";
    const ro = normOverall((run && (run.overall || run.overall_status || run.status || run.verdict)) || "");
    el.innerHTML =
      `<div><b>RID</b>: <span class="muted">${esc(rid)}</span></div>` +
      (started ? `<div><b>Time</b>: <span class="muted">${esc(started)}</span></div>` : "") +
      `<div><b>Run overall</b>: <span class="muted">${esc(ro || "UNKNOWN")}</span></div>` +
      (sevText ? `<div><b>Sev</b>: <span class="muted">${esc(sevText)}</span></div>` : "");
  }

  function renderActions(rid){
    const box = document.getElementById("gs_actions");
    if (!box) return;
    const url = CFG.fileUrl(rid);
    box.innerHTML = `
      <a class="btn" href="${esc(url)}" target="_blank" rel="noopener">Open run_gate.json</a>
      <a class="btn" href="/runs" target="_blank" rel="noopener">Runs &amp; Reports</a>
      <a class="btn" href="/data_source" target="_blank" rel="noopener">Data Source</a>
    `;
  }

  async function fetchJson(url){
    const ac = new AbortController();
    const t = setTimeout(() => ac.abort(), CFG.timeoutMs);
    try{
      const r = await fetch(url, {signal: ac.signal, headers: {"Accept":"application/json"}});
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    } finally { clearTimeout(t); }
  }

  function normalizeTools(summary){
    const byTool = summary.by_tool || summary.tools || summary.tool_results || {};
    const toolState = {};
    let degradedCount = 0;

    for (const t of CFG.tools){
      let ent = byTool[t] || byTool[t.toUpperCase()] || byTool[t.toLowerCase()];
      let st = "UNKNOWN";
      let dg = false;

      if (ent && typeof ent === "object"){
        st = String(ent.status || ent.state || ent.verdict || ent.result || "UNKNOWN").toUpperCase();
        dg = !!(ent.degraded || ent.is_degraded || ent.timeout || ent.timed_out);
        if (dg && (st === "PASS" || st === "OK" || st === "GREEN")) st = "DEGRADED";
      } else {
        // fallback flat fields
        const st2 = summary[`${t}_status`];
        const dg2 = summary[`${t}_degraded`];
        if (st2) st = String(st2).toUpperCase();
        if (dg2 !== undefined) dg = !!dg2;
        if (dg && (st === "PASS" || st === "OK")) st = "DEGRADED";
      }

      toolState[t] = st;
      if (dg) degradedCount++;
    }
    return {toolState, degradedCount};
  }

  function extractTotals(summary){
    const sev = summary.counts_by_severity || summary.severity_counts || summary.by_severity || null;
    if (sev && typeof sev === "object"){
      const c = Number(sev.CRITICAL ?? sev.critical ?? 0) || 0;
      const h = Number(sev.HIGH ?? sev.high ?? 0) || 0;
      const m = Number(sev.MEDIUM ?? sev.medium ?? 0) || 0;
      const l = Number(sev.LOW ?? sev.low ?? 0) || 0;
      const i = Number(sev.INFO ?? sev.info ?? 0) || 0;
      const t = Number(sev.TRACE ?? sev.trace ?? 0) || 0;
      const total = Number(summary.total_findings ?? summary.findings_total ?? (c+h+m+l+i+t)) || (c+h+m+l+i+t);
      return { total, sevText: `C/H/M/L/I/T = ${c}/${h}/${m}/${l}/${i}/${t}` };
    }
    // best-effort
    const total = Number(summary.total_findings ?? summary.findings_total ?? summary.total ?? 0) || 0;
    return total ? { total, sevText: "" } : null;
  }

  function extractReasons(summary, rid, degradedCount, totals){
    let rs = summary.top_reasons || summary.reasons || summary.why || summary.verdict_reasons || [];
    if (typeof rs === "string") rs = rs.split("\n").map(x=>x.trim()).filter(Boolean);
    if (Array.isArray(rs)) rs = rs.map(x => typeof x === "string" ? x : (x && x.text ? x.text : JSON.stringify(x)));

    rs = (rs || []).filter(Boolean).slice(0,3);
    if (rs.length < 3){
      if (totals && totals.total) rs.push(`Tổng findings: ${totals.total}.`);
      if (degradedCount > 0) rs.push(`Degraded tools: ${degradedCount}/${CFG.tools.length}.`);
      rs.push(`RID: ${rid}.`);
      rs = rs.slice(0,3);
    }
    return rs;
  }

  async function refreshOnce(){
    ensurePanel();

    const runs = await fetchJson(CFG.runsUrl);
    const run = (runs && Array.isArray(runs.items) && runs.items[0]) ? runs.items[0] : null;
    const rid = (run && (run.run_id || run.rid || run.id)) || null;

    if (!rid){
      setOverall("UNKNOWN");
      renderReasons(["Không lấy được RID từ /api/vsp/runs?limit=1."]);
      renderStrip(Object.fromEntries(CFG.tools.map(t=>[t,"UNKNOWN"])));
      setText("gs_degraded", `0/${CFG.tools.length}`);
      setText("gs_total", "—");
      return;
    }

    let summary = null;
    try { summary = await fetchJson(CFG.fileUrl(rid)); } catch { summary = null; }

    const overall = normOverall(
      (summary && (summary.overall || summary.overall_status || summary.status || summary.verdict)) ||
      (run && (run.overall || run.overall_status || run.status || run.verdict)) ||
      "UNKNOWN"
    );
    setOverall(overall);

    const totals = summary ? extractTotals(summary) : null;
    setText("gs_total", totals ? String(totals.total) : "—");

    const {toolState, degradedCount} = summary ? normalizeTools(summary) : {toolState: Object.fromEntries(CFG.tools.map(t=>[t,"UNKNOWN"])), degradedCount: 0};
    setText("gs_degraded", `${degradedCount}/${CFG.tools.length}`);
    renderStrip(toolState);

    const reasons = summary ? extractReasons(summary, rid, degradedCount, totals) : [
      "Không đọc được run_gate.json (fallback).",
      `Degraded tools: ${degradedCount}/${CFG.tools.length}.`,
      `RID: ${rid}.`,
    ];
    renderReasons(reasons);

    renderMeta(rid, run || {}, totals ? totals.sevText : "");
    renderActions(rid);
  }

  function start(){
    // Always paint immediately so page is not blank
    ensurePanel();
    setOverall("UNKNOWN");
    renderStrip(Object.fromEntries(CFG.tools.map(t=>[t,"…"])));
    renderReasons(["Loading…"]);

    // Data refresh
    refreshOnce().catch(e => {
      log("refresh error:", e?.message || e);
      renderReasons([`Lỗi tải gate: ${String(e?.message || e).slice(0,120)}`]);
    });

    // Heal loop: if any legacy script wipes DOM, reinsert panel
    const t0 = now();
    const heal = setInterval(() => {
      if (now() - t0 > CFG.healMaxMs) { clearInterval(heal); return; }
      if (!document.getElementById("vsp_gate_story_panel_v1b")) {
        log("heal: panel missing -> reinsert");
        ensurePanel();
      }
    }, CFG.healEveryMs);

    // Periodic refresh
    setInterval(() => refreshOnce().catch(()=>{}), CFG.refreshMs);

    log("loaded + running");
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", start, {once:true});
  else start();
})();

/* VSP_P1_GATE_STORY_REWIRE_RUN_FILE_ALLOW_V1B */
console.log('[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] rewire: run_file -> run_file_allow');


/* VSP_P1_GATE_STORY_FIX_RUNFILE_ALLOW_PARAMS_V2 */
(()=> {
  if (window.__vsp_p1_gate_story_fix_runfile_allow_params_v2) return;
  window.__vsp_p1_gate_story_fix_runfile_allow_params_v2 = true;

  function getRidFromDom(){
    try{
      const txt = (document.body && document.body.textContent) ? document.body.textContent : "";
      const m = txt.match(/RID:\s*([A-Za-z0-9_.\-]+)/);
      return m ? m[1] : "";
    }catch(e){ return ""; }
  }

  const origFetch = window.fetch;
  window.fetch = function(input, init){
    try{
      if (typeof input === "string" && input.includes("/api/vsp/run_file_allow")){
        let url = input;

        // If rid missing, try to attach from DOM
        if (!/[?&]rid=/.test(url)){
          const rid = getRidFromDom();
          if (rid){
            url += (url.includes("?") ? "&" : "?") + "rid=" + encodeURIComponent(rid);
          }
        }
        // If path missing, force run_gate.json (backend will fallback to run_gate_summary.json)
        if (!/[?&]path=/.test(url)){
          url += (url.includes("?") ? "&" : "?") + "path=" + encodeURIComponent("run_gate.json");
        }

        input = url;
      }
    }catch(e){}
    return origFetch(input, init);
  };

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V2 fix: force rid+path for run_file_allow, path=run_gate.json");
})();

/* VSP_P1_GATE_STORY_FIX_RUNFILE_ALLOW_PARAMS_V2 */



/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V3
   - capture gate json from /api/vsp/run_file_allow
   - apply to DOM: Run overall + tool badges (fix UNKNOWN) without relying on internal GateStory code
*/
(()=> {
  if (window.__vsp_p1_gate_story_apply_gate_to_dom_v3) return;
  window.__vsp_p1_gate_story_apply_gate_to_dom_v3 = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];

  function norm(s){ return (s||"").toString().trim().toUpperCase(); }

  function statusFromCounts(ct){
    ct = ct || {};
    const c = (ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0), l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h > 0) return "RED";
    if (m > 0) return "AMBER";
    if (l+i+t > 0) return "GREEN";
    return "UNKNOWN";
  }

  function computeToolStatus(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const k of TOOLS){
      const o = bt[k] || bt[k.toLowerCase()] || null;
      if (!o){ out[k]="UNKNOWN"; continue; }
      const st = norm(o.status || o.overall || o.verdict);
      if (st && st !== "UNKNOWN"){
        // normalize common variants
        if (st === "PASS" || st === "OK" || st === "GREEN") out[k]="GREEN";
        else if (st === "WARN" || st === "AMBER") out[k]="AMBER";
        else if (st === "FAIL" || st === "BLOCK" || st === "RED") out[k]="RED";
        else out[k]=st;
      } else {
        const ct = o.counts_total || o.counts || o.totals || {};
        out[k] = statusFromCounts(ct);
      }
    }
    return out;
  }

  function applyRunOverall(gate){
    const ov = norm(gate && (gate.overall || gate.overall_status));
    if (!ov) return;
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(el => (el.childElementCount===0) && /Run overall:/i.test(el.textContent||""));
    for (const el of nodes.slice(0,5)){
      const t = el.textContent || "";
      el.textContent = t.replace(/Run overall:\s*\w+/i, "Run overall: " + ov);
    }
  }

  function applyToolBadges(map){
    const all = Array.from(document.querySelectorAll("button,span,div"))
      .filter(el => (el.childElementCount===0) && (el.textContent||"").length < 60);

    for (const tool of TOOLS){
      const st = map[tool] || "UNKNOWN";
      for (const el of all){
        const txt = (el.textContent||"").trim();
        if (!txt) continue;
        // match "TOOL - XXX" or "TOOL · XXX"
        const re = new RegExp("^\\s*"+tool+"\\s*([\\-·:\\|])\\s*(GREEN|AMBER|RED|UNKNOWN)\\s*$","i");
        if (re.test(txt)){
          el.textContent = txt.replace(re, tool + " $1 " + st);
        }
      }
    }
  }

  function applyGate(gate){
    if (!gate || typeof gate !== "object") return;
    applyRunOverall(gate);
    const map = computeToolStatus(gate);
    applyToolBadges(map);
  }

  // --- capture gate json from fetch ---
  const prevFetch = window.fetch;
  window.fetch = async function(input, init){
    const res = await prevFetch(input, init);
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url && url.includes("/api/vsp/run_file_allow")){
        // clone + try json
        const c = res.clone();
        c.json().then(j=>{
          if (j && typeof j === "object" && (j.by_tool || j.counts_total || j.overall || j.overall_status)){
            window.__vsp_gate_latest_v3 = j;
            applyGate(j);
          }
        }).catch(()=>{});
      }
    }catch(e){}
    return res;
  };

  // --- periodic apply (in case DOM rerender) ---
  setInterval(()=>{ try{ if (window.__vsp_gate_latest_v3) applyGate(window.__vsp_gate_latest_v3); }catch(e){} }, 1000);

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V3 apply DOM: Run overall + tool UNKNOWN fill (by_tool)");
})();

/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V3 */



/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V4B
   - fix JS syntax; sync "Run overall" + normalize tool badges using latest gate json
*/
(()=> {
  if (window.__vsp_p1_gate_story_apply_gate_to_dom_v4b) return;
  window.__vsp_p1_gate_story_apply_gate_to_dom_v4b = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];
  const norm = (x)=> (x||"").toString().trim().toUpperCase();

  function statusFromCounts(ct){
    ct = ct || {};
    const c=(ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0), l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h>0) return "RED";
    if (m>0) return "AMBER";
    if (l+i+t>0) return "GREEN";
    return "UNKNOWN";
  }

  function computeToolStatus(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const k of TOOLS){
      const o = bt[k] || bt[k.toLowerCase()] || null;
      if (!o){ out[k]="UNKNOWN"; continue; }
      const st0 = norm(o.status || o.overall || o.verdict);
      if (st0 && st0 !== "UNKNOWN"){
        if (st0==="PASS"||st0==="OK"||st0==="GREEN") out[k]="GREEN";
        else if (st0==="WARN"||st0==="AMBER") out[k]="AMBER";
        else if (st0==="FAIL"||st0==="BLOCK"||st0==="RED") out[k]="RED";
        else out[k]=st0;
      } else {
        const ct = o.counts_total || o.counts || o.totals || {};
        out[k] = statusFromCounts(ct);
      }
    }
    return out;
  }

  function applyRunOverall(gate){
    const ov = norm(gate && (gate.overall || gate.overall_status));
    if (!ov) return;
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(el => (el.textContent||"").includes("Run overall:"))
      .sort((a,b)=> (a.textContent||"").length - (b.textContent||"").length);
    for (const el of nodes.slice(0,8)){
      try{
        const t = el.textContent || "";
        const t2 = t.replace(/Run overall:\s*[A-Za-z_]+/i, "Run overall: " + ov);
        if (t2 !== t) el.textContent = t2;
      }catch(e){}
    }
  }

  function applyToolBadges(map){
    const nodes = Array.from(document.querySelectorAll("button,span,div"))
      .filter(el => (el.textContent||"").length < 80);

    for (const tool of TOOLS){
      const st = map[tool] || "UNKNOWN";
      const re = new RegExp("^\\s*" + tool + "\\s*([\\-·:\\|])\\s*(GREEN|AMBER|RED|UNKNOWN)\\s*$","i");
      for (const el of nodes){
        const txt = (el.textContent||"").trim();
        if (!txt) continue;
        if (!txt.toUpperCase().includes(tool)) continue;
        if (re.test(txt)){
          el.textContent = txt.replace(re, tool + " $1 " + st);
        }
      }
    }
  }

  function applyGate(gate){
    if (!gate || typeof gate !== "object") return;
    applyRunOverall(gate);
    applyToolBadges(computeToolStatus(gate));
  }

  const prevFetch = window.fetch;
  window.fetch = async function(input, init){
    const res = await prevFetch(input, init);
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url && url.includes("/api/vsp/run_file_allow")){
        const c = res.clone();
        c.json().then(j=>{
          if (j && typeof j === "object" && (j.by_tool || j.counts_total || j.overall || j.overall_status)){
            window.__vsp_gate_latest_v4b = j;
            applyGate(j);
          }
        }).catch(()=>{});
      }
    }catch(e){}
    return res;
  };

  setInterval(()=>{ try{ if (window.__vsp_gate_latest_v4b) applyGate(window.__vsp_gate_latest_v4b); }catch(e){} }, 900);

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V4B apply DOM: Run overall + tool badge normalize");
})();

/* VSP_P1_GATE_STORY_APPLY_GATE_TO_DOM_V4B */



/* VSP_P1_GATE_STORY_AUTOFETCH_GATE_V5
   - poll /api/vsp/runs -> get latest rid -> fetch /api/vsp/run_file_allow?rid=...&path=run_gate.json
   - triggers existing DOM apply hooks (V3/V4B) because run_file_allow fetch happens
*/
(()=> {
  if (window.__vsp_p1_gate_story_autofetch_gate_v5) return;
  window.__vsp_p1_gate_story_autofetch_gate_v5 = true;

  const BASE = ""; // same-origin
  const RUNS_URL = BASE + "/api/vsp/runs?limit=1&offset=0";
  const POLL_MS = 8000;

  let lastRid = "";
  let inflight = false;

  async function fetchJson(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error("HTTP "+r.status+" "+url);
    return await r.json();
  }

  async function tick(){
    if (document.hidden) return;
    if (inflight) return;
    inflight = true;
    try{
      const j = await fetchJson(RUNS_URL);
      const it = (j && j.items && j.items[0]) ? j.items[0] : {};
      const rid = (it.rid || it.run_id || "").toString();
      if (rid && rid !== lastRid){
        lastRid = rid;
        const gateUrl = BASE + "/api/vsp/run_file_allow?rid=" + encodeURIComponent(rid) +
                        "&path=" + encodeURIComponent("run_gate.json");
        console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V5 fetch gate:", rid);
        // this will be captured by V3/V4B fetch hook and applied to DOM
        fetch(gateUrl, { cache: "no-store" }).catch(()=>{});
      }
    }catch(e){
      console.warn("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V5 tick err:", e && e.message ? e.message : e);
    }finally{
      inflight = false;
    }
  }

  // kick immediately + interval
  setTimeout(tick, 50);
  setInterval(tick, POLL_MS);

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V5 installed: auto-fetch run_gate.json from latest RID");
})();

/* VSP_P1_GATE_STORY_AUTOFETCH_GATE_V5 */



/* VSP_P1_GATE_STORY_RUN_OVERALL_TEXTNODE_FIX_V6
   - Update "Run overall" using TEXT NODE walker (works even if split spans)
   - Reads latest gate from __vsp_gate_latest_v4b (set by V4B) or tries __vsp_gate_latest_v3
*/
(()=> {
  if (window.__vsp_p1_gate_story_run_overall_textnode_fix_v6) return;
  window.__vsp_p1_gate_story_run_overall_textnode_fix_v6 = true;

  const norm = (x)=> (x||"").toString().trim().toUpperCase();
  const STATUSES = ["UNKNOWN","GREEN","AMBER","RED"];

  function getOverall(){
    const g = window.__vsp_gate_latest_v4b || window.__vsp_gate_latest_v3 || window.__vsp_gate_latest_v3 || null;
    return g ? norm(g.overall || g.overall_status) : "";
  }

  function patchTextNodes(ov){
    if (!ov) return 0;
    let n=0;
    try{
      const w = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
      let node;
      while ((node = w.nextNode())) {
        const t = node.nodeValue || "";
        if (t.includes("Run overall:")) {
          const t2 = t.replace(/Run overall:\s*(UNKNOWN|GREEN|AMBER|RED)/i, "Run overall: " + ov);
          if (t2 !== t) { node.nodeValue = t2; n++; }
        }
      }
    }catch(e){}
    return n;
  }

  function patchSplitSpans(ov){
    if (!ov) return 0;
    let n=0;
    try{
      // Find containers that mention "Run overall" and flip any child that is a status token
      const nodes = Array.from(document.querySelectorAll("*"))
        .filter(el => (el.textContent||"").includes("Run overall"));
      for (const el of nodes.slice(0,30)){
        const kids = el.querySelectorAll("span,div,b,i,strong,small");
        for (const k of kids){
          const tx = norm(k.textContent);
          if (STATUSES.includes(tx)) {
            k.textContent = ov;
            n++;
          }
        }
      }
    }catch(e){}
    return n;
  }

  function tick(){
    const ov = getOverall();
    if (!ov) return;
    const a = patchTextNodes(ov);
    const b = patchSplitSpans(ov);
    // only log once when we successfully patched something
    if ((a+b) > 0 && !window.__vsp_p1_gate_story_run_overall_textnode_fix_v6_logged){
      window.__vsp_p1_gate_story_run_overall_textnode_fix_v6_logged = true;
      console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V6 patched Run overall =>", ov, "nodes=", (a+b));
    }
  }

  setInterval(tick, 500);
  setTimeout(tick, 80);
  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V6 installed: Run overall textnode patcher");
})();

/* VSP_P1_GATE_STORY_RUN_OVERALL_TEXTNODE_FIX_V6 */



/* VSP_P1_GATE_STORY_TOOL_TRUTH_V7C (SAFE)
   - DO NOT brute-force rewrite random text nodes
   - Render a dedicated strip container + only update single-tool badges
*/
(()=> {
  if (window.__vsp_p1_gate_story_tool_truth_v7c) return;
  window.__vsp_p1_gate_story_tool_truth_v7c = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];
  const TOKENS = ["GREEN","AMBER","RED","UNKNOWN","MISSING","DEGRADED"];
  const norm = (x)=> (x||"").toString().trim().toUpperCase();

  function getGate(){
    return window.__vsp_gate_latest_v4b
        || window.__vsp_gate_latest_v6
        || window.__vsp_gate_latest_v5
        || window.__vsp_gate_latest_v3
        || window.__vsp_gate_latest
        || null;
  }

  function statusFromCounts(ct){
    ct = ct || {};
    const c=(ct.CRITICAL||0), h=(ct.HIGH||0), m=(ct.MEDIUM||0);
    const l=(ct.LOW||0), i=(ct.INFO||0), t=(ct.TRACE||0);
    if (c+h>0) return "RED";
    if (m>0) return "AMBER";
    if (l+i+t>0) return "GREEN";
    return "UNKNOWN";
  }

  function mapVerdict(x){
    x = norm(x);
    if (!x) return "";
    if (["OK","PASS","GREEN"].includes(x)) return "GREEN";
    if (["WARN","WARNING","AMBER"].includes(x)) return "AMBER";
    if (["FAIL","FAILED","BLOCK","BLOCKED","ERROR","RED"].includes(x)) return "RED";
    if (TOKENS.includes(x)) return x;
    return x;
  }

  function computeToolMap(gate){
    const out = {};
    const bt = (gate && gate.by_tool) ? gate.by_tool : {};
    for (const tool of TOOLS){
      const o = bt[tool] || bt[tool.toLowerCase()] || null;
      if (!o){ out[tool] = "MISSING"; continue; }

      const degraded = !!(o.degraded || o.timeout || o.timed_out || o.time_out);
      if (degraded){ out[tool] = "DEGRADED"; continue; }

      let st = mapVerdict(o.verdict || o.status || o.overall || o.verdict_status);
      if (!st || st==="UNKNOWN"){
        st = statusFromCounts(o.counts || o.counts_total || o.totals || {});
      }
      out[tool] = st || "UNKNOWN";
    }
    return out;
  }

  function findGateStoryRoot(){
    // try known hooks first
    let r = document.querySelector("#vsp5") || document.querySelector("#app") || document.body;

    // prefer area around "Gate Story"
    const all = Array.from(document.querySelectorAll("div,section,main,article"));
    for (const el of all){
      const t = (el.textContent||"").trim();
      if (t.startsWith("Gate Story") && t.length < 60) return el.parentElement || el;
    }
    return r;
  }

  function ensureStripContainer(root){
    let box = document.getElementById("vsp_tool_truth_strip_v7c");
    if (box) return box;

    box = document.createElement("div");
    box.id = "vsp_tool_truth_strip_v7c";
    box.style.display = "flex";
    box.style.flexWrap = "wrap";
    box.style.gap = "8px";
    box.style.marginTop = "10px";

    const label = document.createElement("div");
    label.textContent = "Tool truth (V7C):";
    label.style.opacity = "0.85";
    label.style.fontSize = "12px";
    label.style.marginRight = "10px";
    label.style.alignSelf = "center";

    const row = document.createElement("div");
    row.id = "vsp_tool_truth_strip_v7c_row";
    row.style.display = "flex";
    row.style.flexWrap = "wrap";
    row.style.gap = "8px";

    box.appendChild(label);
    box.appendChild(row);

    // insert near the existing "Tool strip (8)" line if possible
    const nodes = Array.from(document.querySelectorAll("div,span,p"));
    let anchor = null;
    for (const el of nodes){
      const tx=(el.textContent||"").trim();
      if (/^Tool strip/i.test(tx)) { anchor = el; break; }
    }
    if (anchor && anchor.parentElement){
      anchor.parentElement.appendChild(box);
    } else {
      root.appendChild(box);
    }
    return box;
  }

  function pill(tool, st){
    const b = document.createElement("span");
    b.textContent = `${tool} - ${st}`;
    b.setAttribute("data-vsp-tool", tool);
    b.setAttribute("data-vsp-status", st);
    b.style.padding = "4px 10px";
    b.style.borderRadius = "999px";
    b.style.fontSize = "12px";
    b.style.border = "1px solid rgba(255,255,255,0.12)";
    b.style.background = "rgba(255,255,255,0.04)";
    b.style.userSelect = "text";
    return b;
  }

  function renderStrip(mp){
    const root = findGateStoryRoot();
    const box = ensureStripContainer(root);
    const row = document.getElementById("vsp_tool_truth_strip_v7c_row");
    if (!row) return;

    // rebuild row
    row.innerHTML = "";
    for (const tool of TOOLS){
      row.appendChild(pill(tool, mp[tool] || "UNKNOWN"));
    }
  }

  function fixSingleToolBadges(mp){
    // only touch elements that look like EXACTLY one tool badge
    const els = Array.from(document.querySelectorAll("button,span,div,a"));
    for (const el of els){
      const txt = (el.textContent||"").trim();
      if (!txt || txt.length > 40) continue;

      // skip if contains 2+ tool keywords
      let hits = 0;
      for (const t of TOOLS) if (txt.toUpperCase().includes(t)) hits++;
      if (hits != 1) continue;

      for (const tool of TOOLS){
        if (!txt.toUpperCase().includes(tool)) continue;
        const st = mp[tool] || "UNKNOWN";

        const re1 = new RegExp("^\\s*"+tool+"\\s*[-:·\\|]\\s*("+TOKENS.join("|")+")\\s*$","i");
        const re2 = new RegExp("^\\s*"+tool+"\\s*$","i");
        if (re1.test(txt)) el.textContent = txt.replace(re1, tool+" - "+st);
        else if (re2.test(txt)) el.textContent = tool+" - "+st;
        el.setAttribute("data-vsp-status", st);
      }
    }
  }

  let lastSig = "";
  function tick(){
    const g = getGate();
    if (!g) return;
    const mp = computeToolMap(g);

    renderStrip(mp);
    fixSingleToolBadges(mp);

    const sig = JSON.stringify(mp);
    if (sig !== lastSig){
      lastSig = sig;
      console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V7C tool truth:", mp);
    }
  }

  setTimeout(tick, 120);
  setInterval(tick, 1200);
  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V7C installed: safe tool truth strip renderer");
})();

/* VSP_P1_GATE_STORY_TOOL_TRUTH_V7C */



/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V1 */
(()=> {
  if (window.__vsp_p1_hide_legacy_strip_v1) return;
  window.__vsp_p1_hide_legacy_strip_v1 = true;

  function tick(){
    const v7c = document.getElementById("vsp_tool_truth_strip_v7c");
    if (!v7c) return;

    // Heuristic: legacy tool strip line often contains "Tool strip" text
    const nodes = Array.from(document.querySelectorAll("div,span,p"));
    for (const el of nodes){
      const tx = (el.textContent||"").trim();
      if (/^Tool strip\s*\(/i.test(tx)){
        el.style.display = "none";
        const parent = el.parentElement;
        if (parent && parent.children && parent.children.length <= 3){
          // hide the whole legacy block if it's just label+badges
          parent.style.display = "none";
        }
      }
    }
  }
  setTimeout(tick, 200);
  setInterval(tick, 1500);
  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] hide legacy tool strip when V7C present");
})();

/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V1 */



/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V2 */
(()=> {
  if (window.__vsp_p1_hide_legacy_strip_v2) return;
  window.__vsp_p1_hide_legacy_strip_v2 = true;

  const TOOLS = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];

  function toolHits(txt){
    txt = (txt||"");
    let h=0;
    for (const t of TOOLS) if (txt.includes(t)) h++;
    return h;
  }

  function isLegacyBadgeRow(el, v7c){
    if (!el || !el.textContent) return false;
    if (el === v7c) return false;
    if (v7c && (v7c.contains(el) || el.contains(v7c))) return false;

    const tx = (el.textContent||"").trim();
    if (!tx) return false;
    if (tx.includes("Tool truth")) return false; // đừng đụng V7C
    // row badge thường chứa nhiều tool names
    return toolHits(tx) >= 4;
  }

  function hideLegacy(){
    const v7c = document.getElementById("vsp_tool_truth_strip_v7c");
    if (!v7c) return;

    // 1) hide label "Tool strip..."
    for (const el of Array.from(document.querySelectorAll("div,span,p,strong,small"))){
      const tx = (el.textContent||"").trim();
      if (/^Tool\s*strip\b/i.test(tx)){
        el.style.display="none";
        if (el.parentElement) el.parentElement.style.display="none";
      }
    }

    // 2) hide legacy badge row(s) that appear BEFORE v7c in DOM order
    const candidates = Array.from(document.querySelectorAll("div,section,article,span"));
    let hidden=0;
    for (const el of candidates){
      if (!isLegacyBadgeRow(el, v7c)) continue;

      // el is before v7c?
      const rel = el.compareDocumentPosition(v7c);
      const elIsBefore = (rel & Node.DOCUMENT_POSITION_FOLLOWING) !== 0;

      if (elIsBefore){
        el.style.display="none";
        hidden++;
      }
    }

    if (!window.__vsp_p1_hide_legacy_strip_v2_logged){
      window.__vsp_p1_hide_legacy_strip_v2_logged = true;
      console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] hide legacy strip V2: hidden=", hidden);
    }
  }

  setTimeout(hideLegacy, 150);
  setTimeout(hideLegacy, 600);
  setInterval(hideLegacy, 2000);
})();

/* VSP_P1_GATE_STORY_HIDE_LEGACY_STRIP_WHEN_V7C_V2 */


/* VSP_P1_HIDE_LEGACY_STRIP_BY_ID_V3B */
(()=> {
  try{
    if (window.__vsp_hide_legacy_by_id_v3b) return;
    window.__vsp_hide_legacy_by_id_v3b = true;

    const hide = ()=>{
      const el = document.getElementById('vsp_tool_strip_legacy');
      if (el) { el.style.display='none'; el.setAttribute('data-hidden','1'); }
    };

    setTimeout(hide, 50);
    setTimeout(hide, 250);
    setTimeout(hide, 900);
    setInterval(hide, 2500);

    console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V3B hide legacy by id installed");
  }catch(e){
    console.warn("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V3B hide legacy failed:", e);
  }
})();


/* VSP_P1_GATE_STORY_REWIRE_ALLOW_EVERYWHERE_V8 */
console.log('[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V8 rewire allow everywhere applied');


/* VSP_P1_GATE_STORY_FETCH_FALLBACK_LASTGOOD_V9
   If latest RID has no gate artifact -> auto fallback to last_good RID stored in localStorage.
*/
(()=> {
  if (window.__vsp_gate_story_lastgood_v9) return;
  window.__vsp_gate_story_lastgood_v9 = true;

  const LS_KEY = "vsp_last_good_gate_rid_v1";

  function isGateUrl(u){
    try{
      const url = new URL(u, window.location.origin);
      if (!url.pathname.includes("/api/vsp/run_file_allow")) return false;
      const path = (url.searchParams.get("path")||"");
      return /run_gate(_summary)?\.json$/i.test(path);
    }catch(e){ return false; }
  }
  function getRid(u){
    try{ return new URL(u, window.location.origin).searchParams.get("rid")||""; }catch(e){ return ""; }
  }
  function setLastGood(rid){
    if (!rid) return;
    try{ localStorage.setItem(LS_KEY, rid); }catch(e){}
  }
  function getLastGood(){
    try{ return localStorage.getItem(LS_KEY)||""; }catch(e){ return ""; }
  }
  function swapRid(u, rid){
    const url = new URL(u, window.location.origin);
    url.searchParams.set("rid", rid);
    return url.toString();
  }

  const _fetch = window.fetch.bind(window);
  window.fetch = async (input, init) => {
    const url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
    if (!url || !isGateUrl(url)) return _fetch(input, init);

    const rid = getRid(url);
    const lastGood = getLastGood();

    // try original
    const r1 = await _fetch(input, init);
    if (r1 && r1.ok) {
      // mark last good on ok
      setLastGood(rid);
      return r1;
    }

    // fallback if we have last good
    if (lastGood && lastGood !== rid) {
      const u2 = swapRid(url, lastGood);
      console.warn("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1][V9] gate fetch failed for rid=", rid, "=> fallback to last_good=", lastGood);
      // NOTE: if input is Request, we rebuild a Request
      if (typeof input === "string") return _fetch(u2, init);
      try{
        const req2 = new Request(u2, input);
        return _fetch(req2, init);
      }catch(e){
        return _fetch(u2, init);
      }
    }

    return r1;
  };

  console.log("[GateStoryV1][VSP_P1_GATE_ROOT_PICK_V1] V9 installed: fetch fallback to last_good RID");
})();



/* VSP_P1_GATE_STORY_AUTOPICK_GATEJSON_HIDE_LEGACY_V10 */
(()=> {
  if (window.__vsp_gate_story_v10) return;
  window.__vsp_gate_story_v10 = true;
  const TAG = "[GateStoryV10]";
  const TOOL_ORDER = ["BANDIT","SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","CODEQL"];
  const GATE_PATHS = ["run_gate_summary.json","run_gate.json","reports/run_gate_summary.json","reports/run_gate.json"];

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  function findGatePanel(){
    // find element whose text is exactly "Gate Story", then pick a reasonable container
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(n => n && n.childElementCount===0 && (n.textContent||"").trim()==="Gate Story");
    for (const n of nodes){
      const box = n.closest("div");
      if (box) return box;
    }
    return document.body;
  }

  function hideLegacyToolStrip(){
    // Hide any block that contains "Tool strip" label + its badge row (next sibling)
    const all = Array.from(document.querySelectorAll("*"));
    for (const el of all){
      const t = (el.textContent||"").trim();
      if (!t) continue;
      if (/^Tool strip\s*\(/i.test(t) || t==="Tool strip" || t.startsWith("Tool strip ")){
        const parent = el.parentElement;
        if (parent) parent.style.display = "none";
        const next = parent ? parent.nextElementSibling : el.nextElementSibling;
        if (next && next.querySelectorAll && next.querySelectorAll("span,button,div").length>=3){
          next.style.display = "none";
        }
      }
    }
    // Also hide the older concatenated strip line if exists (defensive)
    const bad = all.filter(el => (el.textContent||"").includes("BANDIT -") && (el.textContent||"").includes("SEMGREP -") && el.childElementCount===0);
    for (const el of bad){
      const parent = el.parentElement;
      if (parent) parent.style.display = "none";
      else el.style.display = "none";
    }
    console.log(TAG, "hideLegacyToolStrip done");
  }

  async function fetchGateJsonStrict(rid){
    for (const path of GATE_PATHS){
      const url = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=${encodeURIComponent(path)}`;
      let r;
      try{
        r = await fetch(url, {cache:"no-store"});
      }catch(e){
        continue;
      }
      if (!r || !r.ok) continue;

      const ct = (r.headers.get("content-type")||"").toLowerCase();
      if (!ct.includes("application/json")){
        // Important: run_file_allow may "fallback" to SUMMARY.txt as text/plain -> treat as missing
        console.warn(TAG, "non-json gate response => treat missing", {rid, path, ct});
        continue;
      }
      try{
        const j = await r.json();
        
/* VSP_P1_PREFER_GATE_ROOT_V1 */
try{
  if (j && j.rid_latest_gate_root){
    j.__vsp_prefer_gate_root = true;
    j.__vsp_gate_root = j.rid_latest_gate_root;
    // Force pickers that prefer last_good/latest to land on CI gate_root
    j.rid_last_good = j.rid_latest_gate_root;
    j.rid_latest = j.rid_latest_gate_root;
    console.log("[VSP][GateStory] prefer gate_root:", j.rid_latest_gate_root);
  }
}catch(e){
  console.warn("[VSP][GateStory] prefer gate_root inject err", e);
}
if (j && typeof j === "object" && (j.overall || j.overall_status) && (j.by_tool || j.counts_total)){
          return { rid, path, gate: j };
        }
      }catch(e){
        console.warn(TAG, "json parse failed", {rid, path, e});
      }
    }
    return null;
  }

  async function pickLastGoodGate(){
    // scan recent runs and pick the first RID that has real gate JSON
    const runsUrl = "/api/vsp/runs?limit=120&offset=0";
    let data = null;
    try{
      const r = await fetch(runsUrl, {cache:"no-store"});
      if (!r.ok) return null;
      data = await r.json();
    }catch(e){
      return null;
    }
    const items = data?.items || data?.runs || [];
    for (const it of items){
      const rid = it?.run_id || it?.rid || it?.id;
      if (!rid) continue;
      const g = await fetchGateJsonStrict(rid);
      if (g) return g;
      await sleep(10);
    }
    return null;
  }

  function setTextStartsWith(prefix, newText){
    const nodes = Array.from(document.querySelectorAll("*"))
      .filter(n => n && n.childElementCount===0 && ((n.textContent||"").trim().startsWith(prefix)));
    if (nodes[0]) nodes[0].textContent = newText;
  }

  function renderToolTruth(panel, gateObj){
    const overall = (gateObj.overall || gateObj.overall_status || "UNKNOWN");
    const byTool = gateObj.by_tool || {};

    // Update "RID:" and "Run overall:"
    // (RID is on screen already; we update to picked rid in caller)
    setTextStartsWith("Run overall:", `Run overall: ${overall}`);

    // Update the overall pill if we can find it
    const candidates = Array.from(document.querySelectorAll("span,div,button"))
      .filter(n => /^(UNKNOWN|RED|AMBER|GREEN)$/i.test(((n.textContent||"").trim())) );
    // prefer one that lives inside the Gate panel
    const pill = candidates.find(n => panel.contains(n));
    if (pill) pill.textContent = overall;

    // Render a dedicated strip (V10)
    let box = document.getElementById("vsp_gate_story_tool_truth_v10");
    if (!box){
      box = document.createElement("div");
      box.id = "vsp_gate_story_tool_truth_v10";
      box.style.marginTop = "10px";
      box.style.paddingTop = "8px";
      box.style.borderTop = "1px solid rgba(255,255,255,0.10)";
      panel.appendChild(box);
    }
    box.innerHTML = "";

    const title = document.createElement("div");
    title.textContent = "Tool truth (Gate JSON V10):";
    title.style.fontSize = "12px";
    title.style.opacity = "0.85";
    title.style.marginBottom = "6px";
    box.appendChild(title);

    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.flexWrap = "wrap";
    row.style.gap = "6px";
    box.appendChild(row);

    for (const t of TOOL_ORDER){
      const o = byTool[t] || {};
      const v = (o.verdict || o.status || "MISSING");
      const chip = document.createElement("span");
      chip.textContent = `${t}: ${v}`;
      chip.style.padding = "4px 10px";
      chip.style.borderRadius = "999px";
      chip.style.border = "1px solid rgba(255,255,255,0.14)";
      chip.style.fontSize = "12px";
      chip.style.lineHeight = "16px";
      row.appendChild(chip);
    }
  }

  async function main(){
    const panel = findGatePanel();
    hideLegacyToolStrip();

    const picked = await pickLastGoodGate();
    if (!picked){
      console.warn(TAG, "no gate JSON found in recent runs");
      return;
    }

    // Update RID line on screen
    setTextStartsWith("RID:", `RID: ${picked.rid}`);
    console.log(TAG, "picked last-good gate", picked.rid, "path=", picked.path);

    renderToolTruth(panel, picked.gate);
  }

  // run after other patches executed
  setTimeout(main, 250);
})();


/* VSP_P0_DASH_INJECT_INSIDE_GATE_STORY_V1
   - Runs in /vsp5 even when HTML is minimal
   - Forces tool-truth: mutate /api/vsp/runs json so pickers land on rid_latest_gate_root
   - Injects KPI + Audit panels under Gate Story bar
*/
(()=> {
  try{
    if (window.__vsp_p0_dash_inject_gate_story_v1) return;
    window.__vsp_p0_dash_inject_gate_story_v1 = true;

    const isDash = ()=> (location && location.pathname && location.pathname.indexOf("/vsp5") === 0);
    if (!isDash()) return;

    // --- Global fetch hook (works even if bundle not loaded) ---
    const _fetch = window.fetch ? window.fetch.bind(window) : null;
    if (_fetch && !window.__vsp_p0_runs_fetch_hooked_in_gate_v1){
      window.__vsp_p0_runs_fetch_hooked_in_gate_v1 = true;
      window.fetch = async (input, init) => {
        const res = await _fetch(input, init);
        try{
          const url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
          if (url && url.indexOf("/api/vsp/runs") !== -1 && res && res.ok && typeof res.json === "function"){
            const _json = res.json.bind(res);
            res.json = async () => {
              const j = await _json();
              try{
                if (j && j.rid_latest_gate_root){
                  j.__vsp_gate_root = j.rid_latest_gate_root;
                  j.rid_last_good = j.rid_latest_gate_root;
                  j.rid_latest    = j.rid_latest_gate_root;
                  console.log("[VSP][runs_hook@gate] prefer gate_root:", j.rid_latest_gate_root);
                }
              }catch(e){}
              return j;
            };
          }
        }catch(e){}
        return res;
      };
      console.log("[VSP][runs_hook@gate] installed");
    }

    // --- UI inject shell ---
    const $ = (id)=> document.getElementById(id);
    const setText = (id, v)=> { const el=$(id); if(el) el.textContent = (v==null? "—": String(v)); };

    async function fetchJSON(url){
      const r = await fetch(url, { cache:"no-store" });
      if (!r.ok) throw new Error("http "+r.status+" "+url);
      return await r.json();
    }
    async function probeText(url){
      const r = await fetch(url, { cache:"no-store" });
      if (!r.ok) return { ok:false, status:r.status, size:0 };
      const t = await r.text();
      return { ok: !!t && t.length>1, status:200, size:(t||"").length };
    }

    function ensureShell(){
      if ($("vsp_dash_p1_wrap")) return true;
      if (!document.body) return false;

      const wrap = document.createElement("div");
      wrap.id = "vsp_dash_p1_wrap";
      wrap.style.padding = "14px 14px 10px 14px";
      wrap.innerHTML = `
        <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;">
          <div style="min-width:260px;">
            <div style="font-size:18px;font-weight:700;letter-spacing:.2px;">VSP • Dashboard</div>
            <div style="opacity:.78;font-size:12px;margin-top:4px;">
              Tool truth (gate_root): <span id="vsp_dash_gate_root" style="font-family:ui-monospace,monospace;">—</span>
              • Updated: <span id="vsp_dash_updated_at">—</span>
            </div>
          </div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end;">
            <a class="vsp_btn" href="/runs" style="text-decoration:none;">Runs &amp; Reports</a>
            <a class="vsp_btn" href="/data_source" style="text-decoration:none;">Data Source</a>
            <a class="vsp_btn" href="/settings" style="text-decoration:none;">Settings</a>
            <a class="vsp_btn" href="/rule_overrides" style="text-decoration:none;">Rule Overrides</a>
            <span style="width:1px;height:22px;background:rgba(255,255,255,.10);display:inline-block;"></span>
            <a class="vsp_btn" id="vsp_dash_export_zip" href="#" style="text-decoration:none;">Export ZIP</a>
            <a class="vsp_btn" id="vsp_dash_export_pdf" href="#" style="text-decoration:none;">Export PDF</a>
          </div>
        </div>

        <div style="display:grid;grid-template-columns:repeat(12, 1fr);gap:10px;margin-top:12px;">
          <div style="grid-column:span 3;min-width:220px;" class="vsp_card">
            <div style="opacity:.75;font-size:12px;">Overall</div>
            <div id="vsp_dash_overall" style="margin-top:6px;font-size:20px;font-weight:800;">—</div>
            <div style="margin-top:6px;opacity:.75;font-size:12px;">Degraded: <span id="vsp_dash_degraded">—</span></div>
          </div>

          <div style="grid-column:span 3;min-width:220px;" class="vsp_card">
            <div style="opacity:.75;font-size:12px;">Findings (counts)</div>
            <div style="margin-top:8px;display:flex;flex-wrap:wrap;gap:8px;">
              <span class="vsp_pill" id="vsp_dash_c_critical">CRIT: —</span>
              <span class="vsp_pill" id="vsp_dash_c_high">HIGH: —</span>
              <span class="vsp_pill" id="vsp_dash_c_medium">MED: —</span>
              <span class="vsp_pill" id="vsp_dash_c_low">LOW: —</span>
              <span class="vsp_pill" id="vsp_dash_c_info">INFO: —</span>
              <span class="vsp_pill" id="vsp_dash_c_trace">TRACE: —</span>
            </div>
          </div>

          <div style="grid-column:span 6;min-width:320px;" class="vsp_card">
            <div style="opacity:.75;font-size:12px;">Evidence &amp; Audit Readiness</div>
            <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;" id="vsp_dash_audit_pills"></div>
            <div style="margin-top:8px;opacity:.75;font-size:12px;">Status: <span id="vsp_dash_audit_status" class="vsp_pill">—</span></div>
          </div>
        </div>

        <style>
          .vsp_card{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px;box-shadow:0 8px 24px rgba(0,0,0,.35);}
          .vsp_btn{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);padding:8px 10px;border-radius:12px;font-size:12px;opacity:.9}
          .vsp_btn:hover{opacity:1;filter:brightness(1.08)}
          .vsp_pill{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);padding:6px 8px;border-radius:999px;font-size:12px}
        </style>
      `;

      // chèn sau gate story header (an toàn): insert as first child of body
      document.body.insertBefore(wrap, document.body.children[1] || null);
      return true;
    }

    async function render(){
      if (!ensureShell()) return;

      const meta = await fetchJSON("/api/vsp/runs?_ts=" + Date.now());
      const rid = meta?.rid_latest_gate_root || meta?.rid_latest || meta?.rid_last_good || meta?.rid_latest_findings || "";
      if (!rid) return;

      setText("vsp_dash_gate_root", rid);
      setText("vsp_dash_updated_at", new Date().toLocaleString());

      const aZip = $("vsp_dash_export_zip"), aPdf = $("vsp_dash_export_pdf");
      if (aZip) aZip.href = `/api/vsp/run_export_zip?rid=${encodeURIComponent(rid)}`;
      if (aPdf) aPdf.href = `/api/vsp/run_export_pdf?rid=${encodeURIComponent(rid)}`;

      // gate summary
      let sum = null;
      try{
        sum = await fetchJSON(`/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=run_gate_summary.json&_ts=${Date.now()}`);
      }catch(e){
        sum = await fetchJSON(`/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=run_gate.json&_ts=${Date.now()}`);
      }

      const overall = (sum?.overall_status || sum?.overall || sum?.status || "—").toString().toUpperCase();
      setText("vsp_dash_overall", overall);
      setText("vsp_dash_degraded", (sum?.degraded!=null)? sum.degraded : "—");

      const c = sum?.counts_by_severity || sum?.by_severity || sum?.severity_counts || sum?.summary?.counts_by_severity || {};
      setText("vsp_dash_c_critical", `CRIT: ${Number(c.CRITICAL||0)||0}`);
      setText("vsp_dash_c_high",     `HIGH: ${Number(c.HIGH||0)||0}`);
      setText("vsp_dash_c_medium",   `MED: ${Number(c.MEDIUM||0)||0}`);
      setText("vsp_dash_c_low",      `LOW: ${Number(c.LOW||0)||0}`);
      setText("vsp_dash_c_info",     `INFO: ${Number(c.INFO||0)||0}`);
      setText("vsp_dash_c_trace",    `TRACE: ${Number(c.TRACE||0)||0}`);

      // audit pills
      const pills = $("vsp_dash_audit_pills");
      if (pills) pills.innerHTML = "";
      const req = [
        "run_manifest.json","run_evidence_index.json","run_gate.json","run_gate_summary.json",
        "findings_unified.json","reports/findings_unified.csv","reports/findings_unified.sarif",
      ];
      let okAll = true;
      for (const f of req){
        const u = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=${encodeURIComponent(f)}&_ts=${Date.now()}`;
        const r = await probeText(u);
        if (!r.ok) okAll = false;
        if (pills){
          const sp = document.createElement("span");
          sp.className="vsp_pill";
          sp.style.borderColor = r.ok ? "rgba(80,220,140,.28)" : "rgba(255,72,72,.28)";
          sp.style.background  = r.ok ? "rgba(80,220,140,.10)" : "rgba(255,72,72,.10)";
          sp.textContent = `${f}${r.ok?"":" ✗"}`;
          pills.appendChild(sp);
        }
      }
      const st = $("vsp_dash_audit_status");
      if (st) st.textContent = okAll ? "AUDIT READY" : "MISSING EVIDENCE";

      console.log("[VSP][Dash@gate] rendered rid=", rid, "overall=", overall);
    }

    const kick = ()=> render().catch(e=>console.warn("[VSP][Dash@gate] render err", e));
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", ()=> setTimeout(kick, 200));
    else setTimeout(kick, 200);

    // refresh nhẹ
    setInterval(()=> {
      if (document.visibilityState && document.visibilityState !== "visible") return;
      setText("vsp_dash_updated_at", new Date().toLocaleString());
    }, 15000);

  }catch(e){
    console.warn("[VSP][Dash@gate] init failed", e);
  }
})();


/* VSP_P0_FORCE_RUNFILE_ALLOW_GATE_ROOT_V1
   Force tool-truth at data plane:
   - Fetch /api/vsp/runs -> cache rid_latest_gate_root
   - Rewrite any /api/vsp/run_file_allow?rid=...&path=run_gate(_summary).json to use gate_root
*/
(()=> {
  try{
    if (window.__vsp_p0_force_runfile_gate_root_v1) return;
    window.__vsp_p0_force_runfile_gate_root_v1 = true;

    const KEY = "__vsp_gate_root_current_v1";
    async function initGateRoot(){
      try{
        const r = await fetch("/api/vsp/runs?_ts=" + Date.now(), { cache:"no-store" });
        if (!r.ok) return;
        const j = await r.json();
        const rid = (j && (j.rid_latest_gate_root || j.rid_latest || j.rid_last_good || j.rid_latest_findings)) || "";
        if (rid){
          window.__vsp_gate_root_current = rid;
          sessionStorage.setItem(KEY, rid);
          console.log("[VSP][gate_root] current:", rid);
        }
      }catch(e){}
    }

    // kick early
    initGateRoot();

    const _fetch = window.fetch ? window.fetch.bind(window) : null;
    if (!_fetch) return;

    if (window.__vsp_p0_runfile_fetch_wrapped_v1) return;
    window.__vsp_p0_runfile_fetch_wrapped_v1 = true;

    window.fetch = async (input, init) => {
      // get latest cached gate_root
      const gateRoot = (window.__vsp_gate_root_current || sessionStorage.getItem(KEY) || "").trim();

      // normalize URL string
      let url = "";
      try{
        url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
      }catch(e){}

      // rewrite run_file_allow gate files to gate_root
      try{
        if (gateRoot && url && url.indexOf("/api/vsp/run_file_allow") !== -1 &&
            (url.indexOf("path=run_gate_summary.json") !== -1 || url.indexOf("path=run_gate.json") !== -1)) {

          const u = new URL(url, location.origin);
          const rid0 = u.searchParams.get("rid") || "";
          if (rid0 && rid0 !== gateRoot){
            u.searchParams.set("rid", gateRoot);
            const newUrl = u.toString();
            console.log("[VSP][run_file_allow_rewrite] rid:", rid0, "=>", gateRoot);
            input = (typeof input === "string") ? newUrl : new Request(newUrl, input);
          }
        }
      }catch(e){
        console.warn("[VSP][run_file_allow_rewrite] err", e);
      }

      const res = await _fetch(input, init);

      // also keep gate_root updated when /api/vsp/runs is fetched by anyone
      try{
        if (url && url.indexOf("/api/vsp/runs") !== -1 && res && res.ok && typeof res.json === "function"){
          const _json = res.json.bind(res);
          res.json = async () => {
            const j = await _json();
            try{
              const rid = (j && (j.rid_latest_gate_root || j.rid_latest || j.rid_last_good || j.rid_latest_findings)) || "";
              if (rid){
                window.__vsp_gate_root_current = rid;
                sessionStorage.setItem(KEY, rid);
              }
            }catch(e){}
            return j;
          };
        }
      }catch(e){}
      return res;
    };

    console.log("[VSP][runfile_gate_root] installed");
  }catch(e){
    console.warn("[VSP][runfile_gate_root] init failed", e);
  }
})();


/* VSP_P1_VSP5_THEME_ALIGN_V1
   Goal: align /vsp5 SAFE MODE typography/colors with other 5 tabs.
   - inject shared CSS: /static/css/vsp_dark_commercial_p1_2.css (if present)
   - override minimal /vsp5 inline styles to match dark commercial look
*/
(()=> {
  try{
    if (window.__vsp_p1_vsp5_theme_align_v1) return;
    window.__vsp_p1_vsp5_theme_align_v1 = true;

    const isDash = ()=> (location && location.pathname && location.pathname.indexOf("/vsp5") === 0);
    if (!isDash()) return;

    function ensureLinkCss(){
      const id = "vsp5_shared_css_link_v1";
      if (document.getElementById(id)) return;
      const l = document.createElement("link");
      l.id = id;
      l.rel = "stylesheet";
      l.href = "/static/css/vsp_dark_commercial_p1_2.css";
      l.onload = ()=> console.log("[VSP][theme] shared css loaded");
      l.onerror = ()=> console.warn("[VSP][theme] shared css missing:", l.href);
      (document.head || document.documentElement).appendChild(l);
    }

    function ensureStyle(){
      const id = "vsp5_theme_align_style_v1";
      if (document.getElementById(id)) return;
      const st = document.createElement("style");
      st.id = id;
      st.textContent = `
/* ---- /vsp5 theme align (SAFE MODE) ---- */
:root{
  --vsp-bg: #070e1a;
  --vsp-bg2: #0b1220;
  --vsp-fg: rgba(226,232,240,.96);
  --vsp-muted: rgba(226,232,240,.72);
  --vsp-faint: rgba(226,232,240,.55);
  --vsp-border: rgba(255,255,255,.10);
  --vsp-border2: rgba(255,255,255,.14);
  --vsp-card: rgba(255,255,255,.03);
  --vsp-card2: rgba(255,255,255,.045);
  --vsp-shadow: 0 10px 28px rgba(0,0,0,.42);
}

html, body{
  background: var(--vsp-bg) !important;
  color: var(--vsp-fg) !important;
  font-size: 13px !important;
  line-height: 1.45 !important;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial !important;
}

/* nav top (SAFE MODE html) */
.vsp5nav{
  background: rgba(0,0,0,.26) !important;
  border-bottom: 1px solid var(--vsp-border) !important;
  backdrop-filter: blur(10px);
}
.vsp5nav a{
  color: var(--vsp-fg) !important;
  border: 1px solid var(--vsp-border2) !important;
  background: rgba(255,255,255,.02) !important;
  font-size: 12px !important;
  padding: 8px 10px !important;
  border-radius: 12px !important;
  opacity: .92 !important;
}
.vsp5nav a:hover{
  background: rgba(255,255,255,.06) !important;
  opacity: 1 !important;
}

/* shared components used by injected dashboard */
#vsp_dash_p1_wrap{
  max-width: 1320px;
  margin: 0 auto;
}
#vsp_dash_p1_wrap .vsp_card{
  background: var(--vsp-card) !important;
  border: 1px solid var(--vsp-border) !important;
  border-radius: 16px !important;
  box-shadow: var(--vsp-shadow) !important;
}
#vsp_dash_p1_wrap .vsp_btn{
  color: var(--vsp-fg) !important;
  background: rgba(255,255,255,.035) !important;
  border: 1px solid var(--vsp-border2) !important;
  border-radius: 12px !important;
  font-size: 12px !important;
  padding: 8px 10px !important;
  opacity: .92 !important;
}
#vsp_dash_p1_wrap .vsp_btn:hover{
  opacity: 1 !important;
  filter: brightness(1.08);
}
#vsp_dash_p1_wrap .vsp_pill{
  color: var(--vsp-fg) !important;
  background: rgba(255,255,255,.035) !important;
  border: 1px solid var(--vsp-border2) !important;
  border-radius: 999px !important;
  font-size: 12px !important;
  padding: 6px 8px !important;
  opacity: .92 !important;
}

/* title/labels spacing */
#vsp_dash_p1_wrap .vsp_title{
  font-size: 18px !important;
  font-weight: 800 !important;
  letter-spacing: .2px !important;
}
#vsp_dash_p1_wrap .vsp_subtitle{
  font-size: 12px !important;
  color: var(--vsp-muted) !important;
}
#vsp_dash_p1_wrap .vsp_label{
  font-size: 12px !important;
  color: var(--vsp-muted) !important;
}

/* Gate Story bar: align text a bit */
#vsp5_root, #vsp5_root *{
  color: var(--vsp-fg);
}
      `;
      (document.head || document.documentElement).appendChild(st);
      console.log("[VSP][theme] theme align injected");
    }

    // run
    ensureLinkCss();
    ensureStyle();
  }catch(e){
    console.warn("[VSP][theme] init failed", e);
  }
})();


/* VSP_P1_VSP5_DASH_FULL_COMMERCIAL_V1
   Enhance injected /vsp5 dashboard:
   - Add Run Snapshot card + Severity Donut + Top Findings table (from findings_unified.json)
   - Styling align with enterprise dark (5 tabs)
*/



/* VSP_P1_VSP5_FIX_FINDINGS_SCHEMA_COUNTS_V1
   - robust parse findings_unified.json: JSON or JSONL, nested arrays
   - derive severity counts from findings when gate summary has none
   - update donut + KPI pills + Top Findings
*/



/* VSP_P1_HIDE_DUPLICATE_NAV_V1
   /vsp5 has top nav (safe-mode HTML). Hide the injected bottom nav row to look commercial.
*/


/* VSP_P1_FINDINGS_BYPASS_REWRITE_V6 (SINGLE SOURCE OF TRUTH)
   - schema fixed: root.findings (len=2500)
   - counts fixed: meta.counts_by_severity
   - anti-flap: watchdog re-render if UI gets overwritten
*/
(()=> {
  try{
    if (window.__vsp_p1_findings_bypass_v6) return;
    window.__vsp_p1_findings_bypass_v6 = true;
    if (!(location && location.pathname && location.pathname.indexOf("/vsp5")===0)) return;

    const ORDER = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"];
    const W = {CRITICAL:0,HIGH:1,MEDIUM:2,LOW:3,INFO:4,TRACE:5};

    const $ = (id)=> document.getElementById(id);
    const esc = (s)=> (s==null? "" : String(s)).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    const normSev = (v)=>{
      const s = (v||"").toString().toUpperCase();
      if (ORDER.includes(s)) return s;
      if (s==="WARNING") return "MEDIUM";
      if (s==="ERROR") return "HIGH";
      return "INFO";
    };

    function countsFromMeta(metaCounts){
      const c = {CRITICAL:0,HIGH:0,MEDIUM:0,LOW:0,INFO:0,TRACE:0};
      if (!metaCounts || typeof metaCounts !== "object") return c;
      for (const k of ORDER) c[k] = Number(metaCounts[k]||0)||0;
      return c;
    }

    function updateKpi(counts){
      const map = {
        vsp_dash_c_critical: `CRIT:${counts.CRITICAL||0}`,
        vsp_dash_c_high:     `HIGH:${counts.HIGH||0}`,
        vsp_dash_c_medium:   `MED:${counts.MEDIUM||0}`,
        vsp_dash_c_low:      `LOW:${counts.LOW||0}`,
        vsp_dash_c_info:     `INFO:${counts.INFO||0}`,
        vsp_dash_c_trace:    `TRACE:${counts.TRACE||0}`,
      };
      for (const id of Object.keys(map)){
        const el = $(id);
        if (el) el.textContent = map[id];
      }
    }

    function renderDonut(counts){
      const donut = $("vsp_sev_donut");
      const center = $("vsp_sev_total");
      const legend = $("vsp_sev_legend");
      if (!donut || !center || !legend) return;

      const total = ORDER.reduce((a,k)=>a+(counts[k]||0),0) || 0;
      center.textContent = String(total);

      const tint = {
        CRITICAL:"rgba(255,72,72,.55)",
        HIGH:"rgba(255,120,72,.45)",
        MEDIUM:"rgba(255,190,64,.40)",
        LOW:"rgba(140,200,255,.32)",
        INFO:"rgba(190,190,190,.22)",
        TRACE:"rgba(130,130,130,.18)",
      };

      let acc = 0;
      const segs = [];
      legend.innerHTML = "";
      for (const k of ORDER){
        const v = counts[k]||0;
        if (!v) continue;
        const p = total ? (v/total)*100 : 0;
        const a0 = acc, a1 = acc + p; acc = a1;
        segs.push(`${tint[k]} ${a0}% ${a1}%`);
        const lg = document.createElement("div");
        lg.className = "lg";
        lg.innerHTML = `<span class="dot" style="display:inline-block;width:10px;height:10px;border-radius:999px;margin-right:8px;background:${tint[k]};"></span>${k}:${v}`;
        legend.appendChild(lg);
      }
      if (!segs.length){
        segs.push("rgba(255,255,255,.10) 0% 100%");
        legend.innerHTML = `<div class="lg" style="opacity:.7;">No counts</div>`;
      }
      donut.style.background = `conic-gradient(${segs.join(",")})`;
    }

    function renderTop(findings, rid){
      const rows = $("vsp_findings_rows");
      const metaEl = $("vsp_findings_meta");
      if (metaEl) metaEl.textContent = `items=${findings.length} • rid=${rid.slice(0,24)}…`;
      if (!rows) return;

      const sevBadge = (sev)=>{
        const S = normSev(sev);
        return `<span class="sev_badge sev_${S}">${S}</span>`;
      };

      const top = (findings||[]).slice().sort((a,b)=>{
        const sa = W[normSev(a?.severity)] ?? 9;
        const sb = W[normSev(b?.severity)] ?? 9;
        if (sa!==sb) return sa-sb;
        return String(a?.tool||"").localeCompare(String(b?.tool||""));
      }).slice(0, 12);

      if (!top.length){
        rows.innerHTML = `<tr><td colspan="4" style="opacity:.7;">No findings</td></tr>`;
        return;
      }

      rows.innerHTML = top.map(f=>{
        const sev = normSev(f?.severity);
        const tool = (f?.tool||"—").toString();
        const title = (f?.title||f?.message||"—").toString();
        const rule = (f?.rule_id||f?.id||"").toString();
        const loc  = (f?.location||f?.path||f?.file||"—").toString();
        const t = rule ? `${title} • ${rule}` : title;
        return `<tr>
          <td>${sevBadge(sev)}</td>
          <td style="opacity:.9;">${esc(tool)}</td>
          <td style="opacity:.92;">${esc(t).slice(0,220)}</td>
          <td style="opacity:.85;font-family:ui-monospace,monospace;font-size:11.5px;">${esc(loc).slice(0,220)}</td>
        </tr>`;
      }).join("");
    }

    function ensureIframeFetch(){
      return new Promise((resolve)=>{
        let fr = document.getElementById("vsp_native_fetch_iframe_v6");
        if (fr && fr.contentWindow && fr.contentWindow.fetch) return resolve(fr.contentWindow.fetch.bind(fr.contentWindow));
        fr = document.createElement("iframe");
        fr.id = "vsp_native_fetch_iframe_v6";
        fr.style.cssText = "position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none;";
        fr.src = "about:blank";
        fr.onload = ()=> {
          try{
            if (fr.contentWindow && fr.contentWindow.fetch) resolve(fr.contentWindow.fetch.bind(fr.contentWindow));
            else resolve(window.fetch.bind(window));
          }catch(_){
            resolve(window.fetch.bind(window));
          }
        };
        document.body.appendChild(fr);
      });
    }

    let lastGood = null;

    async function runOnce(){
      const nfetch = await ensureIframeFetch();

      const meta = await (await nfetch("/api/vsp/runs?_ts="+Date.now(), {cache:"no-store"})).json();
      const rid = meta?.rid_latest_gate_root || meta?.rid_latest || meta?.rid_last_good || "";
      if (!rid) return;

      const url = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=findings_unified.json&vsp_no_rewrite=1&_ts=${Date.now()}`;
      const root = await (await nfetch(url, {cache:"no-store"})).json();

      // FIXED schema:
      const counts = countsFromMeta(root?.meta?.counts_by_severity);
      const arr = Array.isArray(root?.findings) ? root.findings : [];

      const total = ORDER.reduce((a,k)=>a+(counts[k]||0),0) || 0;
      if (total > 0 && arr.length >= 50) lastGood = {rid, counts, arr};

      const use = (lastGood && (total===0 || arr.length<=1)) ? lastGood : {rid, counts, arr};

      updateKpi(use.counts);
      renderDonut(use.counts);
      renderTop(use.arr, use.rid);

      // also update "Total findings" label if exists
      const tf = $("vsp_total_findings");
      if (tf) tf.textContent = String(use.arr.length);

      console.log("[VSP][BypassV6] ok rid=", use.rid, "findings=", use.arr.length, "counts=", use.counts);
    }

    // initial burst
    let n=0;
    const burst = setInterval(()=> {
      n++;
      runOnce().catch(e=>console.warn("[VSP][BypassV6] err", e));
      if (n>=4) clearInterval(burst);
    }, 900);

    // watchdog: if someone overwrites UI to 0 -> restore from lastGood
    const obs = new MutationObserver(()=> {
      const t = $("vsp_sev_total");
      if (!t) return;
      const v = Number((t.textContent||"").trim()||0);
      if (v <= 1 && lastGood){
        updateKpi(lastGood.counts);
        renderDonut(lastGood.counts);
        renderTop(lastGood.arr, lastGood.rid);
      }
    });
    obs.observe(document.documentElement, {subtree:true, childList:true, characterData:true});

    // refresh every 60s (visible only)
    setInterval(()=> {
      if (document.visibilityState && document.visibilityState !== "visible") return;
      runOnce().catch(()=>{});
    }, 60000);

    console.log("[VSP][BypassV6] installed (single-renderer)");
  }catch(e){
    console.warn("[VSP][BypassV6] init failed", e);
  }
})();

/* ===================== VSP_P1_DASHBOARD_P1_PANELS_V1 =====================
   Adds: Tool Lane (8), Explain why RED, Top Findings, Trend (10 runs best-effort)
   Uses commercial truth:
     - /api/vsp/rid_latest_gate_root
     - /api/vsp/run_file_allow?rid=...&path=run_gate_summary.json
     - /api/vsp/run_file_allow?rid=...&path=findings_unified.json
   Strict-ish: if findings.meta.counts_by_severity missing => show contract mismatch box.
========================================================================= */
(()=> {
  if (window.__vsp_p1_dash_p1_panels_v1) return;
  window.__vsp_p1_dash_p1_panels_v1 = true;

  const TOOL_ORDER = ["Bandit","Semgrep","Gitleaks","KICS","Trivy","Syft","Grype","CodeQL"];
  const SEV_ORDER  = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"];

  function el(tag, attrs={}, kids=[]){
    const n=document.createElement(tag);
    for (const [k,v] of Object.entries(attrs||{})){
      if (k==="class") n.className=v;
      else if (k==="html") n.innerHTML=v;
      else n.setAttribute(k, String(v));
    }
    (kids||[]).forEach(c=> n.appendChild(typeof c==="string"? document.createTextNode(c) : c));
    return n;
  }

  function cssOnce(){
    if (document.getElementById("VSP_P1_DASH_P1_PANELS_CSS_V1")) return;
    const css = `
      .vspP1Wrap{padding:14px 0 0 0;}
      .vspP1Row{display:flex; gap:12px; flex-wrap:wrap;}
      .vspP1Card{background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:12px 14px; flex:1; min-width:260px;}
      .vspP1Card h3{margin:0 0 8px 0; font-size:12px; opacity:.85; font-weight:700;}
      .vspP1Muted{opacity:.78; font-size:12px;}
      .vspP1Mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
      .vspP1Pills{display:flex; gap:8px; flex-wrap:wrap;}
      .vspP1Pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
                 border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.03); cursor:pointer; user-select:none;}
      .vspP1Dot{width:9px;height:9px;border-radius:50%;}
      .vspP1Table{width:100%; border-collapse:collapse; font-size:12px;}
      .vspP1Table th,.vspP1Table td{padding:8px 8px; border-bottom:1px solid rgba(255,255,255,0.08); vertical-align:top;}
      .vspP1Table th{opacity:.8; text-align:left; font-weight:800;}
      .vspP1Bars{display:flex; gap:6px; align-items:flex-end; height:64px; padding:6px 0;}
      .vspP1Bar{flex:1; background:rgba(255,255,255,0.10); border:1px solid rgba(255,255,255,0.10); border-radius:8px;}
      .vspP1Warn{padding:10px 12px; border-radius:12px; border:1px solid rgba(255,200,0,0.25); background:rgba(255,200,0,0.06); font-size:12px;}
      .vspP1Err{padding:10px 12px; border-radius:12px; border:1px solid rgba(255,0,0,0.25); background:rgba(255,0,0,0.06); font-size:12px;}
    `;
    document.head.appendChild(el("style",{id:"VSP_P1_DASH_P1_PANELS_CSS_V1", html:css}));
  }
  function __vspP1_unwrapAny(x){
    // unwrap common wrappers and also auto-detect the {meta, findings[]} shape
    const seen = new Set();
    function isFindingsObj(o){
      return o && typeof o==="object" && !Array.isArray(o) &&
             o.meta && typeof o.meta==="object" &&
             Array.isArray(o.findings);
    }
    let cur = x;
    while (cur && typeof cur==="object" && !Array.isArray(cur) && !seen.has(cur)){
      seen.add(cur);
      if (isFindingsObj(cur)) return cur;

      // common wrapper keys
      const cand =
        cur.data ?? cur.json ?? cur.content ?? cur.payload ?? cur.body ?? cur.result ?? cur.obj ?? cur.file ?? cur.value;

      if (cand && cand !== cur){
        cur = cand;
        continue;
      }
      break;
    }

    // fallback: one-level deep scan for {meta, findings[]}
    if (cur && typeof cur==="object" && !Array.isArray(cur)){
      for (const k of Object.keys(cur)){
        const v = cur[k];
        if (isFindingsObj(v)) return v;
      }
    }
    return cur;
  }

  async function fetchJSON(url){
    const res = await fetch(url, {credentials:"same-origin"});
    const txt = await res.text();
    let j;
    try{
      j = JSON.parse(txt);
      // sometimes inner JSON is a string
      if (typeof j === "string" && (j.trim().startsWith("{") || j.trim().startsWith("["))){
        try{ j = JSON.parse(j); }catch(e){}
      }


  function __vspP1_normFindingsPayload(x){
    // Accept multiple shapes from run_file_allow:
    // - {meta:{counts_by_severity}, findings:[...]}
    // - {meta:{...}, items:[...]}
    // - {meta:{...}, findings:{items:[...]}} (nested)
    // - {counts_by_severity:{...}, findings:[...]} (rare)
    let o = x;
    if (!o || typeof o !== "object") return o;

    // If findings missing but items present
    if (!("findings" in o) && Array.isArray(o.items)) {
      o.findings = o.items;
    }

    // If findings is nested container with items
    if (o.findings && typeof o.findings === "object" && !Array.isArray(o.findings) && Array.isArray(o.findings.items)) {
      o.findings = o.findings.items;
    }

    // Ensure meta exists
    if (!o.meta || typeof o.meta !== "object") o.meta = {};

    // Accept counts_by_severity from top-level if meta missing
    if (!o.meta.counts_by_severity && o.counts_by_severity && typeof o.counts_by_severity === "object") {
      o.meta.counts_by_severity = o.counts_by_severity;
    }

    return o;
  }

    }catch(e){
      throw new Error("Non-JSON " + res.status);
    }
    if (!res.ok) throw new Error("HTTP " + res.status);

    // unwrap wrappers + auto-detect findings shape
    j = __vspP1_unwrapAny(j);
    return j;
  }

  function pickRID(o){
    if (!o || typeof o!=="object") return null;
    return o.rid || o.run_id || o.latest_rid || o.id || null;
  }

  function normStatus(x){
    const v=String(x||"").toUpperCase();
    if (v.includes("PASS")||v==="GREEN") return "GREEN";
    if (v.includes("WARN")||v==="AMBER"||v==="YELLOW") return "AMBER";
    if (v.includes("FAIL")||v==="RED") return "RED";
    if (v.includes("MISSING")) return "MISSING";
    return v||"UNKNOWN";
  }

  function dot(status){
    const s=normStatus(status);
    let bg="rgba(200,200,200,0.8)";
    if (s==="GREEN") bg="rgba(0,220,120,0.85)";
    if (s==="AMBER") bg="rgba(255,200,0,0.85)";
    if (s==="RED") bg="rgba(255,70,70,0.85)";
    if (s==="MISSING") bg="rgba(160,160,160,0.85)";
    return el("span",{class:"vspP1Dot", style:"background:"+bg});
  }

  function toolObj(gate, tool){
    const bt = gate && gate.by_tool && gate.by_tool[tool];
    const tt = gate && gate.tools && gate.tools[tool];
    const o = bt || tt || null;
    if (o && typeof o==="object"){
      return {
        status: o.status || o.overall || o.result || o.state || "UNKNOWN",
        degraded: !!o.degraded,
        reason: o.degraded_reason || o.reason || o.note || ""
      };
    }
    return {status:"UNKNOWN", degraded:false, reason:""};
  }

  function sevRank(s){
    const v=String(s||"").toUpperCase();
    const i=SEV_ORDER.indexOf(v);
    return i>=0 ? i : 999;
  }

  function normFinding(f){
    const sev = String(f.severity||f.sev||f.level||"").toUpperCase();
    const tool = f.tool || f.source || f.engine || f.detector || "";
    const title = f.title || f.message || f.rule_name || f.rule_id || f.id || "(no title)";
    const loc = (() => {
      const path = f.path || (f.location && f.location.path) || (f.file && f.file.path) || "";
      const line = f.line || (f.location && f.location.line) || (f.start && f.start.line) || "";
      return (path ? path : "(no path)") + (line ? (":" + line) : "");
    })();
    return {sev, tool, title, loc};
  }

  async function main(){
    cssOnce();

    // mount under existing dashboard area
    const host = document.getElementById("vsp5_root") || document.querySelector("main") || document.body;
    if (!host) return;

    let mount = document.getElementById("vsp_p1_panels_mount_v1");
    if (!mount){
      mount = el("div",{id:"vsp_p1_panels_mount_v1", class:"vspP1Wrap"});
      host.appendChild(mount);
    }

        let rid = window.__VSP_RID_LATEST_GATE_ROOT__ || window.__vsp_rid_latest_gate_root || null;

    // P1 commercial: RID resolve with robust fallback
    if (!rid){
      try{
        const o = await fetchJSON("/api/vsp/rid_latest_gate_root");
        rid = pickRID(o);
      }catch(e1){
        // fallback: runs endpoint (GateStory already uses it; usually always available)
        try{
          const runs = await fetchJSON("/api/vsp/runs?limit=1&offset=0");
          const arr = Array.isArray(runs) ? runs : (runs.runs || runs.items || []);
          if (Array.isArray(arr) && arr.length){
            rid = pickRID(arr[0]);
          }
        }catch(e2){}
      }
    }

    if (!rid){
      mount.innerHTML="";
      mount.appendChild(el("div",{class:"vspP1Err"},[
        "Cannot resolve RID (rid_latest_gate_root + runs fallback)."
      ]));
      return;
    }

    let gate, findings;
    try{
      gate = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=run_gate_summary.json");
      findings = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=findings_unified.json");
    }catch(e){
      mount.innerHTML="";
      mount.appendChild(el("div",{class:"vspP1Err"},["Load failed: ", String(e.message||e)]));
      return;
    }

    
    findings = __vspP1_normFindingsPayload(findings);

    const meta = (findings && findings.meta) || {};
    const cbs = meta.counts_by_severity;

    // Debug (1 line) to avoid blind mismatch
    try{
      console.log("[VSP][DashP1PanelsV1][DBG] findings_keys=", Object.keys(findings||{}),
                  "meta_keys=", Object.keys(meta||{}),
                  "has_cbs=", !!cbs,
                  "findings_is_array=", Array.isArray(findings && findings.findings),
                  "type_findings=", typeof (findings && findings.findings));
    }catch(e){}

    if (!cbs || typeof cbs!=="object" || !Array.isArray(findings.findings)){
      mount.innerHTML="";
      mount.appendChild(el("div",{class:"vspP1Err"},[
        "Data contract mismatch (normalized): need meta.counts_by_severity + findings[]"
      ]));
      return;
    }


    // TOOL LANE
    const lane = el("div",{class:"vspP1Card"},[
      el("h3",{},["Tool Lane (8 tools)"]),
      el("div",{class:"vspP1Pills"}, TOOL_ORDER.map(t=>{
        const st = toolObj(gate, t);
        const ns = normStatus(st.status);
        const pill = el("div",{class:"vspP1Pill", title:(st.reason||"")},[
          dot(ns),
          el("span",{class:"vspP1Mono", style:"font-weight:900;"},[t]),
          el("span",{class:"vspP1Muted"},[ns + (st.degraded?" (degraded)":"")]),
        ]);
        pill.addEventListener("click", ()=> { location.href="/runs?rid="+encodeURIComponent(rid); });
        return pill;
      }))
    ]);

    // EXPLAIN WHY RED
    const reasons = [];
    const src = gate.reasons || gate.top_reasons || gate.fail_reasons;
    if (Array.isArray(src)){
      for (const x of src){
        const r = (typeof x==="string") ? x : (x.reason||x.title||"");
        if (r) reasons.push(r);
      }
    }
    if (!reasons.length){
      for (const t of TOOL_ORDER){
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        if (ns==="RED" || st.degraded || ns==="MISSING"){
          reasons.push(`${t}: ${ns}` + (st.reason?` — ${st.reason}`:""));
        }
      }
    }
    const explain = el("div",{class:"vspP1Card"},[
      el("h3",{},["Explain why RED / Degraded"]),
      reasons.length
        ? el("ul",{style:"margin:0; padding-left:18px;"}, reasons.slice(0,8).map(r=>el("li",{class:"vspP1Muted", style:"margin:6px 0;"},[r])))
        : el("div",{class:"vspP1Muted"},["No reasons found in gate summary."])
    ]);

    // TOP FINDINGS
    const topRows = findings.findings.map(normFinding).sort((a,b)=>sevRank(a.sev)-sevRank(b.sev)).slice(0,12);
    const tbl = el("div",{class:"vspP1Card", style:"flex-basis:100%;"},[
      el("h3",{},["Top Findings (fix-first)"]),
      el("table",{class:"vspP1Table"},[
        el("thead",{},[el("tr",{},[
          el("th",{},["Severity"]), el("th",{},["Tool"]), el("th",{},["Title"]), el("th",{},["Location"])
        ])]),
        el("tbody",{}, topRows.map(r=>el("tr",{},[
          el("td",{class:"vspP1Mono"},[r.sev||"UNKNOWN"]),
          el("td",{class:"vspP1Mono"},[String(r.tool||"")]),
          el("td",{},[String(r.title||"")]),
          el("td",{class:"vspP1Mono vspP1Muted"},[String(r.loc||"")]),
        ])))
      ])
    ]);

    // TREND (best-effort)
    const trend = el("div",{class:"vspP1Card"},[
      el("h3",{},["Trend (last 10 runs)"]),
      el("div",{class:"vspP1Muted", id:"vspP1TrendNote"},["Loading runs…"]),
      el("div",{class:"vspP1Bars", id:"vspP1Bars"},[])
    ]);

    // AUDIT HINT
    const audit = el("div",{class:"vspP1Card"},[
      el("h3",{},["Audit / ISO readiness (quick)"]),
      el("div",{class:"vspP1Warn"},[
        "ISO mapping is P1+ (needs rule_id→control table). For now: show evidence presence + honest hints."
      ]),
      el("div",{class:"vspP1Muted", style:"margin-top:8px;"},[
        "Hint: A.5 Access control • A.8 Asset mgmt • A.8.9 Config mgmt (placeholder until mapping is real)."
      ])
    ]);

    mount.innerHTML = "";
    mount.appendChild(el("div",{class:"vspP1Row"},[lane, explain, trend]));
    mount.appendChild(el("div",{class:"vspP1Row", style:"margin-top:12px;"},[tbl]));
    mount.appendChild(el("div",{class:"vspP1Row", style:"margin-top:12px;"},[audit]));

    // fill trend
    (async ()=>{
      const note = mount.querySelector("#vspP1TrendNote");
      const bars = mount.querySelector("#vspP1Bars");
      try{
        const runs = await fetchJSON("/api/vsp/runs?limit=10");
        const arr = Array.isArray(runs) ? runs : (runs.runs || runs.items || []);
        if (!Array.isArray(arr) || !arr.length){
          note.textContent = "No runs data from backend.";
          return;
        }
        const pts = arr.slice(0,10).reverse().map(x=>{
          const c = x.counts_by_severity || (x.meta && x.meta.counts_by_severity) || null;
          const ch = c ? (Number(c.CRITICAL||0) + Number(c.HIGH||0)) : 0;
          return {ch};
        });
        const max = Math.max(1, ...pts.map(p=>p.ch));
        bars.innerHTML="";
        for (const p of pts){
          const h = Math.max(6, Math.round((p.ch/max)*64));
          bars.appendChild(el("div",{class:"vspP1Bar", style:"height:"+h+"px", title:"C+H="+p.ch}));
        }
        note.textContent = "Bar = (CRITICAL+HIGH) (best-effort).";
      }catch(e){
        note.textContent = "Trend unavailable: "+String(e.message||e);
      }
    })();

    console.log("[VSP][DashP1PanelsV1] ok rid="+rid+" top_findings="+topRows.length);
  }

  if (document.readyState==="loading") document.addEventListener("DOMContentLoaded", main);
  else main();
})();
 /* ===================== /VSP_P1_DASHBOARD_P1_PANELS_V1 ===================== */

/* ===================== VSP_P1_DASHBOARD_P1_PANELS_OVERRIDE_V2 =====================
   Purpose: Always render P1 panels on /vsp5 regardless of older addon state.
   Panels: Tool Lane (8), Explain, Top Findings (12), Trend (best-effort)
=================================================================================== */
(()=> {
  if (window.__vsp_p1_dash_p1_override_v2) return;
  window.__vsp_p1_dash_p1_override_v2 = true;

  const TOOL_ORDER = ["Bandit","Semgrep","Gitleaks","KICS","Trivy","Syft","Grype","CodeQL"];
  const SEV_ORDER  = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"];

  function el(tag, attrs={}, kids=[]){
    const n=document.createElement(tag);
    for (const [k,v] of Object.entries(attrs||{})){
      if (k==="class") n.className=v;
      else if (k==="html") n.innerHTML=v;
      else n.setAttribute(k, String(v));
    }
    (kids||[]).forEach(c=> n.appendChild(typeof c==="string"? document.createTextNode(c) : c));
    return n;
  }

  function cssOnce(){
    if (document.getElementById("VSP_P1_DASH_P1_OVR_CSS_V2")) return;
    const css = `
      .vspP1v2Wrap{padding:14px 18px 40px 18px;}
      .vspP1v2Row{display:flex; gap:12px; flex-wrap:wrap;}
      .vspP1v2Card{background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:12px 14px; flex:1; min-width:260px;}
      .vspP1v2Card h3{margin:0 0 8px 0; font-size:12px; opacity:.85; font-weight:800;}
      .vspP1v2Muted{opacity:.78; font-size:12px;}
      .vspP1v2Mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
      .vspP1v2Pills{display:flex; gap:8px; flex-wrap:wrap;}
      .vspP1v2Pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
                   border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.03); cursor:pointer; user-select:none;}
      .vspP1v2Dot{width:9px;height:9px;border-radius:50%;}
      .vspP1v2Table{width:100%; border-collapse:collapse; font-size:12px;}
      .vspP1v2Table th,.vspP1v2Table td{padding:8px 8px; border-bottom:1px solid rgba(255,255,255,0.08); vertical-align:top;}
      .vspP1v2Table th{opacity:.8; text-align:left; font-weight:900;}
      .vspP1v2Bars{display:flex; gap:6px; align-items:flex-end; height:64px; padding:6px 0;}
      .vspP1v2Bar{flex:1; background:rgba(255,255,255,0.10); border:1px solid rgba(255,255,255,0.10); border-radius:8px;}
      .vspP1v2Err{padding:10px 12px; border-radius:12px; border:1px solid rgba(255,0,0,0.25); background:rgba(255,0,0,0.06); font-size:12px;}
      .vspP1v2OkTag{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
                   border:1px solid rgba(0,220,120,0.25); background:rgba(0,220,120,0.06); font-size:12px;}
    `;
    document.head.appendChild(el("style",{id:"VSP_P1_DASH_P1_OVR_CSS_V2", html:css}));
  }

  function normStatus(x){
    const v=String(x||"").toUpperCase();
    if (v.includes("PASS")||v==="GREEN") return "GREEN";
    if (v.includes("WARN")||v==="AMBER"||v==="YELLOW") return "AMBER";
    if (v.includes("FAIL")||v==="RED") return "RED";
    if (v.includes("MISSING")) return "MISSING";
    return v||"UNKNOWN";
  }
  function dot(status){
    const s=normStatus(status);
    let bg="rgba(200,200,200,0.8)";
    if (s==="GREEN") bg="rgba(0,220,120,0.85)";
    if (s==="AMBER") bg="rgba(255,200,0,0.85)";
    if (s==="RED") bg="rgba(255,70,70,0.85)";
    if (s==="MISSING") bg="rgba(160,160,160,0.85)";
    return el("span",{class:"vspP1v2Dot", style:"background:"+bg});
  }

  async function fetchJSON(url){
    const res = await fetch(url, {credentials:"same-origin"});
    const txt = await res.text();
    let j; try{ j=JSON.parse(txt);}catch(e){ throw new Error("Non-JSON "+res.status); }
    if (!res.ok) throw new Error("HTTP "+res.status);

    // unwrap common wrappers
    const seen = new Set();
    function unwrapAny(x){
      let cur = x;
      while (cur && typeof cur==="object" && !Array.isArray(cur) && !seen.has(cur)){
        seen.add(cur);
        const cand = cur.data ?? cur.json ?? cur.content ?? cur.payload ?? cur.body ?? cur.result ?? cur.obj ?? cur.value;
        if (cand && cand !== cur) { cur = cand; continue; }
        break;
      }
      return cur;
    }
    j = unwrapAny(j);

    // normalize findings shapes
    if (j && typeof j==="object" && !Array.isArray(j)){
      if (!j.meta || typeof j.meta!=="object") j.meta = {};
      if (!("findings" in j) && Array.isArray(j.items)) j.findings = j.items;
      if (j.findings && typeof j.findings==="object" && !Array.isArray(j.findings) && Array.isArray(j.findings.items)) j.findings = j.findings.items;
      if (!j.meta.counts_by_severity && j.counts_by_severity && typeof j.counts_by_severity==="object") j.meta.counts_by_severity = j.counts_by_severity;
    }
    return j;
  }

  function pickRID(o){
    if (!o || typeof o!=="object") return null;
    return o.rid || o.run_id || o.latest_rid || o.id || null;
  }

  function toolObj(gate, tool){
    const bt = gate && gate.by_tool && gate.by_tool[tool];
    const tt = gate && gate.tools && gate.tools[tool];
    const o = bt || tt || null;
    if (o && typeof o==="object"){
      return {
        status: o.status || o.overall || o.result || o.state || "UNKNOWN",
        degraded: !!o.degraded,
        reason: o.degraded_reason || o.reason || o.note || ""
      };
    }
    return {status:"UNKNOWN", degraded:false, reason:""};
  }

  function sevRank(s){
    const v=String(s||"").toUpperCase();
    const i=SEV_ORDER.indexOf(v);
    return i>=0 ? i : 999;
  }

  function normFinding(f){
    const sev = String(f.severity||f.sev||f.level||"").toUpperCase();
    const tool = f.tool || f.source || f.engine || f.detector || "";
    const title = f.title || f.message || f.rule_name || f.rule_id || f.id || "(no title)";
    const loc = (() => {
      const path = f.path || (f.location && f.location.path) || (f.file && f.file.path) || "";
      const line = f.line || (f.location && f.location.line) || (f.start && f.start.line) || "";
      return (path ? path : "(no path)") + (line ? (":" + line) : "");
    })();
    return {sev, tool, title, loc};
  }

  function findHost(){
    // try common containers first; fallback to body
    return document.getElementById("vsp_dashboard_mount_v1")
        || document.getElementById("vsp5_root")
        || document.querySelector("main")
        || document.querySelector(".container")
        || document.body;
  }

  async function render(){
    if (location && location.pathname && location.pathname !== "/vsp5") return;

    cssOnce();
    const host = findHost();
    if (!host) return;

    let mount = document.getElementById("vsp_p1_panels_mount_v2");
    if (!mount){
      mount = el("div",{id:"vsp_p1_panels_mount_v2", class:"vspP1v2Wrap"});
      host.appendChild(mount);
    }

    // RID resolve: rid_latest -> runs fallback (do NOT use the buggy spaced endpoint)
    let rid = null;
    try{
      const o = await fetchJSON("/api/vsp/rid_latest_gate_root");
      rid = pickRID(o);
    }catch(e1){
      try{
        const runs = await fetchJSON("/api/vsp/runs?limit=1&offset=0");
        const arr = Array.isArray(runs) ? runs : (runs.runs || runs.items || []);
        if (Array.isArray(arr) && arr.length) rid = pickRID(arr[0]);
      }catch(e2){}
    }

    if (!rid){
      mount.innerHTML = "";
      mount.appendChild(el("div",{class:"vspP1v2Err"},["Cannot resolve RID for dashboard."]));
      return;
    }

    let gate, findings;
    try{
      gate = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=run_gate_summary.json");
      findings = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=findings_unified.json");
    }catch(e){
      mount.innerHTML = "";
      mount.appendChild(el("div",{class:"vspP1v2Err"},["Load failed: "+String(e.message||e)]));
      return;
    }

    const meta = (findings && findings.meta) || {};
    const cbs = meta.counts_by_severity;
    const arrFind = findings && findings.findings;

    if (!cbs || typeof cbs!=="object" || !Array.isArray(arrFind)){
      mount.innerHTML = "";
      mount.appendChild(el("div",{class:"vspP1v2Err"},[
        "Contract mismatch after normalize. keys=" + Object.keys(findings||{}).join(",")
      ]));
      return;
    }

    // Tool lane
    const lane = el("div",{class:"vspP1v2Card"},[
      el("h3",{},["Tool Lane (8 tools)"]),
      el("div",{class:"vspP1v2Pills"}, TOOL_ORDER.map(t=>{
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        const pill = el("div",{class:"vspP1v2Pill", title:(st.reason||"")},[
          dot(ns),
          el("span",{class:"vspP1v2Mono", style:"font-weight:900;"},[t]),
          el("span",{class:"vspP1v2Muted"},[ns + (st.degraded?" (degraded)":"")]),
        ]);
        pill.addEventListener("click", ()=> { location.href="/runs?rid="+encodeURIComponent(rid); });
        return pill;
      }))
    ]);

    // Explain
    const reasons = [];
    const src = gate && (gate.reasons || gate.top_reasons || gate.fail_reasons);
    if (Array.isArray(src)){
      for (const x of src){
        const r = (typeof x==="string") ? x : (x.reason||x.title||"");
        if (r) reasons.push(r);
      }
    }
    if (!reasons.length){
      for (const t of TOOL_ORDER){
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        if (ns==="RED" || st.degraded || ns==="MISSING"){
          reasons.push(`${t}: ${ns}` + (st.reason?` — ${st.reason}`:""));
        }
      }
    }
    const explain = el("div",{class:"vspP1v2Card"},[
      el("h3",{},["Explain why RED / Degraded"]),
      reasons.length
        ? el("ul",{style:"margin:0; padding-left:18px;"}, reasons.slice(0,8).map(r=>el("li",{class:"vspP1v2Muted", style:"margin:6px 0;"},[r])))
        : el("div",{class:"vspP1v2Muted"},["No reasons found in gate summary."])
    ]);

    // Trend
    const trend = el("div",{class:"vspP1v2Card"},[
      el("h3",{},["Trend (last 10 runs)"]),
      el("div",{class:"vspP1v2Muted", id:"vspP1v2TrendNote"},["Loading runs…"]),
      el("div",{class:"vspP1v2Bars", id:"vspP1v2Bars"},[])
    ]);

    // Top findings
    const topRows = arrFind.map(normFinding).sort((a,b)=>sevRank(a.sev)-sevRank(b.sev)).slice(0,12);
    const tbl = el("div",{class:"vspP1v2Card", style:"flex-basis:100%;"},[
      el("h3",{},["Top Findings (fix-first)"]),
      el("div",{class:"vspP1v2OkTag vspP1v2Mono"},[
        "rid=", rid, " • findings=", String(arrFind.length), " • C/H=", String((cbs.CRITICAL||0)+"/"+(cbs.HIGH||0))
      ]),
      el("table",{class:"vspP1v2Table", style:"margin-top:10px;"},[
        el("thead",{},[el("tr",{},[
          el("th",{},["Severity"]), el("th",{},["Tool"]), el("th",{},["Title"]), el("th",{},["Location"])
        ])]),
        el("tbody",{}, topRows.map(r=>el("tr",{},[
          el("td",{class:"vspP1v2Mono"},[r.sev||"UNKNOWN"]),
          el("td",{class:"vspP1v2Mono"},[String(r.tool||"")]),
          el("td",{},[String(r.title||"")]),
          el("td",{class:"vspP1v2Mono vspP1v2Muted"},[String(r.loc||"")]),
        ])))
      ])
    ]);

    mount.innerHTML = "";
    mount.appendChild(el("div",{class:"vspP1v2Row"},[lane, explain, trend]));
    mount.appendChild(el("div",{class:"vspP1v2Row", style:"margin-top:12px;"},[tbl]));

    // fill trend best-effort
    (async ()=>{
      const note = mount.querySelector("#vspP1v2TrendNote");
      const bars = mount.querySelector("#vspP1v2Bars");
      try{
        const runs = await fetchJSON("/api/vsp/runs?limit=10");
        const arr = Array.isArray(runs) ? runs : (runs.runs || runs.items || []);
        if (!Array.isArray(arr) || !arr.length){
          note.textContent = "No runs data from backend.";
          return;
        }
        const pts = arr.slice(0,10).reverse().map(x=>{
          const c = x.counts_by_severity || (x.meta && x.meta.counts_by_severity) || null;
          const ch = c ? (Number(c.CRITICAL||0) + Number(c.HIGH||0)) : 0;
          return {ch};
        });
        const max = Math.max(1, ...pts.map(p=>p.ch));
        bars.innerHTML="";
        for (const p of pts){
          const h = Math.max(6, Math.round((p.ch/max)*64));
          bars.appendChild(el("div",{class:"vspP1v2Bar", style:"height:"+h+"px", title:"C+H="+p.ch}));
        }
        note.textContent = "Bar = (CRITICAL+HIGH) (best-effort).";
      }catch(e){
        note.textContent = "Trend unavailable: "+String(e.message||e);
      }
    })();

    console.log("[VSP][DashP1PanelsOverrideV2] ok rid="+rid+" top_findings="+topRows.length);
  }

  if (document.readyState==="loading") document.addEventListener("DOMContentLoaded", render);
  else render();
})();
 /* ===================== /VSP_P1_DASHBOARD_P1_PANELS_OVERRIDE_V2 ===================== */

/* ===================== VSP_P1_DASHBOARD_P1_PANELS_V3_HARD_FIX =====================
   Goal: stop "patch chồng patch" symptoms by cleaning old mounts + rendering with RID resolved from page.
=================================================================================== */
(()=> {
  if (window.__vsp_dash_p1_v3_hard_fix) return;
  window.__vsp_dash_p1_v3_hard_fix = true;

  // best-effort: prevent earlier add-ons from doing more work on re-load
  window.__vsp_p1_dash_p1_panels_v1 = true;
  window.__vsp_p1_dash_p1_override_v2 = true;

  const TOOL_ORDER = ["Bandit","Semgrep","Gitleaks","KICS","Trivy","Syft","Grype","CodeQL"];
  const SEV_ORDER  = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"];

  function el(tag, attrs={}, kids=[]){
    const n=document.createElement(tag);
    for (const [k,v] of Object.entries(attrs||{})){
      if (k==="class") n.className=v;
      else if (k==="html") n.innerHTML=v;
      else n.setAttribute(k, String(v));
    }
    (kids||[]).forEach(c=> n.appendChild(typeof c==="string"? document.createTextNode(c) : c));
    return n;
  }

  function cssOnce(){
    if (document.getElementById("VSP_DASH_P1_V3_CSS")) return;
    const css = `
      .vspP1v3Wrap{padding:14px 18px 46px 18px;}
      .vspP1v3Row{display:flex; gap:12px; flex-wrap:wrap;}
      .vspP1v3Card{background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:12px 14px; flex:1; min-width:260px;}
      .vspP1v3Card h3{margin:0 0 8px 0; font-size:12px; opacity:.85; font-weight:900;}
      .vspP1v3Muted{opacity:.78; font-size:12px;}
      .vspP1v3Mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
      .vspP1v3Pills{display:flex; gap:8px; flex-wrap:wrap;}
      .vspP1v3Pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
                   border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.03); cursor:pointer; user-select:none;}
      .vspP1v3Dot{width:9px;height:9px;border-radius:50%;}
      .vspP1v3Table{width:100%; border-collapse:collapse; font-size:12px;}
      .vspP1v3Table th,.vspP1v3Table td{padding:8px 8px; border-bottom:1px solid rgba(255,255,255,0.08); vertical-align:top;}
      .vspP1v3Table th{opacity:.8; text-align:left; font-weight:900;}
      .vspP1v3Err{padding:10px 12px; border-radius:12px; border:1px solid rgba(255,0,0,0.25); background:rgba(255,0,0,0.06); font-size:12px;}
      .vspP1v3Ok{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
                border:1px solid rgba(0,220,120,0.25); background:rgba(0,220,120,0.06); font-size:12px;}
    `;
    document.head.appendChild(el("style",{id:"VSP_DASH_P1_V3_CSS", html:css}));
  }

  function normStatus(x){
    const v=String(x||"").toUpperCase();
    if (v.includes("PASS")||v==="GREEN") return "GREEN";
    if (v.includes("WARN")||v==="AMBER"||v==="YELLOW") return "AMBER";
    if (v.includes("FAIL")||v==="RED") return "RED";
    if (v.includes("MISSING")) return "MISSING";
    return v||"UNKNOWN";
  }
  function dot(status){
    const s=normStatus(status);
    let bg="rgba(200,200,200,0.8)";
    if (s==="GREEN") bg="rgba(0,220,120,0.85)";
    if (s==="AMBER") bg="rgba(255,200,0,0.85)";
    if (s==="RED") bg="rgba(255,70,70,0.85)";
    if (s==="MISSING") bg="rgba(160,160,160,0.85)";
    return el("span",{class:"vspP1v3Dot", style:"background:"+bg});
  }

  function pickRID(o){
    if (!o || typeof o!=="object") return null;
    return o.rid || o.run_id || o.latest_rid || o.id || null;
  }

  function unwrapAny(j){
    const seen=new Set();
    let cur=j;
    while(cur && typeof cur==="object" && !Array.isArray(cur) && !seen.has(cur)){
      seen.add(cur);
      const cand = cur.data ?? cur.json ?? cur.content ?? cur.payload ?? cur.body ?? cur.result ?? cur.obj ?? cur.value;
      if (cand && cand !== cur) { cur=cand; continue; }
      break;
    }
    return cur;
  }

  function normFindings(j){
    const o = j && typeof j==="object" ? j : {};
    if (!o.meta || typeof o.meta!=="object") o.meta = {};
    if (!("findings" in o) && Array.isArray(o.items)) o.findings = o.items;
    if (o.findings && typeof o.findings==="object" && !Array.isArray(o.findings) && Array.isArray(o.findings.items)) o.findings = o.findings.items;
    if (!o.meta.counts_by_severity && o.counts_by_severity && typeof o.counts_by_severity==="object") o.meta.counts_by_severity = o.counts_by_severity;
    return o;
  }

  async function fetchJSON(url){
    const res = await fetch(url, {credentials:"same-origin"});
    const txt = await res.text();
    let j; try{ j=JSON.parse(txt);}catch(e){ throw new Error("Non-JSON "+res.status); }
    if (!res.ok) throw new Error("HTTP "+res.status);
    return unwrapAny(j);
  }

  function scrapeRIDFromPage(){
    // UI đang hiển thị: Tool truth (gate_root): VSP_CI_RUN_YYYYmmdd_HHMMSS ...
    const t = (document.body && (document.body.innerText||"")) || "";
    const m = t.match(/\bVSP_[A-Z0-9_]*RUN_\d{8}_\d{6}\b/);
    if (m && m[0]) return m[0];
    const m2 = t.match(/\bRUN_\d{8}_\d{6}\b/);
    if (m2 && m2[0]) return m2[0];
    return null;
  }

  function toolObj(gate, tool){
    const bt = gate && gate.by_tool && gate.by_tool[tool];
    const tt = gate && gate.tools && gate.tools[tool];
    const o = bt || tt || null;
    if (o && typeof o==="object"){
      return {
        status: o.status || o.overall || o.result || o.state || "UNKNOWN",
        degraded: !!o.degraded,
        reason: o.degraded_reason || o.reason || o.note || ""
      };
    }
    return {status:"UNKNOWN", degraded:false, reason:""};
  }

  function sevRank(s){
    const v=String(s||"").toUpperCase();
    const i=SEV_ORDER.indexOf(v);
    return i>=0 ? i : 999;
  }

  function normFinding(f){
    const sev = String(f.severity||f.sev||f.level||"").toUpperCase();
    const tool = f.tool || f.source || f.engine || f.detector || "";
    const title = f.title || f.message || f.rule_name || f.rule_id || f.id || "(no title)";
    const loc = (() => {
      const path = f.path || (f.location && f.location.path) || (f.file && f.file.path) || "";
      const line = f.line || (f.location && f.location.line) || (f.start && f.start.line) || "";
      return (path ? path : "(no path)") + (line ? (":" + line) : "");
    })();
    return {sev, tool, title, loc};
  }

  function cleanupOld(){
    // remove old mounts/banners if any
    const ids = ["vsp_p1_panels_mount_v1","vsp_p1_panels_mount_v2","vsp_p1_panels_mount_v3"];
    ids.forEach(id=>{ const n=document.getElementById(id); if(n) n.remove(); });
    const errNodes = Array.from(document.querySelectorAll(".vspP1Err,.vspP1v2Err,.vspP1v3Err"));
    errNodes.forEach(n=>{ try{ n.remove(); }catch(e){} });
  }

  function findHost(){
    return document.getElementById("vsp5_root")
        || document.querySelector("main")
        || document.body;
  }

  async function render(){
    if (location.pathname !== "/vsp5") return;
    cssOnce();
    cleanupOld();

    const host = findHost();
    const mount = el("div",{id:"vsp_p1_panels_mount_v3", class:"vspP1v3Wrap"});
    host.appendChild(mount);

    // RID resolve (3 tầng)
    let rid = window.__VSP_RID_LATEST_GATE_ROOT__ || window.__vsp_rid_latest_gate_root || null;
    if (!rid) rid = scrapeRIDFromPage();

    if (!rid){
      try{
        const runs = await fetchJSON("/api/vsp/runs?limit=1&offset=0");
        const arr = Array.isArray(runs) ? runs : (runs.runs || runs.items || []);
        if (Array.isArray(arr) && arr.length) rid = pickRID(arr[0]);
      }catch(e){}
    }

    if (!rid){
      mount.appendChild(el("div",{class:"vspP1v3Err"},["Cannot resolve RID (scrape page + runs fallback)."]));
      return;
    }

    let gate, findings;
    try{
      gate = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=run_gate_summary.json");
      findings = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=findings_unified.json");
      findings = normFindings(findings);
    }catch(e){
      mount.appendChild(el("div",{class:"vspP1v3Err"},["Load failed: "+String(e.message||e)]));
      return;
    }

    const cbs = findings && findings.meta && findings.meta.counts_by_severity;
    const arrFind = findings && findings.findings;

    // If we accidentally got gate_summary shape instead of findings_unified, detect and show clear hint
    const keys = Object.keys(findings||{}).join(",");
    if (!cbs || typeof cbs!=="object" || !Array.isArray(arrFind)){
      mount.appendChild(el("div",{class:"vspP1v3Err"},[
        "Findings payload mismatch. keys="+keys+" (expected meta.counts_by_severity + findings[])"
      ]));
      console.log("[VSP][DashP1V3] mismatch keys=", Object.keys(findings||{}));
      return;
    }

    // Tool lane
    const lane = el("div",{class:"vspP1v3Card"},[
      el("h3",{},["Tool Lane (8 tools)"]),
      el("div",{class:"vspP1v3Pills"}, TOOL_ORDER.map(t=>{
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        const pill = el("div",{class:"vspP1v3Pill", title:(st.reason||"")},[
          dot(ns),
          el("span",{class:"vspP1v3Mono", style:"font-weight:900;"},[t]),
          el("span",{class:"vspP1v3Muted"},[ns + (st.degraded?" (degraded)":"")]),
        ]);
        pill.addEventListener("click", ()=> { location.href="/runs?rid="+encodeURIComponent(rid); });
        return pill;
      }))
    ]);

    // Explain
    const reasons = [];
    const src = gate && (gate.reasons || gate.top_reasons || gate.fail_reasons);
    if (Array.isArray(src)){
      for (const x of src){
        const r = (typeof x==="string") ? x : (x.reason||x.title||"");
        if (r) reasons.push(r);
      }
    }
    if (!reasons.length){
      for (const t of TOOL_ORDER){
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        if (ns==="RED" || st.degraded || ns==="MISSING"){
          reasons.push(`${t}: ${ns}` + (st.reason?` — ${st.reason}`:""));
        }
      }
    }
    const explain = el("div",{class:"vspP1v3Card"},[
      el("h3",{},["Explain why RED / Degraded"]),
      reasons.length
        ? el("ul",{style:"margin:0; padding-left:18px;"}, reasons.slice(0,8).map(r=>el("li",{class:"vspP1v3Muted", style:"margin:6px 0;"},[r])))
        : el("div",{class:"vspP1v3Muted"},["No reasons found in gate summary."])
    ]);

    // Top findings
    const topRows = arrFind.map(normFinding).sort((a,b)=>sevRank(a.sev)-sevRank(b.sev)).slice(0,12);
    const tbl = el("div",{class:"vspP1v3Card", style:"flex-basis:100%;"},[
      el("h3",{},["Top Findings (fix-first)"]),
      el("div",{class:"vspP1v3Ok vspP1v3Mono"},[
        "rid=", rid, " • findings=", String(arrFind.length), " • CRIT=", String(cbs.CRITICAL||0), " • HIGH=", String(cbs.HIGH||0)
      ]),
      el("table",{class:"vspP1v3Table", style:"margin-top:10px;"},[
        el("thead",{},[el("tr",{},[
          el("th",{},["Severity"]), el("th",{},["Tool"]), el("th",{},["Title"]), el("th",{},["Location"])
        ])]),
        el("tbody",{}, topRows.map(r=>el("tr",{},[
          el("td",{class:"vspP1v3Mono"},[r.sev||"UNKNOWN"]),
          el("td",{class:"vspP1v3Mono"},[String(r.tool||"")]),
          el("td",{},[String(r.title||"")]),
          el("td",{class:"vspP1v3Mono vspP1v3Muted"},[String(r.loc||"")]),
        ])))
      ])
    ]);

    mount.appendChild(el("div",{class:"vspP1v3Row"},[lane, explain]));
    mount.appendChild(el("div",{class:"vspP1v3Row", style:"margin-top:12px;"},[tbl]));

    console.log("[VSP][DashP1V3] ok rid="+rid+" top_findings="+topRows.length);
  }

  if (document.readyState==="loading") document.addEventListener("DOMContentLoaded", render);
  else render();
})();
 /* ===================== /VSP_P1_DASHBOARD_P1_PANELS_V3_HARD_FIX ===================== */

/* ===================== VSP_P1_DASHBOARD_P1_PANELS_V4_MULTIFINDINGS_HARD_FIX =====================
   Fix: backend may return gate_summary when asking findings_unified; V4 probes multiple paths and accepts only true findings contract.
=============================================================================================== */
(()=> {
  if (window.__vsp_dash_p1_v4) return;
  window.__vsp_dash_p1_v4 = true;

  // disable older addons (best-effort)
  window.__vsp_p1_dash_p1_panels_v1 = true;
  window.__vsp_p1_dash_p1_override_v2 = true;
  window.__vsp_dash_p1_v3_hard_fix = true;

  const TOOL_ORDER = ["Bandit","Semgrep","Gitleaks","KICS","Trivy","Syft","Grype","CodeQL"];
  const SEV_ORDER  = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"];

  function el(tag, attrs={}, kids=[]){
    const n=document.createElement(tag);
    for (const [k,v] of Object.entries(attrs||{})){
      if (k==="class") n.className=v;
      else if (k==="html") n.innerHTML=v;
      else n.setAttribute(k, String(v));
    }
    (kids||[]).forEach(c=> n.appendChild(typeof c==="string"? document.createTextNode(c) : c));
    return n;
  }

  function cssOnce(){
    if (document.getElementById("VSP_DASH_P1_V4_CSS")) return;
    const css = `
      .vspP1v4Wrap{padding:14px 18px 56px 18px;}
      .vspP1v4Row{display:flex; gap:12px; flex-wrap:wrap;}
      .vspP1v4Card{background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:12px 14px; flex:1; min-width:260px;}
      .vspP1v4Card h3{margin:0 0 8px 0; font-size:12px; opacity:.85; font-weight:900;}
      .vspP1v4Muted{opacity:.78; font-size:12px;}
      .vspP1v4Mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
      .vspP1v4Pills{display:flex; gap:8px; flex-wrap:wrap;}
      .vspP1v4Pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
                   border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.03); cursor:pointer; user-select:none;}
      .vspP1v4Dot{width:9px;height:9px;border-radius:50%;}
      .vspP1v4Table{width:100%; border-collapse:collapse; font-size:12px;}
      .vspP1v4Table th,.vspP1v4Table td{padding:8px 8px; border-bottom:1px solid rgba(255,255,255,0.08); vertical-align:top;}
      .vspP1v4Table th{opacity:.8; text-align:left; font-weight:900;}
      .vspP1v4Err{padding:10px 12px; border-radius:12px; border:1px solid rgba(255,0,0,0.25); background:rgba(255,0,0,0.06); font-size:12px;}
      .vspP1v4Ok{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
                border:1px solid rgba(0,220,120,0.25); background:rgba(0,220,120,0.06); font-size:12px;}
    `;
    document.head.appendChild(el("style",{id:"VSP_DASH_P1_V4_CSS", html:css}));
  }

  function normStatus(x){
    const v=String(x||"").toUpperCase();
    if (v.includes("PASS")||v==="GREEN") return "GREEN";
    if (v.includes("WARN")||v==="AMBER"||v==="YELLOW") return "AMBER";
    if (v.includes("FAIL")||v==="RED") return "RED";
    if (v.includes("MISSING")) return "MISSING";
    return v||"UNKNOWN";
  }
  function dot(status){
    const s=normStatus(status);
    let bg="rgba(200,200,200,0.8)";
    if (s==="GREEN") bg="rgba(0,220,120,0.85)";
    if (s==="AMBER") bg="rgba(255,200,0,0.85)";
    if (s==="RED") bg="rgba(255,70,70,0.85)";
    if (s==="MISSING") bg="rgba(160,160,160,0.85)";
    return el("span",{class:"vspP1v4Dot", style:"background:"+bg});
  }

  function pickRID(o){
    if (!o || typeof o!=="object") return null;
    return o.rid || o.run_id || o.latest_rid || o.id || null;
  }

  function unwrapAny(j){
    const seen=new Set();
    let cur=j;
    while(cur && typeof cur==="object" && !Array.isArray(cur) && !seen.has(cur)){
      seen.add(cur);
      const cand = cur.data ?? cur.json ?? cur.content ?? cur.payload ?? cur.body ?? cur.result ?? cur.obj ?? cur.value;
      if (cand && cand !== cur) { cur=cand; continue; }
      break;
    }
    return cur;
  }

  function normFindings(j){
    const o = (j && typeof j==="object") ? j : {};
    if (!o.meta || typeof o.meta!=="object") o.meta = {};
    if (!("findings" in o) && Array.isArray(o.items)) o.findings = o.items;
    if (o.findings && typeof o.findings==="object" && !Array.isArray(o.findings) && Array.isArray(o.findings.items)) o.findings = o.findings.items;
    if (!o.meta.counts_by_severity && o.counts_by_severity && typeof o.counts_by_severity==="object") o.meta.counts_by_severity = o.counts_by_severity;
    return o;
  }

  function isGateSummaryShape(o){
    if (!o || typeof o!=="object" || Array.isArray(o)) return false;
    // typical gate summary keys
    return ("overall" in o) && ("by_tool" in o) && ("counts_total" in o);
  }

  function isFindingsContract(o){
    if (!o || typeof o!=="object" || Array.isArray(o)) return false;
    const meta = o.meta;
    const cbs = meta && meta.counts_by_severity;
    return !!(cbs && typeof cbs==="object" && Array.isArray(o.findings));
  }

  async function fetchJSON(url){
    const res = await fetch(url, {credentials:"same-origin"});
    const txt = await res.text();
    let j; try{ j=JSON.parse(txt);}catch(e){ throw new Error("Non-JSON "+res.status); }
    if (!res.ok) throw new Error("HTTP "+res.status);
    return unwrapAny(j);
  }

  function scrapeRIDFromPage(){
    const t = (document.body && (document.body.innerText||"")) || "";
    const m = t.match(/\bVSP_[A-Z0-9_]*RUN_\d{8}_\d{6}\b/);
    if (m && m[0]) return m[0];
    const m2 = t.match(/\bRUN_\d{8}_\d{6}\b/);
    if (m2 && m2[0]) return m2[0];
    return null;
  }

  function toolObj(gate, tool){
    const bt = gate && gate.by_tool && gate.by_tool[tool];
    const tt = gate && gate.tools && gate.tools[tool];
    const o = bt || tt || null;
    if (o && typeof o==="object"){
      return {
        status: o.status || o.overall || o.result || o.state || "UNKNOWN",
        degraded: !!o.degraded,
        reason: o.degraded_reason || o.reason || o.note || ""
      };
    }
    return {status:"UNKNOWN", degraded:false, reason:""};
  }

  function sevRank(s){
    const v=String(s||"").toUpperCase();
    const i=SEV_ORDER.indexOf(v);
    return i>=0 ? i : 999;
  }

  function normFinding(f){
    const sev = String(f.severity||f.sev||f.level||"").toUpperCase();
    const tool = f.tool || f.source || f.engine || f.detector || "";
    const title = f.title || f.message || f.rule_name || f.rule_id || f.id || "(no title)";
    const loc = (() => {
      const path = f.path || (f.location && f.location.path) || (f.file && f.file.path) || "";
      const line = f.line || (f.location && f.location.line) || (f.start && f.start.line) || "";
      return (path ? path : "(no path)") + (line ? (":" + line) : "");
    })();
    return {sev, tool, title, loc};
  }

  function cleanupOld(){
    ["vsp_p1_panels_mount_v1","vsp_p1_panels_mount_v2","vsp_p1_panels_mount_v3","vsp_p1_panels_mount_v4"].forEach(id=>{
      const n=document.getElementById(id); if (n) n.remove();
    });
    // remove old red bars if any
    Array.from(document.querySelectorAll(".vspP1Err,.vspP1v2Err,.vspP1v3Err,.vspP1v4Err")).forEach(n=>{ try{n.remove();}catch(e){} });
  }

  function findHost(){
    return document.getElementById("vsp5_root")
        || document.querySelector("main")
        || document.body;
  }

  async function loadFindings(rid){
    // Try several allowlist-safe candidates; accept only true findings contract
    const candidates = [
      "findings_unified.json",
      "reports/findings_unified.json",
      "reports/findings_unified.sarif", // (rare; if server wraps into json it will fail contract anyway)
    ];

    let last = null;
    for (const path of candidates){
      try{
        let j = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path="+encodeURIComponent(path));
        j = normFindings(j);

        if (isGateSummaryShape(j)){
          last = {path, keys:Object.keys(j||{}), note:"gate_summary_shape"};
          continue;
        }
        if (isFindingsContract(j)){
          return {ok:true, path, obj:j};
        }
        last = {path, keys:Object.keys(j||{}), note:"not_findings_contract"};
      }catch(e){
        last = {path, err:String(e.message||e)};
      }
    }
    return {ok:false, last};
  }

  async function render(){
    if (location.pathname !== "/vsp5") return;
    cssOnce();
    cleanupOld();

    const host = findHost();
    const mount = el("div",{id:"vsp_p1_panels_mount_v4", class:"vspP1v4Wrap"});
    host.appendChild(mount);

    // RID resolve: global -> scrape page -> runs
    let rid = window.__VSP_RID_LATEST_GATE_ROOT__ || window.__vsp_rid_latest_gate_root || null;
    if (!rid) rid = scrapeRIDFromPage();
    if (!rid){
      try{
        const runs = await fetchJSON("/api/vsp/runs?limit=1&offset=0");
        const arr = Array.isArray(runs) ? runs : (runs.runs || runs.items || []);
        if (Array.isArray(arr) && arr.length) rid = pickRID(arr[0]);
      }catch(e){}
    }
    if (!rid){
      mount.appendChild(el("div",{class:"vspP1v4Err"},["Cannot resolve RID (scrape+runs fallback)."]));
      return;
    }

    // gate summary must load
    let gate=null;
    try{
      gate = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=run_gate_summary.json");
    }catch(e){
      mount.appendChild(el("div",{class:"vspP1v4Err"},["Load gate_summary failed: "+String(e.message||e)]));
      return;
    }

    // findings: multi-path + contract acceptance
    const fr = await loadFindings(rid);
    if (!fr.ok){
      const info = fr.last || {};
      mount.appendChild(el("div",{class:"vspP1v4Err"},[
        "Findings not found/contract mismatch after probes. ",
        "last_path=", String(info.path||"?"), " ",
        "note=", String(info.note||""), " ",
        "keys=", String((info.keys||[]).join(",")) ,
        info.err ? (" err="+info.err) : ""
      ]));
      console.log("[VSP][DashP1V4] findings probe failed:", fr);
      return;
    }

    const findings = fr.obj;
    const meta = findings.meta || {};
    const cbs = meta.counts_by_severity;
    const arrFind = findings.findings;

    // Tool lane
    const lane = el("div",{class:"vspP1v4Card"},[
      el("h3",{},["Tool Lane (8 tools)"]),
      el("div",{class:"vspP1v4Pills"}, TOOL_ORDER.map(t=>{
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        const pill = el("div",{class:"vspP1v4Pill", title:(st.reason||"")},[
          dot(ns),
          el("span",{class:"vspP1v4Mono", style:"font-weight:900;"},[t]),
          el("span",{class:"vspP1v4Muted"},[ns + (st.degraded?" (degraded)":"")]),
        ]);
        pill.addEventListener("click", ()=> { location.href="/runs?rid="+encodeURIComponent(rid); });
        return pill;
      }))
    ]);

    // Explain
    const reasons = [];
    const src = gate && (gate.reasons || gate.top_reasons || gate.fail_reasons);
    if (Array.isArray(src)){
      for (const x of src){
        const r = (typeof x==="string") ? x : (x.reason||x.title||"");
        if (r) reasons.push(r);
      }
    }
    if (!reasons.length){
      for (const t of TOOL_ORDER){
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        if (ns==="RED" || st.degraded || ns==="MISSING"){
          reasons.push(`${t}: ${ns}` + (st.reason?` — ${st.reason}`:""));
        }
      }
    }
    const explain = el("div",{class:"vspP1v4Card"},[
      el("h3",{},["Explain why RED / Degraded"]),
      reasons.length
        ? el("ul",{style:"margin:0; padding-left:18px;"}, reasons.slice(0,8).map(r=>el("li",{class:"vspP1v4Muted", style:"margin:6px 0;"},[r])))
        : el("div",{class:"vspP1v4Muted"},["No reasons found in gate summary."])
    ]);

    // Top findings
    const topRows = arrFind.map(normFinding).sort((a,b)=>sevRank(a.sev)-sevRank(b.sev)).slice(0,12);
    const tbl = el("div",{class:"vspP1v4Card", style:"flex-basis:100%;"},[
      el("h3",{},["Top Findings (fix-first)"]),
      el("div",{class:"vspP1v4Ok vspP1v4Mono"},[
        "rid=", rid, " • findings=", String(arrFind.length),
        " • CRIT=", String(cbs.CRITICAL||0), " • HIGH=", String(cbs.HIGH||0),
        " • source_path=", fr.path
      ]),
      el("table",{class:"vspP1v4Table", style:"margin-top:10px;"},[
        el("thead",{},[el("tr",{},[
          el("th",{},["Severity"]), el("th",{},["Tool"]), el("th",{},["Title"]), el("th",{},["Location"])
        ])]),
        el("tbody",{}, topRows.map(r=>el("tr",{},[
          el("td",{class:"vspP1v4Mono"},[r.sev||"UNKNOWN"]),
          el("td",{class:"vspP1v4Mono"},[String(r.tool||"")]),
          el("td",{},[String(r.title||"")]),
          el("td",{class:"vspP1v4Mono vspP1v4Muted"},[String(r.loc||"")]),
        ])))
      ])
    ]);

    mount.appendChild(el("div",{class:"vspP1v4Row"},[lane, explain]));
    mount.appendChild(el("div",{class:"vspP1v4Row", style:"margin-top:12px;"},[tbl]));

    console.log("[VSP][DashP1V4] ok rid="+rid+" source_path="+fr.path+" top_findings="+topRows.length);
  }

  if (document.readyState==="loading") document.addEventListener("DOMContentLoaded", render);
  else render();
})();
 /* ===================== /VSP_P1_DASHBOARD_P1_PANELS_V4_MULTIFINDINGS_HARD_FIX ===================== */

/* ===================== VSP_P1_DASHBOARD_P1_PANELS_V5_RIDWAIT_HARD_FIX =====================
   Fix: previous versions fail because RID appears after async render. V5 waits/polls and deep-scans runs JSON.
=========================================================================================== */
(()=> {
  if (window.__vsp_dash_p1_v5_ridwait) return;
  window.__vsp_dash_p1_v5_ridwait = true;

  // Disable older addons (best-effort)
  window.__vsp_dash_p1_v4 = true;
  window.__vsp_dash_p1_v3_hard_fix = true;
  window.__vsp_p1_dash_p1_panels_v1 = true;

  const TOOL_ORDER = ["Bandit","Semgrep","Gitleaks","KICS","Trivy","Syft","Grype","CodeQL"];
  const SEV_ORDER  = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"];
  const RID_RE = /\bVSP_[A-Z0-9_]*RUN_\d{8}_\d{6}\b/;
  const RID_RE2 = /\bRUN_\d{8}_\d{6}\b/;

  function el(tag, attrs={}, kids=[]){
    const n=document.createElement(tag);
    for (const [k,v] of Object.entries(attrs||{})){
      if (k==="class") n.className=v;
      else if (k==="html") n.innerHTML=v;
      else n.setAttribute(k, String(v));
    }
    (kids||[]).forEach(c=> n.appendChild(typeof c==="string"? document.createTextNode(c) : c));
    return n;
  }

  function cssOnce(){
    if (document.getElementById("VSP_DASH_P1_V5_CSS")) return;
    const css = `
      .vspP1v5Wrap{padding:14px 18px 56px 18px;}
      .vspP1v5Row{display:flex; gap:12px; flex-wrap:wrap;}
      .vspP1v5Card{background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:12px 14px; flex:1; min-width:260px;}
      .vspP1v5Card h3{margin:0 0 8px 0; font-size:12px; opacity:.85; font-weight:900;}
      .vspP1v5Muted{opacity:.78; font-size:12px;}
      .vspP1v5Mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
      .vspP1v5Pills{display:flex; gap:8px; flex-wrap:wrap;}
      .vspP1v5Pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
                   border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.03); cursor:pointer; user-select:none;}
      .vspP1v5Dot{width:9px;height:9px;border-radius:50%;}
      .vspP1v5Table{width:100%; border-collapse:collapse; font-size:12px;}
      .vspP1v5Table th,.vspP1v5Table td{padding:8px 8px; border-bottom:1px solid rgba(255,255,255,0.08); vertical-align:top;}
      .vspP1v5Table th{opacity:.8; text-align:left; font-weight:900;}
      .vspP1v5Err{padding:10px 12px; border-radius:12px; border:1px solid rgba(255,0,0,0.25); background:rgba(255,0,0,0.06); font-size:12px;}
      .vspP1v5Ok{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
                border:1px solid rgba(0,220,120,0.25); background:rgba(0,220,120,0.06); font-size:12px;}
      .vspP1v5Wait{padding:10px 12px; border-radius:12px; border:1px solid rgba(255,200,0,0.25); background:rgba(255,200,0,0.06); font-size:12px;}
    `;
    document.head.appendChild(el("style",{id:"VSP_DASH_P1_V5_CSS", html:css}));
  }

  function normStatus(x){
    const v=String(x||"").toUpperCase();
    if (v.includes("PASS")||v==="GREEN") return "GREEN";
    if (v.includes("WARN")||v==="AMBER"||v==="YELLOW") return "AMBER";
    if (v.includes("FAIL")||v==="RED") return "RED";
    if (v.includes("MISSING")) return "MISSING";
    return v||"UNKNOWN";
  }
  function dot(status){
    const s=normStatus(status);
    let bg="rgba(200,200,200,0.8)";
    if (s==="GREEN") bg="rgba(0,220,120,0.85)";
    if (s==="AMBER") bg="rgba(255,200,0,0.85)";
    if (s==="RED") bg="rgba(255,70,70,0.85)";
    if (s==="MISSING") bg="rgba(160,160,160,0.85)";
    return el("span",{class:"vspP1v5Dot", style:"background:"+bg});
  }

  function unwrapAny(j){
    const seen=new Set();
    let cur=j;
    while(cur && typeof cur==="object" && !Array.isArray(cur) && !seen.has(cur)){
      seen.add(cur);
      const cand = cur.data ?? cur.json ?? cur.content ?? cur.payload ?? cur.body ?? cur.result ?? cur.obj ?? cur.value;
      if (cand && cand !== cur) { cur=cand; continue; }
      break;
    }
    return cur;
  }

  async function fetchJSON(url){
    const res = await fetch(url, {credentials:"same-origin"});
    const txt = await res.text();
    let j; try{ j=JSON.parse(txt);}catch(e){ throw new Error("Non-JSON "+res.status); }
    if (!res.ok) throw new Error("HTTP "+res.status);
    return unwrapAny(j);
  }

  function normFindings(j){
    const o = (j && typeof j==="object") ? j : {};
    if (!o.meta || typeof o.meta!=="object") o.meta = {};
    if (!("findings" in o) && Array.isArray(o.items)) o.findings = o.items;
    if (o.findings && typeof o.findings==="object" && !Array.isArray(o.findings) && Array.isArray(o.findings.items)) o.findings = o.findings.items;
    if (!o.meta.counts_by_severity && o.counts_by_severity && typeof o.counts_by_severity==="object") o.meta.counts_by_severity = o.counts_by_severity;
    return o;
  }
  function isGateSummaryShape(o){
    return !!(o && typeof o==="object" && !Array.isArray(o) && ("overall" in o) && ("by_tool" in o) && ("counts_total" in o));
  }
  function isFindingsContract(o){
    return !!(o && typeof o==="object" && !Array.isArray(o) && o.meta && o.meta.counts_by_severity && Array.isArray(o.findings));
  }

  function scrapeRIDFromDOM(){
    const t = (document.body && (document.body.innerText||"")) || "";
    const m = t.match(RID_RE);
    if (m && m[0]) return m[0];
    const m2 = t.match(RID_RE2);
    if (m2 && m2[0]) return m2[0];
    return null;
  }

  function findRIDDeep(obj, depth=0){
    if (depth>6) return null;
    if (typeof obj==="string"){
      const m = obj.match(RID_RE);
      if (m && m[0]) return m[0];
      const m2 = obj.match(RID_RE2);
      if (m2 && m2[0]) return m2[0];
      return null;
    }
    if (!obj || typeof obj!=="object") return null;
    if (Array.isArray(obj)){
      for (const x of obj){
        const r = findRIDDeep(x, depth+1);
        if (r) return r;
      }
      return null;
    }
    for (const k of Object.keys(obj)){
      const r = findRIDDeep(obj[k], depth+1);
      if (r) return r;
    }
    return null;
  }

  async function resolveRIDWait(mount){
    const globalCandidates = [
      ".__VSP_RID_LATEST_GATE_ROOT__",
      ".__vsp_rid_latest_gate_root",
      ".__VSP_GATE_ROOT_RID__",
      ".__vsp_gate_root_rid",
      ".__VSP_P1_GATE_ROOT_RID__",
      ".__VSP_LAST_RID__",
      ".__vsp_last_rid",
    ].map(s=>s.slice(1));

    const started = Date.now();
    const maxMs = 10000;
    const stepMs = 500;

    while (Date.now()-started < maxMs){
      // (1) global vars
      for (const key of globalCandidates){
        try{
          const v = window[key];
          if (typeof v==="string" && (RID_RE.test(v) || RID_RE2.test(v))) return v;
        }catch(e){}
      }

      // (2) DOM text (after GateStory async render)
      const ridDom = scrapeRIDFromDOM();
      if (ridDom) return ridDom;

      // (3) runs deep scan
      try{
        const runs = await fetchJSON("/api/vsp/runs?limit=5&offset=0");
        const rid = findRIDDeep(runs);
        if (rid) return rid;
      }catch(e){}

      mount.textContent = "";
      mount.appendChild(el("div",{class:"vspP1v5Wait"},[
        "Waiting for gate_root RID... ",
        el("span",{class:"vspP1v5Mono"},[String(Math.round((Date.now()-started)/100)/10)+"s"]),
        " (poll DOM + /api/vsp/runs)"
      ]));
      await new Promise(r=>setTimeout(r, stepMs));
    }
    return null;
  }

  function toolObj(gate, tool){
    const bt = gate && gate.by_tool && gate.by_tool[tool];
    const tt = gate && gate.tools && gate.tools[tool];
    const o = bt || tt || null;
    if (o && typeof o==="object"){
      return { status: o.status || o.overall || o.result || o.state || "UNKNOWN",
               degraded: !!o.degraded,
               reason: o.degraded_reason || o.reason || o.note || "" };
    }
    return {status:"UNKNOWN", degraded:false, reason:""};
  }

  function sevRank(s){
    const v=String(s||"").toUpperCase();
    const i=SEV_ORDER.indexOf(v);
    return i>=0 ? i : 999;
  }
  function normFinding(f){
    const sev = String(f.severity||f.sev||f.level||"").toUpperCase();
    const tool = f.tool || f.source || f.engine || f.detector || "";
    const title = f.title || f.message || f.rule_name || f.rule_id || f.id || "(no title)";
    const loc = (() => {
      const path = f.path || (f.location && f.location.path) || (f.file && f.file.path) || "";
      const line = f.line || (f.location && f.location.line) || (f.start && f.start.line) || "";
      return (path ? path : "(no path)") + (line ? (":" + line) : "");
    })();
    return {sev, tool, title, loc};
  }

  function cleanupOldBanners(){
    // remove old mounts
    ["vsp_p1_panels_mount_v1","vsp_p1_panels_mount_v2","vsp_p1_panels_mount_v3","vsp_p1_panels_mount_v4","vsp_p1_panels_mount_v5"].forEach(id=>{
      const n=document.getElementById(id); if (n) n.remove();
    });
    // remove any old banner-like nodes containing our known error strings
    const bad = ["Cannot resolve RID", "payload mismatch", "contract mismatch", "mismatch keys="];
    Array.from(document.querySelectorAll("div,section,article")).forEach(n=>{
      const t = (n.textContent||"");
      if (bad.some(x=>t.includes(x)) && t.length < 260) { try{ n.remove(); }catch(e){} }
    });
  }

  async function loadFindings(rid){
    const candidates = ["findings_unified.json", "reports/findings_unified.json"];
    let last=null;
    for (const path of candidates){
      try{
        let j = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path="+encodeURIComponent(path));
        j = normFindings(j);
        if (isGateSummaryShape(j)){ last={path, note:"gate_summary_shape", keys:Object.keys(j||{})}; continue; }
        if (isFindingsContract(j)) return {ok:true, path, obj:j};
        last={path, note:"not_findings_contract", keys:Object.keys(j||{})};
      }catch(e){
        last={path, err:String(e.message||e)};
      }
    }
    return {ok:false, last};
  }

  async function render(){
    if (location.pathname !== "/vsp5") return;
    cssOnce();
    cleanupOldBanners();

    const host = document.getElementById("vsp5_root") || document.querySelector("main") || document.body;
    const mount = el("div",{id:"vsp_p1_panels_mount_v5", class:"vspP1v5Wrap"});
    host.appendChild(mount);

    const rid = await resolveRIDWait(mount);
    if (!rid){
      mount.textContent="";
      mount.appendChild(el("div",{class:"vspP1v5Err"},["Cannot resolve RID after wait (10s)."]));
      console.log("[VSP][DashP1V5] RID resolve failed.");
      return;
    }

    let gate=null;
    try{
      gate = await fetchJSON("/api/vsp/run_file_allow?rid="+encodeURIComponent(rid)+"&path=run_gate_summary.json");
    }catch(e){
      mount.textContent="";
      mount.appendChild(el("div",{class:"vspP1v5Err"},["Load gate_summary failed: "+String(e.message||e)]));
      return;
    }

    const fr = await loadFindings(rid);
    if (!fr.ok){
      const info = fr.last || {};
      mount.textContent="";
      mount.appendChild(el("div",{class:"vspP1v5Err"},[
        "Findings not found/contract mismatch. last_path=", String(info.path||"?"),
        " note=", String(info.note||""),
        " keys=", String((info.keys||[]).join(",")),
        info.err ? (" err="+info.err) : ""
      ]));
      console.log("[VSP][DashP1V5] findings probe failed:", fr);
      return;
    }

    const findings = fr.obj;
    const cbs = findings.meta.counts_by_severity;
    const arrFind = findings.findings;

    // Build UI
    mount.textContent="";

    const lane = el("div",{class:"vspP1v5Card"},[
      el("h3",{},["Tool Lane (8 tools)"]),
      el("div",{class:"vspP1v5Pills"}, TOOL_ORDER.map(t=>{
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        const pill = el("div",{class:"vspP1v5Pill", title:(st.reason||"")},[
          dot(ns),
          el("span",{class:"vspP1v5Mono", style:"font-weight:900;"},[t]),
          el("span",{class:"vspP1v5Muted"},[ns + (st.degraded?" (degraded)":"")]),
        ]);
        pill.addEventListener("click", ()=> { location.href="/runs?rid="+encodeURIComponent(rid); });
        return pill;
      }))
    ]);

    const reasons = [];
    const src = gate && (gate.reasons || gate.top_reasons || gate.fail_reasons);
    if (Array.isArray(src)){
      for (const x of src){
        const r = (typeof x==="string") ? x : (x.reason||x.title||"");
        if (r) reasons.push(r);
      }
    }
    if (!reasons.length){
      for (const t of TOOL_ORDER){
        const st = toolObj(gate,t);
        const ns = normStatus(st.status);
        if (ns==="RED" || st.degraded || ns==="MISSING"){
          reasons.push(`${t}: ${ns}` + (st.reason?` — ${st.reason}`:""));
        }
      }
    }
    const explain = el("div",{class:"vspP1v5Card"},[
      el("h3",{},["Explain why RED / Degraded"]),
      reasons.length
        ? el("ul",{style:"margin:0; padding-left:18px;"}, reasons.slice(0,8).map(r=>el("li",{class:"vspP1v5Muted", style:"margin:6px 0;"},[r])))
        : el("div",{class:"vspP1v5Muted"},["No reasons found in gate summary."])
    ]);

    const topRows = arrFind.map(normFinding).sort((a,b)=>sevRank(a.sev)-sevRank(b.sev)).slice(0,12);

    const tbl = el("div",{class:"vspP1v5Card", style:"flex-basis:100%;"},[
      el("h3",{},["Top Findings (fix-first)"]),
      el("div",{class:"vspP1v5Ok vspP1v5Mono"},[
        "rid=", rid, " • findings=", String(arrFind.length),
        " • CRIT=", String(cbs.CRITICAL||0), " • HIGH=", String(cbs.HIGH||0),
        " • source_path=", fr.path
      ]),
      el("table",{class:"vspP1v5Table", style:"margin-top:10px;"},[
        el("thead",{},[el("tr",{},[
          el("th",{},["Severity"]), el("th",{},["Tool"]), el("th",{},["Title"]), el("th",{},["Location"])
        ])]),
        el("tbody",{}, topRows.map(r=>el("tr",{},[
          el("td",{class:"vspP1v5Mono"},[r.sev||"UNKNOWN"]),
          el("td",{class:"vspP1v5Mono"},[String(r.tool||"")]),
          el("td",{},[String(r.title||"")]),
          el("td",{class:"vspP1v5Mono vspP1v5Muted"},[String(r.loc||"")]),
        ])))
      ])
    ]);

    mount.appendChild(el("div",{class:"vspP1v5Row"},[lane, explain]));
    mount.appendChild(el("div",{class:"vspP1v5Row", style:"margin-top:12px;"},[tbl]));

    console.log("[VSP][DashP1V5] ok rid="+rid+" source_path="+fr.path+" top_findings="+topRows.length);
  }

  // run after full load to ensure GateStory already injected text
  window.addEventListener("load", ()=> { setTimeout(render, 120); });
})();
 /* ===================== /VSP_P1_DASHBOARD_P1_PANELS_V5_RIDWAIT_HARD_FIX ===================== */
