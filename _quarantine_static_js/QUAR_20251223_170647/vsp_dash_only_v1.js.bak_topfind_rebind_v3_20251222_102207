/* VSP_DASH_ONLY_V1 */
(()=> {
  if (window.__vsp_dash_only_v1) return;
  window.__vsp_dash_only_v1 = true;

  const $ = (q,el=document)=>el.querySelector(q);
  const esc = (s)=> String(s??"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  const sevRank = (s)=> ({CRITICAL:0,HIGH:1,MEDIUM:2,LOW:3,INFO:4,TRACE:5}[String(s||"").toUpperCase()] ?? 99);

  const state = {
    rid: null,
    gate: null,
    counts: null,
    tools: null,
    findings: null,
  };

  function log(...a){ console.log("[DASH_ONLY]", ...a); }

  async function jget(url){
    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
    return await r.json();
  }

  function getRidFromQS(){
    const u = new URL(location.href);
    return u.searchParams.get("rid");
  }

  async function resolveRid(){
    const qs = getRidFromQS();
    if (qs) return qs;

    const pin = localStorage.getItem("vsp.rid.pin");
    if (pin) return pin;

    try{
      const j = await jget("/api/vsp/rid_latest_gate_root");
      if (j && j.ok && j.rid) return j.rid;
    }catch(e){
      log("rid_latest_gate_root failed", e?.message || e);
    }
    return null;
  }

  function setStatusBadge(overall){
    const el = $("#overall_badge");
    if(!el) return;
    const o = String(overall||"UNKNOWN").toUpperCase();
    el.textContent = o;
    el.style.borderColor = "rgba(255,255,255,.14)";
    if (o === "PASS" || o === "GREEN") el.style.color = "rgba(34,197,94,.95)";
    else if (o === "STALE" || o === "AMBER" || o === "WARN") el.style.color = "rgba(245,158,11,.98)";
    else if (o === "FAIL" || o === "RED") el.style.color = "rgba(239,68,68,.95)";
    else el.style.color = "rgba(226,232,240,.92)";
  }

  function render(){
    $("#rid_txt").textContent = state.rid || "(no rid)";
    setStatusBadge(state.gate?.overall_status || state.gate?.overall || state.gate?.overall_v2);

    const c = state.counts || {};
    const setK = (id,val)=> { const el=$(id); if(el) el.textContent = (val==null? "—": String(val)); };

    setK("#k_total", c.TOTAL ?? c.total ?? state.gate?.counts_total?.TOTAL);
    setK("#k_crit",  c.CRITICAL ?? c.critical);
    setK("#k_high",  c.HIGH ?? c.high);
    setK("#k_med",   c.MEDIUM ?? c.medium);
    setK("#k_low",   c.LOW ?? c.low);
    setK("#k_info",  c.INFO ?? c.info);
    setK("#k_trace", c.TRACE ?? c.trace);

        const ensureToolsBox = ()=>{
      let el = $("#tools_box")
        || document.querySelector("[data-vsp='tools_box']")
        || document.querySelector(".tools_box")
        || document.querySelector(".tool-lane")
        || null;

      if (!el){
        // find an anchor containing "Tool lane"
        const nodes = Array.from(document.querySelectorAll("div,section,header,h1,h2,h3,h4,span"));
        const anchor = nodes.find(n => (n.textContent||"").toLowerCase().includes("tool lane"));
        if (anchor){
          el = document.createElement("div");
          el.id = "tools_box";
          el.style.marginTop = "8px";
          // try append near anchor
          (anchor.parentElement || document.body).appendChild(el);
        }
      } else {
        if (!el.id) el.id = "tools_box";
      }
      return el;
    };
    const toolsBox = ensureToolsBox();

    if (toolsBox){
      const tools = state.tools || {};
      const order = ["Semgrep","Gitleaks","KICS","Trivy","Syft","Grype","Bandit","CodeQL"];
      toolsBox.innerHTML = order.map(t=>{
        const st = String(tools[t]?.status || tools[t] || "UNKNOWN").toUpperCase();
        const cls = (st==="OK") ? "s-ok" : (st==="MISSING" || st==="DEGRADED") ? "s-miss" : (st==="FAIL" || st==="ERROR") ? "s-bad" : "";
        return `<div class="tool"><div class="t">${esc(t)}</div><div class="s ${cls}">${esc(st)}</div></div>`;
      }).join("");
    }

    const note = $("#note_box");
    if(note){
      const arr = [];
      arr.push(`Source: run_gate_summary.json (tool truth)`);
      arr.push(`No legacy /api/vsp/runs auto-refresh (dash-only).`);
      note.textContent = arr.join("\n");
    }
  }

  async function loadGate(){
    const rid = state.rid;
    if(!rid) throw new Error("No RID resolved");
    const gate = await jget(`/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=run_gate_summary.json`);
    // allow both shapes: {ok:true,...} or raw json
    state.gate = gate?.ok === false ? null : (gate?.ok === true && gate.data ? gate.data : gate);
    // heuristics for counts/tools
    const meta = state.gate?.meta || state.gate || {};
    state.counts = meta.counts_by_severity || meta.counts_total || meta.counts || meta.meta?.counts_by_severity || meta.meta?.counts_total || null;
    state.tools = meta.by_tool || meta.tools || meta.byTool || null;
    render();
  }

  async function loadTopFindings(){
    const rid = state.rid;
    if(!rid) return;
    const out = $("#findings_tbl");
    const btn = $("#btn_load_findings");
    if(btn) btn.disabled = true;

    try{
      const fu = await jget(`/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=findings_unified.json`);
      const payload = fu?.ok === true && fu.findings ? fu : (fu?.ok === true && fu.data ? fu.data : fu);
      const findings = payload.findings || payload?.data?.findings || [];
      const rows = findings
        .map(f=>({
          sev: String(f.severity||"").toUpperCase(),
          tool: f.tool || f.source || "",
          title: f.title || f.rule_id || f.message || "",
          loc: f.location || f.path || (f.file? `${f.file}:${f.line||""}`:""),
        }))
        .sort((a,b)=> sevRank(a.sev)-sevRank(b.sev))
        .slice(0, 25);

      out.innerHTML = rows.map(r=>(
        `<tr><td>${esc(r.sev)}</td><td>${esc(r.tool)}</td><td>${esc(r.title)}</td><td>${esc(r.loc)}</td></tr>`
      )).join("");
      log("loaded top findings", rows.length);
    }catch(e){
      log("load findings failed", e?.message||e);
      out.innerHTML = `<tr><td colspan="4">Failed to load findings_unified.json</td></tr>`;
    }finally{
      if(btn) btn.disabled = false;
    }
  }

  async function boot(){
    log("boot");
    state.rid = await resolveRid();
    if(!state.rid){
      $("#rid_txt").textContent = "(no rid)";
      $("#note_box").textContent = "Cannot resolve RID. (Hint: set VSP_RUNS_ROOT in service env, or open /vsp5?rid=RUN_...)";
      return;
    }
    await loadGate();
  }

  window.__vspDashOnly = {
    pinRid(){
      if(state.rid) localStorage.setItem("vsp.rid.pin", state.rid);
      alert("Pinned RID: " + (state.rid||""));
    },
    clearPin(){
      localStorage.removeItem("vsp.rid.pin");
      alert("Cleared pinned RID");
    },
    refresh(){ return boot(); },
    loadTopFindings(){ return loadTopFindings(); },
  };

  document.addEventListener("click", (e)=>{
    const t = e.target;
    if(!(t instanceof HTMLElement)) return;
    const id = t.id;
    if(id==="btn_refresh") boot();
    if(id==="btn_pin") window.__vspDashOnly.pinRid();
    if(id==="btn_unpin") window.__vspDashOnly.clearPin();
    if(id==="btn_load_findings") loadTopFindings();
  });

  boot();
})();


/* ===================== VSP_P0_DASHONLY_FORCE_RENDER_GATE_SUMMARY_V1 ===================== */
(()=> {
  if (window.__vsp_p0_dashonly_force_render_v1) return;
  window.__vsp_p0_dashonly_force_render_v1 = true;

  const $ = (sel)=> document.querySelector(sel);
  const esc = (x)=> String(x ?? "").replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c]));

  const setTextAny = (ids, val)=>{
    for (const id of ids){
      const el = document.querySelector(id);
      if (el){ el.textContent = (val==null? "—" : String(val)); return true; }
    }
    return false;
  };

  const normKey = (k)=> String(k||"").toLowerCase().replace(/[^a-z0-9]+/g,"");
  const statusOf = (v)=>{
    if (v == null) return "UNKNOWN";
    if (typeof v === "string") return v.toUpperCase();
    if (typeof v === "boolean") return v ? "OK" : "FAIL";
    if (typeof v === "object"){
      const cand = v.status ?? v.state ?? v.result ?? v.verdict ?? v.outcome;
      if (typeof cand === "string") return cand.toUpperCase();
      if (typeof cand === "boolean") return cand ? "OK" : "FAIL";
      if (v.ok === true) return "OK";
      if (v.missing === true) return "MISSING";
      if (v.degraded === true) return "DEGRADED";
    }
    return "UNKNOWN";
  };

  const applySummary = (sum)=>{
    if (!sum || typeof sum !== "object") return;

    const c = sum.counts_total || sum.counts_by_severity || sum.counts || {};
    const CRIT  = c.CRITICAL ?? c.critical;
    const HIGH  = c.HIGH ?? c.high;
    const MED   = c.MEDIUM ?? c.medium;
    const LOW   = c.LOW ?? c.low;
    const INFO  = c.INFO ?? c.info;
    const TRACE = c.TRACE ?? c.trace;

    let TOTAL = c.TOTAL ?? c.total;
    if (TOTAL == null){
      const nums = [CRIT,HIGH,MED,LOW,INFO,TRACE].map(x=> (x==null? 0 : Number(x)||0));
      TOTAL = nums.reduce((a,b)=>a+b,0);
    }

    // KPI ids: try multiple common ids (không đúng thì bỏ qua)
    setTextAny(["#k_total","#kpi_total","#total_val","[data-kpi='TOTAL']"], TOTAL);
    setTextAny(["#k_crit","#kpi_crit","[data-kpi='CRITICAL']"], CRIT);
    setTextAny(["#k_high","#kpi_high","[data-kpi='HIGH']"], HIGH);
    setTextAny(["#k_med","#kpi_med","[data-kpi='MEDIUM']"], MED);
    setTextAny(["#k_low","#kpi_low","[data-kpi='LOW']"], LOW);
    setTextAny(["#k_info","#kpi_info","[data-kpi='INFO']"], INFO);
    setTextAny(["#k_trace","#kpi_trace","[data-kpi='TRACE']"], TRACE);

    // Tool lane
        const ensureToolsBox = ()=>{
      let el = $("#tools_box")
        || document.querySelector("[data-vsp='tools_box']")
        || document.querySelector(".tools_box")
        || document.querySelector(".tool-lane")
        || null;

      if (!el){
        // find an anchor containing "Tool lane"
        const nodes = Array.from(document.querySelectorAll("div,section,header,h1,h2,h3,h4,span"));
        const anchor = nodes.find(n => (n.textContent||"").toLowerCase().includes("tool lane"));
        if (anchor){
          el = document.createElement("div");
          el.id = "tools_box";
          el.style.marginTop = "8px";
          // try append near anchor
          (anchor.parentElement || document.body).appendChild(el);
        }
      } else {
        if (!el.id) el.id = "tools_box";
      }
      return el;
    };
    const toolsBox = ensureToolsBox();

    if (toolsBox){
      const raw = sum.by_tool || sum.byTool || {};
      const normMap = {};
      try{ for (const [k,v] of Object.entries(raw||{})) normMap[normKey(k)] = v; }catch(_e){}

      const pick = (toolName)=>{
        const variants = [
          normKey(toolName),
          normKey(toolName.replace("CodeQL","codeql")),
          normKey(toolName+"_summary"),
          normKey(toolName+"Summary"),
        ];
        for (const k of variants){
          if (k && (k in normMap)) return normMap[k];
        }
        // fallback: try contains
        for (const [k,v] of Object.entries(normMap)){
          if (k.includes(normKey(toolName))) return v;
        }
        return null;
      };

      const order = ["Semgrep","Gitleaks","KICS","Trivy","Syft","Grype","Bandit","CodeQL"];
      toolsBox.innerHTML = order.map(t=>{
        const v = pick(t);
        const st = statusOf(v);
        const cls = (st==="OK" || st==="GREEN") ? "s-ok"
                  : (st==="MISSING" || st==="DEGRADED" || st==="AMBER") ? "s-miss"
                  : (st==="FAIL" || st==="ERROR" || st==="RED") ? "s-bad"
                  : "";
        // normalize display: GREEN->OK, RED->FAIL (optional)
        const disp = (st==="GREEN") ? "OK" : (st==="RED") ? "FAIL" : st;
        return `<div class="tool"><div class="t">${esc(t)}</div><div class="s ${cls}">${esc(disp)}</div></div>`;
      }).join("");
    }

    // Notes (optional)
        const ensureNotesBox = ()=>{
      let el = $("#notes_box") || document.querySelector("[data-vsp='notes_box']") || null;
      if (!el){
        const nodes = Array.from(document.querySelectorAll("div,section,header,h1,h2,h3,h4,span"));
        const anchor = nodes.find(n => (n.textContent||"").toLowerCase().trim().startsWith("notes"));
        if (anchor){
          el = document.createElement("div");
          el.id = "notes_box";
          el.style.marginTop = "6px";
          (anchor.parentElement || document.body).appendChild(el);
        }
      } else {
        if (!el.id) el.id = "notes_box";
      }
      return el;
    };
    const notes = ensureNotesBox();

    if (notes){
      // keep existing content, but ensure source line present
      if (!notes.textContent.includes("run_gate_summary")){
        notes.textContent = "Source: run_gate_summary.json (tool truth). No legacy auto-fetch /api/vsp/runs (dash-only).";
      }
    }
  };

  async function fetchJSON(url){
    const r = await fetch(url, {cache:"no-store"});
    if (!r.ok) throw new Error("HTTP "+r.status);
    return await r.json();
  }

  async function loadOnce(){
    try{
      const meta = await fetchJSON("/api/vsp/rid_latest_gate_root");
      const rid = meta && meta.rid;
      if (!rid) return;
      // show RID if input exists
      setTextAny(["#rid_val","#rid_text","#rid_label"], rid);

      const sum = await fetchJSON(`/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=run_gate_summary.json`);
      applySummary(sum);
    }catch(e){
      // silent (dash-only should not spam)
      console.warn("[VSP][DASH_ONLY] gate_summary fetch failed:", e && e.message ? e.message : e);
    }
  }

  // run now + periodic (30s)
  loadOnce();
  setInterval(loadOnce, 30000);

  console.log("[VSP][DASH_ONLY] force-render gate_summary enabled");
})();
/* ===================== /VSP_P0_DASHONLY_FORCE_RENDER_GATE_SUMMARY_V1 ===================== */



/* VSP_P0_DASH_ONLY_FIX_TRIM_AND_MISSING_TOOLS_V2 */
(()=> {
  if (window.__vsp_dash_fix_trim_missing_v2) return;
  window.__vsp_dash_fix_trim_missing_v2 = true;

  const CANON = [
    {key:"SEMGREP",  label:"Semgrep"},
    {key:"GITLEAKS", label:"Gitleaks"},
    {key:"KICS",     label:"KICS"},
    {key:"TRIVY",    label:"Trivy"},
    {key:"SYFT",     label:"Syft"},
    {key:"GRYPE",    label:"Grype"},
    {key:"BANDIT",   label:"Bandit"},
    {key:"CODEQL",   label:"CodeQL"},
  ];

  function normVerdict(v){
    let x = "";
    try {
      if (v && typeof v === "object") x = (v.verdict || v.status || v.state || v.result || "");
      else x = (v || "");
    } catch(e){ x = ""; }
    x = (x == null ? "" : (""+x)).toUpperCase().trim();
    if (!x) return "UNKNOWN";
    if (x === "OK") return "GREEN";
    if (x === "FAIL") return "RED";
    if (x === "WARN" || x === "WARNING") return "AMBER";
    return x;
  }

  function pillLabel(v){
    const x = normVerdict(v);
    if (x === "GREEN") return "OK";
    if (x === "RED") return "FAIL";
    if (x === "AMBER") return "AMBER";
    if (x === "MISSING") return "MISSING";
    return "UNKNOWN";
  }

  function findToolCard(label){
    // Try multiple heuristics: card contains tool label text
    const nodes = Array.from(document.querySelectorAll("div,section,article,li"));
    label = (label || "").toLowerCase();
    for (const n of nodes){
      const t = (n.textContent || "").toLowerCase();
      if (!t) continue;
      // Must contain tool name and be "card-like" (has border/padding or inside tool lane)
      if (t.includes(label)) {
        // avoid huge containers: prefer smaller nodes
        if (t.length < 220) return n;
      }
    }
    return null;
  }

  function setCardStatus(card, statusText){
    if (!card) return;
    // If card already has a clear status line, update it; else append a status line.
    const st = (statusText || "UNKNOWN").toUpperCase().trim();
    // try find a child that looks like status
    const kids = Array.from(card.querySelectorAll("div,span,p,small"));
    let target = null;
    for (const k of kids){
      const tx = (k.textContent || "").toUpperCase().trim();
      if (tx === "OK" || tx === "FAIL" || tx === "AMBER" || tx === "MISSING" || tx === "UNKNOWN" || tx === "[OBJECT OBJECT]"){
        target = k; break;
      }
    }
    if (!target){
      // pick last child text node-ish
      target = kids.length ? kids[kids.length - 1] : null;
    }
    if (target){
      target.textContent = st;
    } else {
      const d = document.createElement("div");
      d.textContent = st;
      d.style.opacity = "0.85";
      d.style.marginTop = "6px";
      card.appendChild(d);
    }
    // add a css-ish class for visual
    card.classList.remove("ok","fail","amber","missing","unknown");
    if (st==="OK") card.classList.add("ok");
    else if (st==="FAIL") card.classList.add("fail");
    else if (st==="AMBER") card.classList.add("amber");
    else if (st==="MISSING") card.classList.add("missing");
    else card.classList.add("unknown");
  }

  async function fetchJSON(url){
    const r = await fetch(url, {cache:"no-store"});
    if (!r.ok) throw new Error("HTTP "+r.status);
    return await r.json();
  }

  async function refreshFromGateSummary(){
    try {
      const latest = await fetchJSON("/api/vsp/rid_latest_gate_root");
      if (!latest || !latest.ok || !latest.rid) return;
      const rid = latest.rid;

      const gs = await fetchJSON("/api/vsp/run_file_allow?rid=" + encodeURIComponent(rid) + "&path=run_gate_summary.json");
      const byTool = (gs && gs.by_tool && typeof gs.by_tool === "object") ? gs.by_tool : {};

      // update 8 tools; missing -> MISSING
      for (const t of CANON){
        const v = byTool[t.key];
        const verdict = v ? normVerdict(v) : "MISSING";
        const pill = pillLabel(verdict === "MISSING" ? "MISSING" : verdict);
        const card = findToolCard(t.label) || findToolCard(t.key) || null;
        setCardStatus(card, pill);
      }

      // store for other code
      window.__vsp_gate_summary = gs;
    } catch(e){
      console.warn("[VSP][DASH_ONLY] gate_summary refresh failed:", e && e.message ? e.message : e);
    }
  }

  // run once + interval
  setTimeout(refreshFromGateSummary, 250);
  setInterval(refreshFromGateSummary, 4000);
  console.log("[VSP][DASH_ONLY] trim+missing-tools fixer v2 active");
})();


/* VSP_P0_DASH_ONLY_TOOLLANE_HARDEN_V1
   // - Capture run_gate_summary.json via fetch wrapper
   // - Re-render Tool Lane (8 tools) deterministically
   // - Missing tools => MISSING (never UNKNOWN/[object Object])
// */  /* auto-fix: stray block-comment end */
(()=> {
  if (window.__vsp_p0_dash_only_toollane_harden_v1) return;
  window.__vsp_p0_dash_only_toollane_harden_v1 = true;

  const TOOLS = ["SEMGREP","GITLEAKS","KICS","TRIVY","SYFT","GRYPE","BANDIT","CODEQL"];
  const LABEL = { SEMGREP:"Semgrep", GITLEAKS:"Gitleaks", KICS:"KICS", TRIVY:"Trivy", SYFT:"Syft", GRYPE:"Grype", BANDIT:"Bandit", CODEQL:"CodeQL" };

  function upper(x){ return (typeof x === "string") ? x.toUpperCase() : ""; }

  function normVerdict(v){
    if (!v) return "MISSING";
    if (typeof v === "string") return upper(v) || "UNKNOWN";
    if (typeof v === "object") {
      if (typeof v.verdict === "string") return upper(v.verdict) || "UNKNOWN";
      if (typeof v.status  === "string") return upper(v.status)  || "UNKNOWN";
      if (typeof v.state   === "string") return upper(v.state)   || "UNKNOWN";
      if (typeof v.result  === "string") return upper(v.result)  || "UNKNOWN";
      // object but no known keys => treat as UNKNOWN, but never print object
      return "UNKNOWN";
    }
    return "UNKNOWN";
  }

  function byToolFrom(gs){
    if (!gs || typeof gs !== "object") return {};
    return gs.by_tool || gs.byTool || gs.by_tools || {};
  }

  function findHeaderNode(){
    // find leaf node whose text matches "Tool lane (8 tools)"
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node){
        try{
          if (!node || node.children?.length) return NodeFilter.FILTER_SKIP;
          const t = (node.textContent||"").trim();
          if (/^Tool\s*lane\s*\(\s*8\s*tools\s*\)/i.test(t)) return NodeFilter.FILTER_ACCEPT;
        }catch(e){}
        return NodeFilter.FILTER_SKIP;
      }
    });
    return walker.nextNode();
  }

  function badgeStyle(verdict){
    const v = upper(verdict);
    // minimal styling (dark theme friendly)
    const base = "display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);";
    let pill = "padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid rgba(255,255,255,0.10);opacity:0.95;";
    if (v === "GREEN" || v === "OK") pill += "background:rgba(16,185,129,0.12);";
    else if (v === "AMBER" || v === "WARN") pill += "background:rgba(245,158,11,0.12);";
    else if (v === "RED" || v === "FAIL") pill += "background:rgba(239,68,68,0.12);";
    else if (v === "MISSING") pill += "background:rgba(148,163,184,0.10);";
    else pill += "background:rgba(99,102,241,0.10);";
    return { base, pill };
  }

  function renderLane(gs){
    const by = byToolFrom(gs);
    const items = TOOLS.map(t=>{
      const raw = by[t] ?? by[t.toLowerCase()] ?? null;
      const verdict = normVerdict(raw);
      return { tool: t, label: LABEL[t] || t, verdict };
    });

    const html = items.map(it=>{
      const st = badgeStyle(it.verdict);
      return `
        <div style="${st.base}">
          <div style="font-weight:600;letter-spacing:0.2px;">${it.label}</div>
          <div style="${st.pill}">${it.verdict}</div>
        </div>
      `;
    }).join("");

    return `
      <div id="vsp_dash_only_toollane_grid_v1"
           style="display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px;margin-top:10px;">
        ${html}
      </div>
    `;
  }

  function applyToolLane(gs){
    const header = findHeaderNode();
    if (!header) return false;
    const hostId = "vsp_dash_only_toollane_host_v1";
    let host = document.getElementById(hostId);
    if (!host){
      host = document.createElement("div");
      host.id = hostId;
      // insert right after the header node
      header.insertAdjacentElement("afterend", host);
    }
    host.innerHTML = renderLane(gs);
    return true;
  }

  async function forceFetchGateSummary(){
    try{
      const r1 = await window.fetch("/api/vsp/rid_latest_gate_root");
      const j1 = await r1.json();
      const rid = j1 && j1.rid;
      if (!rid) return;
      const url = "/api/vsp/run_file_allow?rid=" + encodeURIComponent(rid) + "&path=run_gate_summary.json";
      const r2 = await window.fetch(url);
      const gs = await r2.json();
      window.__vsp_dash_only_last_gate_summary = gs;
      applyToolLane(gs);
    }catch(e){
      console.warn("[VSP][DASH_ONLY] toollane harden forceFetch failed", e);
    }
  }

  function captureFromFetch(url, resp){
    try{
      if (!url || typeof url !== "string") return;
      if (url.indexOf("run_gate_summary.json") === -1) return;
      resp.clone().json().then(gs=>{
        window.__vsp_dash_only_last_gate_summary = gs;
        applyToolLane(gs);
      }).catch(()=>{});
    }catch(e){}
  }

  // Wrap fetch once
  try{
    const orig = window.fetch;
    if (typeof orig === "function" && !orig.__vsp_toollane_harden_wrapped){
      const wrapped = function(input, init){
        const url = (typeof input === "string") ? input : (input && input.url) || "";
        return orig(input, init).then(resp=>{
          captureFromFetch(url, resp);
          return resp;
        });
      };
      wrapped.__vsp_toollane_harden_wrapped = true;
      window.fetch = wrapped;
    }
  }catch(e){}

  // Kick once after load
  setTimeout(()=> {
    if (window.__vsp_dash_only_last_gate_summary) {
      applyToolLane(window.__vsp_dash_only_last_gate_summary);
    } else {
      forceFetchGateSummary();
    }
  }, 900);

  console.log("[VSP][DASH_ONLY] toollane harden v1 active");
})();


/* VSP_P0_DASH_ONLY_TOOLLANE_DEDUPE_V1
   Hide legacy/duplicate tool lane blocks (UNKNOWN-heavy / "Derived from run_gate_summary.json")
   so only the hardened 8-tool lane remains visible.
// */  /* auto-fix: stray block-comment end */
(()=> {
  if (window.__vsp_p0_dash_only_toollane_dedupe_v1) return;
  window.__vsp_p0_dash_only_toollane_dedupe_v1 = true;

  const toolsRe = /(Semgrep|Gitleaks|KICS|Trivy|Syft|Grype|Bandit|CodeQL)/i;

  function isInsideNewLane(el){
    try{
      return !!(el && (el.id === "vsp_dash_only_toollane_host_v1"
                || el.closest?.("#vsp_dash_only_toollane_host_v1")
                || el.querySelector?.("#vsp_dash_only_toollane_grid_v1")));
    }catch(e){ return false; }
  }

  function hideNode(node, why){
    try{
      if (!node || isInsideNewLane(node)) return false;
      node.style.display = "none";
      node.setAttribute("data-vsp-hide", why || "legacy");
      return true;
    }catch(e){ return false; }
  }

  function hideLegacyOnce(){
    let hid = 0;

    // 1) Blocks around "Derived from run_gate_summary.json"
    const leaves = Array.from(document.querySelectorAll("*")).filter(el => el && el.children && el.children.length === 0);
    for (const el of leaves){
      const tx = (el.textContent || "").trim();
      if (!/Derived from run_gate_summary\.json/i.test(tx)) continue;

      // walk up until a container that looks like the legacy tool lane (has tools + UNKNOWN)
      let cur = el.parentElement;
      for (let i=0; i<10 && cur; i++){
        const t = cur.textContent || "";
        const unknownCnt = (t.match(/UNKNOWN/g) || []).length;
        if (toolsRe.test(t) && unknownCnt >= 1 && !isInsideNewLane(cur)){
          if (hideNode(cur, "legacy-toollane-derived")) hid++;
          break;
        }
        cur = cur.parentElement;
      }
    }

    // 2) UNKNOWN-heavy blocks that contain tool names (but NOT our new lane)
    const divs = Array.from(document.querySelectorAll("div"));
    for (const d of divs){
      if (!d || isInsideNewLane(d)) continue;
      const t = d.textContent || "";
      const unknownCnt = (t.match(/UNKNOWN/g) || []).length;
      if (unknownCnt >= 2 && toolsRe.test(t)){
        // extra safety: avoid hiding big page containers
        const len = t.length;
        if (len < 2200){
          if (hideNode(d, "unknown-heavy")) hid++;
        }
      }
    }

    return hid;
  }

  // run a few times to catch late renders
  let tries = 0;
  const timer = setInterval(()=> {
    tries++;
    const hid = hideLegacyOnce();
    if (hid > 0) console.log("[VSP][DASH_ONLY] dedupe hid blocks:", hid);
    if (tries >= 8) clearInterval(timer);
  }, 700);

  // also run once after a short delay
  setTimeout(()=> hideLegacyOnce(), 1200);

  console.log("[VSP][DASH_ONLY] toollane dedupe v1 active");
})();



   // Hook button "Load top findings (25)" to fetch findings_unified.json on-demand and render table.
   // - NO auto-fetch heavy data
   // - Cache per RID
   // - Robust DOM selectors (text-based)
// */  /* auto-fix: stray block-comment end */
(()=> {
  if (window.__vsp_p0_dash_only_load_top_findings_v1) return;
  window.__vsp_p0_dash_only_load_top_findings_v1 = true;

  const SEV_ORDER = ["CRITICAL","HIGH","MEDIUM","LOW","INFO","TRACE"];
  const SEV_W = {CRITICAL: 600, HIGH: 500, MEDIUM: 400, LOW: 300, INFO: 200, TRACE: 100};

  const cache = window.__vsp_dash_only_cache_findings || (window.__vsp_dash_only_cache_findings = {});

  const norm = (v)=> (v==null ? "" : String(v)).trim();
  const normSev = (v)=>{
    const x = norm(v).toUpperCase();
    if (!x) return "";
    // common aliases
    if (x === "CRIT") return "CRITICAL";
    if (x === "WARN") return "MEDIUM";
    if (x === "WARNING") return "MEDIUM";
    return SEV_ORDER.includes(x) ? x : x;
  };

  const pick = (obj, keys)=>{
    if (!obj || typeof obj !== "object") return "";
    for (const k of keys){
      if (obj[k] != null) return obj[k];
    }
    return "";
  };

  const pickTool = (f)=>{
    return norm(
      pick(f, ["tool","engine","scanner","source","detector","product","provider"]) ||
      pick(f?.meta, ["tool","engine","scanner","source"]) ||
      pick(f?.extra, ["tool","engine","scanner","source"])
    ) || "UNKNOWN";
  };

  const pickSeverity = (f)=>{
    return normSev(
      pick(f, ["severity","sev","level","priority"]) ||
      pick(f?.meta, ["severity","sev","level","priority"]) ||
      pick(f?.extra, ["severity","sev","level","priority"])
    ) || "INFO";
  };

  const pickTitle = (f)=>{
    return norm(
      pick(f, ["title","message","name","summary","rule_name","rule","check_name","id","rule_id","query_name"]) ||
      pick(f?.meta, ["title","message","name","summary","rule_name","rule","check_name","id","rule_id"]) ||
      pick(f?.extra, ["title","message","name","summary","rule_name","rule","check_name","id","rule_id"])
    ) || "(no title)";
  };

  const pickLocation = (f)=>{
    // try common file fields
    const file = norm(
      pick(f, ["path","file","filename","file_path","filepath","uri"]) ||
      pick(f?.location, ["path","file","filename","file_path","filepath","uri"]) ||
      pick(f?.meta, ["path","file","filename","file_path","filepath","uri"]) ||
      pick(f?.extra, ["path","file","filename","file_path","filepath","uri"])
    );

    const line = pick(f, ["line","start_line","begin_line"]) || pick(f?.location, ["line","start_line","begin_line"]) || "";
    const col  = pick(f, ["col","column","start_col"]) || pick(f?.location, ["col","column","start_col"]) || "";

    const lc = (line || col) ? `:${line||""}${col?":"+col:""}` : "";
    return (file ? (file + lc) : (lc ? lc.slice(1) : "(no path)"));
  };

  async function getLatestRid(){
    const url = `/api/vsp/rid_latest_gate_root?_=${Date.now()}`;
    const r = await fetch(url, {cache:"no-store"});
    if (!r.ok) throw new Error(`rid_latest_gate_root http ${r.status}`);
    const j = await r.json();
    if (!j || !j.ok || !j.rid) throw new Error("rid_latest_gate_root invalid json");
    return j.rid;
  }

  async function fetchFindings(rid){
    const url = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=findings_unified.json&_=${Date.now()}`;
    const r = await fetch(url, {cache:"no-store"});
    if (!r.ok) throw new Error(`findings_unified http ${r.status}`);
    const j = await r.json();
    const arr = Array.isArray(j) ? j : (Array.isArray(j?.findings) ? j.findings : []);
    return arr;
  }

  function scoreFinding(f){
    const sev = pickSeverity(f);
    const w = SEV_W[sev] || 150;
    // prefer items with a path/title
    const hasPath = pickLocation(f) && pickLocation(f) !== "(no path)" ? 20 : 0;
    const hasTitle = pickTitle(f) && pickTitle(f) !== "(no title)" ? 10 : 0;
    return w + hasPath + hasTitle;
  }

  function findButton(){
    const btns = Array.from(document.querySelectorAll("button, a"));
    for (const b of btns){
      const t = (b.textContent || "").trim();
      if (/^Load top findings\s*\(\s*25\s*\)\s*$/i.test(t)) return b;
    }
    return null;
  }

  function findTopFindingsTable(){
    // Find a heading-like leaf containing "Top findings"
    const leaves = Array.from(document.querySelectorAll("*"))
      .filter(el => el && el.children && el.children.length === 0);

    let anchor = null;
    for (const el of leaves){
      const tx = (el.textContent || "").trim();
      if (/^Top findings/i.test(tx)) { anchor = el; break; }
    }
    // fallback: any element with that substring
    if (!anchor){
      for (const el of leaves){
        const tx = (el.textContent || "").trim();
        if (/Top findings/i.test(tx)) { anchor = el; break; }
      }
    }
    if (!anchor) return null;

    // climb up to find a table inside
    let cur = anchor.parentElement;
    for (let i=0; i<12 && cur; i++){
      const t = cur.querySelector("table");
      if (t) return t;
      cur = cur.parentElement;
    }
    return null;
  }

  function renderRows(rows){
    const table = findTopFindingsTable();
    if (!table){
      console.warn("[VSP][DASH_ONLY] top findings table not found");
      return false;
    }
    let tbody = table.querySelector("tbody");
    if (!tbody){
      tbody = document.createElement("tbody");
      table.appendChild(tbody);
    }
    tbody.innerHTML = "";

    for (const r of rows){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.sev}</td>
        <td>${r.tool}</td>
        <td title="${r.title.replaceAll('"','&quot;')}">${r.title}</td>
        <td title="${r.loc.replaceAll('"','&quot;')}">${r.loc}</td>
      `;
      tbody.appendChild(tr);
    }
    return true;
  }

  function renderMessage(msg){
    const table = findTopFindingsTable();
    if (!table) return;
    let tbody = table.querySelector("tbody");
    if (!tbody){
      tbody = document.createElement("tbody");
      table.appendChild(tbody);
    }
    tbody.innerHTML = `<tr><td colspan="4">${msg}</td></tr>`;
  }

  async function onClick(){
    const btn = findButton();
    if (!btn) return;

    btn.setAttribute("disabled","disabled");
    const old = btn.textContent;
    btn.textContent = "Loading…";

    try{
      const rid = await getLatestRid();
      if (cache[rid]){
        renderRows(cache[rid]);
        console.log("[VSP][DASH_ONLY] top findings from cache rid=", rid);
        return;
      }

      const arr = await fetchFindings(rid);
      if (!arr || arr.length === 0){
        renderMessage("No findings_unified.json (or empty).");
        console.warn("[VSP][DASH_ONLY] findings_unified empty rid=", rid);
        return;
      }

      const picked = arr
        .filter(x => x && typeof x === "object")
        .map(f => ({
          sev: pickSeverity(f),
          tool: pickTool(f),
          title: pickTitle(f),
          loc: pickLocation(f),
          _score: scoreFinding(f),
        }))
        .sort((a,b)=> (b._score - a._score) || (a.tool.localeCompare(b.tool)) || (a.title.localeCompare(b.title)))
        .slice(0, 25)
        .map(x => ({sev:x.sev, tool:x.tool, title:x.title, loc:x.loc}));

      cache[rid] = picked;
      renderRows(picked);
      console.log("[VSP][DASH_ONLY] loaded top findings rid=", rid, "n=", picked.length);
    }catch(e){
      console.warn("[VSP][DASH_ONLY] load top findings failed:", e);
      renderMessage("Load failed (see console).");
    }finally{
      // restore button
      btn.textContent = old || "Load top findings (25)";
      btn.removeAttribute("disabled");
    }
  }

  function bind(){
    const btn = findButton(); // may be null until UI renders
    if (!btn) return false;
    if (btn.__vsp_bound_topfind) return true;
    btn.__vsp_bound_topfind = true;
    btn.addEventListener("click", (ev)=> { ev.preventDefault(); onClick(); }, {passive:false});
    console.log("[VSP][DASH_ONLY] top-findings hook bound");
    return true;
  }

  // bind now + retry a few times (in case of late render)
  let tries = 0;
  const timer = setInterval(()=> {
    tries++;
    if (bind() || tries >= 12) clearInterval(timer);
  }, 500);

  setTimeout(bind, 1200);
  console.log("[VSP][DASH_ONLY] top-findings v1 active");
})();

/* VSP_P0_DASH_ONLY_LOAD_TOP_FINDINGS_V2
   Replace v1 with robust render into the "Not loaded" area (no fragile table selector).
   Debug logs: click -> rid -> fetch -> render.
// */  /* auto-fix: stray block-comment end */
(()=> {
  if (window.__vsp_p0_dash_only_load_top_findings_v2) return;
  window.__vsp_p0_dash_only_load_top_findings_v2 = true;

  const cache = window.__vsp_dash_only_cache_findings || (window.__vsp_dash_only_cache_findings = {});
  const SEV_W = {CRITICAL:600,HIGH:500,MEDIUM:400,LOW:300,INFO:200,TRACE:100};

  const norm = (v)=> (v==null ? "" : String(v)).trim();
  const normSev = (v)=>{
    const x = norm(v).toUpperCase();
    if (!x) return "INFO";
    if (x === "CRIT") return "CRITICAL";
    if (x === "WARN" || x === "WARNING") return "MEDIUM";
    return x;
  };

  const pick = (obj, keys)=>{
    if (!obj || typeof obj !== "object") return "";
    for (const k of keys) if (obj[k] != null) return obj[k];
    return "";
  };

  const pickTool = (f)=> norm(
    pick(f, ["tool","engine","scanner","source","detector","product","provider"]) ||
    pick(f?.meta, ["tool","engine","scanner","source"]) ||
    pick(f?.extra, ["tool","engine","scanner","source"])
  ) || "UNKNOWN";

  const pickSeverity = (f)=> normSev(
    pick(f, ["severity","sev","level","priority"]) ||
    pick(f?.meta, ["severity","sev","level","priority"]) ||
    pick(f?.extra, ["severity","sev","level","priority"])
  );

  const pickTitle = (f)=> norm(
    pick(f, ["title","message","name","summary","rule_name","rule","check_name","id","rule_id","query_name"]) ||
    pick(f?.meta, ["title","message","name","summary","rule_name","rule","check_name","id","rule_id"]) ||
    pick(f?.extra, ["title","message","name","summary","rule_name","rule","check_name","id","rule_id"])
  ) || "(no title)";

  const pickLocation = (f)=>{
    const file = norm(
      pick(f, ["path","file","filename","file_path","filepath","uri"]) ||
      pick(f?.location, ["path","file","filename","file_path","filepath","uri"]) ||
      pick(f?.meta, ["path","file","filename","file_path","filepath","uri"]) ||
      pick(f?.extra, ["path","file","filename","file_path","filepath","uri"])
    );
    const line = pick(f, ["line","start_line","begin_line"]) || pick(f?.location, ["line","start_line","begin_line"]) || "";
    const col  = pick(f, ["col","column","start_col"]) || pick(f?.location, ["col","column","start_col"]) || "";
    const lc = (line || col) ? `:${line||""}${col?":"+col:""}` : "";
    return (file ? (file + lc) : "(no path)");
  };

  function scoreFinding(f){
    const sev = pickSeverity(f);
    const w = SEV_W[sev] || 150;
    const hasPath = pickLocation(f) !== "(no path)" ? 20 : 0;
    const hasTitle = pickTitle(f) !== "(no title)" ? 10 : 0;
    return w + hasPath + hasTitle;
  }

  async function getLatestRid(){
    const url = `/api/vsp/rid_latest_gate_root?_=${Date.now()}`;
    const r = await fetch(url, {cache:"no-store"});
    if (!r.ok) throw new Error(`rid_latest http ${r.status}`);
    const j = await r.json();
    if (!j?.ok || !j?.rid) throw new Error("rid_latest invalid json");
    return j.rid;
  }

  async function fetchFindings(rid){
    const url = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=findings_unified.json&_=${Date.now()}`;
    const r = await fetch(url, {cache:"no-store"});
    if (!r.ok) throw new Error(`findings http ${r.status}`);
    const j = await r.json();
    const arr = Array.isArray(j) ? j : (Array.isArray(j?.findings) ? j.findings : []);
    return arr;
  }

  function findButton(){
    const btns = Array.from(document.querySelectorAll("button, a"));
    for (const b of btns){
      const t = (b.textContent || "").trim();
      if (/^Load top findings\s*\(\s*25\s*\)\s*$/i.test(t)) return b;
    }
    return null;
  }

  function findTopFindingsSectionRoot(){
    // Find "Top findings" label, then climb to a container that contains the column headers
    const all = Array.from(document.querySelectorAll("*"));
    const leaf = all.find(el => (el.textContent||"").trim().toLowerCase().startsWith("top findings"));
    if (!leaf) return null;

    let cur = leaf;
    for (let i=0; i<14 && cur; i++){
      const txt = (cur.textContent||"").toLowerCase();
      if (txt.includes("severity") && txt.includes("tool") && txt.includes("title") && txt.includes("location")){
        return cur;
      }
      cur = cur.parentElement;
    }
    return leaf.parentElement;
  }

  function renderMessage(msg){
    const root = findTopFindingsSectionRoot();
    if (!root) { console.warn("[VSP][DASH_ONLY] topfind root not found"); return; }

    // Prefer replacing the "Not loaded" cell if present
    const nl = Array.from(root.querySelectorAll("*")).find(el => (el.textContent||"").trim().toLowerCase() === "not loaded");
    if (nl){
      nl.textContent = msg;
      return;
    }

    // fallback: append a small message block
    let box = root.querySelector("[data-vsp-topfind-msg]");
    if (!box){
      box = document.createElement("div");
      box.setAttribute("data-vsp-topfind-msg","1");
      box.style.marginTop = "8px";
      root.appendChild(box);
    }
    box.textContent = msg;
  }

  function renderRows(rows){
    const root = findTopFindingsSectionRoot();
    if (!root) { console.warn("[VSP][DASH_ONLY] topfind root not found"); return false; }

    // If there's a table, use it; otherwise replace "Not loaded" area with a mini table.
    const table = root.querySelector("table");
    if (table){
      let tbody = table.querySelector("tbody");
      if (!tbody){
        tbody = document.createElement("tbody");
        table.appendChild(tbody);
      }
      tbody.innerHTML = "";
      for (const r of rows){
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${r.sev}</td><td>${r.tool}</td><td>${r.title}</td><td>${r.loc}</td>`;
        tbody.appendChild(tr);
      }
      return true;
    }

    // No table: replace "Not loaded" node's parent with table markup
    const nl = Array.from(root.querySelectorAll("*")).find(el => (el.textContent||"").trim().toLowerCase() === "not loaded");
    const host = nl ? (nl.closest("div") || nl.parentElement || root) : root;

    const html = [
      `<table style="width:100%;border-collapse:collapse;margin-top:6px">`,
      `<tbody>`,
      ...rows.map(r => `<tr><td>${r.sev}</td><td>${r.tool}</td><td>${r.title}</td><td>${r.loc}</td></tr>`),
      `</tbody></table>`
    ].join("");

    host.innerHTML = html;
    return true;
  }

  async function onClick(){
    console.log("[VSP][DASH_ONLY] topfind click");
    const btn = findButton();
    if (!btn) { console.warn("[VSP][DASH_ONLY] topfind button missing"); return; }

    btn.setAttribute("disabled","disabled");
    const old = btn.textContent;
    btn.textContent = "Loading…";

    try{
      const rid = await getLatestRid();
      console.log("[VSP][DASH_ONLY] topfind rid=", rid);

      if (cache[rid]){
        renderRows(cache[rid]);
        console.log("[VSP][DASH_ONLY] topfind from cache n=", cache[rid].length);
        return;
      }

      const arr = await fetchFindings(rid);
      console.log("[VSP][DASH_ONLY] topfind raw findings n=", arr?.length || 0);

      if (!arr || arr.length === 0){
        renderMessage("No findings_unified.json (or empty).");
        return;
      }

      const picked = arr
        .filter(x => x && typeof x === "object")
        .map(f => ({
          sev: pickSeverity(f),
          tool: pickTool(f),
          title: pickTitle(f),
          loc: pickLocation(f),
          _score: scoreFinding(f),
        }))
        .sort((a,b)=> (b._score - a._score))
        .slice(0, 25)
        .map(x => ({sev:x.sev, tool:x.tool, title:x.title, loc:x.loc}));

      cache[rid] = picked;
      const ok = renderRows(picked);
      console.log("[VSP][DASH_ONLY] topfind render ok=", ok, "n=", picked.length);
      if (!ok) renderMessage("Render target not found (see console).");
    }catch(e){
      console.warn("[VSP][DASH_ONLY] topfind failed:", e);
      renderMessage("Load failed (see console).");
    }finally{
      btn.textContent = old || "Load top findings (25)";
      btn.removeAttribute("disabled");
    }
  }

  function bind(){
    const btn = findButton();
    if (!btn) return false;
    if (btn.__vsp_bound_topfind_v2) return true;
    btn.__vsp_bound_topfind_v2 = true;
    btn.addEventListener("click", (ev)=>{ ev.preventDefault(); onClick(); }, {passive:false});
    console.log("[VSP][DASH_ONLY] topfind v2 hook bound");
    return true;
  }

  let tries = 0;
  const t = setInterval(()=>{ tries++; if (bind() || tries>=14) clearInterval(t); }, 500);
  setTimeout(bind, 1200);

  console.log("[VSP][DASH_ONLY] topfind v2 active");
})();


/* VSP_P0_DASH_ONLY_FETCH_FALLBACK_FINDINGS_V1 */
(()=> {
  if (window.__vsp_p0_dash_only_fetch_fallback_findings_v1) return;
  window.__vsp_p0_dash_only_fetch_fallback_findings_v1 = true;

  const orig = window.fetch ? window.fetch.bind(window) : null;
  if (!orig) return;

  const shouldHandle = (url)=> (
    typeof url === "string" &&
    url.includes("/api/vsp/run_file_allow") &&
    url.includes("path=findings_unified.json")
  );

  const toReports = (url)=> url.replace("path=findings_unified.json", "path=reports/findings_unified.json");

  window.fetch = async (input, init)=>{
    try{
      const url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
      if (!shouldHandle(url)) return orig(input, init);

      // 1st try
      let res = await orig(input, init);
      if (res && res.status === 404) {
        const url2 = toReports(url);
        console.warn("[VSP][DASH_ONLY] findings_unified.json 404 => retry:", url2);
        res = await orig(url2, init);
      }
      return res;
    } catch(e){
      return orig(input, init);
    }
  };

  console.log("[VSP][DASH_ONLY] fetch fallback findings v1 active");
})();


/* VSP_P0_DASH_ONLY_TOPFIND_USE_CSV_V1 */
(()=> {
  if (window.__vsp_p0_dash_only_topfind_use_csv_v1) return;
  window.__vsp_p0_dash_only_topfind_use_csv_v1 = true;

  const SEV_W = {CRITICAL: 600, HIGH: 500, MEDIUM: 400, LOW: 300, INFO: 200, TRACE: 100};
  const norm = (v)=> (v==null ? "" : String(v)).trim();
  const up = (v)=> norm(v).toUpperCase();

  // minimal CSV parser (handles quotes + commas)
  const parseCSV = (txt)=>{
    const rows = [];
    let i=0, cur="", row=[], inQ=false;
    const pushCell=()=>{ row.push(cur); cur=""; };
    const pushRow=()=>{ rows.push(row); row=[]; };
    while (i < txt.length) {
      const ch = txt[i++];
      if (inQ) {
        if (ch === '"') {
          if (txt[i] === '"') { cur += '"'; i++; } else { inQ = false; }
        } else cur += ch;
      } else {
        if (ch === '"') inQ = true;
        else if (ch === ',') pushCell();
        else if (ch === '\n') { pushCell(); pushRow(); }
        else if (ch === '\r') { /* ignore */ }
        else cur += ch;
      }
    }
    // last
    if (cur.length || row.length) { pushCell(); pushRow(); }
    // drop empty tail rows
    return rows.filter(r=> r.some(c=> String(c||"").trim() !== ""));
  };

  const normKey = (k)=> norm(k).toLowerCase().replace(/[^a-z0-9]+/g,"");
  const pickKey = (keys, wants)=>{
    const kmap = new Map(keys.map(k=> [normKey(k), k]));
    for (const w of wants) {
      for (const [nk, orig] of kmap.entries()){
        if (nk === w) return orig;
      }
    }
    // contains fallback
    for (const w of wants) {
      for (const [nk, orig] of kmap.entries()){
        if (nk.includes(w)) return orig;
      }
    }
    return "";
  };

  const getRID = async ()=>{
    try{
      const r = await fetch("/api/vsp/rid_latest_gate_root");
      const j = await r.json();
      return j && j.rid ? j.rid : "";
    }catch(e){ return ""; }
  };

  const findTopBlock = ()=>{
    // find by heading text if possible
    const nodes = Array.from(document.querySelectorAll("div,section"));
    for (const n of nodes){
      const t = (n.textContent || "");
      if (t.includes("Top findings")) return n;
    }
    // fallback: first table container
    return document.querySelector("table")?.parentElement || document.body;
  };

  const renderTable = (items)=>{
    const host = findTopBlock();
    let table = host.querySelector("table");
    if (!table) {
      table = document.createElement("table");
      table.style.width="100%";
      table.style.borderCollapse="collapse";
      table.innerHTML = "<thead><tr><th>Severity</th><th>Tool</th><th>Title</th><th>Location</th></tr></thead><tbody></tbody>";
      host.appendChild(table);
    }
    const tbody = table.querySelector("tbody") || table.appendChild(document.createElement("tbody"));
    tbody.innerHTML = "";
    for (const it of items){
      const tr = document.createElement("tr");
      const cells = [it.severity, it.tool, it.title, it.location];
      for (const c of cells){
        const td = document.createElement("td");
        td.textContent = c || "";
        td.style.padding="8px 10px";
        td.style.borderTop="1px solid rgba(255,255,255,0.06)";
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  };

  const loadTop = async (limit=25)=>{
    const rid = await getRID();
    if (!rid) throw new Error("no rid");
    const url = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=${encodeURIComponent("reports/findings_unified.csv")}`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error("csv fetch failed: "+resp.status);
    const txt = await resp.text();
    const rows = parseCSV(txt);
    if (!rows.length) throw new Error("empty csv");
    const header = rows[0];
    const keys = header;

    const kSev = pickKey(keys, ["severity","sev","level","risk","prio","priority"]);
    const kTool = pickKey(keys, ["tool","scanner","source","engine"]);
    const kTitle = pickKey(keys, ["title","rule","message","name","check","id"]);
    const kLoc  = pickKey(keys, ["location","path","file","filename","resource","uri"]);

    const idx = (k)=> k ? keys.indexOf(k) : -1;

    const iSev = idx(kSev);
    const iTool= idx(kTool);
    const iTit = idx(kTitle);
    const iLoc = idx(kLoc);

    const items = [];
    for (let r=1;r<rows.length;r++){
      const row = rows[r];
      const sevRaw = (iSev>=0? row[iSev] : "");
      const sev = up(sevRaw);
      const sevN = (sev==="CRIT"?"CRITICAL":sev);
      items.push({
        severity: sevN || "",
        tool: norm(iTool>=0? row[iTool] : ""),
        title: norm(iTit>=0? row[iTit] : ""),
        location: norm(iLoc>=0? row[iLoc] : "")
      });
    }

    // sort by severity weight desc then keep first N
    items.sort((a,b)=> (SEV_W[b.severity]||0)-(SEV_W[a.severity]||0));
    renderTable(items.slice(0, limit));
    return true;
  };

  const hookBtn = ()=>{
    const btns = Array.from(document.querySelectorAll("button,a"));
    const target = btns.find(b=> (b.textContent||"").toLowerCase().includes("load top findings"));
    if (!target) return false;

    // override click (avoid previous handlers)
    target.addEventListener("click", async (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      try{
        const old = target.textContent;
        target.textContent = "Loading…";
        target.disabled = true;
        await loadTop(25);
        target.textContent = old || "Load top findings (25)";
      }catch(e){
        console.warn("[VSP][DASH_ONLY] topfind csv load failed:", e);
        target.textContent = "Load top findings (25)";
      }finally{
        target.disabled = false;
      }
    }, true);

    console.log("[VSP][DASH_ONLY] topfind csv hook bound");
    return true;
  };

  // bind now + retry a few times
  let tries=0;
  const t = setInterval(()=>{
    tries++;
    if (hookBtn() || tries>=10) clearInterval(t);
  }, 500);
})();


/* VSP_P0_DASH_ONLY_TOPFIND_CSV_MAPPING_V2
   - Use reports/findings_unified.csv (allowed=200)
   - Exact mapping: severity,tool,rule_id,title,file,line,message
   - Location = file:line
   - Title = title (fallback: rule_id) + (message short)
   - Capture-phase click override to avoid older hooks fighting
*/
(()=> {
  if (window.__vsp_p0_dash_only_topfind_csv_mapping_v2) return;
  window.__vsp_p0_dash_only_topfind_csv_mapping_v2 = true;

  const SEV_W = {CRITICAL:600, HIGH:500, MEDIUM:400, LOW:300, INFO:200, TRACE:100};
  const norm = (v)=> (v==null ? "" : String(v)).trim();
  const up   = (v)=> norm(v).toUpperCase();
  const clip = (t, n)=> { t=norm(t); return (t.length>n) ? (t.slice(0,n-1)+"…") : t; };

  const parseCSV = (txt)=>{
    const rows=[]; let i=0, cur="", row=[], inQ=false;
    const pushCell=()=>{ row.push(cur); cur=""; };
    const pushRow=()=>{ rows.push(row); row=[]; };
    while(i<txt.length){
      const ch=txt[i++];
      if(inQ){
        if(ch==='"'){
          if(txt[i]==='"'){ cur+='"'; i++; } else inQ=false;
        } else cur+=ch;
      } else {
        if(ch==='"') inQ=true;
        else if(ch===',') pushCell();
        else if(ch==='\n'){ pushCell(); pushRow(); }
        else if(ch==='\r'){ /* ignore */ }
        else cur+=ch;
      }
    }
    if(cur.length || row.length){ pushCell(); pushRow(); }
    return rows.filter(r=> r.some(c=> String(c||"").trim()!==""));
  };

  const getRID = async ()=>{
    const r = await fetch("/api/vsp/rid_latest_gate_root");
    const j = await r.json();
    return j && j.rid ? j.rid : "";
  };

  const findTopHost = ()=>{
    // Try to find the "Top findings" card
    const cards = Array.from(document.querySelectorAll("div,section"));
    for(const c of cards){
      const t = (c.textContent||"");
      if(t.includes("Top findings")) return c;
    }
    return document.body;
  };

  const ensureTable = ()=>{
    const host = findTopHost();
    let table = host.querySelector("table");
    if(!table){
      table = document.createElement("table");
      table.style.width="100%";
      table.style.borderCollapse="collapse";
      table.innerHTML = "<thead><tr><th>Severity</th><th>Tool</th><th>Title</th><th>Location</th></tr></thead><tbody></tbody>";
      host.appendChild(table);
    }
    return table;
  };

  const render = (items)=>{
    const table = ensureTable();
    const tbody = table.querySelector("tbody") || table.appendChild(document.createElement("tbody"));
    tbody.innerHTML = "";
    for(const it of items){
      const tr=document.createElement("tr");
      const cells=[it.severity,it.tool,it.title,it.location];
      for(const c of cells){
        const td=document.createElement("td");
        td.textContent = c || "";
        td.style.padding="8px 10px";
        td.style.borderTop="1px solid rgba(255,255,255,0.06)";
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  };

  const loadTopCsv = async (limit=25)=>{
    const rid = await getRID();
    if(!rid) throw new Error("no rid");
    const path = "reports/findings_unified.csv";
    const url = `/api/vsp/run_file_allow?rid=${encodeURIComponent(rid)}&path=${encodeURIComponent(path)}`;
    const resp = await fetch(url);
    if(!resp.ok) throw new Error("csv fetch failed: "+resp.status);
    const txt = await resp.text();
    const rows = parseCSV(txt);
    if(rows.length < 2) throw new Error("csv empty");

    const h = rows[0].map(x=> norm(x));
    const idx = (k)=> h.indexOf(k);

    // exact expected headers
    const iSev = idx("severity");
    const iTool= idx("tool");
    const iRid = idx("rule_id");
    const iTit = idx("title");
    const iFile= idx("file");
    const iLine= idx("line");
    const iMsg = idx("message");

    const items=[];
    for(let r=1;r<rows.length;r++){
      const row = rows[r];
      const sevRaw = (iSev>=0? row[iSev] : "");
      let sev = up(sevRaw);
      if(sev==="CRIT") sev="CRITICAL";
      if(!sev) sev="";

      const tool = norm(iTool>=0? row[iTool] : "");
      const rid2 = norm(iRid>=0? row[iRid] : "");
      const tit  = norm(iTit>=0? row[iTit] : "");
      const file = norm(iFile>=0? row[iFile] : "");
      const line = norm(iLine>=0? row[iLine] : "");
      const msg  = norm(iMsg>=0? row[iMsg] : "");

      const titleBase = tit || rid2 || "(no title)";
      const title = msg ? (titleBase + " — " + clip(msg, 140)) : titleBase;
      const loc = (file && line) ? `${file}:${line}` : (file || "");

      items.push({severity:sev, tool, title, location:loc});
    }

    items.sort((a,b)=> (SEV_W[b.severity]||0)-(SEV_W[a.severity]||0));
    render(items.slice(0, limit));
    return true;
  };

  const hook = ()=>{
    const btns = Array.from(document.querySelectorAll("button,a"));
    const b = btns.find(x=> (x.textContent||"").toLowerCase().includes("load top findings"));
    if(!b) return false;

    // CAPTURE override: stop old hooks fighting
    b.addEventListener("click", async (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();

      const old = b.textContent || "Load top findings (25)";
      try{
        b.textContent = "Loading…";
        b.disabled = true;
        await loadTopCsv(25);
        b.textContent = old;
        console.log("[VSP][DASH_ONLY] topfind csv v2 loaded");
      }catch(e){
        console.warn("[VSP][DASH_ONLY] topfind csv v2 failed:", e);
        b.textContent = old;
      }finally{
        b.disabled = false;
      }
    }, true);

    console.log("[VSP][DASH_ONLY] topfind csv v2 hook bound");
    return true;
  };

  let tries=0;
  const t=setInterval(()=>{ tries++; if(hook() || tries>=12) clearInterval(t); }, 500);
})();
