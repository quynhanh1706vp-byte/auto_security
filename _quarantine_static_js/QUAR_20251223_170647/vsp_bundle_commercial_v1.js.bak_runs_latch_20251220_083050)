/* VSP_BUNDLE_COMMERCIAL_V1_STUB_P1_V1
   This file was broken (syntax error). Keep as safe stub that loads v2. */
(function(){
  try{
    if (window.__vsp_bundle_commercial_v1_stub) return;
    window.__vsp_bundle_commercial_v1_stub = true;
    var s=document.createElement("script");
    s.src="/static/js/vsp_bundle_commercial_v2.js";
    s.defer=true;
    (document.head||document.documentElement).appendChild(s);
    console.warn("[VSP] v1 bundle stub loaded -> redirected to v2");
  }catch(e){}
})();

/* ===== VSP_P0_RUNS_REPORTS_COMMERCIAL_POLISH_V1 =====
   - Default no-filter + limit=50
   - Bind row click -> localStorage vsp_rid_selected_v2
   - Fix rid_latest fetch order + reduce noisy warn
   Safe: no-op if elements not present.
*/
(function(){
  try{
    function _qs(sel, root){ try{ return (root||document).querySelector(sel);}catch(e){return null;} }
    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel));}catch(e){return [];} }

    function vspSetSelectedRid(rid){
      if(!rid) return;
      try{ localStorage.setItem('vsp_rid_selected_v2', rid); }catch(e){}
      try{ localStorage.setItem('vsp_rid_selected', rid); }catch(e){} // compat
      // optional badges (nếu có)
      const badge =
        document.getElementById('vsp-selected-rid-badge') ||
        document.getElementById('vsp-rid-selected') ||
        document.getElementById('vsp-rid-latest') ||
        _qs('[data-vsp-selected-rid]') ||
        _qs('[data-selected-rid]');
      if(badge){
        try{ badge.textContent = rid; }catch(e){}
      }
    }

    function vspRunsDefaultNoFilterAndLimit(){
      // cố gắng set default limit=50 nếu có input/select
      const limitEls = [
        document.getElementById('limit'),
        document.getElementById('runs-limit'),
        document.getElementById('vsp-runs-limit'),
        _qs('input[name="limit"]'),
        _qs('select[name="limit"]'),
      ].filter(Boolean);

      for(const el of limitEls){
        try{
          if(el.tagName === 'SELECT'){
            // chọn option 50 nếu có
            const opt = Array.from(el.options||[]).find(o => String(o.value) === '50');
            if(opt){ el.value='50'; }
          }else{
            // input
            if(!el.value || String(el.value).trim()==='' || String(el.value)==='20' || String(el.value)==='10'){
              el.value = '50';
            }
          }
        }catch(e){}
      }

      // đảm bảo default không tick filter
      const ids = [
        'has_json','has_summary','has_html','has_csv','has_sarif',
        'filter','filter_on','hide_empty','only_with_artifacts'
      ];
      for(const id of ids){
        const el = document.getElementById(id);
        if(el && (el.type === 'checkbox' || el.type === 'radio')){
          try{ el.checked = false; }catch(e){}
        }
      }
      // các checkbox theo name (phòng khi id khác)
      _qsa('input[type="checkbox"][name^="has_"], input[type="checkbox"][name*="has"]')
        .forEach(el => { try{ el.checked = false; }catch(e){} });
    }

    function vspBindRidRowClick(){
      // delegate click: tìm ancestor có data-run-id/data-rid
      document.addEventListener('click', function(e){
        const t = e.target;
        if(!t || !t.closest) return;
        const holder = t.closest('[data-run-id],[data-rid],[data-runid],tr[data-run-id],tr[data-rid],tr[data-runid]');
        if(!holder) return;
        const rid = holder.getAttribute('data-run-id') || holder.getAttribute('data-rid') || holder.getAttribute('data-runid');
        if(rid) vspSetSelectedRid(rid);
      }, true);
    }

    async function vspFixRidLatestAfterRunsLoad(){
      // chỉ fetch 1 lần, nhẹ
      try{
        const res = await fetch('/api/vsp/runs?limit=1');
        if(!res.ok) return;
        const j = await res.json();
        const rid = (j && j.items && j.items[0] && (j.items[0].run_id || j.items[0].rid)) || j.rid_latest;
        if(rid) vspSetSelectedRid(rid);
      }catch(e){}
    }

    function boot(){
      vspRunsDefaultNoFilterAndLimit();
      vspBindRidRowClick();
      // rid_latest: chạy async sau, tránh log N/A quá sớm
      setTimeout(vspFixRidLatestAfterRunsLoad, 350);
    }

    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', boot);
    }else{
      boot();
    }
  }catch(_e){}
})();

/* ===== VSP_P0_RUN_BADGE_AND_FILTER_RESET_V1 =====
   Goals:
   - Force default Runs tab = no-filter (clear persisted has/filter keys) + limit=50
   - Update header badge "ENV: ... RUN: ..." even if element has no id
   - Refresh runs list once after reset (best-effort)
*/
(function(){
  try{
    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(e){ return []; } }
    function _qs(sel, root){ try{ return (root||document).querySelector(sel); }catch(e){ return null; } }

    function vspUpdateRunBadge(rid){
      if(!rid) return;
      // 1) try known ids first
      const known = [
        'vsp-run-badge','vsp-run-id-badge','vsp-selected-run','vsp-selected-rid-badge',
        'vsp-rid-selected','vsp-rid-latest'
      ];
      for(const id of known){
        const el=document.getElementById(id);
        if(el){ try{ el.textContent = String(el.textContent||'').replace(/RUN:\s*[^|]+/i, 'RUN: '+rid); if(el.textContent===String(el.textContent||'')) el.textContent = rid; }catch(e){} return; }
      }

      // 2) heuristic: find any small badge-like element containing "ENV:" and "RUN:"
      const nodes=_qsa('span,div,small,label');
      for(const el of nodes){
        const t=(el.textContent||'').trim();
        if(!t) continue;
        if(t.includes('ENV:') && t.includes('RUN:')){
          try{
            el.textContent = t.replace(/RUN:\s*[^|]+/i, 'RUN: '+rid);
          }catch(e){}
          return;
        }
      }
    }

    function vspSetSelectedRid(rid){
      if(!rid) return;
      try{ localStorage.setItem('vsp_rid_selected_v2', rid); }catch(e){}
      try{ localStorage.setItem('vsp_rid_selected', rid); }catch(e){}
      vspUpdateRunBadge(rid);
    }

    function vspClearRunsFilterState(){
      // Clear persisted filters that cause "Showing 7 of 298"
      try{
        const ks = Object.keys(localStorage||{});
        for(const k of ks){
          const kl = (k||'').toLowerCase();
          if(
            kl.includes('runs_filter') ||
            kl.includes('vsp_runs') ||
            kl.includes('has_json') || kl.includes('has_summary') || kl.includes('has_html') || kl.includes('has_csv') || kl.includes('has_sarif') ||
            kl.startswith?.('has_') ||
            kl.includes('only_with') ||
            kl.includes('filter_has') ||
            kl.includes('filter_artifact') ||
            kl.includes('runs_limit')
          ){
            try{ localStorage.removeItem(k); }catch(e){}
          }
        }
      }catch(e){}

      // Uncheck any has_* checkbox by id or name
      _qsa('input[type="checkbox"]').forEach(el=>{
        const id=(el.id||'').toLowerCase();
        const nm=(el.name||'').toLowerCase();
        if(id.startsWith('has_') || nm.startsWith('has_') || id.includes('only_with') || nm.includes('only_with')){
          try{ el.checked=false; }catch(e){}
        }
      });

      // Set limit to 50 if there is a limit control
      const limitEls = [
        document.getElementById('limit'),
        document.getElementById('runs-limit'),
        document.getElementById('vsp-runs-limit'),
        _qs('input[name="limit"]'),
        _qs('select[name="limit"]'),
      ].filter(Boolean);

      for(const el of limitEls){
        try{
          if(el.tagName==='SELECT'){
            const opt=Array.from(el.options||[]).find(o=>String(o.value)==='50');
            if(opt) el.value='50';
          }else{
            el.value='50';
          }
        }catch(e){}
      }

      // Clear search box if any
      ['q','runs-q','vsp-runs-q','search','runs-search'].forEach(id=>{
        const el=document.getElementById(id);
        if(el && (el.tagName==='INPUT' || el.tagName==='TEXTAREA')){
          try{ el.value=''; }catch(e){}
        }
      });
    }

    async function vspFixRidLatestAfterRunsLoad(){
      try{
        const res=await fetch('/api/vsp/runs?limit=1');
        if(!res.ok) return;
        const j=await res.json();
        const rid=(j && j.items && j.items[0] && (j.items[0].run_id || j.items[0].rid)) || j.rid_latest;
        if(rid) vspSetSelectedRid(rid);
      }catch(e){}
    }

    function vspBestEffortRefreshRuns(){
      // click a refresh button if exists
      const btn =
        document.getElementById('runs-refresh') ||
        _qs('[data-action="refresh-runs"]') ||
        _qs('[data-vsp-refresh-runs]');

      if(btn && btn.click){
        try{ btn.click(); return; }catch(e){}
      }
      // fallback: call common global if present
      const fns = ['refreshRuns','loadRuns','initRunsTab','vspRunsRefresh'];
      for(const n of fns){
        try{
          if(typeof window[n] === 'function'){ window[n](); return; }
        }catch(e){}
      }
    }

    function boot(){
      vspClearRunsFilterState();
      // rid_latest must be set AFTER reset to avoid "N/A"
      setTimeout(vspFixRidLatestAfterRunsLoad, 350);
      // refresh runs after filter reset
      setTimeout(vspBestEffortRefreshRuns, 650);
    }

    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot);
    else boot();
  }catch(_e){}
})();

/* ===== VSP_P0_FORCE_NOFILTER_MUTATION_V1 =====
   Keep default runs filters OFF even if:
   - checkboxes are rendered after DOMContentLoaded
   - HTML has 'checked' attribute
   Stops once user manually toggles any filter checkbox (commercial UX).
*/
(function(){
  try{
    if(window.__VSP_NOFILTER_OBS_V1) return;
    window.__VSP_NOFILTER_OBS_V1 = true;

    let userTouched=false;

    function isFilterCb(el){
      if(!el || el.type!=='checkbox') return false;
      const id=(el.id||'').toLowerCase();
      const nm=(el.name||'').toLowerCase();
      const lb=((el.getAttribute('aria-label')||'')+' '+(el.getAttribute('data-label')||'')).toLowerCase();
      const t=(id+' '+nm+' '+lb);
      return (
        t.includes('has_json') || t.includes('has_summary') || t.includes('has_sum') ||
        t.includes('has_html') || t.includes('has_csv') || t.includes('has_sarif') ||
        t.startsWith('has_') || t.includes('only_with') || t.includes('artifact')
      );
    }

    function forceOff(root){
      if(userTouched) return;
      const cbs = Array.from((root||document).querySelectorAll('input[type="checkbox"]'));
      for(const el of cbs){
        if(!isFilterCb(el)) continue;
        try{
          if(el.checked) el.checked=false;
          if(el.hasAttribute('checked')) el.removeAttribute('checked');
        }catch(e){}
      }
    }

    // Mark userTouched if they manually click any filter checkbox
    document.addEventListener('click', function(e){
      const t=e.target;
      if(t && t.matches && t.matches('input[type="checkbox"]') && isFilterCb(t)){
        userTouched=true;
        try{ window.__VSP_NOFILTER_USER_TOUCHED_V1=true; }catch(_e){}
      }
    }, true);

    // Initial enforce
    if(document.readyState==='loading'){
      document.addEventListener('DOMContentLoaded', ()=>forceOff(document));
    }else{
      forceOff(document);
    }

    // Observe future DOM additions (checkbox rendered later)
    const obs = new MutationObserver((muts)=>{
      if(userTouched) return;
      for(const m of muts){
        for(const n of Array.from(m.addedNodes||[])){
          if(n && n.querySelectorAll) forceOff(n);
        }
      }
    });
    obs.observe(document.documentElement||document.body, {childList:true, subtree:true});

    // periodic safety (very light)
    setInterval(()=>forceOff(document), 1200);
  }catch(_e){}
})();

/* ===== VSP_P0_RUNS_COMMERCIAL_POLISH_V1 =====
   - /runs default: no-filter (has_*) + limit=50
   - clear sticky degraded badge if /api/vsp/runs returns OK
*/
(function(){
  try{
    function onRunsPage(){
      try{
        const p=(location && location.pathname) ? location.pathname : "";
        return p === "/runs" || p.startsWith("/runs/");
      }catch(_e){ return false; }
    }
    if(!onRunsPage()) return;
    if(window.__VSP_RUNS_POLISH_P0_V1) return;
    window.__VSP_RUNS_POLISH_P0_V1 = true;

    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(e){ return []; } }
    function _qs(sel, root){ try{ return (root||document).querySelector(sel); }catch(e){ return null; } }

    function clearLocalStorageFilters(){
      try{
        const ks = Object.keys(localStorage||{});
        for(const k of ks){
          const kl=(k||"").toLowerCase();
          if(
            kl.includes("runs_filter") || kl.includes("vsp_runs") ||
            kl.startsWith("has_") || kl.includes("has_json") || kl.includes("has_sum") || kl.includes("has_summary") ||
            kl.includes("has_html") || kl.includes("has_csv") || kl.includes("has_sarif") ||
            kl.includes("only_with") || kl.includes("artifact") || kl.includes("runs_limit")
          ){
            try{ localStorage.removeItem(k); }catch(_e){}
          }
        }
      }catch(_e){}
    }

    function forceNoFilter(root){
      // uncheck any "has_*" checkboxes (id/name/label)
      const cbs=_qsa('input[type="checkbox"]', root);
      for(const el of cbs){
        const id=(el.id||"").toLowerCase();
        const nm=(el.name||"").toLowerCase();
        const lb=(el.getAttribute("aria-label")||"").toLowerCase();
        const t=id+" "+nm+" "+lb;
        const isHas = t.startsWith("has_") || t.includes("has_json") || t.includes("has_sum") || t.includes("has_summary") ||
                      t.includes("has_html") || t.includes("has_csv") || t.includes("has_sarif") ||
                      t.includes("only_with") || t.includes("artifact");
        if(!isHas) continue;
        try{
          if(el.checked) el.checked=false;
          if(el.hasAttribute("checked")) el.removeAttribute("checked");
        }catch(_e){}
      }

      // set limit to 50 if control exists
      const limitEls=[
        document.getElementById("limit"),
        document.getElementById("runs-limit"),
        document.getElementById("vsp-runs-limit"),
        _qs('input[name="limit"]'),
        _qs('select[name="limit"]'),
      ].filter(Boolean);

      for(const el of limitEls){
        try{
          if(el.tagName==="SELECT"){
            const opt=Array.from(el.options||[]).find(o=>String(o.value)==="50");
            if(opt) el.value="50";
          }else{
            el.value="50";
          }
        }catch(_e){}
      }
    }

    function hideDegradedBadge(){
      // hide any element showing degraded runs api 503
      const nodes=_qsa("div,span,small,label,button");
      for(const el of nodes){
        const t=(el.textContent||"").toLowerCase();
        if(t.includes("degraded") && t.includes("runs") && t.includes("api")){
          try{ el.style.display="none"; }catch(_e){}
        }
      }
    }

    async function clearDegradedIfRunsOk(){
      try{
        const res=await fetch("/api/vsp/runs?limit=1", {cache:"no-store"});
        if(res && res.ok){
          hideDegradedBadge();
        }
      }catch(_e){}
    }

    function boot(){
      clearLocalStorageFilters();
      forceNoFilter(document);

      // Observe late-render checkboxes and force off
      const obs=new MutationObserver((muts)=>{
        for(const m of muts){
          for(const n of Array.from(m.addedNodes||[])){
            if(n && n.querySelectorAll) forceNoFilter(n);
          }
        }
      });
      try{ obs.observe(document.documentElement||document.body, {childList:true, subtree:true}); }catch(_e){}

      // Clear degraded badge when API OK (a few attempts)
      setTimeout(clearDegradedIfRunsOk, 600);
      setTimeout(clearDegradedIfRunsOk, 2200);
      setTimeout(clearDegradedIfRunsOk, 5200);
    }

    if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", boot);
    else boot();
  }catch(_e){}
})();

/* VSP_P0_DASH_NO_ABORT_MISSING_CONTAINERS_V1: no direct pattern match; no-op */
/* VSP_P0_DASH_V6D_NO_GIVEUP_V1: patched_n=0 */

/* ===== VSP_P0_CLEAR_RUNS_FAIL_ON_SUCCESS_V1 =====
   Clear sticky "RUNS API FAIL" / "degraded (runs API 503)" when any /api/vsp/runs returns OK.
*/
(function(){
  try{
    if(window.__VSP_CLEAR_RUNS_FAIL_V1) return;
    window.__VSP_CLEAR_RUNS_FAIL_V1 = true;

    function _qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(e){ return []; } }

    function hideByText(rx){
      const nodes=_qsa("div,span,small,label,button,a");
      for(const el of nodes){
        const t=(el.textContent||"").trim();
        if(!t) continue;
        if(rx.test(t)){
          try{ el.style.display="none"; }catch(_e){}
        }
      }
    }

    function clearRunsFailUI(){
      // Banner variants
      hideByText(/RUNS\s*API\s*FAIL/i);
      hideByText(/degraded\s*\(runs\s*api\s*503\)/i);
      hideByText(/Error:\s*503\s*\/api\/vsp\/runs/i);

      // If you have specific containers, hide them too (safe if absent)
      const ids=["runs-api-fail","vsp-runs-fail","runs_fail_banner","vsp_runs_fail_banner"];
      for(const id of ids){
        const el=document.getElementById(id);
        if(el){ try{ el.style.display="none"; }catch(_e){} }
      }
    }

    // Wrap fetch (wrap the already-wrapped one) to observe success
    if(window.fetch && !window.__VSP_FETCH_OBS_RUNS_OK_V1){
      window.__VSP_FETCH_OBS_RUNS_OK_V1 = true;
      const orig = window.fetch.bind(window);
      window.fetch = async (input, init)=>{
        const r = await orig(input, init);
        try{
          let u="";
          try{ u = (typeof input==="string") ? input : (input && input.url) ? input.url : ""; }catch(_e){}
          if(u && u.includes("/api/vsp/runs") && r && r.ok){
            clearRunsFailUI();
          }
        }catch(_e){}
        return r;
      };
    }

    // extra safety: clear after load + after 2s (in case banners render after fetch)
    if(document.readyState==="loading"){
      document.addEventListener("DOMContentLoaded", ()=>setTimeout(clearRunsFailUI, 300));
    }else{
      setTimeout(clearRunsFailUI, 300);
    }
    setTimeout(clearRunsFailUI, 2000);
  }catch(_e){}
})();

/* ===== VSP_P0_RUNS_FAIL_HYSTERESIS_V1 =====
   Goal: stop RUNS API FAIL banner from flipping (transient fail vs OK)
   Logic:
     - on /api/vsp/runs json.ok==true => clear banner + lock-hide for 10s
     - on json.ok==false => increment failCount; show only if >=3
*/
(function(){
  try{
    if(window.__VSP_RUNS_FAIL_HYST_V1) return;
    window.__VSP_RUNS_FAIL_HYST_V1 = true;

    const LOCK_OK_MS = 10000;
    const FAIL_SHOW_THRESHOLD = 3;
    const FAIL_WINDOW_MS = 30000;

    const st = window.__vsp_runs_hyst_state || (window.__vsp_runs_hyst_state = {
      lastOkTs: 0,
      failCount: 0,
      firstFailTs: 0
    });

    function now(){ return Date.now(); }

    function shouldForceHide(){
      return st.lastOkTs && (now() - st.lastOkTs) < LOCK_OK_MS;
    }

    function qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(_e){ return []; } }

    function hideRunsFailUI(){
      // 1) hide by common texts
      const rx = /(RUNS\s*API\s*FAIL|degraded\s*\(runs\s*api\s*503\)|Error:\s*503\s*\/api\/vsp\/runs)/i;
      for(const el of qsa("div,span,small,label,button,a")){
        const t=(el.textContent||"").trim();
        if(t && rx.test(t)){
          try{ el.style.display="none"; el.setAttribute("data-vsp-hide","1"); }catch(_e){}
        }
      }
      // 2) hide common ids if present
      for(const id of ["runs-api-fail","vsp-runs-fail","runs_fail_banner","vsp_runs_fail_banner","vsp_ui_data_panel"]){
        const el=document.getElementById(id);
        if(el){
          const t=(el.textContent||"").toLowerCase();
          if(t.includes("runs api fail") || t.includes("error: 503") || t.includes("degraded")){
            try{ el.style.display="none"; el.setAttribute("data-vsp-hide","1"); }catch(_e){}
          }
        }
      }
    }

    function showRunsFailUI(){
      // allow showing only if threshold reached and not in ok-lock
      if(shouldForceHide()) { hideRunsFailUI(); return; }
      if(st.failCount < FAIL_SHOW_THRESHOLD) { hideRunsFailUI(); return; }

      // if UI has a banner element created elsewhere, we just stop hiding it (remove display:none)
      for(const el of qsa('[data-vsp-hide="1"]')){
        try{ el.style.display=""; el.removeAttribute("data-vsp-hide"); }catch(_e){}
      }
    }

    function onRunsJson(j){
      if(j && j.ok === true){
        st.lastOkTs = now();
        st.failCount = 0;
        st.firstFailTs = 0;
        hideRunsFailUI();
        return;
      }
      // ok=false (or missing)
      const t = now();
      if(!st.firstFailTs || (t - st.firstFailTs) > FAIL_WINDOW_MS){
        st.firstFailTs = t;
        st.failCount = 1;
      }else{
        st.failCount += 1;
      }
      showRunsFailUI();
    }

    // Wrap fetch to inspect /api/vsp/runs payload without breaking caller
    if(window.fetch && !window.__VSP_FETCH_OBS_RUNS_JSON_V1){
      window.__VSP_FETCH_OBS_RUNS_JSON_V1 = true;
      const orig = window.fetch.bind(window);
      window.fetch = async (input, init)=>{
        const r = await orig(input, init);
        try{
          let u="";
          try{ u = (typeof input==="string") ? input : (input && input.url) ? input.url : ""; }catch(_e){}
          if(u && u.includes("/api/vsp/runs")){
            // clone so we don't consume body
            const rr = r.clone();
            rr.json().then(onRunsJson).catch(()=>{ /* ignore */ });
          }
        }catch(_e){}
        return r;
      };
    }

    // MutationObserver: if ok-lock active, keep hiding any new banner nodes
    const obs = new MutationObserver((_muts)=>{
      if(shouldForceHide()) hideRunsFailUI();
    });
    try{ obs.observe(document.documentElement||document.body, {childList:true, subtree:true}); }catch(_e){}

    // initial sweep
    setTimeout(()=>{ if(shouldForceHide()) hideRunsFailUI(); }, 200);
    setTimeout(()=>{ if(shouldForceHide()) hideRunsFailUI(); }, 1200);
  }catch(_e){}
})();

/* ===== VSP_P0_SUPPRESS_RUNS_DEGRADED_TOAST_V1 =====
   If runs list is rendered (has RUN ids), suppress any "RUNS API FAIL"/"degraded (runs API 503)" UI.
   This stops flip/flap caused by transient ok:false / cached-degrade.
*/
(function(){
  try{
    if(window.__VSP_SUPPRESS_RUNS_DEGRADED_V1) return;
    window.__VSP_SUPPRESS_RUNS_DEGRADED_V1 = true;

    const RX = /(RUNS\s*API\s*FAIL|degraded\s*\(runs\s*api\s*503\)|Error:\s*503\s*\/api\/vsp\/runs)/i;

    function qsa(sel, root){ try{ return Array.from((root||document).querySelectorAll(sel)); }catch(_e){ return []; } }

    function hasRunsRows(){
      try{
        const t = (document.body && (document.body.innerText||document.body.textContent)) ? (document.body.innerText||document.body.textContent) : "";
        // heuristic: run ids usually contain "_RUN_" or "RUN_" pattern
        return /_RUN_\d{8}_\d{6}/.test(t) || /\bRUN_[A-Z0-9_]{6,}\b/.test(t) || /VSP_CI_RUN_\d{8}_\d{6}/.test(t);
      }catch(_e){ return false; }
    }

    function hideDegradedBits(){
      if(!hasRunsRows()) return; // only hide if list actually rendered
      for(const el of qsa("div,span,small,label,button,a")){
        const t=(el.textContent||"").trim();
        if(t && RX.test(t)){
          try{ el.style.display="none"; el.setAttribute("data-vsp-hide-degraded","1"); }catch(_e){}
        }
      }
      // also hide common toast containers if they contain the text
      for(const el of qsa("[role='alert'], .toast, .toaster, .snackbar, .notification")){
        const t=(el.textContent||"").trim();
        if(t && RX.test(t)){
          try{ el.style.display="none"; el.setAttribute("data-vsp-hide-degraded","1"); }catch(_e){}
        }
      }
    }

    // Run a few times after load (covers late-render toast)
    function burst(){
      hideDegradedBits();
      setTimeout(hideDegradedBits, 500);
      setTimeout(hideDegradedBits, 1500);
      setTimeout(hideDegradedBits, 3000);
      setTimeout(hideDegradedBits, 6000);
    }

    if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", burst);
    else burst();

    // MutationObserver: if it pops back, hide again
    const obs=new MutationObserver((_m)=>{ hideDegradedBits(); });
    try{ obs.observe(document.documentElement||document.body, {childList:true, subtree:true}); }catch(_e){}
  }catch(_e){}
})();
