/* VSP_UI_GLOBAL_SHIMS_COMMERCIAL_P0_V1
 * 목적: UI 안정화(P0)
 *  - Fix: __VSP_DD_ART_CALL__(window.VSP_DASH_DRILLDOWN_ARTIFACTS_P1_V2,...) is not a function
 *  - Fetch fallback: run_status_v2 -> run_status_v1 (+ /v1/<rid>)
 *  - Soft-degrade for missing endpoints (never throw to console)
 */
(function(){
  'use strict';

/* __VSP_DD_ART_CALL__ (P0): safe-call drilldown artifacts handler */
function __VSP_DD_ART_CALL__(h, ...args) {
  try {
    if (typeof h === 'function') return h(...args);
    if (h && typeof h.open === 'function') return h.open(...args);
    if (h && typeof h.install === 'function') return h.install(...args);
    if (h && typeof h.init === 'function') return h.init(...args);
  } catch(e) { try{ console.warn('[VSP][DD_SAFE_CALL]', e); }catch(_e){} }
  return null;
}


  if (window.__VSP_UI_GLOBAL_SHIMS_COMMERCIAL_P0_V1) return;
  window.__VSP_UI_GLOBAL_SHIMS_COMMERCIAL_P0_V1 = 1;

  // ---- (A) normalize drilldown artifacts callable BEFORE anyone uses it ----
  function normalizeCallable(v){
    if (typeof v === 'function') return v;
    if (v && typeof v.open === 'function') {
      const obj = v;
      const fn = function(arg){
        try { return obj.open(arg); } catch(e){ try{ console.warn('[VSP][DD] open failed', e);}catch(_){} return null; }
      };
      fn.__wrapped_from_object = true;
      return fn;
    }
    const noop = function(_arg){ return null; };
    noop.__noop = true;
    return noop;
  }

  try{
    let _val = window.VSP_DASH_DRILLDOWN_ARTIFACTS_P1_V2;
    Object.defineProperty(window, 'VSP_DASH_DRILLDOWN_ARTIFACTS_P1_V2', {
      configurable: true, enumerable: true,
      get: function(){ return _val; },
      set: function(v){ _val = normalizeCallable(v); }
    });
    window.VSP_DASH_DRILLDOWN_ARTIFACTS_P1_V2 = _val;
  }catch(e){
    window.VSP_DASH_DRILLDOWN_ARTIFACTS_P1_V2 = normalizeCallable(window.VSP_DASH_DRILLDOWN_ARTIFACTS_P1_V2);
  }

  // ---- (B) fetch fallback (targeted) ----
  const _fetch = window.fetch ? window.fetch.bind(window) : null;

  // VSP_THROTTLE_DASHBOARD_EXTRAS_P0_V2: throttle + cache + cooldown for dashboard extras to avoid spam ERR_NETWORK_CHANGED
  let __vsp_extras_cache_text = '';
  let __vsp_extras_cache_ts = 0;
  let __vsp_extras_last_try = 0;
  let __vsp_extras_last_fail = 0;
  let __vsp_extras_inflight = null;

  function __vsp_resp_json(text, status=200){
    try {
      return new Response(text || '{}', {
        status: status,
        headers: {'content-type':'application/json; charset=utf-8'}
      });
    } catch(_e) {
      // older browsers fallback
      return new Response(text || '{}');
    }
  }

  async function __vsp_fetch_extras_with_cache(url, init){
    const now = Date.now();
    const THROTTLE_MS = 10_000;   // 1 req / 10s
    const COOLDOWN_MS = 30_000;   // after fail, skip 30s
    const CACHE_OK_MS = 120_000;  // serve cache up to 2 min

    // if hidden -> prefer cache (avoid background spam)
    if (document.hidden && (now - __vsp_extras_cache_ts) < CACHE_OK_MS && __vsp_extras_cache_text) {
      return __vsp_resp_json(__vsp_extras_cache_text, 200);
    }

    // cooldown after fail
    if ((now - __vsp_extras_last_fail) < COOLDOWN_MS) {
      if (__vsp_extras_cache_text) return __vsp_resp_json(__vsp_extras_cache_text, 200);
      return __vsp_resp_json('{}', 200);
    }

    // throttle
    if ((now - __vsp_extras_last_try) < THROTTLE_MS) {
      if (__vsp_extras_cache_text) return __vsp_resp_json(__vsp_extras_cache_text, 200);
      return __vsp_resp_json('{}', 200);
    }

    __vsp_extras_last_try = now;

    // de-dup inflight
    if (__vsp_extras_inflight) {
      const t = await __vsp_extras_inflight;
      return __vsp_resp_json(t, 200);
    }

    __vsp_extras_inflight = (async () => {
      try {
        const r = await _fetch(url, init);
        const t = await r.text();
        if (r && r.ok) {
          __vsp_extras_cache_text = t || '{}';
          __vsp_extras_cache_ts = Date.now();
        }
        return (t || '{}');
      } catch(_e) {
        __vsp_extras_last_fail = Date.now();
        return (__vsp_extras_cache_text || '{}');
      } finally {
        __vsp_extras_inflight = null;
      }
    })();

    const txt = await __vsp_extras_inflight;
    return __vsp_resp_json(txt, 200);
  }
  if (_fetch) {
    function parseRidFromUrl(u){
      try{
        const url = new URL(u, window.location.origin);
        return url.searchParams.get('rid') || '';
      }catch(_){ return ''; }
    }
    function swapEndpoint(u, from, to){
      try { return u.replace(from, to); } catch(_) { return u; }
    }
    async function tryFetch(u, init){
      try { return await _fetch(u, init); } catch(_) { return null; }
    }

    window.fetch = async function(input, init){
      const url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');

      // VSP_THROTTLE_DASHBOARD_EXTRAS_P0_V2: intercept dashboard extras first (avoid repeated failed XHR spam)
      if (url && url.includes('/api/vsp/dashboard_v3_extras_v1')) {
        return await __vsp_fetch_extras_with_cache(url, init);
      }
      let res = null;

      // first attempt
      res = await tryFetch(input, init);

      // if ok => return
      if (res && res.ok) return res;

      // targeted fallbacks
      if (url.includes('/api/vsp/run_status_v2')) {
        const rid = parseRidFromUrl(url);
        // 1) v2 -> v1 (same query)
        let u1 = swapEndpoint(url, '/api/vsp/run_status_v2', '/api/vsp/run_status_v1');
        let r1 = await tryFetch(u1, init);
        if (r1 && r1.ok) return r1;

        // 2) path form /run_status_v1/<rid>
        if (rid) {
          let u2 = '/api/vsp/run_status_v1/' + encodeURIComponent(rid);
          let r2 = await tryFetch(u2, init);
          if (r2 && r2.ok) return r2;
        }
        return res || r1 || null;
      }

      if (url.includes('/api/vsp/findings_effective_v1')) {
        const rid = parseRidFromUrl(url);
        // try path form /findings_effective_v1/<rid>
        if (rid) {
          let u2 = '/api/vsp/findings_effective_v1/' + encodeURIComponent(rid);
          let r2 = await tryFetch(u2, init);
          if (r2 && r2.ok) return r2;
        }
        // no hard fallback => return original (avoid throwing)
        return res;
      }

      // default: return original result (even if null)
      return res;
    };
  }
})();
