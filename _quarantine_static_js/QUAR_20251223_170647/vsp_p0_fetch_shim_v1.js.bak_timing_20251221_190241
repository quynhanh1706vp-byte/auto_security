/* VSP_P0_FETCH_SHIM_V1
 * - Alias /api/vsp/rid_latest -> /api/vsp/rid_latest_gate_root
 * - Rewrite /api/vsp/run_file -> /api/vsp/run_file_allow
 * - Normalize RID variants (VSP_CI_* <-> VSP_CI_RUN_*)
 * - Retry with gate_root_* when run_file_allow fails
 * - Abort requests that hang too long (prevents infinite LOADING)
 */
(()=> {
  if (window.__vsp_p0_fetch_shim_v1) return;
  window.__vsp_p0_fetch_shim_v1 = true;

  const RID_EP = "/api/vsp/rid_latest_gate_root";
  const RUNFILE_ALLOW = "/api/vsp/run_file_allow";

  const uniq = (arr)=> Array.from(new Set(arr.filter(Boolean)));

  const ridVariants = (rid) => {
    if (!rid) return [];
    let r = String(rid);
    const out = [r];

    // normalize common variants
    // VSP_CI_YYYYmmdd_HHMMSS  <->  VSP_CI_RUN_YYYYmmdd_HHMMSS
    if (r.startsWith("VSP_CI_") && !r.startsWith("VSP_CI_RUN_")) {
      out.push(r.replace(/^VSP_CI_/, "VSP_CI_RUN_"));
    }
    if (r.startsWith("VSP_CI_RUN_")) {
      out.push(r.replace(/^VSP_CI_RUN_/, "VSP_CI_"));
    }
    // sometimes "_RUN_" appears mid-string
    out.push(r.replace(/_RUN_/g, "_"));
    out.push(r.replace(/_/g, "_RUN_")); // last resort variant (won't hurt due to uniq)
    return uniq(out);
  };

  let _latestCache = { t: 0, p: null };
  async function getLatest(force=false){
    const now = Date.now();
    if (!force && _latestCache.p && (now - _latestCache.t) < 8000) return _latestCache.p;
    _latestCache.t = now;
    _latestCache.p = (async()=>{
      const r = await fetch(RID_EP, { cache: "no-store" });
      const j = await r.json().catch(()=> ({}));
      return j || {};
    })();
    return _latestCache.p;
  }

  function toURL(input){
    try{
      if (typeof input === "string") return new URL(input, location.origin);
      if (input && typeof input.url === "string") return new URL(input.url, location.origin); // Request
    }catch(_){}
    return null;
  }

  async function fetchWithTimeout(origFetch, url, init, ms){
    const ctrl = (typeof AbortController !== "undefined") ? new AbortController() : null;
    const t = ctrl ? setTimeout(()=>{ try{ ctrl.abort(); }catch(_){} }, ms) : null;
    const init2 = ctrl ? Object.assign({}, init || {}, { signal: ctrl.signal }) : (init || {});
    try{
      return await origFetch(url, init2);
    } finally {
      if (t) clearTimeout(t);
    }
  }

  function initNoCache(init){
    const h = new Headers((init && init.headers) || {});
    // ensure we don't get stuck by cached 404s
    h.set("Cache-Control","no-cache");
    return Object.assign({}, init || {}, { headers: h, cache: "no-store" });
  }

  const origFetch = window.fetch.bind(window);
  window.fetch = async (input, init) => {
    const u = toURL(input);
    if (!u) return origFetch(input, init);

    // alias rid_latest -> rid_latest_gate_root
    if (u.pathname === "/api/vsp/rid_latest") u.pathname = RID_EP;

    // rewrite run_file -> run_file_allow
    if (u.pathname === "/api/vsp/run_file") u.pathname = RUNFILE_ALLOW;

    // if run_file_allow but missing rid -> fill from latest
    if (u.pathname === RUNFILE_ALLOW) {
      const sp = u.searchParams;
      let rid = sp.get("rid");
      if (!rid || rid === "None" || rid === "null") {
        const latest = await getLatest(false).catch(()=> ({}));
        rid = latest.rid || latest.run_id || latest.gate_root || latest.gate_root_id || "";
        if (rid) sp.set("rid", rid);
      }
    }

    // retry logic only for run_file_allow
    if (u.pathname === RUNFILE_ALLOW) {
      const sp = u.searchParams;
      const path = sp.get("path") || "";
      const rid0 = sp.get("rid") || "";
      const latest = await getLatest(false).catch(()=> ({}));
      const gr0 = latest.gate_root || latest.gate_root_id || "";

      const candidates = uniq([
        ...ridVariants(rid0),
        ...ridVariants(gr0),
      ]);

      const baseInit = initNoCache(init);
      const timeoutMs = 8000;

      for (let i=0; i<Math.min(candidates.length, 6); i++){
        const rid = candidates[i];
        const uu = new URL(u.toString());
        uu.searchParams.set("rid", rid);

        const resp = await fetchWithTimeout(origFetch, uu.toString(), baseInit, timeoutMs).catch(()=> null);
        if (resp && resp.ok) return resp;

        // If server returns 200 but body isn't JSON, UI still breaks; let next try happen.
        if (resp && resp.ok) {
          const ct = (resp.headers.get("content-type") || "").toLowerCase();
          if (ct.includes("application/json")) return resp;
        }
      }

      // last attempt: original url
      return fetchWithTimeout(origFetch, u.toString(), baseInit, timeoutMs);
    }

    return fetchWithTimeout(origFetch, u.toString(), initNoCache(init), 8000);
  };

  // XHR alias too (some modules still use XMLHttpRequest)
  const origOpen = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function(method, url, ...rest){
    try{
      const u = new URL(String(url), location.origin);
      if (u.pathname === "/api/vsp/rid_latest") u.pathname = RID_EP;
      if (u.pathname === "/api/vsp/run_file") u.pathname = RUNFILE_ALLOW;
      return origOpen.call(this, method, u.toString(), ...rest);
    }catch(_){
      return origOpen.call(this, method, url, ...rest);
    }
  };

  console.log("[VSP] fetch shim active: VSP_P0_FETCH_SHIM_V1");
})();
