import re

from api.vsp_run_export_api_v3 import bp_run_export_v3


# === VSP_STATUS_DEGRADED_FINISH_HELPER_V1 ===
def _vsp_read_json_file(path):
    try:
        import json
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return json.load(f)
    except Exception:
        return None

def _vsp_guess_final_and_reason(ci_run_dir, state_obj):
    """
    final only when artifacts indicate end:
      - SUMMARY.txt OR reports/findings_unified.json exists
    finish_reason:
      - completed | completed_degraded | running | stalled
    """
    import os, datetime
    ci = (ci_run_dir or "").strip()

    summary = os.path.join(ci, "SUMMARY.txt")
    findings = os.path.join(ci, "reports", "findings_unified.json")
    deg = os.path.join(ci, "degraded_tools.json")

    degraded = _vsp_read_json_file(deg) if (ci and os.path.isfile(deg)) else None
    completed = bool(ci and (os.path.isfile(summary) or os.path.isfile(findings)))

    stall_sec = int(os.environ.get("VSP_STATUS_STALL_SEC", "900"))
    stalled = False
    updated_at = None
    try:
        updated_at = (state_obj or {}).get("updated_at")
    except Exception:
        updated_at = None

    if (not completed) and updated_at:
        try:
            t = datetime.datetime.fromisoformat(str(updated_at).replace("Z",""))
            stalled = (datetime.datetime.now() - t).total_seconds() > stall_sec
        except Exception:
            pass

    if completed:
        if isinstance(degraded, dict) and degraded:
            return True, "completed_degraded", degraded
        return True, "completed", degraded
    return False, ("stalled" if stalled else "running"), degraded
# === END VSP_STATUS_DEGRADED_FINISH_HELPER_V1 ===

# === VSP_PERSIST_AFTER_REQUEST_V22 ===
import os as _os
import json as _json
import time as _time
import traceback as _traceback
from flask import request as _vsp_req

# === VSP_STATUS_READ_DEGRADED_TOOLS_V1 ===
import json as _json
import os as _os
import time as _time
from pathlib import Path as _Path

def _vsp__safe_read_json_file(_p):
    try:
        return _json.loads(_Path(_p).read_text(encoding="utf-8", errors="ignore"))
    except Exception:
        return None

def _vsp__read_degraded_tools_from_ci(_ci_run_dir):
    if not _ci_run_dir:
        return None
    _f = _Path(_ci_run_dir) / "degraded_tools.json"
    if not _f.exists():
        return None
    _d = _vsp__safe_read_json_file(_f)
    if isinstance(_d, dict) and isinstance(_d.get("items"), list):
        return _d.get("items")
    return _d

def _vsp__finish_reason_from_ci(_ci_run_dir):
    # conservative: only say completed if we see an explicit summary marker
    if not _ci_run_dir:
        return None
    _ci = _Path(_ci_run_dir)
    for _m in ("summary_unified.json", "SUMMARY.txt"):
        if (_ci / _m).exists():
            return "completed"
    _rlog = _ci / "runner.log"
    if _rlog.exists():
        _stall = int(_os.environ.get("VSP_STALL_SEC", "300"))
        try:
            _age = _time.time() - _rlog.stat().st_mtime
            if _age > _stall:
                return "stalled"
        except Exception:
            pass
    return "running"
# === END VSP_STATUS_READ_DEGRADED_TOOLS_V1 ===



_VSP_UIREQ_DIR_V22 = "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1"
_VSP_HIT_LOG_V22   = _VSP_UIREQ_DIR_V22 + "/_persist_hits.log"
_VSP_ERR_LOG_V22   = _VSP_UIREQ_DIR_V22 + "/_persist_err.log"

def _vsp_append_v22(path, line):
    try:
        _os.makedirs(_VSP_UIREQ_DIR_V22, exist_ok=True)
        with open(path, "a", encoding="utf-8") as f:
            f.write(line.rstrip("\n") + "\n")
    except Exception:
        pass

def _vsp_merge_write_v22(rid: str, payload: dict):
    try:
        _os.makedirs(_VSP_UIREQ_DIR_V22, exist_ok=True)
        fp = _os.path.join(_VSP_UIREQ_DIR_V22, f"{rid}.json")
        try:
            cur = _json.loads(open(fp, "r", encoding="utf-8").read())
        except Exception:
            cur = {"ok": True, "req_id": rid}

        if not isinstance(payload, dict):
            payload = {}

        # commercial: don't overwrite good values with None/""
        for k, v in payload.items():
            if v is None:
                continue
            if k in ("ci_run_dir","runner_log","stage_sig") and v == "":
                continue
            cur[k] = v

        cur["req_id"] = cur.get("req_id") or rid
        cur["updated_at"] = _time.strftime("%Y-%m-%dT%H:%M:%SZ", _time.gmtime())

        tmp = fp + ".tmp"
        open(tmp, "w", encoding="utf-8").write(_json.dumps(cur, ensure_ascii=False, indent=2))
        _os.replace(tmp, fp)
        return True
    except Exception as e:
        _vsp_append_v22(_VSP_ERR_LOG_V22, f"merge_write_fail rid={rid} err={repr(e)} file={__file__}")
        _vsp_append_v22(_VSP_ERR_LOG_V22, _traceback.format_exc())
        return False

def _vsp_try_json_v22(resp):
    try:
        if hasattr(resp, "get_json"):
            j = resp.get_json(silent=True)
            if isinstance(j, dict):
                return j
        if hasattr(resp, "get_data"):
            s = resp.get_data(as_text=True)
            if isinstance(s, str):
                s2 = s.strip()
                if s2.startswith("{") and s2.endswith("}"):
                    j = _json.loads(s2)
                    if isinstance(j, dict):
                        return j
    except Exception:
        return None
    return None
# === END VSP_PERSIST_AFTER_REQUEST_V22 ===


# === VSP_UIREQ_PERSIST_ROUTE_V19 ===
import os as _os
import json as _json
import time as _time
import traceback as _traceback

_VSP_UIREQ_DIR_V19 = "/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1"
_VSP_HIT_LOG_V19   = _VSP_UIREQ_DIR_V19 + "/_persist_hits.log"
_VSP_ERR_LOG_V19   = _VSP_UIREQ_DIR_V19 + "/_persist_err.log"

def _vsp_append_v19(path, line):
    try:
        _os.makedirs(_VSP_UIREQ_DIR_V19, exist_ok=True)
        with open(path, "a", encoding="utf-8") as f:
            f.write(line.rstrip("\n") + "\n")
    except Exception:
        pass

def _vsp_uireq_update_v19(rid: str, payload: dict):
    fp = _VSP_UIREQ_DIR_V19 + f"/{rid}.json"
    try:
        _os.makedirs(_VSP_UIREQ_DIR_V19, exist_ok=True)
        try:
            cur = _json.loads(open(fp, "r", encoding="utf-8").read())
        except Exception:
            cur = {"ok": True, "req_id": rid}

        if not isinstance(payload, dict):
            payload = {}

        # commercial: don't overwrite good values with None/""
        for k, v in payload.items():
            if v is None:
                continue
            if k in ("ci_run_dir","runner_log","stage_sig") and v == "":
                continue
            cur[k] = v

        cur["req_id"] = cur.get("req_id") or rid
        cur["updated_at"] = _time.strftime("%Y-%m-%dT%H:%M:%SZ", _time.gmtime())

        tmp = fp + ".tmp"
        open(tmp, "w", encoding="utf-8").write(_json.dumps(cur, ensure_ascii=False, indent=2))
        _os.replace(tmp, fp)
        return True
    except Exception as e:
        _vsp_append_v19(_VSP_ERR_LOG_V19, f"update_fail rid={rid} err={repr(e)} file={__file__}")
        _vsp_append_v19(_VSP_ERR_LOG_V19, _traceback.format_exc())
        return False

def vsp_jsonify_persist_uireq_v19(payload):
    # HIT marker: prove handler/module is active
    try:
        rid0 = None
        if isinstance(payload, dict):
            rid0 = payload.get("req_id") or payload.get("request_id") or payload.get("rid")
        _vsp_append_v19(_VSP_HIT_LOG_V19, f"hit ts={_time.time()} file={__file__} rid={rid0}")
    except Exception:
        pass

    try:
        if isinstance(payload, dict):
            rid = payload.get("req_id") or payload.get("request_id") or payload.get("rid")
            if rid:
                _vsp_uireq_update_v19(str(rid), payload)
            else:
                _vsp_append_v19(_VSP_ERR_LOG_V19, f"missing_rid keys={list(payload.keys())} file={__file__}")
        else:
            _vsp_append_v19(_VSP_ERR_LOG_V19, f"payload_not_dict type={type(payload)} file={__file__}")
    except Exception as e:
        _vsp_append_v19(_VSP_ERR_LOG_V19, f"persist_exception err={repr(e)} file={__file__}")
        _vsp_append_v19(_VSP_ERR_LOG_V19, _traceback.format_exc())

    return jsonify(payload)
# === END VSP_UIREQ_PERSIST_ROUTE_V19 ===


# === VSP_PERSIST_ANY_V20 ===
def _vsp_extract_payload_v20(obj):
    """Try to get a dict payload from (dict | (obj,code,headers) | flask.Response | str/bytes json)."""
    try:
        base = obj
        if isinstance(obj, tuple) and len(obj) >= 1:
            base = obj[0]

        if isinstance(base, dict):
            return base

        # flask Response
        if hasattr(base, "get_json"):
            try:
                j = base.get_json(silent=True)
                if isinstance(j, dict):
                    return j
            except Exception:
                pass

        # raw text/json
        if isinstance(base, (str, bytes, bytearray)):
            s = base.decode("utf-8", "ignore") if isinstance(base, (bytes, bytearray)) else base
            s = s.strip()
            if s.startswith("{") and s.endswith("}"):
                try:
                    j = _json.loads(s)
                    if isinstance(j, dict):
                        return j
                except Exception:
                    pass
        return None
    except Exception:
        return None

def _vsp_persist_from_return_v20(retval):
    try:
        payload = _vsp_extract_payload_v20(retval)
        if isinstance(payload, dict):
            rid = payload.get("req_id") or payload.get("request_id") or payload.get("rid")
            if rid:
                _vsp_uireq_update_v19(str(rid), payload)
    except Exception as e:
        try:
            _vsp_append_v19(_VSP_ERR_LOG_V19, f"persist_from_return_fail err={repr(e)} file={__file__}")
        except Exception:
            pass
    return retval
# === END VSP_PERSIST_ANY_V20 ===

from api.vsp_settings_rules_v1 import bp_settings_rules

# === VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3 ===
def _vsp_demoapp_uireq_dir_v3():
    try:
        from pathlib import Path
        try:
            from run_api import vsp_run_api_v1 as m
            d = getattr(m, "_VSP_UIREQ_DIR", None)
            if d:
                return Path(d)
        except Exception:
            pass
        return Path(__file__).resolve().parent / "ui" / "out_ci" / "uireq_v1"
    except Exception:
        return None

def _vsp_demoapp_extract_reqid_v3(ret):
    try:
        if isinstance(ret, tuple) and ret:
            ret0 = ret[0]
        else:
            ret0 = ret
        if isinstance(ret0, dict):
            rid = ret0.get("request_id") or ret0.get("req_id")
            return str(rid) if rid else ""
        j = None
        try:
            j = ret0.get_json(silent=True)
        except Exception:
            j = None
        if isinstance(j, dict):
            rid = j.get("request_id") or j.get("req_id")
            return str(rid) if rid else ""
    except Exception:
        pass
    return ""

def _vsp_demoapp_bootstrap_state_v3(req_id: str, req_payload: dict):
    try:
        import json, time, os
        from pathlib import Path
        st_dir = _vsp_demoapp_uireq_dir_v3()
        if not st_dir:
            return
        st_dir.mkdir(parents=True, exist_ok=True)
        st_path = st_dir / (str(req_id) + ".json")
        if st_path.is_file():
            return
        st = {
            "request_id": str(req_id),
            "synthetic_req_id": True,
            "mode": (req_payload.get("mode","") if isinstance(req_payload, dict) else ""),
            "profile": (req_payload.get("profile","") if isinstance(req_payload, dict) else ""),
            "target_type": (req_payload.get("target_type","") if isinstance(req_payload, dict) else ""),
            "target": (req_payload.get("target","") if isinstance(req_payload, dict) else ""),
            "ci_run_dir": "",
            "runner_log": "",
            "ci_root_from_pid": None,
            "watchdog_pid": 0,
            "stage_sig": "0/0||0",
            "progress_pct": 0,
            "killed": False,
            "kill_reason": "",
            "final": False,
            "stall_timeout_sec": int(os.environ.get("VSP_STALL_TIMEOUT_SEC","600")),
            "total_timeout_sec": int(os.environ.get("VSP_TOTAL_TIMEOUT_SEC","7200")),
            "state_bootstrap_ts": int(time.time()),
        }
        st_path.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
        print("[VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3] wrote", st_path)
    except Exception as e:
        try:
            print("[VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3] FAILED:", e)
        except Exception:
            pass

def _vsp_demoapp_apply_wrappers_v3(app):


  # VSP_DEMOAPP_BOOTSTRAP_ALIAS_RUNV1_V1

  try:

    import json as _json

    from pathlib import Path as _P

    ep_alias = "vsp_run_v1_alias"

    if ep_alias in app.view_functions:

      _orig_alias = app.view_functions[ep_alias]

      def _wrapped_alias_bootstrap_v1(*args, **kwargs):

        ret = _orig_alias(*args, **kwargs)

        resp, code, headers = ret, None, None

        if isinstance(ret, tuple) and len(ret) >= 1:

          resp = ret[0]

          if len(ret) >= 2: code = ret[1]

          if len(ret) >= 3: headers = ret[2]

        data = None

        try:

          if hasattr(resp, "get_json"):

            data = resp.get_json(silent=True)

        except Exception:

          data = None

        # bootstrap uireq state file from run_v1 JSON response

        try:

          if isinstance(data, dict) and data.get("request_id"):

            rid = str(data.get("request_id"))

            udir = _P(__file__).resolve().parent / "ui" / "out_ci" / "uireq_v1"

            udir.mkdir(parents=True, exist_ok=True)

            f = udir / f"{rid}.json"

            state = {

              "request_id": rid,

              "req_id": rid,

              "ok": True,

              "synthetic_req_id": True,

              "mode": data.get("ci_mode") or data.get("mode") or "LOCAL_UI",

              "profile": data.get("profile") or "",

              "target": data.get("target") or "",

              "target_type": data.get("target_type") or "path",

              "stage_sig": "0/0||0",

              "final": False,

              "killed": False,

            }

            f.write_text(_json.dumps(state, ensure_ascii=False, indent=2), encoding="utf-8")

            try: f.chmod(0o755)

            except Exception: pass

            print("[VSP_DEMOAPP_BOOTSTRAP_ALIAS_RUNV1_V1] wrote", str(f))

        except Exception as e:

          try: print("[VSP_DEMOAPP_BOOTSTRAP_ALIAS_RUNV1_V1] write failed:", e)

          except Exception: pass

        return ret

      app.view_functions[ep_alias] = _wrapped_alias_bootstrap_v1

      print("[VSP_DEMOAPP_BOOTSTRAP_ALIAS_RUNV1_V1] wrapped", ep_alias)

  except Exception as e:

    try: print("[VSP_DEMOAPP_BOOTSTRAP_ALIAS_RUNV1_V1] failed:", e)

    except Exception: pass

  # END VSP_DEMOAPP_BOOTSTRAP_ALIAS_RUNV1_V1

  # VSP_DEMOAPP_STATUS_CONTRACT_V2_SAFE

  try:

    from flask import jsonify

    ep = "vsp_run_api_v1.run_status_v1"

    if ep in app.view_functions:

      _orig = app.view_functions[ep]

      def _wrapped_status_contract_v2(req_id, *args, **kwargs):

        ret = _orig(req_id, *args, **kwargs)

        resp, code, headers = ret, None, None

        if isinstance(ret, tuple) and len(ret) >= 1:

          resp = ret[0]

          if len(ret) >= 2: code = ret[1]

          if len(ret) >= 3: headers = ret[2]

        data = None

        try:

          if hasattr(resp, "get_json"):

            data = resp.get_json(silent=True)

        except Exception:

          data = None

        if isinstance(data, dict):

          # === VSP_STATUS_DEGRADED_FINISH_WRAPPER_PATCH_V1 ===
          try:
            _ci = data.get("ci_run_dir") or data.get("ci_dir") or ""
            _final2, _reason2, _degraded2 = _vsp_guess_final_and_reason(_ci, data)
            data["finish_reason"] = _reason2
            data["degraded_tools"] = _degraded2
            data["final"] = bool(_final2)
          except Exception:
            if data.get("finish_reason") is None: data["finish_reason"] = "running"
            if data.get("degraded_tools") is None: data["degraded_tools"] = None
            if data.get("final") is None: data["final"] = False
          # === END VSP_STATUS_DEGRADED_FINISH_WRAPPER_PATCH_V1 ===

          # VSP_STATUS_READ_DEGRADED_TOOLS_V1 (auto)

          try:

            _ci = data.get('ci_run_dir') or data.get('ci_dir') or data.get('run_dir')

            if _ci:

              if data.get('degraded_tools') is None:

                data['degraded_tools'] = _vsp__read_degraded_tools_from_ci(_ci)

              if data.get('finish_reason') is None:

                data['finish_reason'] = _vsp__finish_reason_from_ci(_ci)

              # tighten final: only true when completed marker exists

              if data.get('final') in (None, False) and data.get('finish_reason') == 'completed':

                data['final'] = True

          except Exception:

            pass


          if data.get("ok") is None: data["ok"] = True

          if data.get("req_id") is None: data["req_id"] = str(req_id)

          if data.get("request_id") is None: data["request_id"] = data.get("req_id") or str(req_id)

          # === VSP_DEGRADED_TOOLS_FLAT_V2 ===

          dt = data.get('degraded_tools')

          if isinstance(dt, dict) and isinstance(dt.get('items'), list):

            data['degraded_tools'] = dt['items']

          elif isinstance(dt, list):

            data['degraded_tools'] = dt

          elif dt is None:

            data['degraded_tools'] = []

          else:

            # if some single dict/object slipped in, wrap as 1-item list

            data['degraded_tools'] = [dt]

          # === END VSP_DEGRADED_TOOLS_FLAT_V2 ===


          new_resp = jsonify(data)
          if headers:

            try: new_resp.headers.extend(headers)

            except Exception: pass

          return new_resp if code is None else (new_resp, code)

        return ret

      app.view_functions[ep] = _wrapped_status_contract_v2

      print("[VSP_DEMOAPP_STATUS_CONTRACT_V2_SAFE] wrapped", ep)

  except Exception as e:

    try: print("[VSP_DEMOAPP_STATUS_CONTRACT_V2_SAFE] failed:", e)

    except Exception: pass

  # END VSP_DEMOAPP_STATUS_CONTRACT_V2_SAFE

    try:
        from flask import request
        ep_run = "vsp_run_api_v1.run_v1"

        # === VSP_DEMOAPP_WRAP_ALIAS_RUNV1_V3_2 ===
        ep_alias = "vsp_run_v1_alias"
        if ep_alias in app.view_functions:
            _orig_alias = app.view_functions[ep_alias]
            def _wrapped_alias(*args, **kwargs):
                ret = _orig_alias(*args, **kwargs)
                rid = _vsp_demoapp_extract_reqid_v3(ret)
                if rid:
                    try:
                        payload = request.get_json(silent=True) or {}
                    except Exception:
                        payload = {}
                    _vsp_demoapp_bootstrap_state_v3(rid, payload)
                return ret
            # avoid double wrap
            if not getattr(_orig_alias, "__name__", "").startswith("wrapped_"):
                app.view_functions[ep_alias] = _wrapped_alias
                print("[VSP_DEMOAPP_WRAP_ALIAS_RUNV1_V3_2] wrapped", ep_alias)
        # === END VSP_DEMOAPP_WRAP_ALIAS_RUNV1_V3_2 ===

        ep_st  = "vsp_run_api_v1.run_status_v1"

        if ep_run in app.view_functions:
            orig = app.view_functions[ep_run]
            def wrapped_run(*args, **kwargs):
                ret = orig(*args, **kwargs)
                rid = _vsp_demoapp_extract_reqid_v3(ret)
                if rid:
                    try:
                        payload = request.get_json(silent=True) or {}
                    except Exception:
                        payload = {}
                    _vsp_demoapp_bootstrap_state_v3(rid, payload)
                return ret
            app.view_functions[ep_run] = wrapped_run
            print("[VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3] wrapped", ep_run)

        if ep_st in app.view_functions:
            orig = app.view_functions[ep_st]
            def wrapped_status(req_id, *args, **kwargs):
                try:
                    _vsp_demoapp_bootstrap_state_v3(str(req_id), {})
                except Exception:
                    pass
                return orig(req_id, *args, **kwargs)
            app.view_functions[ep_st] = wrapped_status
            print("[VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3] wrapped", ep_st)

    except Exception as e:
        try:
            print("[VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3] APPLY FAILED:", e)
        except Exception:
            pass
# === END VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3 ===

#!/usr/bin/env python
import os
import subprocess
from pathlib import Path

from vsp_run_picker_v1 import pick_dashboard_run, OUT_DIR
from flask import (
  Flask,
  render_template,
  request,
  jsonify,
  Response,
  Blueprint,
)



# === RUNS_INDEX_FS_V1 ===
import os, json, time
from pathlib import Path as _Path

vsp_runs_fs_bp = Blueprint("vsp_runs_fs_bp", __name__)

def _runsfs_safe_load_json(path):
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            return json.load(f)
    except Exception:
        return None

def _runsfs_sum_totals(totals):
    if not isinstance(totals, dict):
        return 0
    s = 0
    for k,v in totals.items():
        try:
            s += int(v)
        except Exception:
            pass
    return s

def _runsfs_pick_runs(out_root, limit=50, hide_empty=False):
    items = []
    try:
        for name in os.listdir(out_root):
            if not name.startswith("RUN_"):
                continue
            run_dir = os.path.join(out_root, name)
            if not os.path.isdir(run_dir):
                continue
            rpt = os.path.join(run_dir, "report")
            summary = os.path.join(rpt, "summary_unified.json")
            st = os.stat(run_dir)
            created_at = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(st.st_mtime))
            meta = _runsfs_safe_load_json(os.path.join(run_dir, "ci_source_meta.json")) or {}
            s = _runsfs_safe_load_json(summary) or {}
            bysev = (s.get("summary_by_severity") or s.get("by_severity") or {})
            items.append({
                "run_id": name,
                "created_at": created_at,
                "profile": (meta.get("profile") or s.get("profile") or ""),
                "target": (meta.get("target") or s.get("target") or ""),
                "totals": bysev if isinstance(bysev, dict) else {},
                "total_findings": _runsfs_sum_totals(bysev if isinstance(bysev, dict) else {}),
                "has_findings": 1 if _runsfs_sum_totals(bysev if isinstance(bysev, dict) else {}) > 0 else 0,
            })
    except Exception:
        pass
    if hide_empty:
        items = [it for it in items if int(it.get('has_findings',0)) == 1]
    # prefer has_findings then by time
    items.sort(key=lambda x: (int(x.get('has_findings',0)), x.get('created_at','')), reverse=True)
    # prefer has_findings sorting
    return items[:max(1, int(limit))]

@vsp_runs_fs_bp.get("/api/vsp/runs_index_v3_fs")
def vsp_runs_index_v3_fs():
    limit = request.args.get("limit", "40")
    try:
        limit_i = max(1, min(500, int(limit)))
    except Exception:
        limit_i = 40
    bundle_root = _Path(__file__).resolve().parents[1]  # .../SECURITY_BUNDLE
    bundle_root = _Path(os.environ.get('VSP_BUNDLE_ROOT', str(bundle_root))).resolve()
    out_dir = bundle_root / "out"
    hide_empty = request.args.get('hide_empty','0') in ('1','true','yes')
    items = _runsfs_pick_runs(str(out_dir), limit_i, hide_empty=hide_empty)
    kpi = {"total_runs": len(items), "last_n": min(20, len(items))}
    # === VSP_COMMERCIAL_RUNSFS_SORT_V1 (CI-first + newest-first) ===
    try:
        # 1) newest-first (ISO string compare works for YYYY-mm-ddTHH:MM:SS)
        items.sort(key=lambda r: (str(r.get('created_at','')), str(r.get('run_id',''))), reverse=True)
        # 2) CI-first (stable sort)
        items.sort(key=lambda r: (0 if str(r.get('run_id','')).startswith('RUN_VSP_CI_') else 1))
    except Exception:
        pass
    # === END VSP_COMMERCIAL_RUNSFS_SORT_V1 ===

    return jsonify({"ok": True, "source": "fs", "items": items, "kpi": kpi})
# === END RUNS_INDEX_FS_V1 ===

import requests

# === Config chung ===
ROOT = Path(__file__).resolve().parents[1]  # /home/test/Data/SECURITY_BUNDLE
CORE_BASE = "http://localhost:8961"         # Core API (dashboard_v3, runs_index_v3, datasource_v2)


# === VSP_AFTER_REQUEST_PERSIST_HOOK_V22 ===
def vsp_after_request_persist_uireq_v22(resp):
    try:
        path = _vsp_req.path or ""
        # 1) persist from run_v1 response (RID comes from response json)
        if path.startswith("/api/vsp/run_v1"):
            payload = _vsp_try_json_v22(resp)
            if isinstance(payload, dict):
                rid = payload.get("req_id") or payload.get("request_id") or payload.get("rid")
                if rid:
                    _vsp_append_v22(_VSP_HIT_LOG_V22, f"after_v22 run_v1 ts={_time.time()} rid={rid}")
                    _vsp_merge_write_v22(str(rid), payload)

        # 2) persist from run_status_v1 response (RID comes from URL path param)
        if path.startswith("/api/vsp/run_status_v1/"):
            rid = path.rsplit("/", 1)[-1]
            payload = _vsp_try_json_v22(resp)
            if not isinstance(payload, dict):
                payload = {"ok": True, "req_id": rid}
            payload["req_id"] = payload.get("req_id") or rid
            _vsp_append_v22(_VSP_HIT_LOG_V22, f"after_v22 status ts={_time.time()} rid={rid}")
            _vsp_merge_write_v22(str(rid), payload)
    except Exception as e:
        _vsp_append_v22(_VSP_ERR_LOG_V22, f"after_v22_fail err={repr(e)} file={__file__}")
        _vsp_append_v22(_VSP_ERR_LOG_V22, _traceback.format_exc())
    return resp
# === END VSP_AFTER_REQUEST_PERSIST_HOOK_V22 ===

app = Flask(


    __name__,
    static_folder="static",
    template_folder="templates",
)


# === VSP_OPS_ROUTES_V3 ===
@app.get("/healthz")
def vsp_healthz_v3():
    # schema thương mại: ok + status + service
    return {"ok": True, "status": "OK", "service": "vsp-ui-8910"}

def _vsp_build_info_v3():
    # ultra-safe: không bao giờ throw
    try:
        import os, subprocess
        from datetime import datetime
        build_time = os.environ.get("VSP_BUILD_TIME") or datetime.utcnow().isoformat() + "Z"
        git_hash = os.environ.get("VSP_GIT_HASH") or "unknown"

        # chỉ thử git nếu thư mục có .git
        here = os.path.dirname(__file__)
        if git_hash == "unknown" and os.path.isdir(os.path.join(here, ".git")):
            try:
                git_hash = subprocess.check_output(
                    ["git", "rev-parse", "--short", "HEAD"],
                    cwd=here, stderr=subprocess.DEVNULL
                ).decode().strip() or "unknown"
            except Exception:
                git_hash = "unknown"

        return {
            "service": "VSP_UI_GATEWAY",
            "git_hash": git_hash,
            "build_time": build_time,
            "ts": datetime.utcnow().isoformat() + "Z",
            "python": "py" + __import__("sys").version.split()[0],
        }
    except Exception as e:
        # fallback tối đa
        return {
            "service": "VSP_UI_GATEWAY",
            "git_hash": "unknown",
            "build_time": "unknown",
            "ts": "unknown",
            "error": str(e),
        }

@app.get("/api/vsp/version")
def vsp_version_v3():
    # tuyệt đối không throw → không bao giờ rơi vào HTTP_500_INTERNAL wrapper
    info = _vsp_build_info_v3()
    return {"ok": True, "info": info}

# NOTE: giữ /api/vsp/dashboard_v3_latest làm deprecated alias (1 release), tránh hiểu nhầm schema
@app.get("/api/vsp/dashboard_v3_latest")
def vsp_dashboard_v3_latest_deprecated_v3():
    try:
        out = vsp_run_status_latest_v3()
        if isinstance(out, dict):
            out["deprecated"] = True
            out["deprecated_hint"] = "Use /api/vsp/run_status_latest"
        return out
    except Exception as e:
        return {"ok": False, "error": str(e), "deprecated": True}

@app.get("/api/vsp/run_status_latest")
def vsp_run_status_latest_v3():
    # Ưu tiên: nếu đã có hàm vsp_run_status_latest_v1() thì dùng lại
    try:
        fn = globals().get("vsp_run_status_latest_v1")
        if callable(fn):
            out = fn()
            if isinstance(out, dict):
                out.setdefault("ok", True)
            return out
        return {"ok": False, "error": "missing vsp_run_status_latest_v1()"}
    except Exception as e:
        return {"ok": False, "error": str(e)}
# === END VSP_OPS_ROUTES_V3 ===

# === VSP_OPS_ROUTES_V1 ===
@app.get("/healthz")
def vsp_healthz_v1():
    return {"ok": True, "status": "OK"}

@app.get("/api/vsp/version")
def vsp_version_v1():
    return {"ok": True, "info": _vsp_build_info_v1()}

# Alias/deprecate: dashboard_v3_latest -> run_status_latest
# NOTE: giữ 1 release để backward compatible, UI thương mại chỉ dùng run_status_latest
@app.get("/api/vsp/dashboard_v3_latest")
def vsp_dashboard_v3_latest_deprecated_v1():
    try:
        data = vsp_run_status_latest_v1()
        if isinstance(data, dict):
            data["deprecated"] = True
            data["deprecated_hint"] = "Use /api/vsp/run_status_latest"
        return data
    except Exception as e:
        return {"ok": False, "deprecated": True, "error": str(e)}

@app.get("/api/vsp/run_status_latest")
def vsp_run_status_latest_v1():
    # TODO: bạn map vào logic latest progress hiện có
    # Nếu codebase đã có hàm lấy latest status/progress thì gọi vào đây.
    # Fallback an toàn: lấy RID mới nhất từ runs index resolved rồi trả run_status_v2/RID.
    try:
        import requests
        base = "http://127.0.0.1:8910"
        r = requests.get(base + "/api/vsp/runs_index_v3_fs_resolved?limit=1&hide_empty=0&filter=1", timeout=5).json()
        rid = (r.get("items") or [{}])[0].get("run_id")
        if not rid:
            return {"ok": True, "status": "EMPTY", "rid": None}
        s = requests.get(base + f"/api/vsp/run_status_v2/{rid}", timeout=10).json()
        s["ok"] = True
        s["rid"] = rid
        return s
    except Exception as e:
        return {"ok": False, "error": str(e)}
# === END VSP_OPS_ROUTES_V1 ===
# === VSP_RUN_API_FORCE_REGISTER_V2_AST (do not edit) ===
def _vsp__load_runapi_bp__v2():
    # === VSP_REGISTER_RUNAPI_ONCE_V2 ===
    g = globals()
    if g.get('VSP_RUN_API_REGISTERED_ONCE'):
      return
    g['VSP_RUN_API_REGISTERED_ONCE'] = True
    # === END VSP_REGISTER_RUNAPI_ONCE_V2 ===
    try:
        # normal import (package-style)
        from run_api.vsp_run_api_v1 import bp_vsp_run_api_v1
        return bp_vsp_run_api_v1
    except Exception as e1:
        try:
            # fallback: load by file path (works even if run_api isn't a package)
            import importlib.util
            from pathlib import Path as _Path
            mod_path = _Path(__file__).resolve().parent / "run_api" / "vsp_run_api_v1.py"
            spec = importlib.util.spec_from_file_location("vsp_run_api_v1_dyn_v2", str(mod_path))
            mod = importlib.util.module_from_spec(spec)
            assert spec and spec.loader
            spec.loader.exec_module(mod)
            return getattr(mod, "bp_vsp_run_api_v1", None)
        except Exception as e2:
            print("[VSP_RUN_API] WARN load failed:", repr(e1), repr(e2))
            return None

# === VSP_REGISTER_RUNAPI_GUARD_V3 ===
if globals().get("VSP_RUN_API_REGISTERED_ONCE"):
  pass
else:
  globals()["VSP_RUN_API_REGISTERED_ONCE"] = True
  # === END VSP_REGISTER_RUNAPI_GUARD_V3 ===

  try:
      _bp = _vsp__load_runapi_bp__v2()
      if _bp is not None:
          _bps = getattr(app, "blueprints", None) or {}
          if getattr(_bp, "name", None) in _bps:
              print("[VSP_RUN_API] already registered:", _bp.name)
          else:
              app.register_blueprint(_bp)
              print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
      else:
          print("[VSP_RUN_API] WARN: bp_vsp_run_api_v1 is None")
  except Exception as e:
      print("[VSP_RUN_API] WARN: cannot register run_api blueprint:", repr(e))
  # === END VSP_RUN_API_FORCE_REGISTER_V2_AST ===

# === RUNS_INDEX_FS_REGISTER_V1 ===
try:
    app.register_blueprint(vsp_runs_fs_bp)
except Exception as _e:
    pass
# === END RUNS_INDEX_FS_REGISTER_V1 ===

# === Helper proxy sang core 8961 ===
def proxy_get(path: str) -> Response:
    """
    Proxy GET từ 8910 -> 8961, giữ nguyên query string.
    """
    core_url = CORE_BASE + path
    try:
        resp = requests.get(core_url, params=request.args, timeout=60)
    except Exception as e:
        return jsonify(ok=False, error=f"Proxy error to core {core_url}: {e}"), 502

    headers = {}
    ct = resp.headers.get("Content-Type")
    if ct:
        headers["Content-Type"] = ct
    return Response(resp.content, status=resp.status_code, headers=headers)


# === Routes UI chính ===

@app.route("/")
def index():
    _vsp_append_v19(_VSP_HIT_LOG_V19, f"enter_v20 ts={_time.time()} file={__file__} route=/api/vsp/run_status_v1")
    _vsp_append_v19(_VSP_HIT_LOG_V19, f"enter ts={_time.time()} file={__file__} route=/api/vsp/run_status_v1")
    # Trang VSP 5 tab (index.html đã là layout mới)
    return _vsp_persist_from_return_v20(render_template('vsp_dashboard_2025.html'))


@app.route("/security_bundle")
def security_bundle():
    # Giữ route cũ nếu có chỗ nào gọi
    return render_template('vsp_dashboard_2025.html')


# === Proxy API: dashboard_v3, runs_index_v3, datasource_v2 ===



    try:
        root = pathlib.Path(__file__).resolve().parents[1]
        out_dir = root / "out"
        if not out_dir.is_dir():
            return jsonify(ok=False, error="no_out_dir"), 404

        ci_runs = sorted(
            [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_VSP_CI_")]
        )
        if not ci_runs:
            return jsonify(ok=False, error="no_ci_runs"), 404

        latest = ci_runs[-1]
        snap_path = latest / "report" / "ci_snapshot.json"
        flag_path = latest / "report" / "ci_flag_has_findings.env"

        snap_data = {}
        if snap_path.is_file():
            try:
                snap_data = json.loads(snap_path.read_text(encoding="utf-8"))
            except Exception as e:
                app.logger.error("[CI_SNAPSHOT_API] Lỗi đọc %s: %s", snap_path, e)

        has_flag = None
        if flag_path.is_file():
            try:
                for line in flag_path.read_text(encoding="utf-8").splitlines():
                    line = line.strip()
                    if line.startswith("has_findings="):
                        v = line.split("=", 1)[1].strip()
                        has_flag = (v == "1")
                        break
            except Exception as e:
                app.logger.error("[CI_SNAPSHOT_API] Lỗi đọc %s: %s", flag_path, e)

        # Ưu tiên has_findings từ snapshot, fallback sang flag
        has_findings = snap_data.get("has_findings", has_flag)

        resp = {
            "ok": True,
            "run_id": snap_data.get("run_id", latest.name),
            "ci_run_dir": latest.name,
            "source": snap_data.get("source", "CI"),
            "has_findings": bool(has_findings) if has_findings is not None else None,
            "total_findings": snap_data.get("total_findings"),
            "by_severity": snap_data.get("by_severity", {}),
            "top_tools": snap_data.get("top_tools", []),
            "top_cwe": snap_data.get("top_cwe", []),
            "generated_at": snap_data.get("generated_at"),
            "raw": snap_data,
        }
        return jsonify(resp)
    except Exception as e:
        app.logger.exception("[CI_SNAPSHOT_API] Exception: %s", e)
        return jsonify(ok=False, error="exception", detail=str(e)), 500




    ci_runs = sorted(
        [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_VSP_CI_")]
    )
    if not ci_runs:
        return jsonify(ok=False, error="no_ci_runs"), 404

    latest = ci_runs[-1]
    snap_path = latest / "report" / "ci_snapshot.json"
    flag_path = latest / "report" / "ci_flag_has_findings.env"

    if not snap_path.is_file():
        return jsonify(ok=False, error="no_ci_snapshot", run_dir=latest.name), 404

    try:
        snap_data = json.loads(snap_path.read_text(encoding="utf-8"))
    except Exception as e:
        app.logger.exception("[CI_SNAPSHOT_API_V2] Lỗi parse %s: %s", snap_path, e)
        return jsonify(ok=False, error="invalid_snapshot_json", run_dir=latest.name), 500

    has_flag = None
    if flag_path.is_file():
        try:
            for line in flag_path.read_text(encoding="utf-8").splitlines():
                line = line.strip()
                if line.startswith("has_findings="):
                    v = line.split("=", 1)[1].strip()
                    has_flag = (v == "1")
                    break
        except Exception as e:
            app.logger.error("[CI_SNAPSHOT_API_V2] Lỗi đọc %s: %s", flag_path, e)

    has_findings = snap_data.get("has_findings", has_flag)

    resp = {
        "ok": True,
        "run_id": snap_data.get("run_id", latest.name),
        "ci_run_dir": latest.name,
        "source": snap_data.get("source", "CI"),
        "has_findings": bool(has_findings) if has_findings is not None else None,
        "total_findings": snap_data.get("total_findings"),
        "by_severity": snap_data.get("by_severity", {}),
        "top_tools": snap_data.get("top_tools", []),
        "top_cwe": snap_data.get("top_cwe", []),
        "generated_at": snap_data.get("generated_at"),
    }
    return jsonify(resp)


@app.route("/api/vsp/ci_snapshot_latest", methods=["GET"])
def vsp_ci_snapshot_latest():
    """
    Trả về snapshot CI mới nhất:
    - Chọn RUN_VSP_CI_* mới nhất trong out/
    - Đọc report/ci_snapshot.json + ci_flag_has_findings.env
    """
    import json
    import pathlib

    root = pathlib.Path(__file__).resolve().parents[1]
    out_dir = root / "out"

    if not out_dir.is_dir():
        return jsonify(ok=False, error="no_out_dir"), 404

    ci_runs = sorted(
        [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_VSP_CI_")]
    )
    if not ci_runs:
        return jsonify(ok=False, error="no_ci_runs"), 404

    latest = ci_runs[-1]
    snap_path = latest / "report" / "ci_snapshot.json"
    flag_path = latest / "report" / "ci_flag_has_findings.env"

    if not snap_path.is_file():
        return jsonify(ok=False, error="no_ci_snapshot", run_dir=latest.name), 404

    try:
        snap_data = json.loads(snap_path.read_text(encoding="utf-8"))
    except Exception as e:
        app.logger.exception("[CI_SNAPSHOT_API_V2] Lỗi parse %s: %s", snap_path, e)
        return jsonify(ok=False, error="invalid_snapshot_json", run_dir=latest.name), 500

    has_flag = None
    if flag_path.is_file():
        try:
            for line in flag_path.read_text(encoding="utf-8").splitlines():
                line = line.strip()
                if line.startswith("has_findings="):
                    v = line.split("=", 1)[1].strip()
                    has_flag = (v == "1")
                    break
        except Exception as e:
            app.logger.error("[CI_SNAPSHOT_API_V2] Lỗi đọc %s: %s", flag_path, e)

    has_findings = snap_data.get("has_findings", has_flag)

    resp = {
        "ok": True,
        "run_id": snap_data.get("run_id", latest.name),
        "ci_run_dir": latest.name,
        "source": snap_data.get("source", "CI"),
        "has_findings": bool(has_findings) if has_findings is not None else None,
        "total_findings": snap_data.get("total_findings"),
        "by_severity": snap_data.get("by_severity", {}),
        "top_tools": snap_data.get("top_tools", []),
        "top_cwe": snap_data.get("top_cwe", []),
        "generated_at": snap_data.get("generated_at"),
    }
    return jsonify(resp)


@app.route("/api/vsp/dashboard_delta_latest", methods=["GET"])
def vsp_dashboard_delta_latest():
    """
    Lightweight API: so sánh run mới nhất với run liền trước
    dựa trên out/summary_by_run.json.
    """
    import os, json, datetime as _dt

    root = os.path.dirname(os.path.dirname(__file__))
    summary_path = os.path.join(root, "out", "summary_by_run.json")

    if not os.path.exists(summary_path):
        return jsonify({"ok": False, "error": "summary_by_run.json not found"}), 404

    try:
        with open(summary_path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        return jsonify({"ok": False, "error": "failed to load summary_by_run.json: %s" % e}), 500

    # Chuẩn hoá list run
    if isinstance(data, dict):
        items = list(data.get("runs") or data.get("items") or data.values())
    else:
        items = list(data or [])

    if not items:
        return jsonify({"ok": False, "error": "no runs in summary_by_run.json"}), 200

    def extract_ts(item):
        meta = item.get("meta") or {}
        for key in ("started_at", "created_at", "generated_at"):
            v = meta.get(key) or item.get(key)
            if isinstance(v, str):
                try:
                    return _dt.datetime.fromisoformat(v.replace("Z", ""))
                except Exception:
                    pass
        # Fallback: dùng run_id như timestamp thô
        rid = str(item.get("run_id") or "")
        try:
            return _dt.datetime.strptime(rid[-15:], "%Y%m%d_%H%M%S")
        except Exception:
            return _dt.datetime.min

    def is_full_ext(item):
        profile = (item.get("profile") or item.get("mode") or "").upper()
        rid = (item.get("run_id") or "").upper()
        return ("FULL_EXT" in profile) or ("FULL_EXT" in rid)

    full_ext = [it for it in items if is_full_ext(it)]
    source_items = full_ext if len(full_ext) >= 2 else items

    source_items = [it for it in source_items if isinstance(it, dict)]
    if len(source_items) < 2:
        return jsonify({"ok": False, "error": "not enough runs for delta"}), 200

    source_items.sort(
        key=lambda it: (extract_ts(it), str(it.get("run_id") or "")),
        reverse=True,
    )

    current, previous = source_items[0], source_items[1]

    def pick_num(it, keys, default=0):
        for k in keys:
            v = it.get(k)
            if isinstance(v, (int, float)):
                return v
        summary_all = it.get("summary_all") or {}
        for k in keys:
            v = summary_all.get(k)
            if isinstance(v, (int, float)):
                return v
        return default

    cur_total = pick_num(current, ["total_findings", "findings_total"])
    prev_total = pick_num(previous, ["total_findings", "findings_total"])

    cur_score = pick_num(current, ["security_posture_score", "security_score", "score"])
    prev_score = pick_num(previous, ["security_posture_score", "security_score", "score"])

    delta_total = None if (cur_total is None or prev_total is None) else cur_total - prev_total
    delta_score = None if (cur_score is None or prev_score is None) else cur_score - prev_score

    resp = {
        "ok": True,
        "current": {
            "run_id": current.get("run_id"),
            "total_findings": cur_total,
            "security_posture_score": cur_score,
        },
        "previous": {
            "run_id": previous.get("run_id"),
            "total_findings": prev_total,
            "security_posture_score": prev_score,
        },
        "delta": {
            "total_findings": delta_total,
            "security_posture_score": delta_score,
        },
    }
    return jsonify(resp)
@app.route("/api/vsp/dashboard_v3", methods=["GET"])
def api_vsp_dashboard_v3():

    # [VSP_UI_DASHBOARD_V3_LATEST_JSON_PATCH] Ưu tiên đọc file out/vsp_dashboard_v3_latest.json nếu tồn tại
    try:
        import json, pathlib
        from flask import jsonify
        ui_root = pathlib.Path(__file__).resolve().parent
        root = ui_root.parent  # /home/test/Data/SECURITY_BUNDLE
        latest_path = root / "out" / "vsp_dashboard_v3_latest.json"
        if latest_path.is_file():
            model = json.loads(latest_path.read_text(encoding="utf-8"))
            return jsonify(model)
    except Exception as e:  # noqa: E722
        try:
            from flask import current_app
            current_app.logger.warning("VSP_UI_DASHBOARD_V3_LATEST_JSON_PATCH failed: %r", e)
        except Exception:
            print("VSP_UI_DASHBOARD_V3_LATEST_JSON_PATCH failed:", repr(e))
    return proxy_get("/api/vsp/dashboard_v3")






@app.route("/api/vsp/runs_index_v3")
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    - KPI + trend: cố gắng lấy từ out/summary_by_run.json (nếu có).
    - Danh sách runs (items): *không phụ thuộc* vào summary_by_run.json,
      mà tự quét out/RUN_*/report/findings_unified.json.
    """
    import json
    import datetime
    from pathlib import Path
    from flask import request, jsonify

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    kpi = {}
    trend = []

    # (1) Đọc KPI + trend (nếu có)
    if summary_path.exists():
        try:
            with summary_path.open("r", encoding="utf-8") as f:
                summary = json.load(f)
            if isinstance(summary, dict):
                kpi = summary.get("kpi") or {}
                trend = summary.get("trend_crit_high") or summary.get("trend") or []
        except Exception:
            pass

    # (2) Build items bằng cách duyệt RUN_* + findings_unified.json
    items = []

    run_dirs = [
        p for p in out_dir.iterdir()
        if p.is_dir() and p.name.startswith("RUN_")
    ]
    run_dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)

    for run_dir in run_dirs:
        run_id = run_dir.name
        report_dir = run_dir / "report"
        findings_file = report_dir / "findings_unified.json"
        summary_file = report_dir / "summary_unified.json"

        if not findings_file.exists() and not summary_file.exists():
            continue

        total_findings = None
        run_type = "UNKNOWN"
        source = "FULL_EXT"
        score = None
        started_at = None

        # (2a) Ưu tiên lấy total_findings từ findings_unified.json
        if findings_file.exists():
            try:
                with findings_file.open("r", encoding="utf-8") as f:
                    fd = json.load(f)
                if isinstance(fd, dict):
                    if isinstance(fd.get("items"), list):
                        items_list = fd["items"]
                        total_findings = int(fd.get("total", len(items_list)))
                    elif isinstance(fd.get("findings"), list):
                        items_list = fd["findings"]
                        total_findings = len(items_list)
                elif isinstance(fd, list):
                    total_findings = len(fd)
            except Exception:
                pass

        # (2b) Nếu vẫn chưa có total_findings, fallback sang summary_unified.json
        if total_findings is None and summary_file.exists():
            try:
                with summary_file.open("r", encoding="utf-8") as f:
                    s = json.load(f)
            except Exception:
                s = None

            if isinstance(s, dict):
                total_findings = (
                    s.get("summary_all", {}).get("total_findings")
                    if isinstance(s.get("summary_all"), dict)
                    else None
                )
                if total_findings is None:
                    total_findings = s.get("total_findings")

                if total_findings is None:
                    sev = None
                    if "summary_all" in s and isinstance(s["summary_all"], dict):
                        sev = s["summary_all"].get("by_severity")
                    if sev is None:
                        sev = s.get("by_severity")
                    if isinstance(sev, dict):
                        try:
                            total_findings = int(sum(int(v) for v in sev.values()))
                        except Exception:
                            total_findings = None

                run_profile = s.get("run_profile") if isinstance(s.get("run_profile"), dict) else {}
                run_type = run_profile.get("type") or run_profile.get("run_type") or run_type
                source = run_profile.get("source") or run_profile.get("source_type") or source
                score = s.get("security_posture_score")
                if score is None and isinstance(s.get("summary_all"), dict):
                    score = s["summary_all"].get("security_posture_score")
                started_at = run_profile.get("started_at") or run_profile.get("started") or started_at

        # (2c) Nếu vẫn không có total_findings thì bỏ run này
        if total_findings is None:
            continue

        # (2d) Nếu chưa có started_at thì lấy mtime thư mục
        if not started_at:
            try:
                dt = datetime.datetime.fromtimestamp(run_dir.stat().st_mtime)
                started_at = dt.isoformat(timespec="seconds")
            except Exception:
                started_at = ""

        item = {
            "run_id": run_id,
            "run_type": run_type,
            "source": source,
            "total_findings": int(total_findings),
            "security_posture_score": score if isinstance(score, (int, float)) else None,
            "started_at": started_at,
        }
        items.append(item)

    # (3) Áp dụng limit
    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50
    items_slice = items[:limit]

    # (4) Nếu chưa có KPI thì tự build
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = total_findings_sum / float(last_n) if last_n > 0 else 0.0
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    Ưu tiên:
    1) Đọc KPI + trend từ out/summary_by_run.json (nếu có).
    2) Tự quét thư mục out/RUN_* để build danh sách items (list run)
       nên không phụ thuộc schema summary_by_run.json nữa.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify
    import os
    import datetime

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    kpi = {}
    trend = []

    # (1) Đọc KPI + trend (nếu có)
    if summary_path.exists():
        try:
            with summary_path.open("r", encoding="utf-8") as f:
                summary = json.load(f)
            if isinstance(summary, dict):
                kpi = summary.get("kpi") or {}
                trend = summary.get("trend_crit_high") or summary.get("trend") or []
        except Exception:
            pass

    # (2) Quét thư mục RUN_* để build items
    items = []

    # Duyệt tất cả thư mục RUN_* trong out/
    run_dirs = [p for p in out_dir.iterdir() if p.is_dir() and p.name.startswith("RUN_")]
    # Sắp xếp theo thời gian sửa đổi mới nhất (mới -> cũ)
    run_dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)

    for run_dir in run_dirs:
        run_id = run_dir.name
        report_dir = run_dir / "report"
        summary_file = report_dir / "summary_unified.json"
        if not summary_file.exists():
            continue

        try:
            with summary_file.open("r", encoding="utf-8") as f:
                s = json.load(f)
        except Exception:
            continue

        # Lấy total_findings
        total_findings = None
        # Ưu tiên các kiểu phổ biến
        if isinstance(s, dict):
            # Kiểu summary_all.total_findings
            total_findings = (
                s.get("summary_all", {}).get("total_findings")
                if isinstance(s.get("summary_all"), dict)
                else None
            )
            # Kiểu top-level total_findings
            if total_findings is None:
                total_findings = s.get("total_findings")

            # Nếu vẫn None, thử tính từ by_severity
            if total_findings is None:
                sev = None
                if "summary_all" in s and isinstance(s["summary_all"], dict):
                    sev = s["summary_all"].get("by_severity")
                if sev is None:
                    sev = s.get("by_severity")
                if isinstance(sev, dict):
                    try:
                        total_findings = int(sum(int(v) for v in sev.values()))
                    except Exception:
                        total_findings = None

            # Run type / source
            run_profile = s.get("run_profile") if isinstance(s.get("run_profile"), dict) else {}
            run_type = run_profile.get("type") or run_profile.get("run_type") or "UNKNOWN"
            source = run_profile.get("source") or run_profile.get("source_type") or "FULL_EXT"

            # Score nếu có
            score = s.get("security_posture_score")
            if score is None and isinstance(s.get("summary_all"), dict):
                score = s["summary_all"].get("security_posture_score")

            # Time nếu có
            started_at = run_profile.get("started_at") or run_profile.get("started") or None
        else:
            run_type = "UNKNOWN"
            source = "FULL_EXT"
            score = None
            started_at = None

        # Nếu vẫn chưa có total_findings, bỏ qua run này
        if total_findings is None:
            continue

        # Nếu không có started_at thì lấy mtime thư mục
        if not started_at:
            try:
                dt = datetime.datetime.fromtimestamp(run_dir.stat().st_mtime)
                started_at = dt.isoformat(timespec="seconds")
            except Exception:
                started_at = ""

        item = {
            "run_id": run_id,
            "run_type": run_type,
            "source": source,
            "total_findings": int(total_findings),
            "security_posture_score": score if isinstance(score, (int, float)) else None,
            "started_at": started_at,
        }
        items.append(item)

    # (3) Áp dụng limit
    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50
    items_slice = items[:limit]

    # (4) Nếu chưa có KPI thì tự build
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = total_findings_sum / float(last_n) if last_n > 0 else 0.0
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    Đọc summary_by_run.json trong SECURITY_BUNDLE/out và
    expose items + kpi + trend_crit_high cho UI.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    try:
        with summary_path.open("r", encoding="utf-8") as f:
            summary = json.load(f)
    except FileNotFoundError:
        return jsonify({"ok": False, "error": f"Missing {summary_path}"}), 500

    # Chuẩn hóa items theo nhiều kiểu schema khác nhau
    if isinstance(summary, dict):
        raw_items = (
            summary.get("items")
            or summary.get("by_run")
            or summary.get("runs")
            or summary.get("data")
        )
        if isinstance(raw_items, list):
            items = raw_items
        else:
            items = []
        kpi = summary.get("kpi") or {}
        trend = summary.get("trend_crit_high") or summary.get("trend") or []
    else:
        items = summary if isinstance(summary, list) else []
        kpi = {}
        trend = []

    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50

    items_slice = items[:limit]

    # Nếu summary_by_run.json chưa có kpi ⇒ tự tính KPI cơ bản
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = total_findings_sum / float(last_n) if last_n > 0 else 0.0
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    """
    Local implementation cho Runs & Reports tab (VSP 2025 UI demo).

    Đọc summary_by_run.json trong SECURITY_BUNDLE/out và
    expose items + kpi + trend_crit_high cho UI.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify

    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"
    summary_path = out_dir / "summary_by_run.json"

    try:
        with summary_path.open("r", encoding="utf-8") as f:
            summary = json.load(f)
    except FileNotFoundError:
        return jsonify({"ok": False, "error": f"Missing {summary_path}"}), 500

    if isinstance(summary, dict):
        items = summary.get("items") or []
        kpi = summary.get("kpi") or {}
        trend = summary.get("trend_crit_high") or []
    else:
        items = summary
        kpi = {}
        trend = []

    try:
        limit = int(request.args.get("limit", 50))
    except Exception:
        limit = 50

    items_slice = items[:limit]

    # Nếu summary_by_run.json chưa có kpi ⇒ tự tính KPI cơ bản
    if not kpi:
        total_runs = len(items)
        last_n = min(total_runs, 20)
        if last_n > 0:
            last_items = items[:last_n]
            total_findings_sum = 0
            for it in last_items:
                try:
                    total_findings_sum += int(it.get("total_findings", 0))
                except Exception:
                    continue
            avg_last_n = (
                total_findings_sum / float(last_n) if last_n > 0 else 0.0
            )
        else:
            avg_last_n = 0.0

        kpi = {
            "total_runs": total_runs,
            "last_n": last_n,
            "avg_findings_per_run_last_n": avg_last_n,
        }

    return jsonify(
        {
            "ok": True,
            "items": items_slice,
            "kpi": kpi,
            "trend_crit_high": trend,
        }
    )
def api_vsp_runs_index_v3():
    return proxy_get("/api/vsp/runs_index_v3")



@app.route("/api/vsp/datasource_v2")
def api_vsp_datasource_v2():
    """
    Local implementation cho Data Source tab (VSP 2025 UI demo).

    Thay vì proxy sang core, route này đọc trực tiếp
    findings_unified.json của latest FULL_EXT run trong
    SECURITY_BUNDLE/out.
    """
    import json
    from pathlib import Path
    from flask import request, jsonify

    # SECURITY_BUNDLE root = parent của thư mục ui/
    root = Path(__file__).resolve().parent.parent
    out_dir = root / "out"

    dash_path = out_dir / "vsp_dashboard_v3_latest.json"
    try:
        with dash_path.open("r", encoding="utf-8") as f:
            dash = json.load(f)
    except FileNotFoundError:
        return jsonify({"ok": False, "error": f"Missing {dash_path}"}), 500

    latest_run = dash.get("latest_run_id")
    if not latest_run:
        return jsonify(
            {"ok": False, "error": "No latest_run_id in vsp_dashboard_v3_latest.json"}
        ), 500

    findings_path = out_dir / latest_run / "report" / "findings_unified.json"
    try:
        with findings_path.open("r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        return jsonify(
            {
                "ok": False,
                "error": f"Missing findings_unified.json for run {latest_run}",
            }
        ), 500

    # data có thể là list hoặc {items: [...], total: N}
    if isinstance(data, dict) and "items" in data:
        items = data.get("items") or []
        total = int(data.get("total", len(items)))
    else:
        items = data
        total = len(items)

    try:
        limit = int(request.args.get("limit", 100))
    except Exception:
        limit = 100

    items_slice = items[:limit]

    return jsonify(
        {
            "ok": True,
            "run_id": latest_run,
            "total": total,
            "limit": limit,
            "items": items_slice,
        }
    )
def api_vsp_datasource_v2():
    # Proxy đúng sang core, giữ nguyên run_dir, limit, filters,...
    return proxy_get("/api/vsp/datasource_v2")


# === RUN FULL SCAN EXT+ – gọi bin/vsp_selfcheck_full.sh ===

@app.route("/api/vsp/run_full_scan", methods=["POST", "OPTIONS"])
def api_vsp_run_full_scan():
    """
    Nhận JSON:
      {
        "profile": "EXT" | "FAST" | "AGGR" | "FULL" | ...,
        "source_root": "/home/test/Data/khach6",
        "target_url": "https://demo.demasterpro.com"
      }

    Gọi: bin/vsp_selfcheck_full.sh <profile> <source_root> <target_url>
    cwd = /home/test/Data/SECURITY_BUNDLE
    """
    if request.method == "OPTIONS":
        # Đơn giản trả 200 cho preflight nếu có
        return ("", 200)

    data = request.get_json(silent=True) or {}

    profile = data.get("profile") or "FULL_EXT"
    source_root = data.get("source_root") or data.get("src_path") or str(ROOT / "khach6")
    target_url = data.get("target_url") or data.get("url") or "https://demo.demasterpro.com"

    script = ROOT / "bin" / "vsp_selfcheck_full.sh"

    if not script.is_file():
        return jsonify(
            ok=False,
            error=f"Script không tồn tại: {script}",
        ), 500

    # Đảm bảo script có quyền execute
    try:
        os.chmod(str(script), 0o755)
    except Exception:
        pass

    try:
        proc = subprocess.Popen(
            [str(script), profile, source_root, target_url],
            cwd=str(ROOT),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except Exception as e:
        return jsonify(ok=False, error=f"Lỗi chạy {script}: {e}"), 500

    return jsonify(
        ok=True,
        pid=proc.pid,
        profile=profile,
        source_root=source_root,
        target_url=target_url,
    )


# === Healthcheck đơn giản (tuỳ chọn) ===
@app.route("/health")
def health():
    return jsonify(ok=True, app="vsp_demo_app", core=CORE_BASE)


# VSP_RUN_EXPORT_DIRECT_V1_BEGIN
from flask import send_file, request, jsonify, render_template
import io, json, zipfile, subprocess, shutil
from pathlib import Path

@app.route("/api/vsp/settings_v1", methods=["GET", "POST"])

def _settings_file_path():
    import os
    # Cho phép override bằng env nếu cần
    path = os.environ.get("VSP_SETTINGS_FILE")
    if path:
        return path
    return os.path.join(os.path.dirname(__file__), "config", "settings_v1.json")


def _load_settings_from_file():
    import json, os
    path = _settings_file_path()
    if not os.path.isfile(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        # Nếu file hỏng thì trả rỗng để UI còn tự fill mặc định
        return {}


def _save_settings_to_file(data):
    import json, os
    path = _settings_file_path()
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

@app.route("/api/vsp/settings_ui_v1", methods=["GET", "POST"])
def vsp_settings_ui_v1():
    """
    Settings API cho UI:
    - GET  -> trả JSON {ok: true, settings: {...}}
    - POST -> nhận {settings: {...}} hoặc object raw, lưu file rồi trả lại JSON.
    """
    from flask import request, jsonify

    if request.method == "GET":
        settings = _load_settings_from_file()
        return jsonify({"ok": True, "settings": settings})

    payload = request.get_json(silent=True) or {}
    # Nếu payload dạng {settings: {...}} thì lấy bên trong, còn không thì dùng cả object
    if isinstance(payload, dict) and "settings" in payload and isinstance(payload["settings"], dict):
        settings = payload["settings"]
    else:
        settings = payload

    _save_settings_to_file(settings)
    return jsonify({"ok": True, "settings": settings})


def vsp_settings_v1():
    """GET/POST settings trực tiếp trên gateway 8910 (lưu file JSON)."""
    if request.method == "GET":
        settings = _load_settings_from_file()
        return jsonify(ok=True, settings=settings)

    payload = request.get_json(silent=True) or {}
    try:
        _SETTINGS_FILE.parent.mkdir(parents=True, exist_ok=True)
        _SETTINGS_FILE.write_text(json.dumps(payload, indent=2), encoding="utf-8")
    except Exception as e:
        return jsonify(ok=False, error=str(e)), 500
    return jsonify(ok=True)




    """
    UI-only wrapper cho file config/rule_overrides_v1.json.
    Dùng riêng cho tab Rules trên VSP_UI 2025.
    """
    import os, json, flask

    cfg_dir = os.path.join(os.path.dirname(__file__), "config")
    cfg_path = os.path.join(cfg_dir, "rule_overrides_v1.json")

    # POST: lưu overrides từ UI
    if flask.request.method == "POST":
        try:
            body = flask.request.get_json(force=True, silent=False)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc)), 400

        # Hỗ trợ các format:
        # - { "items": [...] }
        # - { "overrides": [...] }
        # - [ ... ]
        data = body
        if isinstance(body, dict):
            if "items" in body:
                data = body["items"]
            elif "overrides" in body:
                data = body["overrides"]

        os.makedirs(cfg_dir, exist_ok=True)
        with open(cfg_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        return flask.jsonify(ok=True)

    # GET: đọc file, nếu chưa có thì trả [] để UI render bảng trống
    if os.path.exists(cfg_path):
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc), items=[], overrides=[], raw=None), 200
    else:
        raw = []

    # Chuẩn hóa: luôn có items + overrides
    if isinstance(raw, dict):
        items = raw.get("items") or raw.get("overrides") or raw
    else:
        items = raw

    return flask.jsonify(ok=True, items=items, overrides=items, raw=raw)
@app.route("/api/vsp/rule_overrides_ui_v1", methods=["GET", "POST", "OPTIONS"])
def vsp_rule_overrides_ui_v1():
    """
    UI-only wrapper cho file config/rule_overrides_v1.json.
    Dùng riêng cho tab Rules trên VSP_UI 2025.
    """
    import os, json, flask

    cfg_dir = os.path.join(os.path.dirname(__file__), "config")
    cfg_path = os.path.join(cfg_dir, "rule_overrides_v1.json")

    # POST: lưu overrides từ UI
    if flask.request.method == "POST":
        try:
            body = flask.request.get_json(force=True, silent=False)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc)), 400

        # Hỗ trợ các format:
        # - { "items": [...] }
        # - { "overrides": [...] }
        # - [ ... ]
        data = body
        if isinstance(body, dict):
            if "items" in body:
                data = body["items"]
            elif "overrides" in body:
                data = body["overrides"]

        os.makedirs(cfg_dir, exist_ok=True)
        with open(cfg_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        return flask.jsonify(ok=True)

    # GET: đọc file, nếu chưa có thì trả [] để UI render bảng trống
    if os.path.exists(cfg_path):
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc), items=[], overrides=[], raw=None), 200
    else:
        raw = []

    # Chuẩn hóa: luôn có items + overrides
    if isinstance(raw, dict):
        items = raw.get("items") or raw.get("overrides") or raw
    else:
        items = raw

    return flask.jsonify(ok=True, items=items, overrides=items, raw=raw)

@app.route("/api/vsp/run_export_v3", methods=["GET"])
def vsp_run_export_v3():
    """
    Direct export HTML/ZIP/PDF/CSV cho 1 run - chạy trên UI gateway (8910).
    """
    from flask import request, jsonify, send_file
    import os, io, zipfile, json

    run_id = (request.args.get("run_id") or "").strip()
    fmt = (request.args.get("fmt") or "html").strip().lower()

    if not run_id:
        return jsonify({"ok": False, "error": "Missing run_id"}), 400

    # Thư mục out gốc: ưu tiên env VSP_OUT_ROOT, fallback ../out cạnh ui/
    base_out = os.environ.get("VSP_OUT_ROOT")
    if not base_out:
        base_out = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "out"))

    run_dir = os.path.join(base_out, run_id)
    if not os.path.isdir(run_dir):
        return jsonify({"ok": False, "error": f"Run dir not found: {run_dir}"}), 404

    report_dir = os.path.join(run_dir, "report")

    # HTML export
    if fmt == "html":
        candidates = [
            os.path.join(report_dir, "vsp_run_report_cio_v3.html"),
            os.path.join(report_dir, "vsp_run_report_cio_v2.html"),
            os.path.join(report_dir, "vsp_run_report_cio.html"),
            os.path.join(report_dir, "run_report.html"),
        ]
        for path in candidates:
            if os.path.isfile(path):
                return send_file(
                    path,
                    mimetype="text/html",
                    as_attachment=False,
                    download_name=os.path.basename(path),
                )

        # fallback – render summary_unified.json thành HTML đơn giản
        summary_path = os.path.join(report_dir, "summary_unified.json")
        summary = {}
        if os.path.isfile(summary_path):
            try:
                with open(summary_path, "r", encoding="utf-8") as f:
                    summary = json.load(f)
            except Exception:
                summary = {}

        body = json.dumps(
            summary or {"note": "No summary_unified.json found"},
            indent=2,
            ensure_ascii=False,
        )

        html = (
            "<html><head><meta charset='utf-8'>"
            "<title>VSP run {run_id}</title></head><body>"
            "<h1>VSP run {run_id}</h1>"
            "<pre>{body}</pre>"
            "</body></html>"
        ).format(run_id=run_id, body=body)

        return html

    # CSV export
    if fmt == "csv":
        csv_path = os.path.join(report_dir, "findings_unified.csv")
        if os.path.isfile(csv_path):
            return send_file(
                csv_path,
                mimetype="text/csv",
                as_attachment=True,
                download_name=f"{run_id}_findings.csv",
            )
        return jsonify({"ok": False, "error": "findings_unified.csv not found"}), 404

    # ZIP export
    if fmt == "zip":
        if not os.path.isdir(report_dir):
            return jsonify({"ok": False, "error": "report dir not found"}), 404

        mem = io.BytesIO()
        with zipfile.ZipFile(mem, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
            for root, dirs, files in os.walk(report_dir):
                for fn in files:
                    full = os.path.join(root, fn)
                    rel = os.path.relpath(full, run_dir)
                    zf.write(full, rel)

        mem.seek(0)
        return send_file(
            mem,
            mimetype="application/zip",
            as_attachment=True,
            download_name=f"{run_id}_report.zip",
        )

    # PDF export (nếu có sẵn file PDF trong report/)
    if fmt == "pdf":
        if os.path.isdir(report_dir):
            for name in os.listdir(report_dir):
                if name.lower().endswith(".pdf"):
                    path = os.path.join(report_dir, name)
                    return send_file(
                        path,
                        mimetype="application/pdf",
                        as_attachment=True,
                        download_name=name,
                    )
        return jsonify({"ok": False, "error": "PDF report not found"}), 404

    return jsonify({"ok": False, "error": f"Unsupported fmt={fmt}"}), 400



@app.route("/api/vsp/run_fullscan_v1", methods=["POST"])
def vsp_run_fullscan_v1():
    """
    Nhận source_root / target_url / profile / mode từ UI,
    gọi shell wrapper vsp_run_fullscan_from_api_v1.sh chạy background.
    """
    import subprocess
    from pathlib import Path
    from flask import request, jsonify

    payload = request.get_json(force=True) or {}
    source_root = payload.get("source_root") or ""
    target_url = payload.get("target_url") or ""
    profile = payload.get("profile") or "FULL_EXT"
    mode = payload.get("mode") or "EXT_ONLY"

    wrapper = Path(__file__).resolve().parent.parent / "bin" / "vsp_run_fullscan_from_api_v1.sh"

    proc = subprocess.Popen(
        [str(wrapper), profile, mode, source_root, target_url],
        cwd=str(wrapper.parent.parent),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )

    app.logger.info("[VSP_RUN_FULLSCAN_API] payload=%s pid=%s", payload, proc.pid)

    return jsonify({
        "ok": True,
        "pid": proc.pid,
        "profile": profile,
        "mode": mode,
    })



@app.route("/api/vsp/rule_overrides_v1", methods=["GET", "POST"], endpoint="vsp_rule_overrides_v1_api_ui")
def vsp_rule_overrides_v1_api():
    """Simple file-based storage cho rule_overrides_v1.

    File lưu tại: ../config/rule_overrides_v1.json (tính từ thư mục ui/).
    """
    root = _VSP_Path2(__file__).resolve().parent.parent  # .../SECURITY_BUNDLE
    cfg_dir = root / "config"
    cfg_dir.mkdir(exist_ok=True)
    cfg_file = cfg_dir / "rule_overrides_v1.json"

    if request.method == "GET":
        if cfg_file.exists():
            try:
                data = _vsp_json2.loads(cfg_file.read_text(encoding="utf-8"))
            except Exception as exc:  # pragma: no cover
                app.logger.warning("Invalid rule_overrides_v1.json: %s", exc)
                data = []
        else:
            data = []
        return jsonify(data)

    payload = request.get_json(force=True, silent=True)
    if payload is None:
        payload = []

    to_save = payload
    try:
        cfg_file.write_text(
            _vsp_json2.dumps(to_save, indent=2, ensure_ascii=False),
            encoding="utf-8",
        )
    except Exception as exc:  # pragma: no cover
        app.logger.error("Cannot write rule_overrides_v1.json: %s", exc)
        return jsonify({"ok": False, "error": str(exc)}), 500

    return jsonify(to_save)

# === VSP Rule Overrides UI API stub V1 ===
from pathlib import Path as _VSP_Path_UI
import json as _vsp_json_ui



@app.route("/api/vsp/rule_overrides_ui_v1", methods=["GET", "POST"])
def vsp_rule_overrides_ui_v1_force():
    app.logger.info("[VSP_RULES_UI] stub handler active (vsp_rule_overrides_ui_v1_force)")
    root = _VSP_Path_UI2(__file__).resolve().parent.parent  # .../SECURITY_BUNDLE
    cfg_dir = root / "config"
    cfg_dir.mkdir(exist_ok=True)
    cfg_file = cfg_dir / "rule_overrides_v1.json"

    if request.method == "GET":
        if cfg_file.exists():
            try:
                data = _vsp_json_ui2.loads(cfg_file.read_text(encoding="utf-8"))
            except Exception as exc:  # pragma: no cover
                app.logger.warning("Invalid rule_overrides_v1.json: %s", exc)
                data = []
        else:
            data = []
        return jsonify(data)

    payload = request.get_json(force=True, silent=True)
    if payload is None:
        payload = []

    to_save = payload
    try:
        cfg_file.write_text(
            _vsp_json_ui2.dumps(to_save, indent=2, ensure_ascii=False),
            encoding="utf-8",
        )
    except Exception as exc:  # pragma: no cover
        app.logger.error("Cannot write rule_overrides_v1.json: %s", exc)
        return jsonify({"ok": False, "error": str(exc)}), 500

    return jsonify(to_save)




    """
    UI-only wrapper cho file config/rule_overrides_v1.json.
    Dùng riêng cho tab Rules trên VSP_UI 2025.
    """
    import os, json, flask

    cfg_dir = os.path.join(os.path.dirname(__file__), "config")
    cfg_path = os.path.join(cfg_dir, "rule_overrides_v1.json")

    # POST: lưu overrides từ UI
    if flask.request.method == "POST":
        try:
            body = flask.request.get_json(force=True, silent=False)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc)), 400

        # Hỗ trợ vài format:
        # - { "items": [...] }
        # - { "overrides": [...] }
        # - [ ... ]
        data = body
        if isinstance(body, dict):
            if "items" in body:
                data = body["items"]
            elif "overrides" in body:
                data = body["overrides"]

        os.makedirs(cfg_dir, exist_ok=True)
        with open(cfg_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        return flask.jsonify(ok=True)

    # GET: đọc file, nếu chưa có thì trả [] để UI render bảng trống
    if os.path.exists(cfg_path):
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception as exc:
            return flask.jsonify(ok=False, error=str(exc), items=[], overrides=[], raw=None), 200
    else:
        raw = []

    # Chuẩn hóa: luôn có items + overrides
    if isinstance(raw, dict):
        items = raw.get("items") or raw.get("overrides") or raw
    else:
        items = raw

    return flask.jsonify(ok=True, items=items, overrides=items, raw=raw)


@app.route("/api/vsp/dashboard_extras_v1")
def vsp_dashboard_extras_v1():
    """Extras cho Dashboard: top findings, noisy paths, CVE, by_tool – stub V1.

    V1 chỉ wrap lại /api/vsp/dashboard_v3 nếu có, để UI có data tối thiểu.
    Sau này có thể mở rộng để đọc trực tiếp findings_unified.json.
    """
    from flask import jsonify

    base = {}
    try:
        # Gọi lại dashboard_v3 để lấy latest_run_id, by_tool...
        with app.test_client() as c:
            r = c.get("/api/vsp/dashboard_v3")
            if r.is_json:
                base = r.get_json() or {}
    except Exception as e:
        base = {"error": str(e)}

    by_tool = (
        base.get("by_tool")
        or base.get("summary_by_tool")
        or {}
    )

    payload = {
        "ok": True,
        "latest_run_id": base.get("latest_run_id"),
        # Các field này V1 có thể rỗng, UI sẽ hiển thị 'No data'
        "top_risky": base.get("top_risky") or [],
        "top_noisy_paths": base.get("top_noisy_paths") or [],
        "top_cves": base.get("top_cves") or [],
        "by_tool_severity": by_tool,
    }
    return jsonify(payload)


@app.route("/api/vsp/datasource_export_v1")
def vsp_datasource_export_v1():
    """Export findings_unified cho Data Source – V1: JSON + CSV.

    - Nếu có run_dir trong query thì dùng run_dir đó.
    - Nếu không, dùng latest_run_id từ /api/vsp/dashboard_v3.
    """

    from flask import request, jsonify, send_file
    import json
    import csv
    import tempfile

    ui_root = Path(__file__).resolve().parent
    bundle_root = ui_root.parent
    out_root = bundle_root / "out"

    fmt = (request.args.get("fmt") or "json").strip().lower()
    run_dir_arg = (request.args.get("run_dir") or "").strip()

    run_dir = None

    if run_dir_arg:
        run_dir = Path(run_dir_arg)
    else:
        # Lấy latest_run_id từ dashboard_v3
        try:
            with app.test_client() as c:
                r = c.get("/api/vsp/dashboard_v3")
                if r.is_json:
                    data = r.get_json() or {}
                else:
                    data = {}
            latest_run_id = data.get("latest_run_id")
            if latest_run_id:
                run_dir = out_root / latest_run_id
        except Exception as e:
            return jsonify(ok=False, error=f"Không lấy được latest_run_id: {e}"), 500

    if run_dir is None:
        return jsonify(ok=False, error="Không xác định được run_dir"), 400

    if not run_dir.is_dir():
        return jsonify(ok=False, error=f"Run dir not found: {run_dir}"), 404

    report_dir = run_dir / "report"
    findings_path = report_dir / "findings_unified.json"

    if not findings_path.is_file():
        return jsonify(ok=False, error=f"Không tìm thấy findings_unified.json trong {report_dir}"), 404

    if fmt == "json":
        # Trả thẳng file JSON
        return send_file(
            findings_path,
            mimetype="application/json",
            as_attachment=True,
            download_name=f"{run_dir.name}_findings_unified.json",
        )

    if fmt == "csv":
        # Convert JSON -> CSV với các cột chuẩn
        try:
            items = json.loads(findings_path.read_text(encoding="utf-8"))
        except Exception as e:
            return jsonify(ok=False, error=f"Không đọc được JSON: {e}"), 500

        if not isinstance(items, list):
            return jsonify(ok=False, error="findings_unified.json không phải là list"), 500

        # Giữ schema giống Data Source ext columns
        fieldnames = [
            "severity",
            "tool",
            "rule",
            "path",
            "line",
            "message",
            "run",
            "cwe",
            "cve",
            "component",
            "tags",
            "fix",
        ]

        def norm_sev(s):
            if not s:
                return ""
            up = str(s).upper()
            known = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]
            return up if up in known else str(s)

        def extract_line(item):
            if "line" in item and item["line"] is not None:
                return item["line"]
            if "line_number" in item and item["line_number"] is not None:
                return item["line_number"]
            loc = item.get("location") or {}
            if isinstance(loc, dict) and "line" in loc:
                return loc["line"]
            return ""

        def extract_rule(item):
            for k in ["rule_id", "rule", "check_id", "check", "rule_name", "id"]:
                if k in item and item[k]:
                    return item[k]
            return ""

        def extract_msg(item):
            for k in ["message", "msg", "description", "title"]:
                if k in item and item[k]:
                    return item[k]
            return ""

        def extract_run(item):
            for k in ["run_id", "run", "run_ref"]:
                if k in item and item[k]:
                    return item[k]
            return ""

        def extract_cwe(item):
            if item.get("cwe"):
                return item["cwe"]
            if item.get("cwe_id"):
                return item["cwe_id"]
            if isinstance(item.get("cwe_list"), list) and item["cwe_list"]:
                return ",".join(map(str, item["cwe_list"]))
            return ""

        def extract_cve(item):
            if item.get("cve"):
                return item["cve"]
            for k in ["cve_list", "cves"]:
                v = item.get(k)
                if isinstance(v, list) and v:
                    return ",".join(map(str, v))
            return ""

        def extract_component(item):
            for k in ["component", "module", "package", "image"]:
                if item.get(k):
                    return item[k]
            return ""

        def extract_tags(item):
            tags = item.get("tags") or item.get("labels")
            if not tags:
                return ""
            if isinstance(tags, list):
                return ",".join(map(str, tags))
            return str(tags)

        def extract_fix(item):
            for k in ["fix", "remediation", "recommendation"]:
                if item.get(k):
                    return item[k]
            return ""

        tmp = tempfile.NamedTemporaryFile(mode="w+", suffix=".csv", delete=False, encoding="utf-8", newline="")
        tmp_path = Path(tmp.name)

        writer = csv.DictWriter(tmp, fieldnames=fieldnames)
        writer.writeheader()

        for it in items:
            if not isinstance(it, dict):
                continue
            row = {
                "severity": norm_sev(it.get("severity") or it.get("level")),
                "tool": it.get("tool") or it.get("source") or it.get("scanner") or "",
                "rule": extract_rule(it),
                "path": it.get("path") or it.get("file") or it.get("location") or "",
                "line": extract_line(it),
                "message": extract_msg(it),
                "run": extract_run(it),
                "cwe": extract_cwe(it),
                "cve": extract_cve(it),
                "component": extract_component(it),
                "tags": extract_tags(it),
                "fix": extract_fix(it),
            }
            writer.writerow(row)

        tmp.flush()
        tmp.close()

        return send_file(
            tmp_path,
            mimetype="text/csv",
            as_attachment=True,
            download_name=f"{run_dir.name}_findings_unified.csv",
        )

    return jsonify(ok=False, error=f"Unsupported fmt={fmt} (chỉ hỗ trợ json|csv trong V1)"), 400

@app.route("/api/vsp/dashboard_v3", methods=["GET"])
def vsp_dashboard_v3():
    """
    Dashboard V3:
      - Chọn run theo:
        + Pin trong vsp_dashboard_pin_v1.json, hoặc
        + FULL_EXT mới nhất có summary_unified.json
      - Trả total_findings + by_severity + by_tool
    """
    import json
    from flask import request, jsonify

    run_id = request.args.get("run_id") or pick_dashboard_run()

    if not run_id:
        return jsonify({
            "ok": False,
            "error": "No FULL_EXT run with summary_unified.json found",
            "latest_run_id": None,
        }), 500

    summary_file = (OUT_DIR / run_id / "report" / "summary_unified.json")

    if not summary_file.is_file():
        return jsonify({
            "ok": False,
            "error": f"summary_unified.json not found for {run_id}",
            "latest_run_id": run_id,
        }), 500

    summary = json.loads(summary_file.read_text(encoding="utf-8"))

    data = {
        "ok": True,
        "latest_run_id": run_id,
        "total_findings": sum(
            s.get("count", 0) for s in summary.get("summary_by_severity", {}).values()
        ),
        "by_severity": summary["summary_by_severity"],
        "by_tool": summary.get("by_tool", {}),
    }
    return jsonify(data)




# ==== VSP_METRICS_AFTER_REQUEST_V1 ====
# Inject KPI cho /api/vsp/dashboard_v3 và /api/vsp/runs_index_v3
# Không phá code cũ – chỉ chỉnh JSON response sau khi route xử lý xong.

from flask import request
import json as _vsp_json
import pathlib as _vsp_pathlib

SEVERITY_BUCKETS = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"]

_VSP_ROOT = _vsp_pathlib.Path(__file__).resolve().parents[1]


def _vsp_build_severity_cards(by_sev):
    """Chuẩn hoá by_severity thành đầy đủ 6 bucket."""
    cards = {sev: 0 for sev in SEVERITY_BUCKETS}
    if not isinstance(by_sev, dict):
        return cards
    for sev, v in by_sev.items():
        if sev not in cards:
            continue
        if isinstance(v, dict):
            n = v.get("count") or v.get("total") or 0
        else:
            n = v
        try:
            cards[sev] = int(n)
        except Exception:
            pass
    return cards


def _vsp_security_score_simple(cards):
    """Score 0–100, càng nhiều CRIT/HIGH thì trừ điểm mạnh."""
    crit = cards.get("CRITICAL", 0)
    high = cards.get("HIGH", 0)
    med = cards.get("MEDIUM", 0)
    low = cards.get("LOW", 0)

    # model đơn giản: mỗi CRIT trừ 8, HIGH trừ 4, MED trừ 2, LOW trừ 1
    penalty = crit * 8 + high * 4 + med * 2 + low * 1
    score = 100 - penalty
    if score < 0:
        score = 0
    if score > 100:
        score = 100
    return int(score)
def vsp_metrics_after_request_v1(resp):
    """Bơm thêm KPI vào dashboard_v3 & runs_index_v3."""
    try:
        path = request.path
    except Exception:
        return resp

    # Chỉ xử lý JSON của namespace /api/vsp/
    if not getattr(resp, "is_json", False):
        return resp
    if not (isinstance(path, str) and path.startswith("/api/vsp/")):
        return resp

    try:
        data = resp.get_json(silent=True)
    except Exception:
        return resp

    changed = False

    # ===== 1) DASHBOARD V3 KPI =====
    if path == "/api/vsp/dashboard_v3" and isinstance(data, dict):
        by_sev = data.get("by_severity") or {}
        cards = _vsp_build_severity_cards(by_sev)

        if not data.get("severity_cards"):
            data["severity_cards"] = cards
            changed = True

        if "security_posture_score" not in data or data.get("security_posture_score") is None:
            data["security_posture_score"] = _vsp_security_score_simple(cards)
            changed = True

        # Alias cho field top_* nếu backend chỉ có top_cwe, top_module
        if "top_risky_tool" not in data:
            data["top_risky_tool"] = data.get("top_risky_tool") or data.get("top_tool")
        if "top_impacted_cwe" not in data:
            data["top_impacted_cwe"] = data.get("top_impacted_cwe") or data.get("top_cwe")
        if "top_vulnerable_module" not in data:
            data["top_vulnerable_module"] = data.get("top_vulnerable_module") or data.get("top_module")
        changed = True

    # ===== 2) RUNS_INDEX V3 KPI (dùng summary_by_run.json) =====
    if path == "/api/vsp/runs_index_v3" and isinstance(data, dict):
        summary_path = _VSP_ROOT / "out" / "summary_by_run.json"
        s = {}
        try:
            if summary_path.is_file():
                s = _vsp_json.loads(summary_path.read_text(encoding="utf-8"))
        except Exception as e:
            print(f"[VSP_METRICS] Lỗi đọc {summary_path}: {e}")

        kpi = s.get("kpi")
        trend = s.get("trend_crit_high")

        if "kpi" not in data and kpi is not None:
            data["kpi"] = kpi
            changed = True
        if "trend_crit_high" not in data and trend is not None:
            data["trend_crit_high"] = trend
            changed = True

    if not changed:
        return resp

    # Ghi lại body JSON mới
    try:
        new_body = _vsp_json.dumps(data, ensure_ascii=False)
        resp.set_data(new_body)
        resp.mimetype = "application/json"
        resp.headers["Content-Type"] = "application/json; charset=utf-8"
        resp.headers["Content-Length"] = str(len(new_body.encode("utf-8")))
    except Exception as e:
        print(f"[VSP_METRICS] Lỗi set_data: {e}")
    return resp

# ==== END VSP_METRICS_AFTER_REQUEST_V1 ====



# ========== VSP_METRICS_TOP_V1 START ==========
import json
import logging
from collections import Counter
from pathlib import Path
from flask import request

logger = logging.getLogger(__name__)

_VSP_RISKY_SEVERITIES_TOP = {"CRITICAL", "HIGH"}

def _vsp_root_dir_from_ui_top():
    try:
        return Path(__file__).resolve().parent.parent
    except Exception:
        return Path(".")

def _vsp_find_report_dir_top(latest_run_id):
    try:
        root = _vsp_root_dir_from_ui_top()
        report_dir = root / "out" / latest_run_id / "report"
        if report_dir.is_dir():
            return report_dir
    except Exception as exc:
        logger.warning("[VSP_METRICS_TOP] Cannot resolve report dir for %s: %s", latest_run_id, exc)
    return None

def _vsp_load_findings_top(report_dir):
    f = report_dir / "findings_unified.json"
    if not f.exists():
        logger.info("[VSP_METRICS_TOP] %s không tồn tại – bỏ qua top_*", f)
        return []

    try:
        data = json.loads(f.read_text(encoding="utf-8"))
    except Exception as exc:
        logger.warning("[VSP_METRICS_TOP] Lỗi đọc %s: %s", f, exc)
        return []

    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        if isinstance(data.get("findings"), list):
            return data["findings"]
        if isinstance(data.get("items"), list):
            return data["items"]
    return []

def _vsp_extract_cwe_top(f):
    # 1) Field trực tiếp
    for key in ("cwe_id", "cwe", "cwe_code", "cweid"):
        val = f.get(key)
        if isinstance(val, str) and val.strip():
            return val.strip()
        if isinstance(val, list) and val:
            first = val[0]
            if isinstance(first, str) and first.strip():
                return first.strip()
            if isinstance(first, dict):
                for kk in ("id", "code", "name"):
                    v2 = first.get(kk)
                    if isinstance(v2, str) and v2.strip():
                        return v2.strip()

    # 2) Danh sách cwes / cwe_ids
    for key in ("cwes", "cwe_ids"):
        val = f.get(key)
        if isinstance(val, list) and val:
            first = val[0]
            if isinstance(first, str) and first.strip():
                return first.strip()
            if isinstance(first, dict):
                for kk in ("id", "code", "name"):
                    v2 = first.get(kk)
                    if isinstance(v2, str) and v2.strip():
                        return v2.strip()

    # 3) Bên trong extra / metadata
    for key in ("extra", "metadata", "details"):
        sub = f.get(key)
        if isinstance(sub, dict):
            for kk in ("cwe_id", "cwe", "cwe_code", "cweid"):
                val = sub.get(kk)
                if isinstance(val, str) and val.strip():
                    return val.strip()
                if isinstance(val, list) and val:
                    first = val[0]
                    if isinstance(first, str) and first.strip():
                        return first.strip()
                    if isinstance(first, dict):
                        for k2 in ("id", "code", "name"):
                            v2 = first.get(k2)
                            if isinstance(v2, str) and v2.strip():
                                return v2.strip()

    # 4) Tìm trong tags/labels có "CWE-"
    for key in ("tags", "labels", "categories"):
        val = f.get(key)
        if isinstance(val, list):
            for item in val:
                if isinstance(item, str) and "CWE-" in item.upper():
                    return item.strip()

    return None

def _vsp_extract_module_top(f):
    # 1) Các key phổ biến cho module/dependency
    for key in (
        "dependency",
        "package",
        "package_name",
        "module",
        "component",
        "image",
        "image_name",
        "target",
        "resource",
        "resource_name",
        "artifact",
    ):
        val = f.get(key)
        if isinstance(val, str) and val.strip():
            return val.strip()

    # 2) Một số tool gói trong extra/metadata
    for key in ("extra", "metadata", "details"):
        sub = f.get(key)
        if isinstance(sub, dict):
            for kk in (
                "dependency",
                "package",
                "package_name",
                "module",
                "component",
                "image",
                "image_name",
                "target",
                "resource",
                "resource_name",
                "artifact",
            ):
                val = sub.get(kk)
                if isinstance(val, str) and val.strip():
                    return val.strip()

    # 3) Fallback: dùng đường dẫn file như "module"
    for key in ("file", "filepath", "path", "location"):
        val = f.get(key)
        if isinstance(val, str) and val.strip():
            return val.strip()

    return None

def _vsp_accumulate_top_metrics(findings, risky_only):
    by_tool = Counter()
    by_cwe = Counter()
    by_module = Counter()

    for item in findings:
        if not isinstance(item, dict):
            continue
        sev = str(item.get("severity", "")).upper()
        if risky_only and sev not in _VSP_RISKY_SEVERITIES_TOP:
            continue

        # Tool / engine
        tool = (
            item.get("tool")
            or item.get("source")
            or item.get("scanner")
            or item.get("engine")
            or item.get("engine_id")
            or item.get("provider")
        )
        if isinstance(tool, str) and tool.strip():
            by_tool[tool.strip()] += 1

        cwe = _vsp_extract_cwe_top(item)
        if cwe:
            by_cwe[cwe] += 1

        module = _vsp_extract_module_top(item)
        if module:
            by_module[module] += 1

    return by_tool, by_cwe, by_module

def _vsp_compute_top_metrics_top(latest_run_id):
    report_dir = _vsp_find_report_dir_top(latest_run_id)
    if not report_dir:
        return {}

    findings = _vsp_load_findings_top(report_dir)
    if not findings:
        return {}

    # Pass 1: chỉ CRITICAL/HIGH
    by_tool, by_cwe, by_module = _vsp_accumulate_top_metrics(findings, risky_only=True)

    # Nếu CWE/module không có thì fallback dùng tất cả severity
    if not by_cwe or not by_module:
        by_tool_all, by_cwe_all, by_module_all = _vsp_accumulate_top_metrics(findings, risky_only=False)
        if not by_tool and by_tool_all:
            by_tool = by_tool_all
        if not by_cwe and by_cwe_all:
            by_cwe = by_cwe_all
        if not by_module and by_module_all:
            by_module = by_module_all

    result = {}

    if by_tool:
        tool, n = by_tool.most_common(1)[0]
        result["top_risky_tool"] = {
            "id": tool,
            "label": tool,
            "crit_high": int(n),
        }

    if by_cwe:
        cwe, n = by_cwe.most_common(1)[0]
        result["top_impacted_cwe"] = {
            "id": cwe,
            "label": cwe,
            "count": int(n),
        }

    if by_module:
        module, n = by_module.most_common(1)[0]
        result["top_vulnerable_module"] = {
            "id": module,
            "label": module,
            "count": int(n),
        }

    return result
def vsp_metrics_after_request_top_v1(response):
    # Hậu xử lý riêng cho Dashboard V3 để bơm top_* nếu thiếu.
    try:
        path = request.path
    except RuntimeError:
        return response

    if path != "/api/vsp/dashboard_v3":
        return response

    mimetype = response.mimetype or ""
    if not mimetype.startswith("application/json"):
        return response

    try:
        data = json.loads(response.get_data(as_text=True) or "{}")
    except Exception:
        logger.warning("[VSP_METRICS_TOP] Không parse được JSON từ %s", path)
        return response

    latest_run_id = data.get("latest_run_id")
    if not isinstance(latest_run_id, str) or not latest_run_id:
        return response

    top = _vsp_compute_top_metrics_top(latest_run_id)
    if not top:
        return response

    for key in ("top_risky_tool", "top_impacted_cwe", "top_vulnerable_module"):
        if key in top and not data.get(key):
            data[key] = top[key]

    new_body = json.dumps(data, ensure_ascii=False).encode("utf-8")
    response.set_data(new_body)
    response.headers["Content-Length"] = str(len(new_body))
    return response

# ========== VSP_METRICS_TOP_V1 END ==========
# == VSP_TABS_ROUTER_INJECT_ANY_V1 ==
def vsp_tabs_router_inject_any(response):
    """Inject router JS vào TẤT CẢ response text/html.
    Không phụ thuộc id vsp-dashboard-main nữa.
    """
    try:
        ctype = response.headers.get("Content-Type", "")
        if "text/html" not in ctype.lower():
            return response

        body = response.get_data(as_text=True)

        # Nếu đã có script rồi thì thôi
        if "vsp_tabs_hash_router_v1.js" in body:
            return response

        if "</body>" not in body:
            return response

        body = body.replace(
            "</body>",
            '  <script src="/static/js/vsp_tabs_hash_router_v1.js" defer></script>\n</body>'
        )
        response.set_data(body)
    except Exception as e:
        print("[VSP_TABS_ROUTER_INJECT_ANY][ERR]", e)
    return response



# === VSP UI WHOAMI DEBUG V2 + API RUN CI TRIGGER ===
@app.route("/__vsp_ui_whoami", methods=["GET"])
def vsp_ui_whoami():
    """
    Endpoint debug để kiểm tra app nào đang chạy trên gateway 8910.
    """
    from flask import jsonify
    import os
    return jsonify({
        "ok": True,
        "app": "vsp_demo_app",
        "cwd": os.getcwd(),
        "file": __file__,
    })

@app.route("/api/vsp/run", methods=["POST"])
def api_vsp_run():
    """
    Trigger scan từ UI:
    Body:
    {
      "mode": "local" | "ci",
      "profile": "FULL_EXT",
      "target_type": "path",
      "target": "/path/to/project"
    }
    """
    import subprocess
    from pathlib import Path
    from flask import request, jsonify

    try:
        data = request.get_json(force=True, silent=True) or {}
    except Exception:
        data = {}

    mode = (data.get("mode") or "local").lower()
    profile = data.get("profile") or "FULL_EXT"
    target_type = data.get("target_type") or "path"
    target = data.get("target") or ""

    ci_mode = "LOCAL_UI"
    if mode in ("ci", "gitlab", "jenkins"):
        ci_mode = mode.upper() + "_UI"

    # Hiện tại chỉ hỗ trợ target_type=path
    if target_type != "path":
        return jsonify({
            "ok": False,
            "implemented": True,
            "ci_triggered": False,
            "error": "Only target_type='path' is supported currently"
        }), 400

    # Nếu không truyền, default là project SECURITY-10-10-v4
    if not target:
        target = "/home/test/Data/SECURITY-10-10-v4"

    wrapper = Path(__file__).resolve().parents[1] / "bin" / "vsp_ci_trigger_from_ui_v1.sh"

    if not wrapper.exists():
        return jsonify({
            "ok": False,
            "implemented": False,
            "ci_triggered": False,
            "error": f"Wrapper not found: {wrapper}"
        }), 500

    try:
        proc = subprocess.Popen(
            [str(wrapper), profile, target, ci_mode],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = proc.communicate(timeout=5)
        req_id = (stdout or "").strip() or "UNKNOWN"

        if proc.returncode != 0:
            return jsonify({
                "ok": False,
                "implemented": True,
                "ci_triggered": False,
                "request_id": req_id,
                "error": f"Wrapper exited with code {proc.returncode}",
                "stderr": (stderr or "")[-4000:],
            }), 500

        return jsonify({
            "ok": True,
            "implemented": True,
            "ci_triggered": True,
            "request_id": req_id,
            "profile": profile,
            "target": target,
            "ci_mode": ci_mode,
            "message": "Scan request accepted, CI pipeline running in background."
        })
    except subprocess.TimeoutExpired:
        return jsonify({
            "ok": True,
            "implemented": True,
            "ci_triggered": True,
            "request_id": "TIMEOUT_SPAWN",
            "profile": profile,
            "target": target,
            "ci_mode": ci_mode,
            "message": "Scan request spawned (timeout on wrapper stdout)."
        })
    except Exception as e:
        return jsonify({
            "ok": False,
            "implemented": False,
            "ci_triggered": False,
            "error": str(e),
        }), 500
# === END VSP UI WHOAMI DEBUG V2 + API RUN CI TRIGGER ===



# ============================================================
# VSP UI -> CI: Status endpoint for polling (Run Scan Now UI)
# GET /api/vsp/run_status/<req_id>
# - Reads UI trigger log: SECURITY_BUNDLE/out_ci/ui_triggers/UIREQ_*.log
# - Parses ci_run_id, gate, final rc
# - Returns tail log lines
# ============================================================
def _vsp_tail_lines(p: str, n: int = 80):
    try:
        with open(p, "r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()
        return lines[-n:]
    except Exception as e:
        return [f"[run_status][ERR] cannot read log: {e}"]

def _vsp_parse_status_from_log(lines):
    # defaults
    status = "PENDING"
    final_rc = None
    ci_run_id = None
    gate = None

    # Parse ci_run_id from OUTER banner
    rx_run = re.compile(r"\bRUN_ID\b\s*=\s*(VSP_CI_\d{8}_\d{6})")
    rx_run2 = re.compile(r"\bRUN_ID\b\s*=\s*(VSP_CI_\d{8}_\d{6})")
    rx_outer = re.compile(r"\[VSP_CI_OUTER\].*?\bRUN_ID\b\s*=\s*(VSP_CI_\d{8}_\d{6})")
    rx_pipe_end = re.compile(r"\[VSP_UI_RUN\].*?Pipeline kết thúc với RC=(\-?\d+)")
    rx_gate_final = re.compile(r"\[VSP_CI_GATE\].*?\bFinal RC\b\s*:\s*(\-?\d+)")
    rx_runner_rc = re.compile(r"\[VSP_CI_GATE\].*?Runner kết thúc với RC=(\-?\d+)")
    rx_gate_pass = re.compile(r"\[VSP_CI_GATE\].*?\bGATE PASS\b")
    rx_gate_fail = re.compile(r"\[VSP_CI_GATE\].*?\bGATE FAIL\b")

    saw_start = False
    for ln in lines:
        if "[VSP_UI_RUN]" in ln or "[VSP_CI_OUTER]" in ln or "[VSP_CI_GATE]" in ln:
            saw_start = True

        m = rx_outer.search(ln) or rx_run.search(ln) or rx_run2.search(ln)
        if m and not ci_run_id:
            ci_run_id = m.group(1)

        if rx_gate_pass.search(ln):
            gate = "PASS"
        if rx_gate_fail.search(ln):
            gate = "FAIL"

        m = rx_gate_final.search(ln)
        if m:
            final_rc = int(m.group(1))

        m = rx_pipe_end.search(ln)
        if m:
            final_rc = int(m.group(1))

        # Nếu runner chết sớm mà chưa có Final RC
        if final_rc is None:
            m = rx_runner_rc.search(ln)
            if m:
                final_rc = int(m.group(1))

    if not saw_start:
        status = "PENDING"
    else:
        # Có start
        status = "RUNNING"
        if final_rc is not None:
            status = "DONE" if final_rc == 0 else "FAILED"

    return status, ci_run_id, gate, final_rc

def _vsp_try_read_has_findings(ci_run_id: str):
    # ưu tiên nếu đã sync về VSP core: out/RUN_VSP_CI_x/report/ci_flag_has_findings.env
    if not ci_run_id:
        return None

    vsp_run_id = "RUN_" + ci_run_id.replace("VSP_CI_", "VSP_CI_")
    vsp_flag = Path("/home/test/Data/SECURITY_BUNDLE/out") / vsp_run_id / "report" / "ci_flag_has_findings.env"
    # fallback: có thể có flag trong CI_RUN_DIR/report/ci_flag_has_findings.env (nếu bạn tạo ở outer)
    ci_flag = Path("/home/test/Data/SECURITY-10-10-v4/out_ci") / ci_run_id / "report" / "ci_flag_has_findings.env"

    for fp in [vsp_flag, ci_flag]:
        try:
            if fp.is_file():
                data = fp.read_text(encoding="utf-8", errors="ignore").splitlines()
                for ln in data:
                    ln = ln.strip()
                    if ln.startswith("has_findings="):
                        return int(ln.split("=", 1)[1].strip())
        except Exception:
            continue
    return None

@app.route("/api/vsp/run_status/<req_id>", methods=["GET"])
def api_vsp_run_status(req_id):
    # req_id expected like UIREQ_YYYYmmdd_HHMMSS_pid
    log_dir = Path("/home/test/Data/SECURITY_BUNDLE/out_ci/ui_triggers")
    log_path = log_dir / f"{req_id}.log"

    if not log_path.is_file():
        return jsonify({
            "ok": False,
            "error": f"REQ log not found: {log_path}"
        }), 404

    lines = _vsp_tail_lines(str(log_path), n=90)
    status, ci_run_id, gate, final_rc = _vsp_parse_status_from_log(lines)

    has_findings = _vsp_try_read_has_findings(ci_run_id)
    flag = {}
    if has_findings is not None:
        flag["has_findings"] = has_findings

    return jsonify({
        "ok": True,
        "request_id": req_id,
        "status": status,
        "ci_run_id": ci_run_id,
        "gate": gate,
        "final": final_rc,
        "flag": flag,
        "tail": lines[-60:]  # UI show last 60 lines
    })
# ============================================================


# === VSP_JSON_ERRHANDLERS_V4 ===
# Contract: any /api/vsp/* error must still be JSON so jq never dies.
def _vsp_env_int(name, default):
    try:
        import os
        v = os.getenv(name, "")
        if str(v).strip() == "":
            return int(default)
        return int(float(v))
    except Exception:
        return int(default)

def _vsp_api_json_err(code, msg):
    from flask import jsonify
    stall = _vsp_env_int("VSP_UIREQ_STALL_TIMEOUT_SEC", _vsp_env_int("VSP_STALL_TIMEOUT_SEC", 600))
    total = _vsp_env_int("VSP_UIREQ_TOTAL_TIMEOUT_SEC", _vsp_env_int("VSP_TOTAL_TIMEOUT_SEC", 7200))
    if stall < 1: stall = 1
    if total < 1: total = 1
    payload = {
        "ok": False,
        "status": "ERROR",
        "final": True,
        "error": msg,
        "http_code": code,
        "stall_timeout_sec": stall,
        "total_timeout_sec": total,
        "progress_pct": 0,
        "stage_index": 0,
        "stage_total": 0,
        "stage_name": "",
        "stage_sig": "",
    }
    return jsonify(payload), 200

def _vsp_err_404(e):
    try:
        from flask import request
        if request.path.startswith("/api/vsp/"):
            return _vsp_api_json_err(404, "HTTP_404_NOT_FOUND")
    except Exception:
        pass
    return ("Not Found", 404)

def _vsp_err_500(e):
    try:
        from flask import request
        if request.path.startswith("/api/vsp/"):
            return _vsp_api_json_err(500, "HTTP_500_INTERNAL")
    except Exception:
        pass
    return ("Internal Server Error", 500)

app.register_error_handler(404, _vsp_err_404)
app.register_error_handler(500, _vsp_err_500)
# === END VSP_JSON_ERRHANDLERS_V4 ===

# === VSP_RUN_API_FALLBACK_V1 ===
    
import os as _os
if _os.getenv("VSP_ENABLE_RUNAPI_FALLBACK", "0") != "1":
    print("[VSP_RUN_API_FALLBACK] disabled by default (set VSP_ENABLE_RUNAPI_FALLBACK=1 to enable)")
else:
    # If real run_api blueprint fails to load, we still MUST expose /api/vsp/run_v1 and /api/vsp/run_status_v1/*
    # so UI + jq never breaks. This is the "commercial contract".
    def _vsp_env_int(name, default):
        try:
            import os
            v = os.getenv(name, "")
            if str(v).strip() == "":
                return int(default)
            return int(float(v))
        except Exception:
            return int(default)

    def _vsp_contractize(payload):
        if not isinstance(payload, dict):
            payload = {"ok": False, "status": "ERROR", "final": True, "error": "INVALID_STATUS_PAYLOAD"}
        stall = _vsp_env_int("VSP_UIREQ_STALL_TIMEOUT_SEC", _vsp_env_int("VSP_STALL_TIMEOUT_SEC", 600))
        total = _vsp_env_int("VSP_UIREQ_TOTAL_TIMEOUT_SEC", _vsp_env_int("VSP_TOTAL_TIMEOUT_SEC", 7200))
        if stall < 1: stall = 1
        if total < 1: total = 1
        payload.setdefault("ok", bool(payload.get("ok", False)))
        payload.setdefault("status", payload.get("status") or "UNKNOWN")
        payload.setdefault("final", bool(payload.get("final", False)))
        payload.setdefault("error", payload.get("error") or "")
        payload.setdefault("req_id", payload.get("req_id") or "")
        payload["stall_timeout_sec"] = int(payload.get("stall_timeout_sec") or stall)
        payload["total_timeout_sec"] = int(payload.get("total_timeout_sec") or total)
        payload.setdefault("killed", bool(payload.get("killed", False)))
        payload.setdefault("kill_reason", payload.get("kill_reason") or "")
        payload.setdefault("progress_pct", int(payload.get("progress_pct") or 0))
        payload.setdefault("stage_index", int(payload.get("stage_index") or 0))
        payload.setdefault("stage_total", int(payload.get("stage_total") or 0))
        payload.setdefault("stage_name", payload.get("stage_name") or "")
        payload.setdefault("stage_sig", payload.get("stage_sig") or "")
        payload.setdefault("updated_at", int(__import__("time").time()))
        return payload

    try:
        bp_vsp_run_api_v1  # noqa
    except Exception:
        bp_vsp_run_api_v1 = None

    if bp_vsp_run_api_v1 is None:
        from flask import Blueprint, request, jsonify
        bp_vsp_run_api_v1 = Blueprint("vsp_run_api_v1_fallback", __name__)
        _VSP_FALLBACK_REQ = {}

        @bp_vsp_run_api_v1.route("/api/vsp/run_v1_alias", methods=["POST"])
        def _fallback_run_v1():
            # Keep same behavior: missing body => 400 but still JSON
            body = None
            try:
                body = request.get_json(silent=True)
            except Exception:
                body = None
            if not body:
                return jsonify({"ok": False, "error": "MISSING_BODY"}), 400

            req_id = "REQ_FALLBACK_" + __import__("time").strftime("%Y%m%d_%H%M%S")
            st = _vsp_contractize({
                "ok": True,
                "status": "RUNNING",
                "final": False,
                "error": "",
                "req_id": req_id,
                "progress_pct": 0,
                "stage_index": 0,
                "stage_total": 0,
                "stage_name": "INIT",
                "stage_sig": "0/0|INIT|0",
            })
            _VSP_FALLBACK_REQ[req_id] = st
            return jsonify({"ok": True, "request_id": req_id, "implemented": False, "message": "Fallback run_api active (real bp load failed)."}), 200

        @bp_vsp_run_api_v1.route("/api/vsp/run_status_v1/<req_id>", methods=["GET"])
        def _fallback_run_status_v1(req_id):
            if req_id not in _VSP_FALLBACK_REQ:
                return jsonify(_vsp_contractize({
                    "ok": False,
                    "status": "NOT_FOUND",
                    "final": True,
                    "error": "REQ_ID_NOT_FOUND",
                    "req_id": req_id
                })), 200
            return jsonify(_vsp_contractize(_VSP_FALLBACK_REQ[req_id])), 200

        try:
            app.register_blueprint(bp_vsp_run_api_v1)
            print("[VSP_RUN_API_FALLBACK] mounted /api/vsp/run_v1 + /api/vsp/run_status_v1/*")
        except Exception as e:
            print("[VSP_RUN_API_FALLBACK] mount failed:", repr(e))
# === END VSP_RUN_API_FALLBACK_V1 ===

# === VSP_RUN_V1_ALIAS_V1 ===
# Commercial contract: provide POST /api/vsp/run_v1 as stable entrypoint.
# Implementation: alias to existing /api/vsp/run (api_vsp_run) handler.
from flask import request, jsonify

@app.route("/api/vsp/run_v1_alias", methods=["POST"])
def vsp_run_v1_alias():
  """
  Commercial contract:
  - POST /api/vsp/run_v1 always returns JSON (jq-safe)
  - Never return request_id=TIMEOUT_SPAWN to client
  - If underlying api_vsp_run returns TIMEOUT_SPAWN/empty => replace with synthetic VSP_UIREQ_...
  """
  from flask import request, jsonify
  import time, random, string

  body = None
  try:
    body = request.get_json(silent=True)
  except Exception:
    body = None
  if not body:
    return jsonify({"ok": False, "error": "MISSING_BODY"}), 400

  fn = globals().get("api_vsp_run")
  if not callable(fn):
    return jsonify({"ok": False, "error": "RUN_ALIAS_TARGET_MISSING", "final": True}), 500

  resp = fn()
  code = 200
  headers = None

  if isinstance(resp, tuple):
    if len(resp) >= 2:
      code = resp[1]
    if len(resp) >= 3:
      headers = resp[2]
    resp = resp[0]

  data = None
  # flask Response
  try:
    if hasattr(resp, "get_json"):
      data = resp.get_json(silent=True)
  except Exception:
    data = None

  # dict direct
  if data is None and isinstance(resp, dict):
    data = resp

  if not isinstance(data, dict):
    data = {"ok": True, "implemented": True}

  rid = data.get("request_id") or data.get("req_id") or ""
  if rid in ("", "TIMEOUT_SPAWN"):
    rid2 = "VSP_UIREQ_" + time.strftime("%Y%m%d_%H%M%S") + "_" + "".join(random.choice(string.ascii_lowercase+string.digits) for _ in range(6))
    data["request_id"] = rid2
    data["synthetic_req_id"] = True
    data["message"] = data.get("message") or "Spawn wrapper timed out; returned synthetic request_id for status tracking."

  out = jsonify(data)
  if headers is not None:
    return out, code, headers
  return out, code
def api_vsp_rule_overrides_save():
    """
    Lưu rule overrides từ UI editor.
    Expect body: { "items": [ {id, tool, pattern, severity, scope, enabled, ...}, ... ] }
    """
    from flask import request, jsonify

    try:
        payload = request.get_json(force=True) or {}
    except Exception:
        return jsonify({"ok": False, "error": "Invalid JSON"}), 400

    items = payload.get("items")
    if not isinstance(items, list):
        return jsonify({"ok": False, "error": "Field 'items' must be list"}), 400

    # validate đơn giản
    for it in items:
        if not isinstance(it, dict):
            return jsonify({"ok": False, "error": "Each item must be object"}), 400
        if "id" not in it or "tool" not in it or "severity" not in it:
            return jsonify({"ok": False, "error": "Each item must have id/tool/severity"}), 400

    data = {"items": items}
    _save_rule_overrides(data)
    return jsonify({"ok": True, "items_count": len(items)})

# === VSP DAST STUB API – có thể nâng cấp sau ===
from flask import request, jsonify

@app.route("/api/vsp/dast/scan", methods=["POST"])
def api_vsp_dast_scan():
    """
    Stub DAST từ UI:
    Body:
    {
      "url": "https://example.com"
    }
    Hiện tại chỉ ghi lịch sử planned, chưa gọi Nessus/ZAP thật.
    """
    from flask import request, jsonify
    from pathlib import Path
    import json
    import datetime

    data = request.get_json(silent=True) or {}
    url = data.get("url") or ""

    root = Path(__file__).resolve().parents[1]
    hist_path = root / "out" / "dast_history.json"
    hist_path.parent.mkdir(parents=True, exist_ok=True)

    try:
        history = json.loads(hist_path.read_text(encoding="utf-8"))
        if not isinstance(history, list):
            history = []
    except Exception:
        history = []

    entry = {
        "url": url,
        "engine": "DAST_STUB_V1",
        "status": "PLANNED",
        "created_at": datetime.datetime.utcnow().isoformat() + "Z",
    }
    history.append(entry)
    hist_path.write_text(json.dumps(history, indent=2), encoding="utf-8")

    return jsonify({
        "ok": True,
        "implemented": False,
        "engine": "DAST_STUB_V1",
        "url": url,
        "status": "PLANNED"
    })
# === END API VSP DAST SCAN (CLEAN V1) ===

# === API VSP DAST HISTORY (CLEAN V1) ===
@app.route("/api/vsp/dast/history", methods=["GET"])
def api_vsp_dast_history():
    """
    Trả lại lịch sử DAST stub (dast_history.json)
    """
    from flask import jsonify
    from pathlib import Path
    import json

    root = Path(__file__).resolve().parents[1]
    hist_path = root / "out" / "dast_history.json"

    try:
        data = json.loads(hist_path.read_text(encoding="utf-8"))
        if not isinstance(data, list):
            data = []
    except Exception:
        data = []

    return jsonify({
        "ok": True,
        "items": data,
    })
# === END API VSP DAST HISTORY (CLEAN V1) ===

# === VSP RULE OVERRIDES SAVE API (CLEAN V1) ===
@app.route("/api/vsp/rule_overrides_save_v1", methods=["POST"])
def vsp_rule_overrides_save_v1():
    """
    Nhận JSON root object (đúng schema rule_overrides_ui_v1)
    Ghi xuống out/vsp_rule_overrides_v1.json (backup bản cũ nếu có).
    """
    from flask import request, jsonify
    from pathlib import Path
    import json

    data = request.get_json(silent=True)
    if not isinstance(data, dict):
        return jsonify({"ok": False, "error": "Root JSON phải là object."}), 400

    root = Path(__file__).resolve().parents[1]
    overrides_path = root / "out" / "vsp_rule_overrides_v1.json"
    overrides_path.parent.mkdir(parents=True, exist_ok=True)

    # Backup cũ
    if overrides_path.exists():
        backup = overrides_path.with_suffix(".json.bak_ui_save")
        try:
            overrides_path.replace(backup)
        except Exception:
            pass

    overrides_path.write_text(
        json.dumps(data, indent=2, ensure_ascii=False),
        encoding="utf-8",
    )

    return jsonify({"ok": True, "path": str(overrides_path)})
# === END VSP RULE OVERRIDES SAVE API (CLEAN V1) ===

# === VSP UI WHOAMI DEBUG V1 ===
def vsp_ui_whoami():
    """
    Endpoint debug để kiểm tra app nào đang chạy trên gateway 8910.
    """
    from flask import jsonify
    import os
    return jsonify({
        "ok": True,
        "app": "vsp_demo_app",
        "cwd": os.getcwd(),
        "file": __file__,
    })
# === END VSP UI WHOAMI DEBUG V1 ===


# === VSP UI WHOAMI DEBUG V1 ===




# === VSP_RUN_API_BLUEPRINT_V1 ===
try:
    from run_api.vsp_run_api_v1 import bp_vsp_run_api_v1
    bp_name = getattr(bp_vsp_run_api_v1, 'name', 'vsp_run_api_v1')
    if bp_name in getattr(app, 'blueprints', {}):
        print(f"[VSP_RUN_API] skip blueprint already registered: {bp_name}")
    else:
        bp_name = getattr(bp_vsp_run_api_v1, 'name', 'vsp_run_api_v1')
        if bp_name in getattr(app, 'blueprints', {}):
            print(f"[VSP_RUN_API] skip blueprint already registered: {bp_name}")
        else:
            app.register_blueprint(bp_vsp_run_api_v1)
# [VSP_REGCLEAN_V3_DISABLED]             print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
# [VSP_REGCLEAN_V3_DISABLED]         print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
# [VSP_REGCLEAN_V3_DISABLED]     print("[VSP_RUN_API] OK registered: /api/vsp/run_v1 + /api/vsp/run_status_v1/<REQ_ID>")
except Exception as e:
    print("[VSP_RUN_API] ERR register blueprint:", repr(e))
# === END VSP_RUN_API_BLUEPRINT_V1 ===

# === VSP_ENSURE_MAIN_RUN_V1 ===
def _vsp_find_flask_app():
  try:
    import flask
  except Exception:
    return None
  for k,v in globals().items():
    try:
      if isinstance(v, flask.Flask):
        return v
    except Exception:
      pass
  return None


# === VSP_DEMOAPP_PERSIST_UIREQ_FROM_STATUS_V2 ===
try:
    from run_api import vsp_run_api_v1 as _runapi_mod
    import json as _json, os as _os
    from pathlib import Path as _Path

    def _vsp_persist_uireq(_rid: str, _data: dict) -> bool:
        udir = getattr(_runapi_mod, "_VSP_UIREQ_DIR", None)
        if not udir or not _rid:
            return False
        fp = _Path(str(udir)) / f"{_rid}.json"
        cur = {}
        if fp.exists():
            try:
                cur = _json.loads(fp.read_text(encoding="utf-8", errors="ignore")) or {}
            except Exception:
                cur = {}

        # merge fields from status response
        for k in [
            "request_id","req_id",
            "ci_run_dir","runner_log",
            "stage_sig","progress_pct",
            "status","final",
            "killed","kill_reason",
            "stall_timeout_sec","total_timeout_sec",
        ]:
            if k in _data and _data[k] is not None:
                cur[k] = _data[k]

        tmp = fp.with_suffix(".json.tmp")
        tmp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding="utf-8")
        _os.replace(tmp, fp)
        return True

    def _wrap_status_persist(app, endpoint="vsp_run_api_v1.run_status_v1"):
        if not app or endpoint not in getattr(app, "view_functions", {}):
            return False
        _orig = app.view_functions[endpoint]

        def _wrapped(req_id, *a, **kw):
            resp = _orig(req_id, *a, **kw)

            body = resp[0] if isinstance(resp, tuple) else resp
            data = None
            try:
                if hasattr(body, "get_json"):
                    data = body.get_json(silent=True)
                elif isinstance(body, dict):
                    data = body
            except Exception:
                data = None

            if isinstance(data, dict):
                rid = data.get("request_id") or data.get("req_id") or req_id
                if rid and _vsp_persist_uireq(rid, data):
                    print(f"[VSP_DEMOAPP_PERSIST_UIREQ_FROM_STATUS_V2] persisted {rid}")
            return resp

        app.view_functions[endpoint] = _wrapped
        print(f"[VSP_DEMOAPP_PERSIST_UIREQ_FROM_STATUS_V2] wrapped {endpoint}")
        return True

    _wrap_status_persist(app)
except Exception as _e:
    print("[VSP_DEMOAPP_PERSIST_UIREQ_FROM_STATUS_V2] WARN:", _e)
# === END VSP_DEMOAPP_PERSIST_UIREQ_FROM_STATUS_V2 ===
# === VSP_AFTER_REQUEST_REGISTER_V26 ===
try:
    if not globals().get("_VSP_AFTER_V22_REGISTERED"):
        app.after_request(vsp_after_request_persist_uireq_v22)
        globals()["_VSP_AFTER_V22_REGISTERED"] = True
        try:
            _vsp_append_v22(_VSP_HIT_LOG_V22, f"after_v22_registered_v26 ts={_time.time()} file={__file__}")
        except Exception:
            pass
except Exception as _e:
    try:
        _vsp_append_v22(_VSP_ERR_LOG_V22, f"after_v22_register_v26_fail err={repr(_e)} file={__file__}")
        _vsp_append_v22(_VSP_ERR_LOG_V22, _traceback.format_exc())
    except Exception:
        pass
# === END VSP_AFTER_REQUEST_REGISTER_V26 ===



if __name__ == "__main__":
  app = _vsp_find_flask_app()
  if app is None:
    raise SystemExit("[FATAL] No Flask app instance found in vsp_demo_app.py")
  # Fixed commercial port 8910



  # === BEGIN VSP_WATCHDOG_HOOK_V1 ===
  try:
    from run_api.vsp_watchdog_hook_v1 import install as _vsp_wd_install
    _vsp_wd_install(app)
  except Exception as _e:
    print('[VSP_WD_HOOK] install failed:', _e)
  # === END VSP_WATCHDOG_HOOK_V1 ===

  # VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3 APPLY

  try:

    _vsp_demoapp_apply_wrappers_v3(app)

  except Exception:

    pass

  # END VSP_DEMOAPP_UIREQ_BOOTSTRAP_SAFE_V3 APPLY




  # === VSP_DEMOAPP_REINSTALL_PERSIST_UIREQ_BEFORE_RUN_V1 ===


  try:


    # re-install persist wrapper at the very end (avoid being overwritten by watchdog hook)


    if '_vsp_demoapp_install_persist_uireq_on_status_v1' in globals():


      _vsp_demoapp_install_persist_uireq_on_status_v1(app)


      print('[VSP_DEMOAPP_REINSTALL_PERSIST_UIREQ_BEFORE_RUN_V1] re-installed persist wrapper on run_status_v1')


    else:


      print('[VSP_DEMOAPP_REINSTALL_PERSIST_UIREQ_BEFORE_RUN_V1] INFO: installer function not found; skipping (ok)')


  except Exception as _e:


    print('[VSP_DEMOAPP_REINSTALL_PERSIST_UIREQ_BEFORE_RUN_V1] WARN:', _e)


  # === END VSP_DEMOAPP_REINSTALL_PERSIST_UIREQ_BEFORE_RUN_V1 ===



  # === VSP_RUNV1_CONTRACT_BEFORE_APP_RUN_V4 ===



  try:



      from flask import jsonify



      # wrap /api/vsp/run_v1 response to always include request_id + rid



      _ep = None



      try:



          for r in app.url_map.iter_rules():



              if getattr(r, 'rule', None) == '/api/vsp/run_v1':



                  _ep = r.endpoint



                  break



      except Exception:



          _ep = None



  



      if _ep and _ep in app.view_functions:



          _orig = app.view_functions[_ep]



  



          def _wrapped_run_v1_contract_v4(*args, **kwargs):



              ret = _orig(*args, **kwargs)



              resp, code, headers = ret, None, None



              if isinstance(ret, tuple) and len(ret) >= 1:



                  resp = ret[0]



                  if len(ret) >= 2: code = ret[1]



                  if len(ret) >= 3: headers = ret[2]



  



              data = None



              try:



                  if hasattr(resp, 'get_json'):



                      data = resp.get_json(silent=True)



              except Exception:



                  data = None



  



              if isinstance(data, dict):



                  rid = data.get('request_id') or data.get('req_id') or data.get('rid')



                  if rid:



                      data['request_id'] = rid



                      data['req_id'] = rid



                      data['rid'] = rid



                  if data.get('ok') is None:



                      data['ok'] = True



                  new_resp = jsonify(data)



                  if headers:



                      try: new_resp.headers.extend(headers)



                      except Exception: pass



                  return new_resp if code is None else (new_resp, code)



              return ret



  



          app.view_functions[_ep] = _wrapped_run_v1_contract_v4



          try: print('[VSP_RUNV1_CONTRACT_BEFORE_APP_RUN_V4] wrapped', _ep)



          except Exception: pass



  except Exception as e:



      try: print('[VSP_RUNV1_CONTRACT_BEFORE_APP_RUN_V4] failed:', e)



      except Exception: pass



  # === END VSP_RUNV1_CONTRACT_BEFORE_APP_RUN_V4 ===




  app.run(host="0.0.0.0", port=8910, debug=False)
# === END VSP_ENSURE_MAIN_RUN_V1 ===

# === VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1 ===
def _vsp_demoapp_install_persist_uireq_on_status_v1(app):
  try:
    if getattr(app, "_vsp_persist_uireq_on_status_v1_installed", False):
      return
    app._vsp_persist_uireq_on_status_v1_installed = True

    ep = "vsp_run_api_v1.run_status_v1"
    orig = app.view_functions.get(ep)
    if not orig:
      print("[VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1] WARN: endpoint not found:", ep)
      return

    def _persist(req_id, patch):
      try:
        from run_api import vsp_run_api_v1 as api
        udir = getattr(api, "_VSP_UIREQ_DIR", None)
        if not udir or not req_id:
          return False

        sp = Path(str(udir)) / f"{req_id}.json"
        if not sp.exists():
          return False

        import json
        st = json.loads(sp.read_text(encoding="utf-8", errors="replace") or "{}")
        changed = False
        for k, v in (patch or {}).items():
          if v is None:
            continue
          if st.get(k) != v:
            st[k] = v
            changed = True
        if changed:
          sp.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")
        return changed
      except Exception as e:
        print("[VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1] persist WARN:", e)
        return False

    def wrapped(*args, **kwargs):
      resp = orig(*args, **kwargs)

      data = resp
      code = None
      if isinstance(resp, tuple) and len(resp) >= 1:
        data = resp[0]
        code = resp[1] if len(resp) >= 2 else None

      d = None
      try:
        if hasattr(data, "get_json"):
          d = data.get_json(silent=True)
        elif isinstance(data, dict):
          d = data
      except Exception:
        d = None

      try:
        if isinstance(d, dict) and d.get("ok") is True:
          rid = d.get("req_id") or d.get("request_id")
          patch = {
            "ci_run_dir": d.get("ci_run_dir"),
            "runner_log": d.get("runner_log"),
            "stage_sig": d.get("stage_sig"),
            "progress_pct": d.get("progress_pct"),
            "final": d.get("final"),
            "killed": d.get("killed"),
            "kill_reason": d.get("kill_reason"),
          }
          if _persist(rid, patch):
            print("[VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1] persisted", rid)
      except Exception as e:
        print("[VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1] WARN:", e)

      return resp

    app.view_functions[ep] = wrapped
    print("[VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1] wrapped", ep)
  except Exception as e:
    print("[VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1] FATAL:", e)
# === END VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1 ===

# auto-install (safe)
try:
  _vsp_demoapp_install_persist_uireq_on_status_v1(app)
except Exception as _e:
  print("[VSP_DEMOAPP_PERSIST_UIREQ_ON_STATUS_V1] install failed:", _e)


# === VSP_DEMOAPP_PERSIST_UIREQ_POSTINIT_V2 ===
def _vsp_demoapp_persist_uireq_postinit_v2(app):
    try:
        import json as _json, os as _os
        from pathlib import Path as _Path

        # decide uireq dir
        _udir = None
        try:
            from run_api import vsp_run_api_v1 as _m
            _udir = getattr(_m, "_VSP_UIREQ_DIR", None)
        except Exception:
            _udir = None
        if not _udir:
            _udir = _Path(__file__).resolve().parent / "ui" / "out_ci" / "uireq_v1"
        _udir = _Path(str(_udir))
        _udir.mkdir(parents=True, exist_ok=True)

        def _persist(_rid: str, _data: dict) -> bool:
            if not _rid:
                return False
            fp = _udir / f"{_rid}.json"
            cur = {}
            if fp.exists():
                try:
                    cur = _json.loads(fp.read_text(encoding="utf-8", errors="ignore")) or {}
                except Exception:
                    cur = {}
            for k in ["request_id","req_id","ci_run_dir","runner_log","stage_sig","progress_pct",
                      "status","final","killed","kill_reason","stall_timeout_sec","total_timeout_sec"]:
                if k in _data and _data[k] is not None:
                    cur[k] = _data[k]
            tmp = fp.with_suffix(".json.tmp")
            tmp.write_text(_json.dumps(cur, ensure_ascii=False, indent=2), encoding="utf-8")
            _os.replace(tmp, fp)
            return True

        # find endpoints serving run_status
        endpoints = set()
        for r in app.url_map.iter_rules():
            if r.rule.startswith("/api/vsp/run_status_v1/"):
                endpoints.add(r.endpoint)

        wrapped = 0
        for ep in sorted(endpoints):
            if ep not in app.view_functions:
                continue
            orig = app.view_functions[ep]

            def _make(_ep, _fn):
                def _wrapped(req_id, *a, **kw):
                    resp = _fn(req_id, *a, **kw)
                    body = resp[0] if isinstance(resp, tuple) else resp
                    data = None
                    try:
                        if hasattr(body, "get_json"):
                            data = body.get_json(silent=True)
                        elif isinstance(body, dict):
                            data = body
                    except Exception:
                        data = None

                    if isinstance(data, dict):
                        rid = data.get("request_id") or data.get("req_id") or req_id
                        if _persist(str(rid), data):
                            print(f"[VSP_DEMOAPP_PERSIST_UIREQ_POSTINIT_V2] persisted {rid}")
                    return resp
                return _wrapped

            app.view_functions[ep] = _make(ep, orig)
            wrapped += 1

        print(f"[VSP_DEMOAPP_PERSIST_UIREQ_POSTINIT_V2] wrapped={wrapped} uireq_dir={_udir}")
        return True
    except Exception as _e:
        print("[VSP_DEMOAPP_PERSIST_UIREQ_POSTINIT_V2] WARN:", _e)
        return False
# === END VSP_DEMOAPP_PERSIST_UIREQ_POSTINIT_V2 ===




# === VSP_RUNV1_CONTRACT_APPENDSAFE_V3 ===
def _vsp_install_runv1_contract_appendsafe_v3(app):
    try:
        from flask import jsonify
    except Exception:
        return
    try:
        # Find endpoint by URL rule
        ep = None
        try:
            for r in app.url_map.iter_rules():
                if getattr(r, 'rule', None) == '/api/vsp/run_v1':
                    ep = r.endpoint
                    break
        except Exception:
            ep = None

        if not ep:
            return
        if ep not in app.view_functions:
            return

        _orig = app.view_functions[ep]

        def _wrapped(*args, **kwargs):
            ret = _orig(*args, **kwargs)

            resp, code, headers = ret, None, None
            if isinstance(ret, tuple) and len(ret) >= 1:
                resp = ret[0]
                if len(ret) >= 2:
                    code = ret[1]
                if len(ret) >= 3:
                    headers = ret[2]

            data = None
            try:
                if hasattr(resp, 'get_json'):
                    data = resp.get_json(silent=True)
            except Exception:
                data = None

            if isinstance(data, dict):
                rid = data.get('request_id') or data.get('req_id') or data.get('rid')
                if rid:
                    data['request_id'] = rid
                    data['req_id'] = rid
                    data['rid'] = rid
                if data.get('ok') is None:
                    data['ok'] = True

                new_resp = jsonify(data)
                if headers:
                    try:
                        new_resp.headers.extend(headers)
                    except Exception:
                        pass
                return new_resp if code is None else (new_resp, code)

            return ret

        app.view_functions[ep] = _wrapped
        try:
            print('[VSP_RUNV1_CONTRACT_APPENDSAFE_V3] wrapped', ep)
        except Exception:
            pass
    except Exception as e:
        try:
            print('[VSP_RUNV1_CONTRACT_APPENDSAFE_V3] failed:', e)
        except Exception:
            pass

try:
    _vsp_install_runv1_contract_appendsafe_v3(app)
except Exception:
    pass
# === END VSP_RUNV1_CONTRACT_APPENDSAFE_V3 ===

# === VSP COMMERCIAL HEALTHZ V1 ===
try:
    from flask import jsonify
    @app.get("/healthz")
    def vsp_healthz_v1():
        return jsonify({"ok": True, "service": "vsp-ui-8910"}), 200
except Exception:
    pass
# === END VSP COMMERCIAL HEALTHZ V1 ===


# === VSP ARTIFACT ENDPOINT V1 ===
from flask import request, abort, send_file

def _vsp_safe_join(base: str, rel: str) -> str:
    import os
    base_abs = os.path.abspath(base)
    target = os.path.abspath(os.path.join(base_abs, rel.strip("/")))
    if not (target == base_abs or target.startswith(base_abs + os.sep)):
        raise ValueError("path traversal")
    return target

@app.get("/api/vsp/run_artifact_v1/<rid>")
def vsp_run_artifact_v1(rid):
    # expects run_status_v1(rid) returns ci_run_dir
    try:
        # reuse existing status builder if present
        st = None
        try:
            st = run_status_v1(rid)  # may return Response
        except Exception:
            st = None

        # fallback: compute ci_run_dir from your existing mapping if any
        # Here we read persisted uireq state if exists
        from pathlib import Path
        import json
        u = Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1") / f"{rid}.json"
        ci_dir = None
        if u.exists():
            try:
                ci_dir = json.loads(u.read_text(encoding="utf-8")).get("ci_run_dir")
            except Exception:
                ci_dir = None

        if not ci_dir:
            abort(404, "ci_run_dir missing")

        rel = request.args.get("path", "")
        if not rel:
            abort(400, "missing path")
        full = _vsp_safe_join(ci_dir, rel)
        if not Path(full).exists():
            abort(404, "not found")
        # serve as plain text for logs/html/json; browser can download others
        return send_file(full, as_attachment=False)
    except Exception as e:
        abort(400, str(e))
# === END VSP ARTIFACT ENDPOINT V1 ===

# === VSP COMMERCIAL HEALTHZ V2 ===
try:
    from flask import jsonify
    @app.route('/healthz', methods=['GET'])
    def vsp_healthz_v2():
        return jsonify({'ok': True, 'service': 'vsp-ui-8910'}), 200
except Exception:
    pass
# === END VSP COMMERCIAL HEALTHZ V2 ===


# === VSP RUN_STATUS FS RESOLVER V2 ===
import os, json, time, glob
from pathlib import Path
from flask import jsonify

def _read_json(path: Path):
    try:
        return json.loads(path.read_text(encoding="utf-8", errors="ignore") or "{}")
    except Exception:
        return None

def _find_ci_run_dir_by_rid(rid: str):
    """
    Resolve rid -> ci_run_dir robustly.
    Supports:
      - RUN_VSP_CI_YYYYmmdd_HHMMSS (points to /home/test/Data/SECURITY-10-10-v4/out_ci/<RID>)
      - VSP_CI_YYYYmmdd_HHMMSS
      - VSP_UIREQ_YYYYmmdd_HHMMSS_xxx (look under ui/out_ci/uireq_v1/<rid>.json for ci_run_dir)
    """
    if not rid:
        return None

    # 1) If uireq state exists, trust its ci_run_dir
    try:
        uireq = Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1") / f"{rid}.json"
        if uireq.exists():
            j = _read_json(uireq) or {}
            cd = j.get("ci_run_dir") or j.get("ci_dir")
            if cd and Path(cd).exists():
                return cd
    except Exception:
        pass

    # 2) Direct known CI roots (search a few common places)
    candidates = []

    # primary demo env root (you used it)
    candidates.append(Path("/home/test/Data/SECURITY-10-10-v4/out_ci") / rid)

    # sometimes rid inside ci dir without RUN_ prefix
    if rid.startswith("RUN_"):
        candidates.append(Path("/home/test/Data/SECURITY-10-10-v4/out_ci") / rid.replace("RUN_", "", 1))
    else:
        candidates.append(Path("/home/test/Data/SECURITY-10-10-v4/out_ci") / ("RUN_" + rid))

    # optional: SECURITY_BUNDLE out (if you also run locally there)
    candidates.append(Path("/home/test/Data/SECURITY_BUNDLE/out_ci") / rid)
    candidates.append(Path("/home/test/Data/SECURITY_BUNDLE/out") / rid)

    for c in candidates:
        try:
            if c.exists() and c.is_dir():
                return str(c)
        except Exception:
            pass

    # 3) Last resort: glob scan by prefix timestamp (bounded)
    # If rid includes YYYYmmdd_HHMMSS pattern, try matching folders quickly
    m = re.search(r"(20\d{6}_\d{6})", rid)
    if m:
        ts = m.group(1)
        globs = [
            f"/home/test/Data/SECURITY-10-10-v4/out_ci/*{ts}*",
            f"/home/test/Data/SECURITY_BUNDLE/out_ci/*{ts}*",
        ]
        for g in globs:
            for path in sorted(glob.glob(g), reverse=True)[:20]:
                try:
                    if Path(path).is_dir():
                        return str(Path(path))
                except Exception:
                    continue
    return None

def _read_degraded_tools(ci_run_dir: str):
    if not ci_run_dir:
        return []
    fp = Path(ci_run_dir) / "degraded_tools.json"
    if fp.exists():
        j = _read_json(fp)
        if isinstance(j, list):
            return j
        if isinstance(j, dict) and isinstance(j.get("degraded_tools"), list):
            return j["degraded_tools"]
    return []

# Wrap/override run_status endpoint output at app level
try:
    _orig_run_status_v1 = vsp_run_api_v1.run_status_v1  # type: ignore
except Exception:
    _orig_run_status_v1 = None

@app.get("/api/vsp/run_status_v1/<rid>")
def vsp_run_status_v1_fs_resolver(rid):
    """
    Commercial status:
      - always returns degraded_tools as list
      - always returns ci_run_dir if resolvable
    """
    base = {}
    # 1) try original handler (if any)
    try:
        if _orig_run_status_v1:
            resp = _orig_run_status_v1(rid)
            # resp could be (jsonify, code) or Response
            payload = None
            code = 200
            if isinstance(resp, tuple):
                payload = resp[0].get_json(silent=True) if hasattr(resp[0], "get_json") else None
                code = resp[1] if len(resp) > 1 else 200
            else:
                payload = resp.get_json(silent=True) if hasattr(resp, "get_json") else None
            if isinstance(payload, dict):
                base = payload
                base.setdefault("ok", True)
                base.setdefault("rid", rid)
                # let it pass through; we'll normalize below
    except Exception as e:
        base = {"ok": False, "rid": rid, "error": str(e)}

    # 2) FS resolve ci_run_dir if missing
    ci_dir = base.get("ci_run_dir") or base.get("ci_dir")
    if not ci_dir:
        ci_dir = _find_ci_run_dir_by_rid(rid)
        if ci_dir:
            base["ci_run_dir"] = ci_dir

    # 3) normalize degraded_tools
    dt = base.get("degraded_tools")
    if not isinstance(dt, list):
        dt = _read_degraded_tools(ci_dir) if ci_dir else []
    base["degraded_tools"] = dt

    # 4) ok/final/finish_reason normalization
    if base.get("ci_run_dir"):
        base["ok"] = True
    else:
        base.setdefault("ok", False)
        base.setdefault("error", "ci_run_dir_not_resolved")
    base.setdefault("final", False)
    base.setdefault("finish_reason", "running" if not base.get("final") else "finished")

    return jsonify(base), 200
# === END VSP RUN_STATUS FS RESOLVER V2 ===


# === VSP STATUS+ARTIFACT V2 ===
import os, json, glob, re
from pathlib import Path
from flask import request, jsonify, Response

def _read_json(path: Path):
    try:
        return json.loads(path.read_text(encoding="utf-8", errors="ignore") or "{}")
    except Exception:
        return None

def _norm_rid(rid: str) -> str:
    rid = (rid or "").strip()
    if rid.startswith("RUN_"):
        rid = rid[4:]  # RUN_VSP_CI_... -> VSP_CI_...
    return rid

def _safe_join(base: Path, rel: str) -> Path:
    rel = (rel or "").lstrip("/").replace("\\", "/")
    if ".." in rel.split("/"):
        raise ValueError("path traversal")
    out = (base / rel).resolve()
    base_r = base.resolve()
    if str(out) != str(base_r) and not str(out).startswith(str(base_r) + os.sep):
        raise ValueError("outside base")
    return out

def _guess_mime(path: str) -> str:
    s = (path or "").lower()
    if s.endswith(".json"): return "application/json; charset=utf-8"
    if s.endswith(".sarif"): return "application/sarif+json; charset=utf-8"
    if s.endswith(".html") or s.endswith(".htm"): return "text/html; charset=utf-8"
    if s.endswith(".txt") or s.endswith(".log"): return "text/plain; charset=utf-8"
    if s.endswith(".zip"): return "application/zip"
    return "application/octet-stream"

def _find_ci_run_dir_any(rid: str):
    rid0 = rid
    rid = _norm_rid(rid)
    roots = [
        Path("/home/test/Data/SECURITY-10-10-v4/out_ci"),
        Path("/home/test/Data/SECURITY_BUNDLE/out_ci"),
        Path("/home/test/Data/SECURITY_BUNDLE/out"),
    ]
    # try exact
    for root in roots:
        for cand in [root / rid, root / rid0]:
            if cand.exists() and cand.is_dir():
                return str(cand)

    # timestamp glob bounded
    m = re.search(r"(20\d{6}_\d{6})", rid0)
    if m:
        ts = m.group(1)
        globs = [f"/home/test/Data/SECURITY-10-10-v4/out_ci/*{ts}*",
                 f"/home/test/Data/SECURITY_BUNDLE/out_ci/*{ts}*"]
        for g in globs:
            for path in sorted(glob.glob(g), reverse=True)[:50]:
                try:
                    pp = Path(path)
                    if pp.is_dir():
                        return str(pp)
                except Exception:
                    pass
    return None

def _read_degraded(ci_run_dir: str):
    if not ci_run_dir:
        return []
    fp = Path(ci_run_dir) / "degraded_tools.json"
    if fp.exists():
        j = _read_json(fp)
        if isinstance(j, list): return j
        if isinstance(j, dict) and isinstance(j.get("degraded_tools"), list):
            return j["degraded_tools"]
    return []

@app.get("/api/vsp/run_status_v2/<rid>")
def vsp_run_status_v2(rid):
    ci_dir = _find_ci_run_dir_any(rid)
    degraded = _read_degraded(ci_dir) if ci_dir else []
    ok = bool(ci_dir)
    return jsonify({
        "ok": ok,
        "rid": rid,
        "rid_norm": _norm_rid(rid),
        "ci_run_dir": ci_dir,
        "degraded_tools": degraded,
        "final": False,
        "finish_reason": "running",
        "error": None if ok else "ci_run_dir_not_found"
    }), 200

@app.get("/api/vsp/run_artifact_v2/<rid>")
def vsp_run_artifact_v2(rid):
    rel = request.args.get("path", "") or ""
    if not rel:
        return jsonify({"ok": False, "rid": rid, "error": "missing_path"}), 400

    ci_dir = _find_ci_run_dir_any(rid)
    bases = []
    if ci_dir:
        bases.append(Path(ci_dir))
    bases.append(Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci"))
    bases.append(Path("/home/test/Data/SECURITY_BUNDLE/ui/out_ci/uireq_v1"))

    last = None
    for base in bases:
        try:
            fp = _safe_join(base, rel)
            if fp.exists() and fp.is_file():
                return Response(fp.read_bytes(), status=200, mimetype=_guess_mime(rel))
        except Exception as e:
            last = e
            continue

    
    # fallback for runner.log -> best available log
    if rel in ("runner.log", "runner_outer.log", "ui_8910.log"):
        best = _pick_best_log(ci_dir) if ci_dir else ""
        if best and best != rel:
            try:
                fp2 = _safe_join(Path(ci_dir), best)
                if fp2.exists() and fp2.is_file():
                    return Response(fp2.read_bytes(), status=200, mimetype=_guess_mime(best))
            except Exception:
                pass

    return jsonify({"ok": False, "rid": rid, "error": "artifact_not_found", "path": rel}), 404

# === END VSP STATUS+ARTIFACT V2 ===

# === VSP ARTIFACT V2 LOG FALLBACK V1 ===
def _pick_best_log(ci_dir: str) -> str:
    """
    Return relative path of best log inside ci_dir.
    Priority:
      1) runner.log / runner*.log
      2) out_ci/*.log
      3) tool logs commonly used
    """
    try:
        base = Path(ci_dir)
        if not base.exists():
            return "runner.log"
        # exact / runner*
        for cand in ["runner.log", "runner_outer.log", "ui_8910.log", "ci_runner.log"]:
            if (base / cand).exists():
                return cand
        # glob runner*.log
        gl = sorted(base.glob("runner*.log"), key=lambda x: x.stat().st_mtime, reverse=True)
        if gl:
            return gl[0].name
        # out_ci/*.log
        out_ci = base / "out_ci"
        if out_ci.exists():
            gl2 = sorted(out_ci.glob("*.log"), key=lambda x: x.stat().st_mtime, reverse=True)
            if gl2:
                return str(gl2[0].relative_to(base))
        # common tool logs
        candidates = [
            "kics/kics.log",
            "semgrep/semgrep.log",
            "codeql/codeql.log",
            "gitleaks/gitleaks.log",
            "trivy/trivy.log",
            "unify/unify.log",
        ]
        for c in candidates:
            if (base / c).exists():
                return c
    except Exception:
        pass
    return "runner.log"
# === END VSP ARTIFACT V2 LOG FALLBACK V1 ===



# === VSP ARTIFACT INDEX + RUNS INDEX RESOLVED V2 ===
from flask import jsonify, request
import os, json, re
from pathlib import Path
from datetime import datetime

def _list_files_rel(base: Path, max_files=400):
    out = []
    try:
        base = base.resolve()
        n = 0
        for root, dirs, files in os.walk(base):
            # skip heavy dirs
            dirs[:] = [d for d in dirs if d not in (".git","node_modules","dist","build","target",".venv","venv","__pycache__","cache")]
            for fn in files:
                n += 1
                if n > max_files:
                    return out
                fp = Path(root) / fn
                try:
                    rel = fp.resolve().relative_to(base).as_posix()
                    out.append(rel)
                except Exception:
                    pass
    except Exception:
        pass
    return out

@app.get("/api/vsp/run_artifacts_index_v1/<rid>")
def vsp_run_artifacts_index_v1(rid):
    ci_dir = _find_ci_run_dir_any(rid)  # from STATUS+ARTIFACT V2 block
    if not ci_dir:
        return jsonify({"ok": False, "rid": rid, "error": "ci_run_dir_not_found"}), 404
    base = Path(ci_dir)
    files = _list_files_rel(base, max_files=1200)
    common = []
    for cand in [
        "degraded_tools.json",
        "runner.log",
        "CI_SUMMARY.txt",
        "CI_SUMMARY_HUMAN.txt",
        "kics/kics.log",
        "gitleaks/gitleaks.log",
        "semgrep/semgrep.log",
        "codeql/codeql.log",
        "report/findings_unified.json",
        "report/summary_unified.json",
    ]:
        if (base / cand).exists():
            common.append(cand)
    return jsonify({
        "ok": True,
        "rid": rid,
        "rid_norm": _norm_rid(rid),
        "ci_run_dir": ci_dir,
        "common": common,
        "files": files
    }), 200

def _parse_totals_from_summary(ci_dir: Path):
    # best-effort: read report/summary_unified.json if exists
    try:
        s = ci_dir / "report" / "summary_unified.json"
        if s.exists():
            j = json.loads(s.read_text(encoding="utf-8", errors="ignore") or "{}")
            # try common shapes
            if isinstance(j, dict):
                totals = {}
                # tolerate either summary_all/by_severity or by_severity direct
                bysev = None
                if isinstance(j.get("summary_all"), dict):
                    bysev = j["summary_all"].get("by_severity")
                if bysev is None:
                    bysev = j.get("by_severity")
                if isinstance(bysev, dict):
                    totals["by_severity"] = bysev
                return totals
    except Exception:
        pass
    return {}

def _looks_like_run_dir(name: str) -> bool:
    return bool(re.match(r"^(VSP_CI|RUN_VSP|RUN_).*20\d{6}_\d{6}", name or ""))

@app.get("/api/vsp/runs_index_v3_fs_resolved")
def vsp_runs_index_v3_fs_resolved():
    """
    FS-native resolved runs index (commercial-safe).
    - does NOT depend on any existing handler naming
    - returns items with run_id/req_id + rid_norm + ci_run_dir
    """
    limit = int(request.args.get("limit","20") or "20")
    hide_empty = request.args.get("hide_empty","0") == "1"
    # filter=1 keeps only resolvable (always true here), still keep param for compatibility
    filter_unresolved = request.args.get("filter","1") == "1"

    roots = [
        Path("/home/test/Data/SECURITY-10-10-v4/out_ci"),
        Path("/home/test/Data/SECURITY_BUNDLE/out_ci"),
        Path("/home/test/Data/SECURITY_BUNDLE/out"),
    ]

    dirs = []
    for r in roots:
        try:
            if r.exists():
                for d in r.iterdir():
                    if d.is_dir() and _looks_like_run_dir(d.name):
                        dirs.append(d)
        except Exception:
            continue

    # sort newest first by mtime
    dirs.sort(key=lambda d: d.stat().st_mtime, reverse=True)

    items = []
    for d in dirs:
        if len(items) >= limit:
            break

        # normalize rid: UI currently uses RUN_* but disk uses VSP_CI_*
        dir_name = d.name
        rid_norm = dir_name.replace("RUN_", "", 1) if dir_name.startswith("RUN_") else dir_name
        rid = ("RUN_" + rid_norm) if not dir_name.startswith("RUN_") else dir_name  # keep UI-style

        # hide_empty: require summary/findings exist OR at least one known log exists
        if hide_empty:
            has_any = any((d / x).exists() for x in [
                "report/findings_unified.json",
                "report/summary_unified.json",
                "kics/kics.log",
                "gitleaks/gitleaks.log",
            ])
            if not has_any:
                continue

        created_at = datetime.fromtimestamp(d.stat().st_mtime).isoformat()
        totals = _parse_totals_from_summary(d)

        items.append({
            "run_id": rid,
            "req_id": rid,
            "request_id": rid,
            "created_at": created_at,
            "profile": "",
            "target": "",
            "totals": totals or {},
            "rid_norm": rid_norm,
            "ci_run_dir": str(d),
            "source_root": str(d.parent),
        })

    return jsonify({
        "ok": True,
        "source": "fs_resolved_v2",
        "filter_unresolved": filter_unresolved,
        "items": items
    }), 200
# === END VSP ARTIFACT INDEX + RUNS INDEX RESOLVED V2 ===



